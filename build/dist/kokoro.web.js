function e(e,t){return t.forEach((function(t){t&&"string"!=typeof t&&!Array.isArray(t)&&Object.keys(t).forEach((function(n){if("default"!==n&&!(n in e)){var r=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,r.get?r:{enumerable:!0,get:function(){return t[n]}})}}))})),Object.freeze(e)}const t=new Map,n=[],r=async e=>{const n=t.get(e);if(!n)return"backend not found.";if(n.initialized)return n.backend;if(n.aborted)return n.error;{const t=!!n.initPromise;try{return t||(n.initPromise=n.backend.init(e)),await n.initPromise,n.initialized=!0,n.backend}catch(e){return t||(n.error=`${e}`,n.aborted=!0),n.error}finally{delete n.initPromise}}};let s="warning";const a={wasm:{},webgl:{},webgpu:{},versions:{common:"1.21.0"},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);s=e}},get logLevel(){return s}};Object.defineProperty(a,"logLevel",{enumerable:!0});const i=a,A=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:n,width:r}=t,s=t.norm??{mean:255,bias:0};let a,i;a="number"==typeof s.mean?[s.mean,s.mean,s.mean,s.mean]:[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],i="number"==typeof s.bias?[s.bias,s.bias,s.bias,s.bias]:[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];const A=void 0!==t.format?t.format:"RGBA",o=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",l=n*r,u="RGBA"===o?new Float32Array(4*l):new Float32Array(3*l);let d=4,h=0,f=1,g=2,p=3,m=0,b=l,C=2*l,I=-1;"RGB"===A&&(d=3,h=0,f=1,g=2,p=-1),"RGBA"===o?I=3*l:"RBG"===o?(m=0,C=l,b=2*l):"BGR"===o&&(C=0,b=l,m=2*l);for(let t=0;t<l;t++,h+=d,g+=d,f+=d,p+=d)u[m++]=(e[h]+i[0])/a[0],u[b++]=(e[f]+i[1])/a[1],u[C++]=(e[g]+i[2])/a[2],-1!==I&&-1!==p&&(u[I++]=(e[p]+i[3])/a[3]);return new c("float32",u,"RGBA"===o?[1,4,n,r]:[1,3,n,r])},o=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),l=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let u=!1;let c=class{constructor(e,t,n){let r,s;if((()=>{if(!u){u=!0;const e="undefined"!=typeof BigInt64Array&&BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&BigUint64Array.from,n=globalThis.Float16Array,r=void 0!==n&&n.from;e&&(o.set("int64",BigInt64Array),l.set(BigInt64Array,"int64")),t&&(o.set("uint64",BigUint64Array),l.set(BigUint64Array,"uint64")),r?(o.set("float16",n),l.set(n,"float16")):o.set("float16",Uint16Array)}})(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,r=e.type,s=e.dims,e.location){case"cpu-pinned":{const t=o.get(r);if(!t)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint64"!==r&&"int8"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,i;if("string"==typeof e)if(r=e,i=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");a=t}else{const n=o.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&n===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${n.name} as data.`);a="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else if(t instanceof n)a=t;else if(t instanceof Uint8ClampedArray){if("uint8"!==e)throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");a=Uint8Array.from(t)}else{if(!("float16"===e&&t instanceof Uint16Array&&n!==Uint16Array))throw new TypeError(`A ${r} tensor's data must be type of ${n}`);a=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length)}}else if(i=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)r="string",a=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",a=Uint8Array.from(e)}}else if(e instanceof Uint8ClampedArray)r="uint8",a=Uint8Array.from(e);else{const t=l.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,a=e}if(void 0===i)i=[a.length];else if(!Array.isArray(i))throw new TypeError("A tensor's dims must be a number array");s=i,this.cpuData=a,this.dataLocation="cpu"}const a=(e=>{let t=1;for(let n=0;n<e.length;n++){const r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t})(s);if(this.cpuData&&a!==this.cpuData.length&&("uint4"!==r&&"int4"!==r||Math.ceil(a/2)!==this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=s,this.size=a}static async fromImage(e,t){return(async(e,t)=>{const n="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,r="undefined"!=typeof ImageData&&e instanceof ImageData,s="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,a="string"==typeof e;let i,o=t??{};const l=()=>{if("undefined"!=typeof document)return document.createElement("canvas");if("undefined"!=typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=e=>"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(n){const n=l();n.width=e.width,n.height=e.height;const r=u(n);if(null==r)throw new Error("Can not access image data");{let n=e.height,s=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(n=t.resizedHeight,s=t.resizedWidth),void 0!==t){if(o=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=n,o.width=s}else o.tensorFormat="RGBA",o.height=n,o.width=s;r.drawImage(e,0,0),i=r.getImageData(0,0,s,n).data}}else{if(!r){if(s){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");const n=l();n.width=e.width,n.height=e.height;const r=u(n);if(null!=r){const t=e.height,n=e.width;return r.drawImage(e,0,0,n,t),i=r.getImageData(0,0,n,t).data,o.height=t,o.width=n,A(i,o)}throw new Error("Can not access image data")}if(a)return new Promise(((t,n)=>{const r=l(),s=u(r);if(!e||!s)return n();const a=new Image;a.crossOrigin="Anonymous",a.src=e,a.onload=()=>{r.width=a.width,r.height=a.height,s.drawImage(a,0,0,r.width,r.height);const e=s.getImageData(0,0,r.width,r.height);o.height=r.height,o.width=r.width,t(A(e.data,o))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let n,r;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(n=t.resizedHeight,r=t.resizedWidth):(n=e.height,r=e.width),void 0!==t&&(o=t),o.format="RGBA",o.height=n,o.width=r,void 0!==t){const t=l();t.width=r,t.height=n;const s=u(t);if(null==s)throw new Error("Can not access image data");s.putImageData(e,0,0),i=s.getImageData(0,0,r,n).data}else i=e.data}}if(void 0!==i)return A(i,o);throw new Error("Input data provided is not supported - aborted tensor creation")})(e,t)}static fromTexture(e,t){return((e,t)=>{const{width:n,height:r,download:s,dispose:a}=t;return new c({location:"texture",type:"float32",texture:e,dims:[1,r,n,4],download:s,dispose:a})})(e,t)}static fromGpuBuffer(e,t){return((e,t)=>{const{dataType:n,dims:r,download:s,dispose:a}=t;return new c({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:s,dispose:a})})(e,t)}static fromMLTensor(e,t){return((e,t)=>{const{dataType:n,dims:r,download:s,dispose:a}=t;return new c({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:r,download:s,dispose:a})})(e,t)}static fromPinnedBuffer(e,t,n){return((e,t,n)=>new c({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]}))(e,t,n)}toDataURL(e){return((e,t)=>{const n="undefined"!=typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];const r=n.getContext("2d");if(null!=r){let s,a;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],a=e.dims[3]):(s=e.dims[3],a=e.dims[2]);const i=void 0!==t?.format?t.format:"RGB",A=t?.norm;let o,l;void 0===A||void 0===A.mean?o=[255,255,255,255]:"number"==typeof A.mean?o=[A.mean,A.mean,A.mean,A.mean]:(o=[A.mean[0],A.mean[1],A.mean[2],0],void 0!==A.mean[3]&&(o[3]=A.mean[3])),void 0===A||void 0===A.bias?l=[0,0,0,0]:"number"==typeof A.bias?l=[A.bias,A.bias,A.bias,A.bias]:(l=[A.bias[0],A.bias[1],A.bias[2],0],void 0!==A.bias[3]&&(l[3]=A.bias[3]));const u=a*s;let c=0,d=u,h=2*u,f=-1;"RGBA"===i?(c=0,d=u,h=2*u,f=3*u):"RGB"===i?(c=0,d=u,h=2*u):"RBG"===i&&(c=0,h=u,d=2*u);for(let t=0;t<a;t++)for(let n=0;n<s;n++){const s=(e.data[c++]-l[0])*o[0],a=(e.data[d++]-l[1])*o[1],i=(e.data[h++]-l[2])*o[2],A=-1===f?255:(e.data[f++]-l[3])*o[3];r.fillStyle="rgba("+s+","+a+","+i+","+A+")",r.fillRect(n,t,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")})(this,e)}toImageData(e){return((e,t)=>{const n="undefined"!=typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let r;if(null==n)throw new Error("Can not access image data");{let s,a,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],a=e.dims[1],i=e.dims[3]):(s=e.dims[3],a=e.dims[2],i=e.dims[1]);const A=void 0!==t&&void 0!==t.format?t.format:"RGB",o=t?.norm;let l,u;void 0===o||void 0===o.mean?l=[255,255,255,255]:"number"==typeof o.mean?l=[o.mean,o.mean,o.mean,o.mean]:(l=[o.mean[0],o.mean[1],o.mean[2],255],void 0!==o.mean[3]&&(l[3]=o.mean[3])),void 0===o||void 0===o.bias?u=[0,0,0,0]:"number"==typeof o.bias?u=[o.bias,o.bias,o.bias,o.bias]:(u=[o.bias[0],o.bias[1],o.bias[2],0],void 0!==o.bias[3]&&(u[3]=o.bias[3]));const c=a*s;if(void 0!==t&&(void 0!==t.format&&4===i&&"RGBA"!==t.format||3===i&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");const d=4;let h=0,f=1,g=2,p=3,m=0,b=c,C=2*c,I=-1;"RGBA"===A?(m=0,b=c,C=2*c,I=3*c):"RGB"===A?(m=0,b=c,C=2*c):"RBG"===A&&(m=0,C=c,b=2*c),r=n.createImageData(s,a);for(let t=0;t<a*s;h+=d,f+=d,g+=d,p+=d,t++)r.data[h]=(e.data[m++]-u[0])*l[0],r.data[f]=(e.data[b++]-u[1])*l[1],r.data[g]=(e.data[C++]-u[2])*l[2],r.data[p]=-1===I?255:(e.data[I++]-u[3])*l[3]}return r})(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return((e,t)=>{switch(e.location){case"cpu":return new c(e.type,e.data,t);case"cpu-pinned":return new c({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new c({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new c({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new c({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}})(this,e)}};const d=c,h=(e,t)=>{(void 0===a.trace?a.wasm.trace:a.trace)&&console.timeStamp(`${e}::ORT::${t}`)},f=(e,t)=>{const n=(new Error).stack?.split(/\r\n|\r|\n/g)||[];let r=!1;for(let s=0;s<n.length;s++){if(r&&!n[s].includes("TRACE_FUNC")){let r=`FUNC_${e}::${n[s].trim().split(" ")[1]}`;return t&&(r+=`::${t}`),void h("CPU",r)}n[s].includes("TRACE_FUNC")&&(r=!0)}},g=e=>{(void 0===a.trace?a.wasm.trace:a.trace)&&f("BEGIN",e)},p=e=>{(void 0===a.trace?a.wasm.trace:a.trace)&&f("END",e)};const m=class e{constructor(e){this.handler=e}async run(e,t,n){g();const r={};let s={};if("object"!=typeof e||null===e||e instanceof d||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof d)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(const e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)s=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else{let e=!1;const i=Object.getOwnPropertyNames(t);for(const n of this.outputNames)if(-1!==i.indexOf(n)){const s=t[n];(null===s||s instanceof d)&&(e=!0,a=!1,r[n]=s)}if(e){if("object"==typeof n&&null!==n)s=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else s=t}}else if(void 0!==t)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(a)for(const e of this.outputNames)r[e]=null;const i=await this.handler.run(e,r,s),A={};for(const e in i)if(Object.hasOwnProperty.call(i,e)){const t=i[e];A[e]=t instanceof d?t:new d(t.type,t.data,t.dims)}return p(),A}async release(){return this.handler.dispose()}static async create(t,s,a,i){let A;g();let o={};if("string"==typeof t){if(A=t,"object"==typeof s&&null!==s)o=s;else if(void 0!==s)throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(A=t,"object"==typeof s&&null!==s)o=s;else if(void 0!==s)throw new TypeError("'options' must be an object.")}else{if(!(t instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const e=t;let n=0,r=t.byteLength;if("object"==typeof s&&null!==s)o=s;else if("number"==typeof s){if(n=s,!Number.isSafeInteger(n))throw new RangeError("'byteOffset' must be an integer.");if(n<0||n>=e.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(r=t.byteLength-n,"number"==typeof a){if(r=a,!Number.isSafeInteger(r))throw new RangeError("'byteLength' must be an integer.");if(r<=0||n+r>e.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${e.byteLength-n}].`);if("object"==typeof i&&null!==i)o=i;else if(void 0!==i)throw new TypeError("'options' must be an object.")}else if(void 0!==a)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==s)throw new TypeError("'options' must be an object.");A=new Uint8Array(e,n,r)}}const[l,u]=await(async e=>{const t=e.executionProviders||[],s=t.map((e=>"string"==typeof e?e:e.name)),a=0===s.length?n:s;let i;const A=[],o=new Set;for(const e of a){const t=await r(e);"string"==typeof t?A.push({name:e,err:t}):(i||(i=t),i===t&&o.add(e))}if(!i)throw new Error(`no available backend found. ERR: ${A.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`);for(const{name:e,err:t}of A)s.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);const l=t.filter((e=>o.has("string"==typeof e?e:e.name)));return[i,new Proxy(e,{get:(e,t)=>"executionProviders"===t?l:Reflect.get(e,t)})]})(o),c=await l.createInferenceSessionHandler(A,u);return p(),new e(c)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};var b,C,I,w,k,x,y,v,E,B,M,D,T,S,N,G,F,P,Q,z,O,R,L,W,_,V,H,U,j,Y,K,X=Object.freeze({__proto__:null,InferenceSession:m,TRACE:h,TRACE_FUNC_BEGIN:g,TRACE_FUNC_END:p,Tensor:d,env:i,registerBackend:(e,r,s)=>{if(!r||"function"!=typeof r.init||"function"!=typeof r.createInferenceSessionHandler)throw new TypeError("not a valid backend");{const a=t.get(e);if(void 0===a)t.set(e,{backend:r,priority:s});else{if(a.priority>s)return;if(a.priority===s&&a.backend!==r)throw new Error(`cannot register backend "${e}" using priority ${s}`)}if(s>=0){const r=n.indexOf(e);-1!==r&&n.splice(r,1);for(let r=0;r<n.length;r++)if(t.get(n[r]).priority<=s)return void n.splice(r,0,e);n.push(e)}}}}),q=Object.defineProperty,Z=Object.getOwnPropertyDescriptor,J=Object.getOwnPropertyNames,$=Object.prototype.hasOwnProperty,ee=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):e)((function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')})),te=(e,t)=>()=>(e&&(t=e(e=0)),t),ne=(e,t)=>{for(var n in t)q(e,n,{get:t[n],enumerable:!0})},re=e=>((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let s of J(t))!$.call(e,s)&&s!==n&&q(e,s,{get:()=>t[s],enumerable:!(r=Z(t,s))||r.enumerable});return e})(q({},"__esModule",{value:!0}),e),se=te((()=>{b=new Map,C=[],I=(e,t,n)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createInferenceSessionHandler)throw new TypeError("not a valid backend");{let r=b.get(e);if(void 0===r)b.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let t=C.indexOf(e);-1!==t&&C.splice(t,1);for(let t=0;t<C.length;t++)if(b.get(C[t]).priority<=n)return void C.splice(t,0,e);C.push(e)}}},w=async e=>{let t=b.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(e){return n||(t.error=`${e}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},k=async e=>{let t,n=e.executionProviders||[],r=n.map((e=>"string"==typeof e?e:e.name)),s=0===r.length?C:r,a=[],i=new Set;for(let e of s){let n=await w(e);"string"==typeof n?a.push({name:e,err:n}):(t||(t=n),t===n&&i.add(e))}if(!t)throw new Error(`no available backend found. ERR: ${a.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`);for(let{name:e,err:t}of a)r.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);let A=n.filter((e=>i.has("string"==typeof e?e:e.name)));return[t,new Proxy(e,{get:(e,t)=>"executionProviders"===t?A:Reflect.get(e,t)})]}})),ae=te((()=>{se()})),ie=te((()=>{x="1.22.0-dev.20250409-89f8206ba4"})),Ae=te((()=>{ie(),y="warning",v={wasm:{},webgl:{},webgpu:{},versions:{common:x},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);y=e}},get logLevel(){return y}},Object.defineProperty(v,"logLevel",{enumerable:!0})})),oe=te((()=>{Ae(),E=v})),le=te((()=>{B=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let r=n.getContext("2d");if(null!=r){let s,a;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],a=e.dims[3]):(s=e.dims[3],a=e.dims[2]);let i,A,o=void 0!==t?.format?t.format:"RGB",l=t?.norm;void 0===l||void 0===l.mean?i=[255,255,255,255]:"number"==typeof l.mean?i=[l.mean,l.mean,l.mean,l.mean]:(i=[l.mean[0],l.mean[1],l.mean[2],0],void 0!==l.mean[3]&&(i[3]=l.mean[3])),void 0===l||void 0===l.bias?A=[0,0,0,0]:"number"==typeof l.bias?A=[l.bias,l.bias,l.bias,l.bias]:(A=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(A[3]=l.bias[3]));let u=a*s,c=0,d=u,h=2*u,f=-1;"RGBA"===o?(c=0,d=u,h=2*u,f=3*u):"RGB"===o?(c=0,d=u,h=2*u):"RBG"===o&&(c=0,h=u,d=2*u);for(let t=0;t<a;t++)for(let n=0;n<s;n++){let s=(e.data[c++]-A[0])*i[0],a=(e.data[d++]-A[1])*i[1],o=(e.data[h++]-A[2])*i[2],l=-1===f?255:(e.data[f++]-A[3])*i[3];r.fillStyle="rgba("+s+","+a+","+o+","+l+")",r.fillRect(n,t,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")},M=(e,t)=>{let n,r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");if(null==r)throw new Error("Can not access image data");{let s,a,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],a=e.dims[1],i=e.dims[3]):(s=e.dims[3],a=e.dims[2],i=e.dims[1]);let A,o,l=void 0!==t&&void 0!==t.format?t.format:"RGB",u=t?.norm;void 0===u||void 0===u.mean?A=[255,255,255,255]:"number"==typeof u.mean?A=[u.mean,u.mean,u.mean,u.mean]:(A=[u.mean[0],u.mean[1],u.mean[2],255],void 0!==u.mean[3]&&(A[3]=u.mean[3])),void 0===u||void 0===u.bias?o=[0,0,0,0]:"number"==typeof u.bias?o=[u.bias,u.bias,u.bias,u.bias]:(o=[u.bias[0],u.bias[1],u.bias[2],0],void 0!==u.bias[3]&&(o[3]=u.bias[3]));let c=a*s;if(void 0!==t&&(void 0!==t.format&&4===i&&"RGBA"!==t.format||3===i&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");let d=4,h=0,f=1,g=2,p=3,m=0,b=c,C=2*c,I=-1;"RGBA"===l?(m=0,b=c,C=2*c,I=3*c):"RGB"===l?(m=0,b=c,C=2*c):"RBG"===l&&(m=0,C=c,b=2*c),n=r.createImageData(s,a);for(let t=0;t<a*s;h+=d,f+=d,g+=d,p+=d,t++)n.data[h]=(e.data[m++]-o[0])*A[0],n.data[f]=(e.data[b++]-o[1])*A[1],n.data[g]=(e.data[C++]-o[2])*A[2],n.data[p]=-1===I?255:(e.data[I++]-o[3])*A[3]}return n}})),ue=te((()=>{he(),D=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");let n,r,{height:s,width:a}=t,i=t.norm??{mean:255,bias:0};n="number"==typeof i.mean?[i.mean,i.mean,i.mean,i.mean]:[i.mean[0],i.mean[1],i.mean[2],i.mean[3]??255],r="number"==typeof i.bias?[i.bias,i.bias,i.bias,i.bias]:[i.bias[0],i.bias[1],i.bias[2],i.bias[3]??0];let A=void 0!==t.format?t.format:"RGBA",o=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",l=s*a,u="RGBA"===o?new Float32Array(4*l):new Float32Array(3*l),c=4,d=0,h=1,f=2,g=3,p=0,m=l,b=2*l,C=-1;"RGB"===A&&(c=3,d=0,h=1,f=2,g=-1),"RGBA"===o?C=3*l:"RBG"===o?(p=0,b=l,m=2*l):"BGR"===o&&(b=0,m=l,p=2*l);for(let t=0;t<l;t++,d+=c,f+=c,h+=c,g+=c)u[p++]=(e[d]+r[0])/n[0],u[m++]=(e[h]+r[1])/n[1],u[b++]=(e[f]+r[2])/n[2],-1!==C&&-1!==g&&(u[C++]=(e[g]+r[3])/n[3]);return new W("float32",u,"RGBA"===o?[1,4,s,a]:[1,3,s,a])},T=async(e,t)=>{let n,r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,s=typeof ImageData<"u"&&e instanceof ImageData,a=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,i="string"==typeof e,A=t??{},o=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},l=e=>typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(r){let r=o();r.width=e.width,r.height=e.height;let s=l(r);if(null==s)throw new Error("Can not access image data");{let r=e.height,a=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(r=t.resizedHeight,a=t.resizedWidth),void 0!==t){if(A=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");A.tensorFormat="RGBA",A.height=r,A.width=a}else A.tensorFormat="RGBA",A.height=r,A.width=a;s.drawImage(e,0,0),n=s.getImageData(0,0,a,r).data}}else{if(!s){if(a){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");let r=o();r.width=e.width,r.height=e.height;let s=l(r);if(null!=s){let t=e.height,r=e.width;return s.drawImage(e,0,0,r,t),n=s.getImageData(0,0,r,t).data,A.height=t,A.width=r,D(n,A)}throw new Error("Can not access image data")}if(i)return new Promise(((t,n)=>{let r=o(),s=l(r);if(!e||!s)return n();let a=new Image;a.crossOrigin="Anonymous",a.src=e,a.onload=()=>{r.width=a.width,r.height=a.height,s.drawImage(a,0,0,r.width,r.height);let e=s.getImageData(0,0,r.width,r.height);A.height=r.height,A.width=r.width,t(D(e.data,A))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let r,s;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,s=t.resizedWidth):(r=e.height,s=e.width),void 0!==t&&(A=t),A.format="RGBA",A.height=r,A.width=s,void 0!==t){let t=o();t.width=s,t.height=r;let a=l(t);if(null==a)throw new Error("Can not access image data");a.putImageData(e,0,0),n=a.getImageData(0,0,s,r).data}else n=e.data}}if(void 0!==n)return D(n,A);throw new Error("Input data provided is not supported - aborted tensor creation")},S=(e,t)=>{let{width:n,height:r,download:s,dispose:a}=t;return new W({location:"texture",type:"float32",texture:e,dims:[1,r,n,4],download:s,dispose:a})},N=(e,t)=>{let{dataType:n,dims:r,download:s,dispose:a}=t;return new W({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:s,dispose:a})},G=(e,t)=>{let{dataType:n,dims:r,download:s,dispose:a}=t;return new W({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:r,download:s,dispose:a})},F=(e,t,n)=>new W({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})})),ce=te((()=>{P=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Q=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),z=!1,O=()=>{if(!z){z=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,n=globalThis.Float16Array,r=typeof n<"u"&&n.from;e&&(P.set("int64",BigInt64Array),Q.set(BigInt64Array,"int64")),t&&(P.set("uint64",BigUint64Array),Q.set(BigUint64Array,"uint64")),r?(P.set("float16",n),Q.set(n,"float16")):P.set("float16",Uint16Array)}}})),de=te((()=>{he(),R=e=>{let t=1;for(let n=0;n<e.length;n++){let r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},L=(e,t)=>{switch(e.location){case"cpu":return new W(e.type,e.data,t);case"cpu-pinned":return new W({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new W({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new W({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new W({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}})),he=te((()=>{le(),ue(),ce(),de(),W=class{constructor(e,t,n){let r,s;if(O(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,r=e.type,s=e.dims,e.location){case"cpu-pinned":{let t=P.get(r);if(!t)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint64"!==r&&"int8"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,i;if("string"==typeof e)if(r=e,i=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");a=t}else{let n=P.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&n===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${n.name} as data.`);a="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else if(t instanceof n)a=t;else if(t instanceof Uint8ClampedArray){if("uint8"!==e)throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");a=Uint8Array.from(t)}else{if(!("float16"===e&&t instanceof Uint16Array&&n!==Uint16Array))throw new TypeError(`A ${r} tensor's data must be type of ${n}`);a=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length)}}else if(i=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)r="string",a=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",a=Uint8Array.from(e)}}else if(e instanceof Uint8ClampedArray)r="uint8",a=Uint8Array.from(e);else{let t=Q.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,a=e}if(void 0===i)i=[a.length];else if(!Array.isArray(i))throw new TypeError("A tensor's dims must be a number array");s=i,this.cpuData=a,this.dataLocation="cpu"}let a=R(s);if(this.cpuData&&a!==this.cpuData.length&&("uint4"!==r&&"int4"!==r||Math.ceil(a/2)!==this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=s,this.size=a}static async fromImage(e,t){return T(e,t)}static fromTexture(e,t){return S(e,t)}static fromGpuBuffer(e,t){return N(e,t)}static fromMLTensor(e,t){return G(e,t)}static fromPinnedBuffer(e,t,n){return F(e,t,n)}toDataURL(e){return B(this,e)}toImageData(e){return M(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return L(this,e)}}})),fe=te((()=>{he(),_=W})),ge=te((()=>{Ae(),V=(e,t)=>{(typeof v.trace>"u"?!v.wasm.trace:!v.trace)||console.timeStamp(`${e}::ORT::${t}`)},H=(e,t)=>{let n=(new Error).stack?.split(/\r\n|\r|\n/g)||[],r=!1;for(let s=0;s<n.length;s++){if(r&&!n[s].includes("TRACE_FUNC")){let r=`FUNC_${e}::${n[s].trim().split(" ")[1]}`;return t&&(r+=`::${t}`),void V("CPU",r)}n[s].includes("TRACE_FUNC")&&(r=!0)}},U=e=>{(typeof v.trace>"u"?!v.wasm.trace:!v.trace)||H("BEGIN",e)},j=e=>{(typeof v.trace>"u"?!v.wasm.trace:!v.trace)||H("END",e)}})),pe=te((()=>{se(),fe(),ge(),Y=class e{constructor(e){this.handler=e}async run(e,t,n){U();let r={},s={};if("object"!=typeof e||null===e||e instanceof _||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof _)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,i=Object.getOwnPropertyNames(t);for(let n of this.outputNames)if(-1!==i.indexOf(n)){let s=t[n];(null===s||s instanceof _)&&(e=!0,a=!1,r[n]=s)}if(e){if("object"==typeof n&&null!==n)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else s=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(a)for(let e of this.outputNames)r[e]=null;let i=await this.handler.run(e,r,s),A={};for(let e in i)if(Object.hasOwnProperty.call(i,e)){let t=i[e];A[e]=t instanceof _?t:new _(t.type,t.data,t.dims)}return j(),A}async release(){return this.handler.dispose()}static async create(t,n,r,s){U();let a,i={};if("string"==typeof t){if(a=t,"object"==typeof n&&null!==n)i=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(a=t,"object"==typeof n&&null!==n)i=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{if(!(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{let e=t,A=0,o=t.byteLength;if("object"==typeof n&&null!==n)i=n;else if("number"==typeof n){if(A=n,!Number.isSafeInteger(A))throw new RangeError("'byteOffset' must be an integer.");if(A<0||A>=e.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(o=t.byteLength-A,"number"==typeof r){if(o=r,!Number.isSafeInteger(o))throw new RangeError("'byteLength' must be an integer.");if(o<=0||A+o>e.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${e.byteLength-A}].`);if("object"==typeof s&&null!==s)i=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(typeof r<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");a=new Uint8Array(e,A,o)}}let[A,o]=await k(i),l=await A.createInferenceSessionHandler(a,o);return j(),new e(l)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}})),me=te((()=>{pe(),K=Y})),be=te((()=>{})),Ce=te((()=>{})),Ie=te((()=>{})),we=te((()=>{})),ke={};ne(ke,{InferenceSession:()=>K,TRACE:()=>V,TRACE_FUNC_BEGIN:()=>U,TRACE_FUNC_END:()=>j,Tensor:()=>_,env:()=>E,registerBackend:()=>I});var xe=te((()=>{ae(),oe(),me(),fe(),be(),Ce(),ge(),Ie(),we()})),ye=te((()=>{})),ve={};ne(ve,{default:()=>Me});var Ee,Be,Me,De=te((()=>{Ec(),Il(),Cl(),Ee="ort-wasm-proxy-worker",(Be=globalThis.self?.name===Ee)&&(self.onmessage=e=>{let{type:t,in:n}=e.data;try{switch(t){case"init-wasm":nt(n.wasm).then((()=>{ju(n).then((()=>{postMessage({type:t})}),(e=>{postMessage({type:t,err:e})}))}),(e=>{postMessage({type:t,err:e})}));break;case"init-ep":{let{epName:e,env:r}=n;Yu(r,e).then((()=>{postMessage({type:t})}),(e=>{postMessage({type:t,err:e})}));break}case"copy-from":{let{buffer:e}=n,r=Zu(e);postMessage({type:t,out:r});break}case"create":{let{model:e,options:r}=n;Ju(e,r).then((e=>{postMessage({type:t,out:e})}),(e=>{postMessage({type:t,err:e})}));break}case"release":$u(n),postMessage({type:t});break;case"run":{let{sessionId:e,inputIndices:r,inputs:s,outputIndices:a,options:i}=n;tc(e,r,s,a,new Array(a.length).fill(null),i).then((e=>{e.some((e=>"cpu"!==e[3]))?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:e},rc([...s,...e]))}),(e=>{postMessage({type:t,err:e})}));break}case"end-profiling":nc(n),postMessage({type:t})}}catch(e){postMessage({type:t,err:e})}}),Me=Be?null:e=>new Worker(e??Oe,{type:"module",name:Ee})})),Te={};ne(Te,{default:()=>Ge});var Se,Ne,Ge,Fe,Pe,Qe,ze,Oe,Re,Le,We,_e,Ve,He,Ue,je,Ye,Ke,Xe,qe,Ze,Je,$e,et,tt,nt,rt,st,at,it,At,ot,lt,ut,ct,dt,ht,ft,gt,pt,mt,bt,Ct,It,wt,kt,xt,yt,vt,Et,Bt,Mt,Dt,Tt,St,Nt,Gt,Ft,Pt,Qt,zt,Ot,Rt,Lt,Wt,_t,Vt,Ht,Ut,jt,Yt,Kt,Xt,qt,Zt,Jt,$t,en,tn,nn,rn,sn,an,An,on,ln,un,cn,dn,hn,fn,gn,pn,mn,bn,Cn,In,wn,kn,xn,yn,vn,En,Bn,Mn,Dn,Tn,Sn,Nn,Gn,Fn,Pn,Qn,zn,On,Rn,Ln,Wn,_n,Vn,Hn,Un,jn,Yn,Kn,Xn,qn,Zn,Jn,$n,er,tr,nr,rr,sr,ar,ir,Ar,or,lr,ur,cr,dr,hr,fr,gr,pr,mr,br,Cr,Ir,wr,kr,xr,yr,vr,Er,Br,Mr,Dr,Tr,Sr,Nr,Gr,Fr,Pr,Qr,zr,Or,Rr,Lr,Wr,_r,Vr,Hr,Ur,jr,Yr,Kr,Xr,qr,Zr,Jr,$r,es,ts,ns,rs,ss,as,is,As,os,ls,us,cs,ds,hs,fs,gs,ps,ms,bs,Cs,Is,ws,ks,xs,ys,vs,Es,Bs,Ms,Ds,Ts,Ss,Ns,Gs,Fs,Ps,Qs,zs,Os,Rs,Ls,Ws,_s,Vs,Hs,Us,js,Ys,Ks,Xs,qs,Zs,Js,$s,ea,ta,na,ra,sa,aa,ia,Aa,oa,la,ua,ca,da,ha,fa,ga,pa,ma,ba,Ca,Ia,wa,ka,xa,ya,va,Ea,Ba,Ma,Da,Ta,Sa,Na,Ga,Fa,Pa,Qa,za,Oa,Ra,La,Wa,_a,Va,Ha,Ua,ja,Ya,Ka,Xa,qa,Za,Ja,$a,ei,ti,ni,ri,si,ai,ii,Ai,oi,li,ui,ci,di,hi,fi,gi,pi,mi,bi,Ci,Ii,wi,ki,xi,yi,vi,Ei,Bi,Mi,Di,Ti,Si,Ni,Gi,Fi,Pi,Qi,zi,Oi,Ri,Li,Wi,_i,Vi,Hi,Ui,ji,Yi,Ki,Xi,qi,Zi,Ji,$i,eA,tA,nA,rA,sA,aA,iA,AA,oA,lA,uA,cA,dA,hA,fA,gA,pA,mA,bA,CA,IA,wA,kA,xA,yA,vA,EA,BA,MA,DA,TA,SA,NA,GA,FA,PA,QA,zA,OA,RA,LA,WA,_A,VA,HA,UA,jA,YA,KA,XA,qA,ZA,JA,$A,eo,to,no,ro,so,ao,io,Ao,oo,lo,uo,co,ho,fo,go,po,mo,bo,Co,Io,wo,ko,xo,yo,vo,Eo,Bo,Mo,Do,To,So,No,Go,Fo,Po,Qo,zo,Oo,Ro,Lo,Wo,_o,Vo,Ho,Uo,jo,Yo,Ko,Xo,qo,Zo,Jo,$o,el,tl,nl,rl,sl,al,il,Al,ol,ll,ul,cl,dl,hl,fl,gl,pl,ml,bl=te((()=>{Se=import.meta.url,Ne=async function(e={}){var t,n,r=e,s=new Promise(((e,r)=>{t=e,n=r})),a="object"==typeof window,i=typeof WorkerGlobalScope<"u",A=i&&self.name?.startsWith("em-pthread");r.mountExternalData=(e,t)=>{e.startsWith("./")&&(e=e.substring(2)),(r.Eb||(r.Eb=new Map)).set(e,t)},r.unmountExternalData=()=>{delete r.Eb};var o=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,pc:!0}).buffer.constructor;let l=e=>async(...t)=>{try{if(r.Fb)throw Error("Session already started");let n=r.Fb={dc:t[0],errors:[]},s=await e(...t);if(r.Fb!==n)throw Error("Session mismatch");r.Jb?.flush();let a=n.errors;if(0<a.length){let e=await Promise.all(a);if(e=e.filter((e=>e)),0<e.length)throw Error(e.join("\n"))}return s}finally{r.Fb=null}};r.jsepInit=(e,t)=>{if("webgpu"===e){[r.Jb,r.Ub,r.Yb,r.Kb,r.Xb,r.jb,r.Zb,r.ac,r.Vb,r.Wb,r.$b]=t;let e=r.Jb;r.jsepRegisterBuffer=(t,n,r,s)=>e.registerBuffer(t,n,r,s),r.jsepGetBuffer=t=>e.getBuffer(t),r.jsepCreateDownloader=(t,n,r)=>e.createDownloader(t,n,r),r.jsepOnCreateSession=t=>{e.onCreateSession(t)},r.jsepOnReleaseSession=t=>{e.onReleaseSession(t)},r.jsepOnRunStart=t=>e.onRunStart(t),r.bc=(t,n)=>{e.upload(t,n)}}else if("webnn"===e){let e=t[0];[r.nc,r.Nb,r.webnnEnsureTensor,r.Ob,r.webnnDownloadTensor]=t.slice(1),r.webnnReleaseTensorId=r.Nb,r.webnnUploadTensor=r.Ob,r.webnnOnRunStart=t=>e.onRunStart(t),r.webnnOnRunEnd=e.onRunEnd.bind(e),r.webnnRegisterMLContext=(t,n)=>{e.registerMLContext(t,n)},r.webnnOnReleaseSession=t=>{e.onReleaseSession(t)},r.webnnCreateMLTensorDownloader=(t,n)=>e.createMLTensorDownloader(t,n),r.webnnRegisterMLTensor=(t,n,r,s)=>e.registerMLTensor(t,n,r,s),r.webnnCreateMLContext=t=>e.createMLContext(t),r.webnnRegisterMLConstant=(t,n,s,a,i,A)=>e.registerMLConstant(t,n,s,a,i,r.Eb,A),r.webnnRegisterGraphInput=e.registerGraphInput.bind(e),r.webnnIsGraphInput=e.isGraphInput.bind(e),r.webnnCreateTemporaryTensor=e.createTemporaryTensor.bind(e),r.webnnIsInt64Supported=e.isInt64Supported.bind(e)}};let u=()=>{let e=(e,t,n)=>(...r)=>{let s=Lt,a=t?.();r=e(...r);let i=t?.();return a!==i&&(e=i,n(a),t=n=null),Lt!=s?new Promise(((e,t)=>{jt={resolve:e,reject:t}})):r};(()=>{for(let t of["_OrtAppendExecutionProvider","_OrtCreateSession","_OrtRun","_OrtRunWithBinding","_OrtBindInput"])r[t]=e(r[t],(()=>r[t]),(e=>r[t]=e))})(),void 0!==l&&(r._OrtRun=l(r._OrtRun),r._OrtRunWithBinding=l(r._OrtRunWithBinding)),u=void 0};r.asyncInit=()=>{u?.()};var c,d,h=Object.assign({},r),f=(e,t)=>{throw t},g="";(a||i)&&(i?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),Se&&(g=Se),g=g.startsWith("blob:")?"":g.slice(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1),i&&(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),c=async e=>{if(P(e))return new Promise(((t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n(r.status)},r.onerror=n,r.send(null)}));var t=await fetch(e,{credentials:"same-origin"});if(t.ok)return t.arrayBuffer();throw Error(t.status+" : "+t.url)});var p=console.log.bind(console),m=console.error.bind(console),b=p,C=m;Object.assign(r,h),h=null;var I,w,k,x,y,v,E,B,M,D,T,S,N,G=r.wasmBinary,F=!1,P=e=>e.startsWith("file://");function Q(){return I.buffer!=x.buffer&&j(),x}function z(){return I.buffer!=x.buffer&&j(),y}function O(){return I.buffer!=x.buffer&&j(),v}function R(){return I.buffer!=x.buffer&&j(),E}function L(){return I.buffer!=x.buffer&&j(),B}function W(){return I.buffer!=x.buffer&&j(),M}function _(){return I.buffer!=x.buffer&&j(),D}function V(){return I.buffer!=x.buffer&&j(),N}if(A){let e=function(t){try{var n=t.data,s=n.Bb;if("load"===s){let t=[];self.onmessage=e=>t.push(e),self.startWorker=()=>{postMessage({Bb:"loaded"});for(let n of t)e(n);self.onmessage=e};for(let e of n.Rb)r[e]&&!r[e].proxy||(r[e]=(...t)=>{postMessage({Bb:"callHandler",Qb:e,args:t})},"print"==e&&(b=r[e]),"printErr"==e&&(C=r[e]));I=n.kc,j(),H(n.lc)}else if("run"===s){Ie(n.Ab),hr(n.Ab,0,0,1,0,0),me(),Et(n.Ab),U||(lr(),U=!0);try{we(n.fc,n.Hb)}catch(e){if("unwind"!=e)throw e}}else"setimmediate"!==n.target&&("checkMailbox"===s?U&&Bt():s&&(C(`worker: received unknown command ${s}`),C(n)))}catch(e){throw fr(),e}};var H,U=!1;C=function(...e){e=e.join(" "),console.error(e)},self.alert=function(...e){postMessage({Bb:"alert",text:e.join(" "),ic:ur()})},self.onunhandledrejection=e=>{throw e.reason||e},self.onmessage=e}function j(){var e=I.buffer;r.HEAP8=x=new Int8Array(e),r.HEAP16=v=new Int16Array(e),r.HEAPU8=y=new Uint8Array(e),r.HEAPU16=E=new Uint16Array(e),r.HEAP32=B=new Int32Array(e),r.HEAPU32=M=new Uint32Array(e),r.HEAPF32=D=new Float32Array(e),r.HEAPF64=N=new Float64Array(e),r.HEAP64=T=new BigInt64Array(e),r.HEAPU64=S=new BigUint64Array(e)}function Y(){A?startWorker(r):ir.Ca()}A||(I=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),j());var K,X=0,q=null;function Z(){if(0==--X&&q){var e=q;q=null,e()}}function J(e){throw C(e="Aborted("+e+")"),F=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),n(e),e}function $(){return{a:{L:ne,Aa:te,b:xe,$:ve,A:De,pa:Te,X:Fe,Z:Pe,qa:Qe,na:ze,ga:Oe,ma:Re,J:Le,Y:We,V:_e,oa:Ve,W:He,va:Ye,E:$e,Q:tt,O:lt,D:ct,u:dt,r:ht,P:ft,z:kt,R:xt,ja:yt,T:Mt,aa:Tt,M:St,F:Nt,ia:Et,sa:Gt,t:Qt,Ba:zt,w:Xt,o:Zt,l:en,c:st,n:nn,j:An,v:on,p:ln,f:un,s:cn,m:dn,e:hn,k:fn,i:gn,g:pn,d:mn,da:bn,ea:kn,fa:xn,ba:yn,ca:vn,N:Mn,xa:Dn,ua:Sn,h:Fn,C:Pn,G:Qn,ta:Tn,x:zn,ra:On,U:Rn,q:Bn,y:Ln,K:Wn,S:_n,za:jn,ya:Yn,ka:Zn,la:Jn,_:ce,B:$n,I:er,ha:tr,H:rr,a:I,wa:le}}}var ee={829644:(e,t,n,s,a)=>{if(void 0===r||!r.Eb)return 1;if((e=Me(Number(e>>>0))).startsWith("./")&&(e=e.substring(2)),!(e=r.Eb.get(e)))return 2;if(t=Number(t>>>0),n=Number(n>>>0),s=Number(s>>>0),t+n>e.byteLength)return 3;try{let i=e.subarray(t,t+n);switch(a){case 0:z().set(i,s>>>0);break;case 1:r.mc?r.mc(s,i):r.bc(s,i);break;default:return 4}return 0}catch{return 4}},830468:(e,t,n)=>{r.Ob(e,z().subarray(t>>>0,t+n>>>0))},830532:()=>r.nc(),830574:e=>{r.Nb(e)},830611:()=>{r.Vb()},830642:()=>{r.Wb()},830671:()=>{r.$b()},830696:e=>r.Ub(e),830729:e=>r.Yb(e),830761:(e,t,n)=>{r.Kb(Number(e),Number(t),Number(n),!0)},830824:(e,t,n)=>{r.Kb(Number(e),Number(t),Number(n))},830881:()=>typeof wasmOffsetConverter<"u",830938:e=>{r.jb("Abs",e,void 0)},830989:e=>{r.jb("Neg",e,void 0)},831040:e=>{r.jb("Floor",e,void 0)},831093:e=>{r.jb("Ceil",e,void 0)},831145:e=>{r.jb("Reciprocal",e,void 0)},831203:e=>{r.jb("Sqrt",e,void 0)},831255:e=>{r.jb("Exp",e,void 0)},831306:e=>{r.jb("Erf",e,void 0)},831357:e=>{r.jb("Sigmoid",e,void 0)},831412:(e,t,n)=>{r.jb("HardSigmoid",e,{alpha:t,beta:n})},831491:e=>{r.jb("Log",e,void 0)},831542:e=>{r.jb("Sin",e,void 0)},831593:e=>{r.jb("Cos",e,void 0)},831644:e=>{r.jb("Tan",e,void 0)},831695:e=>{r.jb("Asin",e,void 0)},831747:e=>{r.jb("Acos",e,void 0)},831799:e=>{r.jb("Atan",e,void 0)},831851:e=>{r.jb("Sinh",e,void 0)},831903:e=>{r.jb("Cosh",e,void 0)},831955:e=>{r.jb("Asinh",e,void 0)},832008:e=>{r.jb("Acosh",e,void 0)},832061:e=>{r.jb("Atanh",e,void 0)},832114:e=>{r.jb("Tanh",e,void 0)},832166:e=>{r.jb("Not",e,void 0)},832217:(e,t,n)=>{r.jb("Clip",e,{min:t,max:n})},832286:e=>{r.jb("Clip",e,void 0)},832338:(e,t)=>{r.jb("Elu",e,{alpha:t})},832396:e=>{r.jb("Gelu",e,void 0)},832448:e=>{r.jb("Relu",e,void 0)},832500:(e,t)=>{r.jb("LeakyRelu",e,{alpha:t})},832564:(e,t)=>{r.jb("ThresholdedRelu",e,{alpha:t})},832634:(e,t)=>{r.jb("Cast",e,{to:t})},832692:e=>{r.jb("Add",e,void 0)},832743:e=>{r.jb("Sub",e,void 0)},832794:e=>{r.jb("Mul",e,void 0)},832845:e=>{r.jb("Div",e,void 0)},832896:e=>{r.jb("Pow",e,void 0)},832947:e=>{r.jb("Equal",e,void 0)},833e3:e=>{r.jb("Greater",e,void 0)},833055:e=>{r.jb("GreaterOrEqual",e,void 0)},833117:e=>{r.jb("Less",e,void 0)},833169:e=>{r.jb("LessOrEqual",e,void 0)},833228:(e,t,n,s,a)=>{r.jb("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(L().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},833403:(e,t,n,s,a)=>{r.jb("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(L().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},833577:(e,t,n,s,a)=>{r.jb("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(L().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},833751:(e,t,n,s,a)=>{r.jb("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(L().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},833926:(e,t,n,s,a)=>{r.jb("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(L().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},834100:(e,t,n,s,a)=>{r.jb("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(L().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},834273:(e,t,n,s,a)=>{r.jb("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(L().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},834446:(e,t,n,s,a)=>{r.jb("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(L().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},834623:(e,t,n,s,a)=>{r.jb("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(L().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},834803:(e,t,n,s,a)=>{r.jb("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(L().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},834983:e=>{r.jb("Where",e,void 0)},835036:(e,t,n)=>{r.jb("Transpose",e,{perm:t?Array.from(L().subarray(Number(t)>>>0,Number(n)>>>0)):[]})},835160:(e,t,n,s)=>{r.jb("DepthToSpace",e,{blocksize:t,mode:Me(n),format:s?"NHWC":"NCHW"})},835293:(e,t,n,s)=>{r.jb("DepthToSpace",e,{blocksize:t,mode:Me(n),format:s?"NHWC":"NCHW"})},835426:(e,t,n,s,a,i,A,o,l,u,c,d,h,f,g)=>{r.jb("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:[n],group:s,kernelShape:[a],pads:[i,A],strides:[o],wIsConst:()=>!!Q()[u>>>0],outputPadding:c?Array.from(L().subarray(Number(c)>>>0,Number(d)>>>0)):[],outputShape:h?Array.from(L().subarray(Number(h)>>>0,Number(f)>>>0)):[],activation:Me(g)})},835859:(e,t,n,s,a,i,A,o,l,u,c,d,h,f)=>{r.jb("ConvTranspose",e,{format:o?"NHWC":"NCHW",autoPad:t,dilations:Array.from(L().subarray(Number(n)>>>0,2+(Number(n)>>>0)>>>0)),group:s,kernelShape:Array.from(L().subarray(Number(a)>>>0,2+(Number(a)>>>0)>>>0)),pads:Array.from(L().subarray(Number(i)>>>0,4+(Number(i)>>>0)>>>0)),strides:Array.from(L().subarray(Number(A)>>>0,2+(Number(A)>>>0)>>>0)),wIsConst:()=>!!Q()[l>>>0],outputPadding:u?Array.from(L().subarray(Number(u)>>>0,Number(c)>>>0)):[],outputShape:d?Array.from(L().subarray(Number(d)>>>0,Number(h)>>>0)):[],activation:Me(f)})},836520:(e,t,n,s,a,i,A,o,l,u,c,d,h,f,g)=>{r.jb("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:[n],group:s,kernelShape:[a],pads:[i,A],strides:[o],wIsConst:()=>!!Q()[u>>>0],outputPadding:c?Array.from(L().subarray(Number(c)>>>0,Number(d)>>>0)):[],outputShape:h?Array.from(L().subarray(Number(h)>>>0,Number(f)>>>0)):[],activation:Me(g)})},836953:(e,t,n,s,a,i,A,o,l,u,c,d,h,f)=>{r.jb("ConvTranspose",e,{format:o?"NHWC":"NCHW",autoPad:t,dilations:Array.from(L().subarray(Number(n)>>>0,2+(Number(n)>>>0)>>>0)),group:s,kernelShape:Array.from(L().subarray(Number(a)>>>0,2+(Number(a)>>>0)>>>0)),pads:Array.from(L().subarray(Number(i)>>>0,4+(Number(i)>>>0)>>>0)),strides:Array.from(L().subarray(Number(A)>>>0,2+(Number(A)>>>0)>>>0)),wIsConst:()=>!!Q()[l>>>0],outputPadding:u?Array.from(L().subarray(Number(u)>>>0,Number(c)>>>0)):[],outputShape:d?Array.from(L().subarray(Number(d)>>>0,Number(h)>>>0)):[],activation:Me(f)})},837614:(e,t)=>{r.jb("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},837705:(e,t,n,s,a,i,A,o,l,u,c,d,h,f)=>{r.jb("AveragePool",e,{format:f?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:s,storage_order:a,dilations:i?Array.from(L().subarray(Number(i)>>>0,Number(A)>>>0)):[],kernel_shape:o?Array.from(L().subarray(Number(o)>>>0,Number(l)>>>0)):[],pads:u?Array.from(L().subarray(Number(u)>>>0,Number(c)>>>0)):[],strides:d?Array.from(L().subarray(Number(d)>>>0,Number(h)>>>0)):[]})},838184:(e,t)=>{r.jb("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},838275:(e,t,n,s,a,i,A,o,l,u,c,d,h,f)=>{r.jb("AveragePool",e,{format:f?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:s,storage_order:a,dilations:i?Array.from(L().subarray(Number(i)>>>0,Number(A)>>>0)):[],kernel_shape:o?Array.from(L().subarray(Number(o)>>>0,Number(l)>>>0)):[],pads:u?Array.from(L().subarray(Number(u)>>>0,Number(c)>>>0)):[],strides:d?Array.from(L().subarray(Number(d)>>>0,Number(h)>>>0)):[]})},838754:(e,t)=>{r.jb("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},838841:(e,t,n,s,a,i,A,o,l,u,c,d,h,f)=>{r.jb("MaxPool",e,{format:f?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:s,storage_order:a,dilations:i?Array.from(L().subarray(Number(i)>>>0,Number(A)>>>0)):[],kernel_shape:o?Array.from(L().subarray(Number(o)>>>0,Number(l)>>>0)):[],pads:u?Array.from(L().subarray(Number(u)>>>0,Number(c)>>>0)):[],strides:d?Array.from(L().subarray(Number(d)>>>0,Number(h)>>>0)):[]})},839316:(e,t)=>{r.jb("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},839403:(e,t,n,s,a,i,A,o,l,u,c,d,h,f)=>{r.jb("MaxPool",e,{format:f?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:s,storage_order:a,dilations:i?Array.from(L().subarray(Number(i)>>>0,Number(A)>>>0)):[],kernel_shape:o?Array.from(L().subarray(Number(o)>>>0,Number(l)>>>0)):[],pads:u?Array.from(L().subarray(Number(u)>>>0,Number(c)>>>0)):[],strides:d?Array.from(L().subarray(Number(d)>>>0,Number(h)>>>0)):[]})},839878:(e,t,n,s,a)=>{r.jb("Gemm",e,{alpha:t,beta:n,transA:s,transB:a})},839982:e=>{r.jb("MatMul",e,void 0)},840036:(e,t,n,s)=>{r.jb("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:s})},840144:(e,t,n,s)=>{r.jb("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:s})},840252:(e,t)=>{r.jb("Softmax",e,{axis:t})},840315:(e,t)=>{r.jb("Concat",e,{axis:t})},840375:(e,t,n,s,a)=>{r.jb("Split",e,{axis:t,numOutputs:n,splitSizes:s?Array.from(L().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},840531:e=>{r.jb("Expand",e,void 0)},840585:(e,t)=>{r.jb("Gather",e,{axis:Number(t)})},840656:(e,t)=>{r.jb("GatherElements",e,{axis:Number(t)})},840735:(e,t)=>{r.jb("GatherND",e,{batch_dims:Number(t)})},840814:(e,t,n,s,a,i,A,o,l,u,c)=>{r.jb("Resize",e,{antialias:t,axes:n?Array.from(L().subarray(Number(n)>>>0,Number(s)>>>0)):[],coordinateTransformMode:Me(a),cubicCoeffA:i,excludeOutside:A,extrapolationValue:o,keepAspectRatioPolicy:Me(l),mode:Me(u),nearestMode:Me(c)})},841176:(e,t,n,s,a,i,A)=>{r.jb("Slice",e,{starts:t?Array.from(L().subarray(Number(t)>>>0,Number(n)>>>0)):[],ends:s?Array.from(L().subarray(Number(s)>>>0,Number(a)>>>0)):[],axes:i?Array.from(L().subarray(Number(i)>>>0,Number(A)>>>0)):[]})},841440:e=>{r.jb("Tile",e,void 0)},841492:(e,t,n)=>{r.jb("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},841606:(e,t,n)=>{r.jb("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},841720:e=>{r.jb("Range",e,void 0)},841773:(e,t)=>{r.jb("Einsum",e,{equation:Me(t)})},841854:(e,t,n,s,a)=>{r.jb("Pad",e,{mode:t,value:n,pads:s?Array.from(L().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},841997:(e,t,n,s,a,i)=>{r.jb("BatchNormalization",e,{epsilon:t,momentum:n,spatial:!!a,trainingMode:!!s,format:i?"NHWC":"NCHW"})},842166:(e,t,n,s,a,i)=>{r.jb("BatchNormalization",e,{epsilon:t,momentum:n,spatial:!!a,trainingMode:!!s,format:i?"NHWC":"NCHW"})},842335:(e,t,n)=>{r.jb("CumSum",e,{exclusive:Number(t),reverse:Number(n)})},842432:(e,t,n)=>{r.jb("DequantizeLinear",e,{axis:t,blockSize:n})},842522:(e,t,n,s,a)=>{r.jb("GridSample",e,{align_corners:t,mode:Me(n),padding_mode:Me(s),format:a?"NHWC":"NCHW"})},842692:(e,t,n,s,a)=>{r.jb("GridSample",e,{align_corners:t,mode:Me(n),padding_mode:Me(s),format:a?"NHWC":"NCHW"})},842862:(e,t)=>{r.jb("ScatterND",e,{reduction:Me(t)})},842947:(e,t,n,s,a,i,A,o,l)=>{r.jb("Attention",e,{numHeads:t,isUnidirectional:n,maskFilterValue:s,scale:a,doRotary:i,qkvHiddenSizes:A?Array.from(L().subarray(Number(o)>>>0,Number(o)+A>>>0)):[],pastPresentShareBuffer:!!l})},843219:e=>{r.jb("BiasAdd",e,void 0)},843274:e=>{r.jb("BiasSplitGelu",e,void 0)},843335:e=>{r.jb("FastGelu",e,void 0)},843391:(e,t,n,s,a,i,A,o,l,u,c,d,h,f,g,p)=>{r.jb("Conv",e,{format:d?"NHWC":"NCHW",auto_pad:t,dilations:n?Array.from(L().subarray(Number(n)>>>0,Number(s)>>>0)):[],group:a,kernel_shape:i?Array.from(L().subarray(Number(i)>>>0,Number(A)>>>0)):[],pads:o?Array.from(L().subarray(Number(o)>>>0,Number(l)>>>0)):[],strides:u?Array.from(L().subarray(Number(u)>>>0,Number(c)>>>0)):[],w_is_const:()=>!!Q()[Number(h)>>>0],activation:Me(f),activation_params:g?Array.from(_().subarray(Number(g)>>>0,Number(p)>>>0)):[]})},843975:e=>{r.jb("Gelu",e,void 0)},844027:(e,t,n,s,a,i,A,o,l)=>{r.jb("GroupQueryAttention",e,{numHeads:t,kvNumHeads:n,scale:s,softcap:a,doRotary:i,rotaryInterleaved:A,smoothSoftmax:o,localWindowSize:l})},844244:(e,t,n,s)=>{r.jb("LayerNormalization",e,{axis:t,epsilon:n,simplified:!!s})},844355:(e,t,n,s)=>{r.jb("LayerNormalization",e,{axis:t,epsilon:n,simplified:!!s})},844466:(e,t,n,s,a,i)=>{r.jb("MatMulNBits",e,{k:t,n:n,accuracyLevel:s,bits:a,blockSize:i})},844593:(e,t,n,s,a,i)=>{r.jb("MultiHeadAttention",e,{numHeads:t,isUnidirectional:n,maskFilterValue:s,scale:a,doRotary:i})},844752:(e,t)=>{r.jb("QuickGelu",e,{alpha:t})},844816:(e,t,n,s,a)=>{r.jb("RotaryEmbedding",e,{interleaved:!!t,numHeads:n,rotaryEmbeddingDim:s,scale:a})},844955:(e,t,n)=>{r.jb("SkipLayerNormalization",e,{epsilon:t,simplified:!!n})},845057:(e,t,n)=>{r.jb("SkipLayerNormalization",e,{epsilon:t,simplified:!!n})},845159:(e,t,n,s)=>{r.jb("GatherBlockQuantized",e,{gatherAxis:t,quantizeAxis:n,blockSize:s})},845280:e=>{r.Zb(e)},845314:(e,t)=>r.ac(Number(e),Number(t),r.Fb.dc,r.Fb.errors)};function te(e,t,n){return Kt((async()=>{await r.Xb(Number(e),Number(t),Number(n))}))}function ne(){return typeof wasmOffsetConverter<"u"}class re{name="ExitStatus";constructor(e){this.message=`Program terminated with exit(${e})`,this.status=e}}var se=e=>{e.terminate(),e.onmessage=()=>{}},ae=[],ie=e=>{0==de.length&&(Ce(),be(de[0]));var t=de.pop();if(!t)return 6;he.push(t),ge[e.Ab]=t,t.Ab=e.Ab;var n={Bb:"run",fc:e.ec,Hb:e.Hb,Ab:e.Ab};return t.postMessage(n,e.Mb),0},Ae=0,oe=(e,t,...n)=>{for(var r=2*n.length,s=xr(),a=kr(8*r),i=a>>>3,A=0;A<n.length;A++){var o=n[A];"bigint"==typeof o?(T[i+2*A]=1n,T[i+2*A+1]=o):(T[i+2*A]=0n,V()[i+2*A+1>>>0]=o)}return e=gr(e,0,r,a,t),wr(s),e};function le(e){if(A)return oe(0,1,e);if(k=e,!(0<Ae)){for(var t of he)se(t);for(t of de)se(t);de=[],he=[],ge={},F=!0}f(0,new re(e))}function ue(e){if(A)return oe(1,0,e);ce(e)}var ce=e=>{if(k=e,A)throw ue(e),"unwind";le(e)},de=[],he=[],fe=[],ge={},pe=e=>{var t=e.Ab;delete ge[t],de.push(e),he.splice(he.indexOf(e),1),e.Ab=0,pr(t)};function me(){fe.forEach((e=>e()))}var be=e=>new Promise((t=>{e.onmessage=n=>{var s=(n=n.data).Bb;if(n.Gb&&n.Gb!=ur()){var a=ge[n.Gb];a?a.postMessage(n,n.Mb):C(`Internal error! Worker sent a message "${s}" to target pthread ${n.Gb}, but that thread no longer exists!`)}else"checkMailbox"===s?Bt():"spawnThread"===s?ie(n):"cleanupThread"===s?pe(ge[n.hc]):"loaded"===s?(e.loaded=!0,t(e)):"alert"===s?alert(`Thread ${n.ic}: ${n.text}`):"setimmediate"===n.target?e.postMessage(n):"callHandler"===s?r[n.Qb](...n.args):s&&C(`worker sent an unknown command ${s}`)},e.onerror=e=>{throw C(`worker sent an error! ${e.filename}:${e.lineno}: ${e.message}`),e};var n,s=[];for(n of[])r.propertyIsEnumerable(n)&&s.push(n);e.postMessage({Bb:"load",Rb:s,kc:I,lc:w})}));function Ce(){var e=new Worker((()=>{let e=URL;return import.meta.url>"file:"&&import.meta.url<"file;"?new e("ort.bundle.min.mjs",import.meta.url):new URL(import.meta.url)})(),{type:"module",workerData:"em-pthread",name:"em-pthread"});de.push(e)}var Ie=e=>{j();var t=W()[e+52>>>2>>>0];e=W()[e+56>>>2>>>0],Ir(t,t-e),wr(t)},we=(e,t)=>{Ae=0,e=yr(e,t),0<Ae?k=e:mr(e)};class ke{constructor(e){this.Ib=e-24}}function xe(e,t,n){var r=new ke(e>>>=0);throw t>>>=0,n>>>=0,W()[r.Ib+16>>>2>>>0]=0,W()[r.Ib+4>>>2>>>0]=t,W()[r.Ib+8>>>2>>>0]=n,e}function ye(e,t,n,r){return A?oe(2,1,e,t,n,r):ve(e,t,n,r)}function ve(e,t,n,r){if(e>>>=0,n>>>=0,r>>>=0,void 0===o)return 6;var s=[];return A&&0===s.length?ye(e,t>>>=0,n,r):(e={ec:n,Ab:e,Hb:r,Mb:s},A?(e.Bb="spawnThread",postMessage(e,s),0):ie(e))}var Ee=typeof TextDecoder<"u"?new TextDecoder:void 0,Be=(e,t=0,n=NaN)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&Ee)return Ee.decode(e.buffer instanceof ArrayBuffer?e.subarray(t,n):e.slice(t,n));for(r="";t<n;){var s=e[t++];if(128&s){var a=63&e[t++];if(192==(224&s))r+=String.fromCharCode((31&s)<<6|a);else{var i=63&e[t++];65536>(s=224==(240&s)?(15&s)<<12|a<<6|i:(7&s)<<18|a<<12|i<<6|63&e[t++])?r+=String.fromCharCode(s):(s-=65536,r+=String.fromCharCode(55296|s>>10,56320|1023&s))}}else r+=String.fromCharCode(s)}return r},Me=(e,t)=>(e>>>=0)?Be(z(),e,t):"";function De(e,t,n){return A?oe(3,1,e,t,n):0}function Te(e,t){if(A)return oe(4,1,e,t)}var Ne=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},Ge=(e,t,n)=>{var r=z();if(t>>>=0,0<n){var s=t;n=t+n-1;for(var a=0;a<e.length;++a){var i=e.charCodeAt(a);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++a)),127>=i){if(t>=n)break;r[t++>>>0]=i}else{if(2047>=i){if(t+1>=n)break;r[t++>>>0]=192|i>>6}else{if(65535>=i){if(t+2>=n)break;r[t++>>>0]=224|i>>12}else{if(t+3>=n)break;r[t++>>>0]=240|i>>18,r[t++>>>0]=128|i>>12&63}r[t++>>>0]=128|i>>6&63}r[t++>>>0]=128|63&i}}r[t>>>0]=0,e=t-s}else e=0;return e};function Fe(e,t){if(A)return oe(5,1,e,t)}function Pe(e,t,n){if(A)return oe(6,1,e,t,n)}function Qe(e,t,n){return A?oe(7,1,e,t,n):0}function ze(e,t){if(A)return oe(8,1,e,t)}function Oe(e,t,n){if(A)return oe(9,1,e,t,n)}function Re(e,t,n,r){if(A)return oe(10,1,e,t,n,r)}function Le(e,t,n,r){if(A)return oe(11,1,e,t,n,r)}function We(e,t,n,r){if(A)return oe(12,1,e,t,n,r)}function _e(e){if(A)return oe(13,1,e)}function Ve(e,t){if(A)return oe(14,1,e,t)}function He(e,t,n){if(A)return oe(15,1,e,t,n)}var Ue,je,Ye=()=>J(""),Ke=e=>{for(var t="";z()[e>>>0];)t+=Ue[z()[e++>>>0]];return t},Xe={},qe={};function Ze(e,t,n={}){return function(e,t,n={}){var r=t.name;if(!e)throw new je(`type "${r}" must have a positive integer typeid pointer`);if(qe.hasOwnProperty(e)){if(n.Sb)return;throw new je(`Cannot register type '${r}' twice`)}qe[e]=t,Xe.hasOwnProperty(e)&&(t=Xe[e],delete Xe[e],t.forEach((e=>e())))}(e,t,n)}var Je=(e,t,n)=>{switch(t){case 1:return n?e=>Q()[e>>>0]:e=>z()[e>>>0];case 2:return n?e=>O()[e>>>1>>>0]:e=>R()[e>>>1>>>0];case 4:return n?e=>L()[e>>>2>>>0]:e=>W()[e>>>2>>>0];case 8:return n?e=>T[e>>>3]:e=>S[e>>>3];default:throw new TypeError(`invalid integer width (${t}): ${e}`)}};function $e(e,t,n){n>>>=0,Ze(e>>>=0,{name:t=Ke(t>>>0),fromWireType:e=>e,toWireType:function(e,t){if("bigint"!=typeof t&&"number"!=typeof t)throw t=null===t?"null":"object"==(e=typeof t)||"array"===e||"function"===e?t.toString():""+t,new TypeError(`Cannot convert "${t}" to ${this.name}`);return"number"==typeof t&&(t=BigInt(t)),t},Cb:et,readValueFromPointer:Je(t,n,-1==t.indexOf("u")),Db:null})}var et=8;function tt(e,t,n,r){Ze(e>>>=0,{name:t=Ke(t>>>0),fromWireType:function(e){return!!e},toWireType:function(e,t){return t?n:r},Cb:et,readValueFromPointer:function(e){return this.fromWireType(z()[e>>>0])},Db:null})}var nt=[],rt=[];function st(e){9<(e>>>=0)&&0==--rt[e+1]&&(rt[e]=void 0,nt.push(e))}var at=e=>{if(!e)throw new je("Cannot use deleted val. handle = "+e);return rt[e]},it=e=>{switch(e){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let t=nt.pop()||rt.length;return rt[t]=e,rt[t+1]=1,t}};function At(e){return this.fromWireType(W()[e>>>2>>>0])}var ot={name:"emscripten::val",fromWireType:e=>{var t=at(e);return st(e),t},toWireType:(e,t)=>it(t),Cb:et,readValueFromPointer:At,Db:null};function lt(e){return Ze(e>>>0,ot)}var ut=(e,t)=>{switch(t){case 4:return function(e){return this.fromWireType(_()[e>>>2>>>0])};case 8:return function(e){return this.fromWireType(V()[e>>>3>>>0])};default:throw new TypeError(`invalid float width (${t}): ${e}`)}};function ct(e,t,n){n>>>=0,Ze(e>>>=0,{name:t=Ke(t>>>0),fromWireType:e=>e,toWireType:(e,t)=>t,Cb:et,readValueFromPointer:ut(t,n),Db:null})}function dt(e,t,n,r,s){if(e>>>=0,n>>>=0,t=Ke(t>>>0),-1===s&&(s=4294967295),s=e=>e,0===r){var a=32-8*n;s=e=>e<<a>>>a}var i=t.includes("unsigned")?function(e,t){return t>>>0}:function(e,t){return t};Ze(e,{name:t,fromWireType:s,toWireType:i,Cb:et,readValueFromPointer:Je(t,n,0!==r),Db:null})}function ht(e,t,n){function r(e){var t=W()[e>>>2>>>0];return e=W()[e+4>>>2>>>0],new s(Q().buffer,e,t)}var s=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][t];Ze(e>>>=0,{name:n=Ke(n>>>0),fromWireType:r,Cb:et,readValueFromPointer:r},{Sb:!0})}function ft(e,t){Ze(e>>>=0,{name:t=Ke(t>>>0),fromWireType:function(e){for(var t,n=W()[e>>>2>>>0],r=e+4,s=r,a=0;a<=n;++a){var i=r+a;a!=n&&0!=z()[i>>>0]||(s=Me(s,i-s),void 0===t?t=s:(t+="\0",t+=s),s=i+1)}return cr(e),t},toWireType:function(e,t){t instanceof ArrayBuffer&&(t=new Uint8Array(t));var n="string"==typeof t;if(!(n||t instanceof Uint8Array||t instanceof Uint8ClampedArray||t instanceof Int8Array))throw new je("Cannot pass non-string to std::string");var r=n?Ne(t):t.length,s=dr(4+r+1),a=s+4;if(W()[s>>>2>>>0]=r,n)Ge(t,a,r+1);else if(n)for(n=0;n<r;++n){var i=t.charCodeAt(n);if(255<i)throw cr(s),new je("String has UTF-16 code units that do not fit in 8 bits");z()[a+n>>>0]=i}else for(n=0;n<r;++n)z()[a+n>>>0]=t[n];return null!==e&&e.push(cr,s),s},Cb:et,readValueFromPointer:At,Db(e){cr(e)}})}var gt=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,pt=(e,t)=>{for(var n=e>>1,r=n+t/2;!(n>=r)&&R()[n>>>0];)++n;if(32<(n<<=1)-e&&gt)return gt.decode(z().slice(e,n));for(n="",r=0;!(r>=t/2);++r){var s=O()[e+2*r>>>1>>>0];if(0==s)break;n+=String.fromCharCode(s)}return n},mt=(e,t,n)=>{if(n??=2147483647,2>n)return 0;var r=t;n=(n-=2)<2*e.length?n/2:e.length;for(var s=0;s<n;++s){var a=e.charCodeAt(s);O()[t>>>1>>>0]=a,t+=2}return O()[t>>>1>>>0]=0,t-r},bt=e=>2*e.length,Ct=(e,t)=>{for(var n=0,r="";!(n>=t/4);){var s=L()[e+4*n>>>2>>>0];if(0==s)break;++n,65536<=s?(s-=65536,r+=String.fromCharCode(55296|s>>10,56320|1023&s)):r+=String.fromCharCode(s)}return r},It=(e,t,n)=>{if(t>>>=0,n??=2147483647,4>n)return 0;var r=t;n=r+n-4;for(var s=0;s<e.length;++s){var a=e.charCodeAt(s);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&e.charCodeAt(++s)),L()[t>>>2>>>0]=a,(t+=4)+4>n)break}return L()[t>>>2>>>0]=0,t-r},wt=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);55296<=r&&57343>=r&&++n,t+=4}return t};function kt(e,t,n){if(e>>>=0,t>>>=0,n=Ke(n>>>=0),2===t)var r=pt,s=mt,a=bt,i=e=>R()[e>>>1>>>0];else 4===t&&(r=Ct,s=It,a=wt,i=e=>W()[e>>>2>>>0]);Ze(e,{name:n,fromWireType:e=>{for(var n,s=W()[e>>>2>>>0],a=e+4,A=0;A<=s;++A){var o=e+4+A*t;A!=s&&0!=i(o)||(a=r(a,o-a),void 0===n?n=a:(n+="\0",n+=a),a=o+t)}return cr(e),n},toWireType:(e,r)=>{if("string"!=typeof r)throw new je(`Cannot pass non-string to C++ string type ${n}`);var i=a(r),A=dr(4+i+t);return W()[A>>>2>>>0]=i/t,s(r,A+4,i+t),null!==e&&e.push(cr,A),A},Cb:et,readValueFromPointer:At,Db(e){cr(e)}})}function xt(e,t){Ze(e>>>=0,{Tb:!0,name:t=Ke(t>>>0),Cb:0,fromWireType:()=>{},toWireType:()=>{}})}function yt(e){hr(e>>>0,!i,1,!a,131072,!1),me()}var vt=e=>{if(!F)try{if(e(),!(0<Ae))try{A?mr(k):ce(k)}catch(e){e instanceof re||"unwind"==e||f(0,e)}}catch(e){e instanceof re||"unwind"==e||f(0,e)}};function Et(e){e>>>=0,"function"==typeof Atomics.jc&&(Atomics.jc(L(),e>>>2,e).value.then(Bt),e+=128,Atomics.store(L(),e>>>2,1))}var Bt=()=>{var e=ur();e&&(Et(e),vt(Cr))};function Mt(e,t){(e>>>=0)==t>>>0?setTimeout(Bt):A?postMessage({Gb:e,Bb:"checkMailbox"}):(e=ge[e])&&e.postMessage({Bb:"checkMailbox"})}var Dt=[];function Tt(e,t,n,r,s){for(t>>>=0,r/=2,Dt.length=r,n=s>>>0>>>3,s=0;s<r;s++)Dt[s]=T[n+2*s]?T[n+2*s+1]:V()[n+2*s+1>>>0];return(t?ee[t]:Ar[e])(...Dt)}var St=()=>{Ae=0};function Nt(e){e>>>=0,A?postMessage({Bb:"cleanupThread",hc:e}):pe(ge[e])}function Gt(e){}var Ft=(e,t)=>{var n=qe[e];if(void 0===n)throw e=or(e),n=Ke(e),cr(e),new je(`${t} has unknown type ${n}`);return n},Pt=(e,t,n)=>{var r=[];return e=e.toWireType(r,n),r.length&&(W()[t>>>2>>>0]=it(r)),e};function Qt(e,t,n){return t>>>=0,n>>>=0,e=at(e>>>0),t=Ft(t,"emval::as"),Pt(t,n,e)}function zt(e,t){return t>>>=0,e=at(e>>>0),(t=Ft(t,"emval::as")).toWireType(null,e)}var Ot=e=>{try{e()}catch(e){J(e)}},Rt=0,Lt=null,Wt=0,_t=[],Vt={},Ht={},Ut=0,jt=null,Yt=[];function Kt(e){return function(){if(!F){if(0===Rt){var t=!1,n=!1;(t=>{e().then(t)})(((e=0)=>{if(!F&&(Wt=e,t=!0,n)){Rt=2,Ot((()=>Br(Lt))),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.resume(),e=!1;try{var r=function(){var e=L()[Lt+8>>>2>>>0];return e=ir[Ht[e]],--Ae,e()}()}catch(t){r=t,e=!0}var s=!1;if(!Lt){var a=jt;a&&(jt=null,(e?a.reject:a.resolve)(r),s=!0)}if(e&&!s)throw r}})),n=!0,t||(Rt=1,Lt=function(){var e=dr(65548),t=e+12;W()[e>>>2>>>0]=t,W()[e+4>>>2>>>0]=t+65536,t=_t[0];var n=Vt[t];return void 0===n&&(n=Ut++,Vt[t]=n,Ht[n]=t),t=n,L()[e+8>>>2>>>0]=t,e}(),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.pause(),Ot((()=>vr(Lt))))}else 2===Rt?(Rt=0,Ot(Mr),cr(Lt),Lt=null,Yt.forEach(vt)):J(`invalid state: ${Rt}`);return Wt}}()}function Xt(e){return e>>>=0,Kt((async()=>{var t=await at(e);return it(t)}))}var qt=[];function Zt(e,t,n,r){return n>>>=0,r>>>=0,(e=qt[e>>>0])(null,t=at(t>>>0),n,r)}var Jt={},$t=e=>{var t=Jt[e];return void 0===t?Ke(e):t};function en(e,t,n,r,s){return n>>>=0,r>>>=0,s>>>=0,(e=qt[e>>>0])(t=at(t>>>0),t[n=$t(n)],r,s)}var tn=()=>"object"==typeof globalThis?globalThis:Function("return this")();function nn(e){return 0==(e>>>=0)?it(tn()):(e=$t(e),it(tn()[e]))}var rn=e=>{var t=qt.length;return qt.push(e),t},sn=(e,t)=>{for(var n=Array(e),r=0;r<e;++r)n[r]=Ft(W()[t+4*r>>>2>>>0],"parameter "+r);return n},an=(e,t)=>Object.defineProperty(t,"name",{value:e});function An(e,t,n){var r=(t=sn(e,t>>>0)).shift();e--;var s="return function (obj, func, destructorsRef, args) {\n",a=0,i=[];0===n&&i.push("obj");for(var A=["retType"],o=[r],l=0;l<e;++l)i.push("arg"+l),A.push("argType"+l),o.push(t[l]),s+=`  var arg${l} = argType${l}.readValueFromPointer(args${a?"+"+a:""});\n`,a+=t[l].Cb;return s+=`  var rv = ${1===n?"new func":"func.call"}(${i.join(", ")});\n`,r.Tb||(A.push("emval_returnValue"),o.push(Pt),s+="  return emval_returnValue(retType, destructorsRef, rv);\n"),A.push(s+"};\n"),e=function(e){var t=Function;if(!(t instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof t} which is not a function`);var n=an(t.name||"unknownFunctionName",(function(){}));return n.prototype=t.prototype,n=new n,(e=t.apply(n,e))instanceof Object?e:n}(A)(...o),n=`methodCaller<(${t.map((e=>e.name)).join(", ")}) => ${r.name}>`,rn(an(n,e))}function on(e){return e=$t(e>>>0),it(r[e])}function ln(e,t){return t>>>=0,e=at(e>>>0),t=at(t),it(e[t])}function un(e){9<(e>>>=0)&&(rt[e+1]+=1)}function cn(){return it([])}function dn(e){e=at(e>>>0);for(var t=Array(e.length),n=0;n<e.length;n++)t[n]=e[n];return it(t)}function hn(e){return it($t(e>>>0))}function fn(){return it({})}function gn(e){for(var t=at(e>>>=0);t.length;){var n=t.pop();t.pop()(n)}st(e)}function pn(e,t,n){t>>>=0,n>>>=0,e=at(e>>>0),t=at(t),n=at(n),e[t]=n}function mn(e,t){return t>>>=0,e=(e=Ft(e>>>0,"_emval_take_value")).readValueFromPointer(t),it(e)}function bn(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),L()[t>>>2>>>0]=e.getUTCSeconds(),L()[t+4>>>2>>>0]=e.getUTCMinutes(),L()[t+8>>>2>>>0]=e.getUTCHours(),L()[t+12>>>2>>>0]=e.getUTCDate(),L()[t+16>>>2>>>0]=e.getUTCMonth(),L()[t+20>>>2>>>0]=e.getUTCFullYear()-1900,L()[t+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,L()[t+28>>>2>>>0]=e}var Cn=e=>e%4==0&&(e%100!=0||e%400==0),In=[0,31,60,91,121,152,182,213,244,274,305,335],wn=[0,31,59,90,120,151,181,212,243,273,304,334];function kn(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),L()[t>>>2>>>0]=e.getSeconds(),L()[t+4>>>2>>>0]=e.getMinutes(),L()[t+8>>>2>>>0]=e.getHours(),L()[t+12>>>2>>>0]=e.getDate(),L()[t+16>>>2>>>0]=e.getMonth(),L()[t+20>>>2>>>0]=e.getFullYear()-1900,L()[t+24>>>2>>>0]=e.getDay();var n=(Cn(e.getFullYear())?In:wn)[e.getMonth()]+e.getDate()-1|0;L()[t+28>>>2>>>0]=n,L()[t+36>>>2>>>0]=-60*e.getTimezoneOffset(),n=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(n!=r&&e.getTimezoneOffset()==Math.min(r,n)),L()[t+32>>>2>>>0]=e}function xn(e){e>>>=0;var t=new Date(L()[e+20>>>2>>>0]+1900,L()[e+16>>>2>>>0],L()[e+12>>>2>>>0],L()[e+8>>>2>>>0],L()[e+4>>>2>>>0],L()[e>>>2>>>0],0),n=L()[e+32>>>2>>>0],r=t.getTimezoneOffset(),s=new Date(t.getFullYear(),6,1).getTimezoneOffset(),a=new Date(t.getFullYear(),0,1).getTimezoneOffset(),i=Math.min(a,s);return 0>n?L()[e+32>>>2>>>0]=+(s!=a&&i==r):0<n!=(i==r)&&(s=Math.max(a,s),t.setTime(t.getTime()+6e4*((0<n?i:s)-r))),L()[e+24>>>2>>>0]=t.getDay(),n=(Cn(t.getFullYear())?In:wn)[t.getMonth()]+t.getDate()-1|0,L()[e+28>>>2>>>0]=n,L()[e>>>2>>>0]=t.getSeconds(),L()[e+4>>>2>>>0]=t.getMinutes(),L()[e+8>>>2>>>0]=t.getHours(),L()[e+12>>>2>>>0]=t.getDate(),L()[e+16>>>2>>>0]=t.getMonth(),L()[e+20>>>2>>>0]=t.getYear(),e=t.getTime(),BigInt(isNaN(e)?-1:e/1e3)}function yn(e,t,n,r,s,a,i){return A?oe(16,1,e,t,n,r,s,a,i):-52}function vn(e,t,n,r,s,a){if(A)return oe(17,1,e,t,n,r,s,a)}var En={},Bn=()=>performance.timeOrigin+performance.now();function Mn(e,t){if(A)return oe(18,1,e,t);if(En[e]&&(clearTimeout(En[e].id),delete En[e]),!t)return 0;var n=setTimeout((()=>{delete En[e],vt((()=>br(e,performance.timeOrigin+performance.now())))}),t);return En[e]={id:n,qc:t},0}function Dn(e,t,n,r){e>>>=0,t>>>=0,n>>>=0,r>>>=0;var s=(new Date).getFullYear(),a=new Date(s,0,1).getTimezoneOffset();s=new Date(s,6,1).getTimezoneOffset();var i=Math.max(a,s);W()[e>>>2>>>0]=60*i,L()[t>>>2>>>0]=+(a!=s),e=(t=e=>{var t=Math.abs(e);return`UTC${0<=e?"-":"+"}${String(Math.floor(t/60)).padStart(2,"0")}${String(t%60).padStart(2,"0")}`})(a),t=t(s),s<a?(Ge(e,n,17),Ge(t,r,17)):(Ge(e,r,17),Ge(t,n,17))}var Tn=()=>Date.now();function Sn(e,t,n){return 0<=e&&3>=e?(e=0===e?Date.now():performance.timeOrigin+performance.now(),T[n>>>0>>>3]=BigInt(Math.round(1e6*e)),0):28}var Nn=[],Gn=(e,t)=>{Nn.length=0;for(var n;n=z()[e++>>>0];){var r=105!=n;t+=(r&=112!=n)&&t%8?4:0,Nn.push(112==n?W()[t>>>2>>>0]:106==n?T[t>>>3]:105==n?L()[t>>>2>>>0]:V()[t>>>3>>>0]),t+=r?8:4}return Nn};function Fn(e,t,n){return e>>>=0,t=Gn(t>>>0,n>>>0),ee[e](...t)}function Pn(e,t,n){return e>>>=0,t=Gn(t>>>0,n>>>0),ee[e](...t)}var Qn=()=>{};function zn(e,t){return C(Me(e>>>0,t>>>0))}var On=()=>{throw Ae+=1,"unwind"};function Rn(){return 4294901760}var Ln=()=>navigator.hardwareConcurrency;function Wn(){return J("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function _n(e){e>>>=0;var t=z().length;if(e<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);e:{r=(Math.min(4294901760,65536*Math.ceil(Math.max(e,r)/65536))-I.buffer.byteLength+65535)/65536|0;try{I.grow(r),j();var s=1;break e}catch{}s=void 0}if(s)return!0}return!1}var Vn=()=>(J("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),Hn={},Un=e=>{e.forEach((e=>{Vn()}))};function jn(){var e=Error().stack.toString().split("\n");return"Error"==e[0]&&e.shift(),Un(e),Hn.Lb=Vn(),Hn.cc=e,Hn.Lb}function Yn(e,t,n){if(e>>>=0,t>>>=0,Hn.Lb==e)var r=Hn.cc;else"Error"==(r=Error().stack.toString().split("\n"))[0]&&r.shift(),Un(r);for(var s=3;r[s]&&Vn()!=e;)++s;for(e=0;e<n&&r[e+s];++e)L()[t+4*e>>>2>>>0]=Vn();return e}var Kn,Xn={},qn=()=>{if(!Kn){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(e in Xn)void 0===Xn[e]?delete t[e]:t[e]=Xn[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);Kn=n}return Kn};function Zn(e,t){if(A)return oe(19,1,e,t);e>>>=0,t>>>=0;var n=0;return qn().forEach(((r,s)=>{var a=t+n;for(s=W()[e+4*s>>>2>>>0]=a,a=0;a<r.length;++a)Q()[s++>>>0]=r.charCodeAt(a);Q()[s>>>0]=0,n+=r.length+1})),0}function Jn(e,t){if(A)return oe(20,1,e,t);e>>>=0,t>>>=0;var n=qn();W()[e>>>2>>>0]=n.length;var r=0;return n.forEach((e=>r+=e.length+1)),W()[t>>>2>>>0]=r,0}function $n(e){return A?oe(21,1,e):52}function er(e,t,n,r){return A?oe(22,1,e,t,n,r):52}function tr(e,t,n,r){return A?oe(23,1,e,t,n,r):70}var nr=[null,[],[]];function rr(e,t,n,r){if(A)return oe(24,1,e,t,n,r);t>>>=0,n>>>=0,r>>>=0;for(var s=0,a=0;a<n;a++){var i=W()[t>>>2>>>0],o=W()[t+4>>>2>>>0];t+=8;for(var l=0;l<o;l++){var u=z()[i+l>>>0],c=nr[e];0===u||10===u?((1===e?b:C)(Be(c)),c.length=0):c.push(u)}s+=o}return W()[r>>>2>>>0]=s,0}A||function(){for(var e=r.numThreads-1;e--;)Ce();ae.unshift((()=>{X++,function(e){A?e():Promise.all(de.map(be)).then(e)}((()=>Z()))}))}();for(var sr=Array(256),ar=0;256>ar;++ar)sr[ar]=String.fromCharCode(ar);Ue=sr,je=r.BindingError=class extends Error{constructor(e){super(e),this.name="BindingError"}},r.InternalError=class extends Error{constructor(e){super(e),this.name="InternalError"}},rt.push(0,1,void 0,1,null,1,!0,1,!1,1),r.count_emval_handles=()=>rt.length/2-5-nt.length;var ir,Ar=[le,ue,ye,De,Te,Fe,Pe,Qe,ze,Oe,Re,Le,We,_e,Ve,He,yn,vn,Mn,Zn,Jn,$n,er,tr,rr];!async function(){function e(e,t){return ir=e.exports,ir=function(){var e=ir,t={};for(let[n,r]of Object.entries(e))t[n]="function"==typeof r?(...e)=>{_t.push(n);try{return r(...e)}finally{F||(_t.pop(),Lt&&1===Rt&&0===_t.length&&(Rt=0,Ae+=1,Ot(Er),typeof Fibers<"u"&&Fibers.rc()))}}:r;return t}(),ir=function(){var e=ir,t=e=>t=>e(t)>>>0,n=e=>()=>e()>>>0;return(e=Object.assign({},e)).Da=t(e.Da),e.fb=n(e.fb),e.hb=t(e.hb),e.tb=t(e.tb),e.ub=n(e.ub),e.__cxa_get_exception_ptr=t(e.__cxa_get_exception_ptr),e}(),fe.push(ir.ib),w=t,Z(),ir}X++;var t=$();if(r.instantiateWasm)return new Promise((n=>{r.instantiateWasm(t,((t,r)=>{e(t,r),n(t.exports)}))}));if(A)return new Promise((t=>{H=n=>{var r=new WebAssembly.Instance(n,$());t(e(r,n))}}));K??=r.locateFile?r.locateFile?r.locateFile("ort-wasm-simd-threaded.jsep.wasm",g):g+"ort-wasm-simd-threaded.jsep.wasm":new URL("ort-wasm-simd-threaded.jsep.wasm",import.meta.url).href;try{var s=await async function(e){var t=K;if(!G&&"function"==typeof WebAssembly.instantiateStreaming&&!P(t))try{var n=fetch(t,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(n,e)}catch(e){C(`wasm streaming compile failed: ${e}`),C("falling back to ArrayBuffer instantiation")}return async function(e,t){try{var n=await async function(e){if(!G)try{var t=await c(e);return new Uint8Array(t)}catch{}if(e==K&&G)e=new Uint8Array(G);else{if(!d)throw"both async and sync fetching of the wasm failed";e=d(e)}return e}(e);return await WebAssembly.instantiate(n,t)}catch(e){C(`failed to asynchronously prepare wasm: ${e}`),J(e)}}(t,e)}(t);return e(s.instance,s.module)}catch(e){return n(e),Promise.reject(e)}}();var or=e=>(or=ir.Da)(e),lr=()=>(lr=ir.Ea)();r._OrtInit=(e,t)=>(r._OrtInit=ir.Fa)(e,t),r._OrtGetLastError=(e,t)=>(r._OrtGetLastError=ir.Ga)(e,t),r._OrtCreateSessionOptions=(e,t,n,s,a,i,A,o,l,u)=>(r._OrtCreateSessionOptions=ir.Ha)(e,t,n,s,a,i,A,o,l,u),r._OrtAppendExecutionProvider=(e,t,n,s,a)=>(r._OrtAppendExecutionProvider=ir.Ia)(e,t,n,s,a),r._OrtAddFreeDimensionOverride=(e,t,n)=>(r._OrtAddFreeDimensionOverride=ir.Ja)(e,t,n),r._OrtAddSessionConfigEntry=(e,t,n)=>(r._OrtAddSessionConfigEntry=ir.Ka)(e,t,n),r._OrtReleaseSessionOptions=e=>(r._OrtReleaseSessionOptions=ir.La)(e),r._OrtCreateSession=(e,t,n)=>(r._OrtCreateSession=ir.Ma)(e,t,n),r._OrtReleaseSession=e=>(r._OrtReleaseSession=ir.Na)(e),r._OrtGetInputOutputCount=(e,t,n)=>(r._OrtGetInputOutputCount=ir.Oa)(e,t,n),r._OrtGetInputOutputMetadata=(e,t,n,s)=>(r._OrtGetInputOutputMetadata=ir.Pa)(e,t,n,s),r._OrtFree=e=>(r._OrtFree=ir.Qa)(e),r._OrtCreateTensor=(e,t,n,s,a,i)=>(r._OrtCreateTensor=ir.Ra)(e,t,n,s,a,i),r._OrtGetTensorData=(e,t,n,s,a)=>(r._OrtGetTensorData=ir.Sa)(e,t,n,s,a),r._OrtReleaseTensor=e=>(r._OrtReleaseTensor=ir.Ta)(e),r._OrtCreateRunOptions=(e,t,n,s)=>(r._OrtCreateRunOptions=ir.Ua)(e,t,n,s),r._OrtAddRunConfigEntry=(e,t,n)=>(r._OrtAddRunConfigEntry=ir.Va)(e,t,n),r._OrtReleaseRunOptions=e=>(r._OrtReleaseRunOptions=ir.Wa)(e),r._OrtCreateBinding=e=>(r._OrtCreateBinding=ir.Xa)(e),r._OrtBindInput=(e,t,n)=>(r._OrtBindInput=ir.Ya)(e,t,n),r._OrtBindOutput=(e,t,n,s)=>(r._OrtBindOutput=ir.Za)(e,t,n,s),r._OrtClearBoundOutputs=e=>(r._OrtClearBoundOutputs=ir._a)(e),r._OrtReleaseBinding=e=>(r._OrtReleaseBinding=ir.$a)(e),r._OrtRunWithBinding=(e,t,n,s,a)=>(r._OrtRunWithBinding=ir.ab)(e,t,n,s,a),r._OrtRun=(e,t,n,s,a,i,A,o)=>(r._OrtRun=ir.bb)(e,t,n,s,a,i,A,o),r._OrtEndProfiling=e=>(r._OrtEndProfiling=ir.cb)(e),r._JsepOutput=(e,t,n)=>(r._JsepOutput=ir.db)(e,t,n),r._JsepGetNodeName=e=>(r._JsepGetNodeName=ir.eb)(e);var ur=()=>(ur=ir.fb)(),cr=r._free=e=>(cr=r._free=ir.gb)(e),dr=r._malloc=e=>(dr=r._malloc=ir.hb)(e),hr=(e,t,n,r,s,a)=>(hr=ir.kb)(e,t,n,r,s,a),fr=()=>(fr=ir.lb)(),gr=(e,t,n,r,s)=>(gr=ir.mb)(e,t,n,r,s),pr=e=>(pr=ir.nb)(e),mr=e=>(mr=ir.ob)(e),br=(e,t)=>(br=ir.pb)(e,t),Cr=()=>(Cr=ir.qb)(),Ir=(e,t)=>(Ir=ir.rb)(e,t),wr=e=>(wr=ir.sb)(e),kr=e=>(kr=ir.tb)(e),xr=()=>(xr=ir.ub)(),yr=r.dynCall_ii=(e,t)=>(yr=r.dynCall_ii=ir.vb)(e,t),vr=e=>(vr=ir.wb)(e),Er=()=>(Er=ir.xb)(),Br=e=>(Br=ir.yb)(e),Mr=()=>(Mr=ir.zb)();return r.stackSave=()=>xr(),r.stackRestore=e=>wr(e),r.stackAlloc=e=>kr(e),r.setValue=function(e,t,n="i8"){switch(n.endsWith("*")&&(n="*"),n){case"i1":case"i8":Q()[e>>>0]=t;break;case"i16":O()[e>>>1>>>0]=t;break;case"i32":L()[e>>>2>>>0]=t;break;case"i64":T[e>>>3]=BigInt(t);break;case"float":_()[e>>>2>>>0]=t;break;case"double":V()[e>>>3>>>0]=t;break;case"*":W()[e>>>2>>>0]=t;break;default:J(`invalid type for setValue: ${n}`)}},r.getValue=function(e,t="i8"){switch(t.endsWith("*")&&(t="*"),t){case"i1":case"i8":return Q()[e>>>0];case"i16":return O()[e>>>1>>>0];case"i32":return L()[e>>>2>>>0];case"i64":return T[e>>>3];case"float":return _()[e>>>2>>>0];case"double":return V()[e>>>3>>>0];case"*":return W()[e>>>2>>>0];default:J(`invalid type for getValue: ${t}`)}},r.UTF8ToString=Me,r.stringToUTF8=Ge,r.lengthBytesUTF8=Ne,function e(){if(0<X)q=e;else if(A)t(r),Y();else{for(;0<ae.length;)ae.shift()(r);0<X?q=e:(r.calledRun=!0,F||(Y(),t(r)))}}(),r.PTR_SIZE=4,s},Ge=Ne,Fe=globalThis.self?.name?.startsWith("em-pthread"),Fe&&Ne()})),Cl=te((()=>{ye(),Pe=typeof location>"u"?void 0:location.origin,Qe=import.meta.url>"file:"&&import.meta.url<"file;",ze=()=>{if(Qe){let e=URL;return new URL(new e("ort.bundle.min.mjs",import.meta.url).href,Pe).href}return import.meta.url},Oe=ze(),Re=()=>{if(Oe&&!Oe.startsWith("blob:"))return Oe.substring(0,Oe.lastIndexOf("/")+1)},Le=(e,t)=>{try{let n=t??Oe;return(n?new URL(e,n):new URL(e)).origin===Pe}catch{return!1}},We=(e,t)=>{let n=t??Oe;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},_e=(e,t)=>`${t??"./"}${e}`,Ve=async e=>{let t=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},He=async e=>(await import(e)).default,Ue=(De(),re(ve)).default,je=async()=>{if(!Oe)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Le(Oe))return[void 0,Ue()];let e=await Ve(Oe);return[e,Ue(e)]},Ye=(bl(),re(Te)).default,Ke=async(e,t,n)=>{if(!e&&!t&&Ye&&Oe&&Le(Oe))return[void 0,Ye];{let r="ort-wasm-simd-threaded.jsep.mjs",s=e??We(r,t),a=n&&s&&!Le(s,t),i=a?await Ve(s):s??_e(r,t);return[a?i:void 0,await He(i)]}}})),Il=te((()=>{Cl(),qe=!1,Ze=!1,Je=!1,$e=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},et=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},tt=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},nt=async e=>{if(qe)return Promise.resolve();if(Ze)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Je)throw new Error("previous call to 'initializeWebAssembly()' failed.");Ze=!0;let t=e.initTimeout,n=e.numThreads;if(!1!==e.simd)if("relaxed"===e.simd){if(!tt())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!et())throw new Error("WebAssembly SIMD is not supported in the current environment.");let r=$e();n>1&&!r&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let s=e.wasmPaths,a="string"==typeof s?s:void 0,i=s?.mjs,A=i?.href??i,o=s?.wasm,l=o?.href??o,u=e.wasmBinary,[c,d]=await Ke(A,a,n>1),h=!1,f=[];if(t>0&&f.push(new Promise((e=>{setTimeout((()=>{h=!0,e()}),t)}))),f.push(new Promise(((e,t)=>{let r={numThreads:n};if(u)r.wasmBinary=u;else if(l||a)r.locateFile=e=>l??a+e;else if(A&&0!==A.indexOf("blob:"))r.locateFile=e=>new URL(e,A).href;else if(c){let e=Re();e&&(r.locateFile=t=>e+t)}d(r).then((t=>{Ze=!1,qe=!0,Xe=t,e(),c&&URL.revokeObjectURL(c)}),(e=>{Ze=!1,Je=!0,t(e)}))}))),await Promise.race(f),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},rt=()=>{if(qe&&Xe)return Xe;throw new Error("WebAssembly is not initialized yet.")}})),wl=te((()=>{Il(),st=(e,t)=>{let n=rt(),r=n.lengthBytesUTF8(e)+1,s=n._malloc(r);return n.stringToUTF8(e,s,r),t.push(s),s},at=(e,t,n,r)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,s])=>{let a=t?t+e:e;if("object"==typeof s)at(s,a+".",n,r);else if("string"==typeof s||"number"==typeof s)r(a,s.toString());else{if("boolean"!=typeof s)throw new Error("Can't handle extra config type: "+typeof s);r(a,s?"1":"0")}}))},it=e=>{let t=rt(),n=t.stackSave();try{let n=t.PTR_SIZE,r=t.stackAlloc(2*n);t._OrtGetLastError(r,r+n);let s=Number(t.getValue(r,4===n?"i32":"i64")),a=t.getValue(r+n,"*"),i=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${s}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(n)}}})),kl=te((()=>{Il(),wl(),At=e=>{let t=rt(),n=0,r=[],s=e||{};try{if(void 0===e?.logSeverityLevel)s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===e?.logVerbosityLevel)s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===e?.terminate&&(s.terminate=!1);let a=0;return void 0!==e?.tag&&(a=st(e.tag,r)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,a),0===n&&it("Can't create run options."),void 0!==e?.extra&&at(e.extra,"",new WeakSet,((e,s)=>{let a=st(e,r),i=st(s,r);0!==t._OrtAddRunConfigEntry(n,a,i)&&it(`Can't set a run config entry: ${e} - ${s}.`)})),[n,r]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),r.forEach((e=>t._free(e))),e}}})),xl=te((()=>{Il(),wl(),ot=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},lt=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},ut=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)},ct=(e,t,n,r)=>{let s=st(t,r),a=st(n,r);0!==rt()._OrtAddSessionConfigEntry(e,s,a)&&it(`Can't set a session config entry: ${t} - ${n}.`)},dt=async(e,t,n)=>{for(let r of t){let t="string"==typeof r?r:r.name,s=[];switch(t){case"webnn":if(t="WEBNN","string"!=typeof r){let t=r?.deviceType;t&&ct(e,"deviceType",t,n)}break;case"webgpu":if(t="JS","string"!=typeof r){let t=r;if(t?.preferredLayout){if("NCHW"!==t.preferredLayout&&"NHWC"!==t.preferredLayout)throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${t.preferredLayout}`);ct(e,"preferredLayout",t.preferredLayout,n)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}let a=st(t,n),i=s.length,A=0,o=0;if(i>0){A=rt()._malloc(i*rt().PTR_SIZE),n.push(A),o=rt()._malloc(i*rt().PTR_SIZE),n.push(o);for(let e=0;e<i;e++)rt().setValue(A+e*rt().PTR_SIZE,s[e][0],"*"),rt().setValue(o+e*rt().PTR_SIZE,s[e][1],"*")}0!==await rt()._OrtAppendExecutionProvider(e,a,A,o,i)&&it(`Can't append execution provider: ${t}.`)}},ht=async e=>{let t=rt(),n=0,r=[],s=e||{};ut(s);try{let e=ot(s.graphOptimizationLevel??"all"),a=lt(s.executionMode??"sequential"),i="string"==typeof s.logId?st(s.logId,r):0,A=s.logSeverityLevel??2;if(!Number.isInteger(A)||A<0||A>4)throw new Error(`log serverity level is not valid: ${A}`);let o=s.logVerbosityLevel??0;if(!Number.isInteger(o)||o<0||o>4)throw new Error(`log verbosity level is not valid: ${o}`);let l="string"==typeof s.optimizedModelFilePath?st(s.optimizedModelFilePath,r):0;if(n=t._OrtCreateSessionOptions(e,!!s.enableCpuMemArena,!!s.enableMemPattern,a,!!s.enableProfiling,0,i,A,o,l),0===n&&it("Can't create session options."),s.executionProviders&&await dt(n,s.executionProviders,r),void 0!==s.enableGraphCapture){if("boolean"!=typeof s.enableGraphCapture)throw new Error(`enableGraphCapture must be a boolean value: ${s.enableGraphCapture}`);ct(n,"enableGraphCapture",s.enableGraphCapture.toString(),r)}if(s.freeDimensionOverrides)for(let[e,a]of Object.entries(s.freeDimensionOverrides)){if("string"!=typeof e)throw new Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof a||!Number.isInteger(a)||a<0)throw new Error(`free dimension override value must be a non-negative integer: ${a}`);let s=st(e,r);0!==t._OrtAddFreeDimensionOverride(n,s,a)&&it(`Can't set a free dimension override: ${e} - ${a}.`)}return void 0!==s.extra&&at(s.extra,"",new WeakSet,((e,t)=>{ct(n,e,t,r)})),[n,r]}catch(e){throw 0!==n&&0!==t._OrtReleaseSessionOptions(n)&&it("Can't release session options."),r.forEach((e=>t._free(e))),e}}})),yl=te((()=>{ft=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},gt=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},pt=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],r="number"==typeof t?t:t.reduce(((e,t)=>e*t),1);return n>0?Math.ceil(r*n):void 0},mt=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},bt=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Ct=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,It=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint64"===e||"int8"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,wt=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}})),vl=te((()=>{ye(),kt=async e=>{if("string"==typeof e){let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),r=n?parseInt(n,10):0;if(r<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let n,s=t.body.getReader();try{n=new ArrayBuffer(r)}catch(e){if(!(e instanceof RangeError))throw e;{let e=Math.ceil(r/65536);n=new WebAssembly.Memory({initial:e,maximum:e}).buffer}}let a=0;for(;;){let{done:e,value:t}=await s.read();if(e)break;let r=t.byteLength;new Uint8Array(n,a,r).set(t),a+=r}return new Uint8Array(n,0,r)}}return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}})),El=te((()=>{yl(),xt=["V","I","W","E","F"],yt=(e,t)=>{console.log(`[${xt[e]},${(new Date).toISOString()}]${t}`)},Bt=(e,t)=>{vt=e,Et=t},Mt=(e,t)=>{let n=bt(e);n>=bt(vt)&&yt(n,"function"==typeof t?t():t)},Dt=(...e)=>{Et&&Mt(...e)}})),Bl=te((()=>{Tt=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},St=class{static calcShape(e,t,n=!1){let r=e.length,s=t.length;if(0===r)return t;if(0===s)return e;let a=Math.max(e.length,t.length),i=new Array(a);if(n){if(r<2||s<2)return;let n=Tt.calcMatMulShape([e[r-2],e[r-1]],[t[s-2],t[s-1]]);if(void 0===n)return;[i[a-2],i[a-1]]=n}for(let A=n?3:1;A<=a;A++){let n=r-A<0?1:e[r-A],o=s-A<0?1:t[s-A];if(n!==o&&n>1&&o>1)return;let l=Math.max(n,o);if(n&&o)i[a-A]=Math.max(n,o);else{if(l>1)return;i[a-A]=0}}return i}static isValidBroadcast(e,t){let n=e.length,r=t.length;if(n>r)return!1;for(let s=1;s<=n;s++)if(1!==e[n-s]&&e[n-s]!==t[r-s])return!1;return!0}},Nt=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(e,t=4){let n=e.length;if(0===n)return[];let r=new Array(n),s=n-1;for(;s>=0;){if(e[s]%t===0){r[s]=e[s]/t;break}if(t%e[s]!==0)throw new Error("cannot convert shape");r[s]=1,t/=e[s],s--}for(s--;s>=0;s--)r[s]=e[s];return r}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let s=t;s<n;s++){if(e[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=Number(e[s])}return r}static computeStrides(e){let t=e.length;if(0===t)return[];if(1===t)return[1];let n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((n=>this.normalizeAxis(n,t??e.length)))}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){let n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}},Gt=class e{static adjustPoolAttributes(e,t,n,r,s,a){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<s.length){if(s[e]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let e=0;e<2*n.length;e++)if(e<a.length){if(a[e]<0)throw new Error("pad should be greater than or equal to 1")}else a.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(a[e]>=n[e]||a[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,r,s,a,i,A){if(A){if(a.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(s.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let o=0;o<t.length-2;o++)e.adjustPadAndReturnShape(t[o+(i?1:2)],n[o],r[o],s[o],a,o,o+t.length-2,A)}}static computePoolOutputShape(t,n,r,s,a,i,A){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let o=[n[0],n[1]];return e.computeShapeHelper(t,n,o,r,s,a,i,A),o}static computeConvOutputShape(t,n,r,s,a,i,A){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let o=[t[0],n[0]];return e.computeShapeHelper(!1,t,o,r,s,a,i,A),o}static computeShapeHelper(t,n,r,s,a,i,A,o){if(t)for(let e=0;e<n.length-2;e++)r.push(1);else for(let t=0;t<n.length-2;t++)r.push(e.adjustPadAndReturnShape(n[t+2],s[t],a[t],i[t],A,t,t+n.length-2,o))}static adjustPadAndReturnShape(e,t,n,r,s,a,i,A){let o=n*(r-1)+1;if(!A||"NOTSET"===A)return Math.floor((e+s[a]+s[i]-o)/t+1);switch(A){case"VALID":return s[a]=0,s[i]=0,Math.floor((e-o)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let n=((e+t-1)/t-1)*t+r-e;return s[a]=Math.floor("SAME_LOWER"===A?(n+1)/2:n/2),s[i]=n-s[a],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}},Ft=class{static getShapeOfGemmResult(e,t,n,r,s){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let a,i,A;t?(a=e[1],i=e[0]):(a=e[0],i=e[1]);let o=-1;if(r?(A=n[0],o=1):(A=n[1],o=0),n[o]!==i)throw new Error("dimension mismatch");if(a<=0||A<=0||i<=0)throw new Error("invalid shape specified");if(s&&!St.isValidBroadcast(s,[a,A]))throw new Error("gemm: invalid bias shape for broadcast");return[a,A,i]}},Pt=-34028234663852886e22,Qt=34028234663852886e22})),Ml=te((()=>{yl(),zt=(e,t)=>new(mt(t))(e)})),Dl=te((()=>{El(),Ot=(e,t=!0)=>{if(e.byteLength%8!=0)throw new Error("Invalid Uint8Array length - must be a multiple of 8 (BigInt).");let n=e.byteLength/8,r=new BigInt64Array(e.buffer,e.byteOffset,n),s=new Int32Array(n);for(let e=0;e<n;e++){let t=r[e];if(t>2147483647n||t<-2147483648n)throw new Error(`Overflow occurred when converting BigInt to Int32 at index ${e}: ${t}`);s[e]=Number(t)}return t?new Uint8Array(s.buffer):s},Rt=(e,t=!0)=>{if(e.byteLength%4!=0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (Int32).");let n=e.byteLength/4,r=new Int32Array(e.buffer,e.byteOffset,n),s=BigInt64Array.from(r,BigInt);return t?new Uint8Array(s.buffer):s},Lt=1,Wt=()=>Lt++,_t=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),Vt=(e,t)=>{let n=_t.get(e);if(!n)throw new Error("Unsupported data type.");return t.length>0?Math.ceil(t.reduce(((e,t)=>e*t))*n/8):0},Ht=class{constructor(e){this.shouldConvertInt64toInt32=!1,this.isInt64ToInt32Converted=!1;let{sessionId:t,context:n,tensor:r,dataType:s,shape:a,shouldConvertInt64toInt32:i=!1}=e;this.sessionId=t,this.mlContext=n,this.mlTensor=r,this.dataType=s,this.tensorShape=a,this.shouldConvertInt64toInt32=i}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return Vt(this.dataType,this.tensorShape)}destroy(){Dt("verbose",(()=>"[WebNN] TensorWrapper.destroy")),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e,t){if(e){let e=await this.mlContext.readTensor(this.mlTensor),n=Rt(new Uint8Array(e));return t?void(t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength)).set(n):n.buffer}return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(e,t,n){return this.mlContext===e&&this.dataType===t&&this.tensorShape.length===n.length&&this.tensorShape.every(((e,t)=>e===n[t]))}setIsInt64ToInt32Converted(e){this.isInt64ToInt32Converted=e}},Ut=class{constructor(e,t){this.tensorManager=e,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,t,n,r){let s=t,a=this.tensorManager.getMLContext(e),i="int64"===s&&!a.opSupportLimits().input.dataTypes.includes("int64");if(i&&(s="int32",Dt("verbose",(()=>"[WebNN] TensorIdTracker.ensureTensor: convert dataType from int64 to int32"))),this.wrapper){if(this.wrapper.canReuseTensor(a,s,n))return this.wrapper.tensor;if(r){if(this.wrapper.byteLength!==Vt(s,n))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let A=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,s,n,A,!0,!0,i),r&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){let t=e;if(this.wrapper){if(this.wrapper.shouldConvertInt64toInt32&&(t=Ot(e,!0),this.wrapper.setIsInt64ToInt32Converted(!0)),t.byteLength===this.wrapper.byteLength)return void this.wrapper.write(t);Dt("verbose",(()=>"Data size does not match tensor size. Releasing tensor.")),this.releaseTensor()}this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(e){if(this.activeUpload){let t=this.wrapper?.isInt64ToInt32Converted?Rt(this.activeUpload):this.activeUpload;return e?void(e instanceof ArrayBuffer?new Uint8Array(e).set(t):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(t)):t.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read(this.wrapper?.shouldConvertInt64toInt32,e):this.wrapper.read(this.wrapper?.shouldConvertInt64toInt32)}},jt=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(e){let t=this.backend.getMLContext(e);if(!t)throw new Error("MLContext not found for session.");return t}reserveTensorId(){let e=Wt();return this.tensorTrackersById.set(e,new Ut(this)),e}releaseTensorId(e){let t=this.tensorTrackersById.get(e);t&&(this.tensorTrackersById.delete(e),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(e,t,n,r,s){Dt("verbose",(()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${n}, shape: ${r}, copyOld: ${s}}`));let a=this.tensorTrackersById.get(t);if(!a)throw new Error("Tensor not found.");return a.ensureTensor(e,n,r,s)}upload(e,t){let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");n.upload(t)}async download(e,t){Dt("verbose",(()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${t?.byteLength}}`));let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");return n.download(t)}releaseTensorsForSession(e){for(let t of this.freeTensors)t.sessionId===e&&t.destroy();this.freeTensors=this.freeTensors.filter((t=>t.sessionId!==e))}registerTensor(e,t,n,r){let s=this.getMLContext(e),a=Wt(),i=new Ht({sessionId:e,context:s,tensor:t,dataType:n,shape:r});return this.tensorTrackersById.set(a,new Ut(this,i)),this.externalTensors.add(i),a}async getCachedTensor(e,t,n,r,s,a,i=!1){let A=this.getMLContext(e);for(let[r,s]of this.freeTensors.entries())if(s.canReuseTensor(A,t,n)){Dt("verbose",(()=>`[WebNN] Reusing tensor {dataType: ${t}, shape: ${n}}`));let s=this.freeTensors.splice(r,1)[0];return s.sessionId=e,s}Dt("verbose",(()=>`[WebNN] MLContext.createTensor {dataType: ${t}, shape: ${n}}`));let o=await A.createTensor({dataType:t,shape:n,dimensions:n,usage:r,writable:s,readable:a});return new Ht({sessionId:e,context:A,tensor:o,dataType:t,shape:n,shouldConvertInt64toInt32:i})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},Yt=(...e)=>new jt(...e)})),Tl=te((()=>{yl(),Il(),Ml(),Dl(),El(),Kt=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),Xt=(e,t)=>{if(e===t)return!0;if(void 0===e||void 0===t)return!1;let n=Object.keys(e).sort(),r=Object.keys(t).sort();return n.length===r.length&&n.every(((n,s)=>n===r[s]&&e[n]===t[n]))},qt=class{constructor(e){this.tensorManager=Yt(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.temporaryGraphInputs=[],this.temporarySessionTensorIds=new Map,Bt(e.logLevel,!!e.debug)}get currentSessionId(){if(void 0===this.activeSessionId)throw new Error("No active session");return this.activeSessionId}onRunStart(e){Dt("verbose",(()=>`[WebNN] onRunStart {sessionId: ${e}}`)),this.activeSessionId=e}onRunEnd(e){Dt("verbose",(()=>`[WebNN] onRunEnd {sessionId: ${e}}`));let t=this.temporarySessionTensorIds.get(e);if(t){for(let e of t)Dt("verbose",(()=>`[WebNN] releasing temporary tensor {tensorId: ${e}}`)),this.tensorManager.releaseTensorId(e);this.temporarySessionTensorIds.delete(e),this.activeSessionId=void 0}}async createMLContext(e){if(e instanceof GPUDevice){let t=this.mlContextCache.findIndex((t=>t.gpuDevice===e));if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:t}),t}}if(void 0===e){let e=this.mlContextCache.findIndex((e=>void 0===e.options&&void 0===e.gpuDevice));if(-1!==e)return this.mlContextCache[e].mlContext;{let e=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:e}),e}}let t=this.mlContextCache.findIndex((t=>Xt(t.options,e)));if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:t}),t}}registerMLContext(e,t){this.mlContextBySessionId.set(e,t);let n=this.sessionIdsByMLContext.get(t);n||(n=new Set,this.sessionIdsByMLContext.set(t,n)),n.add(e),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(e,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(e){this.sessionGraphInputs.delete(e);let t=this.mlContextBySessionId.get(e);if(!t)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let n=this.sessionIdsByMLContext.get(t);if(n.delete(e),0===n.size){this.sessionIdsByMLContext.delete(t);let e=this.mlContextCache.findIndex((e=>e.mlContext===t));-1!==e&&this.mlContextCache.splice(e,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){Dt("verbose",(()=>`[WebNN] releaseTensorId {tensorId: ${e}}`)),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,t,n,r,s){let a=Kt.get(n);if(!a)throw new Error(`Unsupported ONNX data type: ${n}`);return this.tensorManager.ensureTensor(e??this.currentSessionId,t,a,r,s)}async createTemporaryTensor(e,t,n){Dt("verbose",(()=>`[WebNN] createTemporaryTensor {onnxDataType: ${t}, shape: ${n}}`));let r=Kt.get(t);if(!r)throw new Error(`Unsupported ONNX data type: ${t}`);let s=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(e,s,r,n,!1);let a=this.temporarySessionTensorIds.get(e);return a?a.push(s):this.temporarySessionTensorIds.set(e,[s]),s}uploadTensor(e,t){if(!rt().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");Dt("verbose",(()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${t.byteLength}}`)),this.tensorManager.upload(e,t)}async downloadTensor(e,t){return this.tensorManager.download(e,t)}createMLTensorDownloader(e,t){return async()=>{let n=await this.tensorManager.download(e);return zt(n,t)}}registerMLTensor(e,t,n,r){let s=Kt.get(n);if(!s)throw new Error(`Unsupported ONNX data type: ${n}`);let a=this.tensorManager.registerTensor(e,t,s,r);return Dt("verbose",(()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${s}, dimensions: ${r}} -> {tensorId: ${a}}`)),a}registerMLConstant(e,t,n,r,s,a,i=!1){if(!a)throw new Error("External mounted files are not available.");let A=e;e.startsWith("./")&&(A=e.substring(2));let o=a.get(A);if(!o)throw new Error(`File with name ${A} not found in preloaded files.`);if(t+n>o.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let l,u=o.slice(t,t+n).buffer;switch(s.dataType){case"float32":l=new Float32Array(u);break;case"float16":l=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(u):new Uint16Array(u);break;case"int32":l=new Int32Array(u);break;case"uint32":l=new Uint32Array(u);break;case"int64":i?(l=Ot(new Uint8Array(u),!1),s.dataType="int32"):l=new BigInt64Array(u);break;case"uint64":l=new BigUint64Array(u);break;case"int8":l=new Int8Array(u);break;case"int4":case"uint4":case"uint8":l=new Uint8Array(u);break;default:throw new Error(`Unsupported data type: ${s.dataType} in creating WebNN Constant from external data.`)}return Dt("verbose",(()=>`[WebNN] registerMLConstant {dataType: ${s.dataType}, shape: ${s.shape}}} ${i?"(Note: it was int64 data type and registered to int32 as workaround)":""}`)),r.constant(s,l)}registerGraphInput(e){this.temporaryGraphInputs.push(e)}isGraphInput(e,t){let n=this.sessionGraphInputs.get(e);return!!n&&n.includes(t)}isInt64Supported(e){return!!this.mlContextBySessionId.get(e)?.opSupportLimits().input.dataTypes.includes("int64")}flush(){}}})),Sl=te((()=>{})),Nl=te((()=>{El(),Sl(),Zt=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Jt=[],$t=e=>16*Math.ceil(Number(e)/16),en=e=>{for(let t=0;t<Jt.length;t++){let n=Jt[t];if(e<=n)return n}return 16*Math.ceil(e/16)},tn=1,nn=()=>tn++,rn=async(e,t,n,r)=>{let s=$t(n),a=e.device.createBuffer({size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let i=e.getCommandEncoder();e.endComputePass(),i.copyBufferToBuffer(t,0,a,0,s),e.flush(),await a.mapAsync(GPUMapMode.READ);let A=a.getMappedRange();if(r){let e=r();return e.set(new Uint8Array(A,0,n)),e}return new Uint8Array(A.slice(0,n))}finally{a.destroy()}},sn=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[e]of Zt)Jt.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[]);this.sessionCount=0}upload(e,t){let n=t.buffer,r=t.byteOffset,s=t.byteLength,a=$t(s),i=this.storageCache.get(e);if(!i)throw new Error("gpu data for uploading does not exist");if(Number(i.originalSize)!==s)throw new Error(`inconsistent data size. gpu data size=${i.originalSize}, data size=${s}`);let A=this.backend.device.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),o=A.getMappedRange();new Uint8Array(o).set(new Uint8Array(n,r,s)),A.unmap();let l=this.backend.device.createCommandEncoder();l.copyBufferToBuffer(A,0,i.gpuData.buffer,0,a),this.backend.device.queue.submit([l.finish()]),A.destroy(),Dt("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${e})`))}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=$t(n.originalSize),a=this.backend.getCommandEncoder();this.backend.endComputePass(),a.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,s)}registerExternalBuffer(e,t,n){let r;if(n){if(r=n[0],e===n[1])return Dt("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, buffer is the same, skip.`)),r;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error("Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!")}else r=nn();return this.storageCache.set(r,{gpuData:{id:r,type:0,buffer:e},originalSize:t}),Dt("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, registered.`)),r}unregisterExternalBuffer(e){void 0!==e&&(this.storageCache.delete(e),Dt("verbose",(()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`)))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n,r=en(e),s=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,a=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||a){let e=(s?this.freeBuffers:this.freeUniformBuffers).get(r);n=e&&e.length>0?e.pop():this.backend.device.createBuffer({size:r,usage:t})}else n=this.backend.device.createBuffer({size:r,usage:t});let i={id:nn(),type:0,buffer:n};return this.storageCache.set(i.id,{gpuData:i,originalSize:Number(e)}),Dt("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${i.id}`)),i}get(e){return this.storageCache.get(e)?.gpuData}release(e){let t="bigint"==typeof e?Number(e):e,n=this.storageCache.get(t);if(!n){if(0===this.storageCache.size)return 0;throw new Error("releasing data does not exist")}return Dt("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${n.gpuData.id}`)),this.storageCache.delete(t),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(e,t){let n=this.storageCache.get(Number(e));if(!n)throw new Error("data does not exist");await rn(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){if(0!==this.buffersPending.length)if("default"===this.backend.sessionStatus){for(let e of this.buffersPending){let t=Zt.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(e.size)||[];void 0===t||n.length>=t?e.destroy():n.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(e.size)||[];void 0===t||n.length>=t?e.destroy():n.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let t of this.buffersPending)e.push(t);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.freeUniformBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.capturedPendingBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(e){let t=this.capturedPendingBuffers.get(e);t&&(t.forEach((e=>{e.destroy()})),this.capturedPendingBuffers.delete(e)),this.sessionCount-=1,0===this.sessionCount&&(Dt("warning",(()=>"[WebGPU] Clearing webgpu buffer cache")),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.storageCache=new Map)}},an=(...e)=>new sn(...e)})),Gl=te((()=>{An=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this.key}},on=e=>new An(e)})),Fl=te((()=>{yl(),Bl(),ln=64,un=(e,t)=>{if(3===t)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==t)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},cn=(e,t=1)=>{let n=un(e,t);return"string"==typeof n?n:n[0]},dn=(e,t=1)=>{let n=un(e,t);return"string"==typeof n?n:n[1]},hn=(...e)=>{let t=[];return e.forEach((e=>{0!==e.length&&t.push({type:12,data:e},{type:12,data:Nt.computeStrides(e)})})),t},fn=e=>e%4==0?4:e%2==0?2:1,gn=(e="f32",t,n="0")=>t&&1!==t?`vec${t}<${e}>(${n})`:`${e}(${n})`,pn=(e,t,n)=>"f32"===e?n:1===t?`f32(${n})`:`vec${t}<f32>(${n})`,mn=(e,t)=>4===t?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:2===t?`(${e}.x + ${e}.y)`:3===t?`(${e}.x + ${e}.y + ${e}.z)`:e,bn=(e,t,n,r)=>e.startsWith("uniforms.")&&n>4?"string"==typeof t?"f16"===r?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:"f16"===r?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,Cn=(e,t,n,r,s)=>{let a="number"==typeof n,i=a?n:n.length,A=[...new Array(i).keys()],o=i<2?"u32":i<=4?`vec${i}<u32>`:`array<u32, ${i}>`,l=un(t,s),u="string"==typeof l?l:l[1],c="string"==typeof l?l:l[0],d={indices:o,value:u,storage:c,tensor:t},h=e=>"string"==typeof e?e:`${e}u`,f={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},g=a?"uniforms.":"",p=`${g}${e}_shape`,m=`${g}${e}_strides`,b="";for(let e=0;e<i-1;e++)b+=`\n    let dim${e} = current / ${bn(m,e,i)};\n    let rest${e} = current % ${bn(m,e,i)};\n    indices[${e}] = dim${e};\n    current = rest${e};\n    `;b+=`indices[${i-1}] = current;`;let C=i<2?"":`\n  fn o2i_${e}(offset: u32) -> ${d.indices} {\n    var indices: ${d.indices};\n    var current = offset;\n    ${b}\n    return indices;\n  }`,I=[];if(i>=2)for(let e=i-1;e>=0;e--)I.push(`${bn(m,e,i)} * (indices[${e}])`);let w=i<2?"":`\n  fn i2o_${e}(indices: ${d.indices}) -> u32 {\n    return ${I.join("+")};\n  }`,k=(...e)=>0===i?"0u":`${d.indices}(${e.map(h).join(",")})`,x=(e,t)=>i<2?`${e}`:`${bn(e,t,i)}`,y={},v=(t,n)=>(()=>{if(d.storage===d.value)return`${e}[${t}]=${n};`;if("vec2<u32>"===d.storage&&"i32"===d.value)return`${e}[${t}]=vec2<u32>(u32(${n}), select(0u, 0xFFFFFFFFu, ${n} < 0));`;if("vec2<u32>"===d.storage&&"u32"===d.value)return`${e}[${t}]=vec2<u32>(u32(${n}), 0u);`;if("u32"===d.storage&&"vec4<bool>"===d.value)return`${e}[${t}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n}));`;throw new Error(`not supported combination of storage type ${d.storage} and value type ${d.value} yet`)})(),E=t=>(()=>{if(d.storage===d.value)return`${e}[${t}]`;if("vec2<u32>"===d.storage&&"i32"===d.value)return`i32(${e}[${t}].x)`;if("vec2<u32>"===d.storage&&"u32"===d.value)return`u32(${e}[${t}].x)`;if("u32"===d.storage&&"vec4<bool>"===d.value)return`vec4<bool>(bool(${e}[${t}] & 0xFFu), bool(${e}[${t}] & 0xFF00u), bool(${e}[${t}] & 0xFF0000u), bool(${e}[${t}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${d.storage} and value type ${d.value} yet`)})(),B=i<2?"":`\n  fn get_${e}ByIndices(indices: ${d.indices}) -> ${u} {\n    return ${E(`i2o_${e}(indices)`)};\n  }`,M=i<2?"":(()=>{let t=A.map((e=>`d${e}: u32`)).join(", "),n=A.map((e=>`d${e}`)).join(", ");return`\n  fn get_${e}(${t}) -> ${u} {\n    return get_${e}ByIndices(${k(n)});\n  }`})(),D=i<2?"":`\n  fn set_${e}ByIndices(indices: ${d.indices}, value: ${u}) {\n    ${v(`i2o_${e}(indices)`,"value")}\n  }`,T=i<2?"":(()=>{let t=A.map((e=>`d${e}: u32`)).join(", "),n=A.map((e=>`d${e}`)).join(", ");return`\n  fn set_${e}(${t}, value: ${u}) {\n    set_${e}ByIndices(${k(n)}, value);\n  }`})();return{impl:()=>{let e=[],t=!1;return f.offsetToIndices&&(e.push(C),t=!0),f.indicesToOffset&&(e.push(w),t=!0),f.broadcastedIndicesToOffset&&(Object.values(y).forEach((t=>e.push(t))),t=!0),f.set&&(e.push(T),t=!0),f.setByIndices&&(e.push(D),t=!0),f.get&&(e.push(M),t=!0),f.getByIndices&&(e.push(B),t=!0),!a&&t&&e.unshift(`const ${p} = ${d.indices}(${n.join(",")});`,`const ${m} = ${d.indices}(${Nt.computeStrides(n).join(",")});`),e.join("\n")},type:d,offsetToIndices:t=>(f.offsetToIndices=!0,i<2?t:`o2i_${e}(${t})`),indicesToOffset:t=>(f.indicesToOffset=!0,i<2?t:`i2o_${e}(${t})`),broadcastedIndicesToOffset:(t,n)=>{f.broadcastedIndicesToOffset=!0;let r=`${n.name}broadcastedIndicesTo${e}Offset`;if(r in y)return`${r}(${t})`;let s=[];for(let e=i-1;e>=0;e--){let t=n.indicesGet("outputIndices",e+n.rank-i);s.push(`${x(m,e)} * (${t} % ${x(p,e)})`)}return y[r]=`fn ${r}(outputIndices: ${n.type.indices}) -> u32 {\n             return ${s.length>0?s.join("+"):"0u"};\n           }`,`${r}(${t})`},indices:k,indicesGet:x,indicesSet:(e,t,n)=>i<2?`${e}=${n};`:`${bn(e,t,i)}=${n};`,set:(...t)=>{if(t.length!==i+1)throw new Error(`indices length must be ${i}`);let n=t[i];if("string"!=typeof n)throw new Error("value must be string");let r=t.slice(0,i).map(h).join(",");return 0===i?v("0u",n):1===i?v(r[0],n):(f.set=!0,f.setByIndices=!0,f.indicesToOffset=!0,`set_${e}(${r}, ${n})`)},setByOffset:v,setByIndices:(t,n)=>i<2?v(t,n):(f.setByIndices=!0,f.indicesToOffset=!0,`set_${e}ByIndices(${t}, ${n});`),get:(...t)=>{if(t.length!==i)throw new Error(`indices length must be ${i}`);let n=t.map(h).join(",");return 0===i?E("0u"):1===i?E(n[0]):(f.get=!0,f.getByIndices=!0,f.indicesToOffset=!0,`get_${e}(${n})`)},getByOffset:E,getByIndices:t=>i<2?E(t):(f.getByIndices=!0,f.indicesToOffset=!0,`get_${e}ByIndices(${t})`),usage:r,name:e,strides:m,shape:p,rank:i}},In=(e,t,n,r=1)=>Cn(e,t,n,"input",r),wn=(e,t,n,r=1)=>Cn(e,t,n,"output",r),kn=(e,t,n)=>Cn(e,t,n,"atomicOutput",1),xn=(e,t,n,r=1)=>Cn(e,t,n,"internal",r),yn=class{constructor(e,t){this.normalizedDispatchGroup=e,this.limits=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=ln){let t="number"==typeof e?e:e[0],n="number"==typeof e?1:e[1],r="number"==typeof e?1:e[2];if(t>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||r>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${t}, ${n}, ${r}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(t*n*r>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${t}, ${n}, ${r}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let s=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${t}, ${n}, ${r})\n  fn main(${s?"@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(local_invocation_id) local_id : vec3<u32>":"@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>"}) {\n    ${s?"let global_idx = global_id.x;\n         let workgroup_index = workgroup_id.x;":`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\n         let global_idx = workgroup_index * ${t*n*r}u + local_idx;`}\n  `}appendVariableUniforms(e){0!==e.rank&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,t){if("internal"===e.usage)throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let n="input"===e.usage?"read":"read_write",r="atomicOutput"===e.usage?"atomic<i32>":e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${r}>;`}declareVariables(...e){return e.map((e=>this.declareVariable(e,this.variableIndex++))).join("\n")}registerInternalVariable(e){if("internal"!==e.usage)throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach((e=>this.registerInternalVariable(e))),this}registerUniform(e,t,n=1){return this.uniforms.push({name:e,type:t,length:n}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(0===this.uniforms.length)return"";let e=[];for(let{name:t,type:n,length:r}of this.uniforms)if(r&&r>4)"f16"===n?e.push(`@align(16) ${t}:array<mat2x4<${n}>, ${Math.ceil(r/8)}>`):e.push(`${t}:array<vec4<${n}>, ${Math.ceil(r/4)}>`);else{let s=null==r||1===r?n:`vec${r}<${n}>`;e.push(`${t}:${s}`)}return`\n      struct Uniforms { ${e.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map((e=>e.impl())).join("\n")+this.internalVariables.map((e=>e.impl())).join("\n")}get variablesInfo(){if(0===this.uniforms.length)return;let e=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map((t=>[e(t.type),t.length??1]))}},vn=(e,t)=>new yn(e,t)})),Pl=te((()=>{yl(),Bl(),Gl(),Fl(),En=(e,t)=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if(0!==t.length&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},Bn=(e,t)=>0!==t.length?t:[...new Array(e).keys()].reverse(),Mn=(e,t)=>Nt.sortBasedOnPerm(e,Bn(e.length,t)),Dn=(e,t,n,r)=>{let s=`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`;for(let n=0;n<t;++n)s+=`a[${e[n]}]=i[${n}];`;return s+"return a;}"},Tn=(e,t)=>{let n=[],r=[];for(let s=0;s<e.length;++s)1!==e[s]&&n.push(e[s]),1!==e[t[s]]&&r.push(t[s]);return{newShape:n,newPerm:r}},Sn=(e,t)=>{let n=0;for(let r=0;r<e.length;++r)if(1!==t[e[r]]){if(e[r]<n)return!1;n=e[r]}return!0},Nn=(e,t)=>{let n,r=e.dataType,s=e.dims.length,a=Bn(s,t),i=Mn(e.dims,a),A=e.dims,o=i;if(s<2||Sn(a,e.dims))return n=e=>{let t=In("input",r,A,4),n=wn("output",r,o,4);return`\n  ${e.registerUniform("output_size","u32").declareVariables(t,n)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    output[global_idx] = input[global_idx];\n  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let t=Nt.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64/4)},programUniforms:[{type:12,data:Math.ceil(t/4)}]}},getShaderSource:n};let{newShape:l,newPerm:u}=Tn(e.dims,a),c=Nt.areEqual(u,[2,3,1]),d=Nt.areEqual(u,[3,1,2]);if(2===l.length||c||d){A=c?[l[0],l[1]*l[2]]:d?[l[0]*l[1],l[2]]:l,o=[A[1],A[0]];let t=16;return n=e=>{let n=In("a",r,A.length),s=wn("output",r,o.length);return`\n  ${e.registerUniform("output_size","u32").declareVariables(n,s)}\n  var<workgroup> tile : array<array<${s.type.value}, ${t+1}>, ${t}>;\n  ${e.mainStart([t,t,1])}\n    let stride = (uniforms.output_shape[1] - 1) / ${t} + 1;\n    let workgroup_id_x = workgroup_index % stride;\n    let workgroup_id_y = workgroup_index / stride;\n    let input_col = workgroup_id_y * ${t}u + local_id.x;\n    let input_row = workgroup_id_x * ${t}u + local_id.y;\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\n      tile[local_id.y][local_id.x] = ${n.getByIndices(`${n.type.indices}(input_row, input_col)`)};\n    }\n    workgroupBarrier();\n\n    let output_col = workgroup_id_x * ${t}u + local_id.x;\n    let output_row = workgroup_id_y * ${t}u + local_id.y;\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\n      ${s.setByIndices(`${s.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}\n    }\n  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let n=Nt.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(o[1]/t),y:Math.ceil(o[0]/t)},programUniforms:[{type:12,data:n},...hn(A,o)]}},getShaderSource:n}}return n=e=>{let t=In("a",r,A.length),n=wn("output",r,o.length);return`\n  ${e.registerUniform("output_size","u32").declareVariables(t,n)}\n\n  ${Dn(a,s,t,n)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${n.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${n.setByOffset("global_idx",t.getByIndices("aIndices"))}\n  }`},{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:()=>{let t=Nt.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:[{type:12,data:t},...hn(A,o)]}},getShaderSource:n}},Gn=(e,t)=>{En(e.inputs,t.perm),e.compute(Nn(e.inputs[0],t.perm))},Fn=e=>on({perm:e.perm})})),Ql=te((()=>{yl(),Bl(),Fl(),zl(),Pl(),Pn={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Qn={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},zn={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},On={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Rn=(e,t)=>{let n=[];for(let r=t-e;r<t;++r)n.push(r);return n},Ln=(e,t)=>{let n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);let s=t.map((t=>e[t]));return[n,s]},Wn=(e,t)=>{let n=e.length+t.length,r=[],s=0;for(let a=0;a<n;a++)-1===t.indexOf(a)?r.push(e[s++]):r.push(1);return r},_n=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},Vn=(e,t)=>{let n=[];if(!_n(e,t)){for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);e.forEach((e=>n.push(e)))}return n},Hn=(e,t,n,r,s,a,i)=>{let A=n[0].dims,o=Nt.size(a),l=Nt.size(i),u=In("_A",n[0].dataType,A),c=wn("output",s,a),d=64;1===o&&(d=256);let h=`\n          var<workgroup> aBestValues : array<f32, ${d}>;\n       `;return{name:e,shaderCache:{hint:`${t};${d}`,inputDependencies:["type"]},getShaderSource:e=>`\n        ${e.registerUniform("reduceSize","u32").declareVariables(u,c)}\n        ${h}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${e.mainStart(d)}\n\n          let outputIndex = global_idx / ${d};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${zn[r]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${d}) {\n           let candidate = f32(${u.getByOffset("offset + k")});\n           bestValue = ${Pn[r]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${d}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${Qn[r]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${c.setByOffset("outputIndex",""+("mean"===r?`${c.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${c.type.storage}(${On[r]})`))};\n         }\n        }`,getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:o},programUniforms:[{type:12,data:l}]})}},Un=(e,t,n,r)=>{let s=1===e.inputs.length?n:ar(e.inputs,n),a=s.axes;0===a.length&&!s.noopWithEmptyAxes&&(a=e.inputs[0].dims.map(((e,t)=>t)));let i=Nt.normalizeAxes(a,e.inputs[0].dims.length),A=i,o=e.inputs[0],l=Vn(A,e.inputs[0].dims.length);l.length>0&&(o=e.compute(Nn(e.inputs[0],l),{inputs:[0],outputs:[-1]})[0],A=Rn(A.length,o.dims.length));let[u,c]=Ln(o.dims,A),d=u;s.keepDims&&(d=Wn(u,i)),e.compute(Hn(t,s.cacheKey,[o],r,e.inputs[0].dataType,d,c),{inputs:[o]})},jn=(e,t)=>{Un(e,"ReduceMeanShared",t,"mean")},Yn=(e,t)=>{Un(e,"ReduceL1Shared",t,"l1")},Kn=(e,t)=>{Un(e,"ReduceL2Shared",t,"l2")},Xn=(e,t)=>{Un(e,"ReduceLogSumExpShared",t,"logSumExp")},qn=(e,t)=>{Un(e,"ReduceMaxShared",t,"max")},Zn=(e,t)=>{Un(e,"ReduceMinShared",t,"min")},Jn=(e,t)=>{Un(e,"ReduceProdShared",t,"prod")},$n=(e,t)=>{Un(e,"ReduceSumShared",t,"sum")},er=(e,t)=>{Un(e,"ReduceSumSquareShared",t,"sumSquare")},tr=(e,t)=>{Un(e,"ReduceLogSumShared",t,"logSum")}})),zl=te((()=>{yl(),Bl(),Gl(),Fl(),Ql(),nr=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.")},rr=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],sr=(e,t,n,r,s,a,i=!1,A=!1)=>{let o=[],l=n[0].dims,u=l.length,c=Nt.normalizeAxes(s,u),d=!A&&0===c.length;l.forEach(((e,t)=>{d||c.indexOf(t)>=0?i&&o.push(1):o.push(e)}));let h=o.length,f=Nt.size(o);return{name:e,shaderCache:t,getShaderSource:e=>{let t=[],s=In("_A",n[0].dataType,u),A=wn("output",a,h),o=r(s,A,c),f=o[2];for(let e=0,n=0;e<u;e++)d||c.indexOf(e)>=0?(i&&n++,f=`for(var j${e}: u32 = 0; j${e} < ${l[e]}; j${e}++) {\n                  ${o[2].includes("last_index")?`let last_index = j${e};`:""}\n                  ${s.indicesSet("input_indices",e,`j${e}`)}\n                  ${f}\n                }`):(t.push(`${s.indicesSet("input_indices",e,A.indicesGet("output_indices",n))};`),n++);return`\n\n        ${e.registerUniform("output_size","u32").declareVariables(s,A)}\n\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${s.type.indices};\n          let output_indices = ${A.offsetToIndices("global_idx")};\n\n          ${t.join("\n")}\n          ${o[0]}       // init ops for reduce max/min\n          ${o[1]}\n          ${f}\n          ${o[3]}\n          ${4===o.length?A.setByOffset("global_idx","value"):o.slice(4).join("\n")}\n        }`},getRunData:()=>({outputs:[{dims:o,dataType:a}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...hn(l,o)]})}},ar=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),on({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},ir=(e,t,n,r)=>{let s=e.inputs,a=1===s.length?n:ar(s,n);e.compute(sr(t,{hint:a.cacheKey,inputDependencies:["rank"]},[s[0]],a.noopWithEmptyAxes&&0===a.axes.length?rr:r,a.axes,s[0].dataType,a.keepDims,a.noopWithEmptyAxes),{inputs:[0]})},Ar=(e,t)=>{nr(e.inputs),ir(e,"ReduceLogSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,"value = log(value);"]))},or=(e,t)=>{nr(e.inputs),ir(e,"ReduceL1",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByIndices("input_indices")});`,""]))},lr=(e,t)=>{nr(e.inputs),ir(e,"ReduceL2",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"]))},ur=(e,t)=>{nr(e.inputs),ir(e,"ReduceLogSumExp",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByIndices("input_indices")});`,"value = log(value);"]))},cr=(e,t)=>{nr(e.inputs),ir(e,"ReduceMax",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(e.indicesSet("input_indices",t,0));return[`${r.join("\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = max(value, ${e.getByIndices("input_indices")});`,""]}))},dr=(e,t)=>{nr(e.inputs),ir(e,"ReduceMean",t,((t,n,r)=>{let s=1;for(let n=0;n<t.rank;n++)(r.indexOf(n)>=0||0===r.length)&&(s*=e.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${t.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${s});`]}))},hr=(e,t)=>{nr(e.inputs),ir(e,"ReduceMin",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(`input_indices[${t}] = 0;`);return[`${r.join("\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = min(value, ${e.getByIndices("input_indices")});`,""]}))},fr=(e,t)=>{nr(e.inputs),ir(e,"ReduceProd",t,((e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByIndices("input_indices")};`,""]))},gr=(e,t)=>{nr(e.inputs),ir(e,"ReduceSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,""]))},pr=(e,t)=>{nr(e.inputs),ir(e,"ReduceSumSquare",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += t * t;`,""]))},mr=(e,t,n)=>{if(0===t.length)return n;let r=1,s=1;for(let n=0;n<t.length;n++)-1===t.indexOf(n)?r*=e[n]:s*=e[n];return s<32&&r>1024},br=(e,t)=>{mr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?dr(e,t):jn(e,t)},Cr=(e,t)=>{mr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?or(e,t):Yn(e,t)},Ir=(e,t)=>{mr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?lr(e,t):Kn(e,t)},wr=(e,t)=>{mr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ur(e,t):Xn(e,t)},kr=(e,t)=>{mr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?cr(e,t):qn(e,t)},xr=(e,t)=>{mr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?hr(e,t):Zn(e,t)},yr=(e,t)=>{mr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?fr(e,t):Jn(e,t)},vr=(e,t)=>{mr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?gr(e,t):$n(e,t)},Er=(e,t)=>{mr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?pr(e,t):er(e,t)},Br=(e,t)=>{mr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ar(e,t):tr(e,t)}})),Ol=te((()=>{yl(),Gl(),zl(),Mr=e=>{if(!e||0===e.length||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},Dr=(e,t)=>{Mr(e.inputs);e.compute(sr("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],((e,n,r)=>{let s=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&s.push(`input_indices[${t}] = 0;`);return[`${s.join("\n")}`,`var value = ${e.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${e.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]}),[t.axis],7,t.keepDims),{inputs:[0]})},Tr=(e,t)=>{Mr(e.inputs);e.compute(sr("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],((e,n,r)=>{let s=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&s.push(`input_indices[${t}] = 0;`);return[`${s.join("\n")}`,`var value = ${e.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${e.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]}),[t.axis],7,t.keepDims),{inputs:[0]})},Sr=e=>on(e)})),Rl=te((()=>{yl(),Bl(),Sl(),Fl(),Nr=(e,t)=>{let n=e[0],r=e[1],s=e[2],a=e[3],i=e[4],A=e[5];if(i&&A)throw new Error("Attention cannot have both past and attention_bias");if(3!==n.dims.length)throw new Error('Input "input" must have 3 dimensions');let o=n.dims[0],l=n.dims[1],u=n.dims[2];if(1!==s.dims.length)throw new Error('Input "bias" is expected to have 1 dimensions');if(2!==r.dims.length)throw new Error('Input "weights" is expected to have 2 dimensions');if(r.dims[0]!==u)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(s.dims[0]!==r.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let c=s.dims[0]/3,d=c,h=d;if(t.qkvHiddenSizes.length>0){if(3!==t.qkvHiddenSizes.length)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let e of t.qkvHiddenSizes)if(e%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");c=t.qkvHiddenSizes[0],d=t.qkvHiddenSizes[1],h=t.qkvHiddenSizes[2]}let f=l;if(c!==d)throw new Error("qkv_hidden_sizes first element should be same as the second");if(s.dims[0]!==c+d+h)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let g=0;if(i){if(d!==h)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(5!==i.dims.length)throw new Error('Input "past" must have 5 dimensions');if(2!==i.dims[0])throw new Error('Input "past" first dimension must be 2');if(i.dims[1]!==o)throw new Error('Input "past" second dimension must be batch_size');if(i.dims[2]!==t.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(i.dims[4]!==d/t.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(g=i.dims[3])}let p=f+g;if(a)throw new Error("Mask not supported");if(i)throw new Error("past is not supported");if(A){if(4!==A.dims.length)throw new Error('Input "attention_bias" must have 4 dimensions');if(A.dims[0]!==o||A.dims[1]!==t.numHeads||A.dims[2]!==l||A.dims[3]!==p)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:o,sequenceLength:l,pastSequenceLength:g,kvSequenceLength:f,totalSequenceLength:p,maxSequenceLength:-1,inputHiddenSize:u,hiddenSize:c,vHiddenSize:h,headSize:Math.floor(c/t.numHeads),vHeadSize:Math.floor(h/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Gr=(e,t,n)=>t&&e?`\n      let total_sequence_length_input = u32(${t.getByOffset("0")});\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\n      total_sequence_length = u32(${e?.getByOffset("batchIdx")}) + 1;\n      var past_sequence_length: u32 = 0;\n      if (is_first_prompt == false) {\n        past_sequence_length = total_sequence_length - sequence_length;\n      }\n       `:`\n    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};\n    let present_sequence_length = total_sequence_length;\n    `,Fr=(e,t,n,r,s,a,i,A)=>{let o=fn(i?1:a),l=64,u=a/o;u<l&&(l=32);let c=Math.ceil(a/o/l),d=[{type:12,data:t},{type:12,data:n},{type:12,data:r},{type:12,data:s},{type:12,data:u},{type:12,data:c}],h=cn(e.dataType,o),f=dn(1,o),g=["type"];i&&g.push("type"),A&&g.push("type");return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${l};${h};${o}`,inputDependencies:g},getShaderSource:t=>{let n=wn("x",e.dataType,e.dims,o),r=[n],s=i?In("seq_lens",i.dataType,i.dims):void 0;s&&r.push(s);let a=A?In("total_sequence_length_input",A.dataType,A.dims):void 0;a&&r.push(a);let u=dn(e.dataType);return`\n  var<workgroup> thread_max: array<f32, ${l}>;\n  var<workgroup> thread_sum: array<f32, ${l}>;\n  ${t.registerUniforms([{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}]).declareVariables(...r)}\n  ${t.mainStart([l,1,1])}\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let sequence_length = uniforms.sequence_length;\n    var total_sequence_length = uniforms.total_sequence_length;\n    ${Gr(s,a,!1)}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = (global_idx / ${l}) * uniforms.total_sequence_length + local_offset;\n    let seq_causal_length = ${i?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};\n    var thread_max_vector = ${f}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      thread_max_vector = max(${f}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(o){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${o}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${l}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${f}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      sum_vector += exp(${f}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(o){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${o}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${l}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        x[offset + i] = ${n.type.value}(${u}(1.0) / ${u}(seq_causal_length));\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        var f32input = ${f}(x[offset + i]);\n        x[offset + i] = ${n.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n      ${i?`\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\n          x[offset + total_seq_id] = ${n.type.value}(${u}(0));\n        }`:""};\n  }`},getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:s,z:t*n},programUniforms:d})}},Pr=(e,t,n,r,s,a,i,A,o)=>{let l=i+a.kvSequenceLength,u=[a.batchSize,a.numHeads,a.sequenceLength,l],c=e>1&&r,d=a.kvNumHeads?a.kvNumHeads:a.numHeads,h=c?[a.batchSize,d,l,a.headSize]:void 0,f=a.nReps?a.nReps:1,g=0===a.scale?1/Math.sqrt(a.headSize):a.scale,p=fn(a.headSize),m=a.headSize/p,b=12,C={x:Math.ceil(l/b),y:Math.ceil(a.sequenceLength/b),z:a.batchSize*a.numHeads},I=[{type:12,data:a.sequenceLength},{type:12,data:m},{type:12,data:l},{type:12,data:a.numHeads},{type:12,data:a.headSize},{type:1,data:g},{type:12,data:i},{type:12,data:a.kvSequenceLength},{type:12,data:f}],w=c&&r&&Nt.size(r.dims)>0,k=["type","type"];w&&k.push("type"),s&&k.push("type"),A&&k.push("type"),o&&k.push("type");let x=[{dims:u,dataType:t.dataType,gpuDataType:0}];c&&x.push({dims:h,dataType:t.dataType,gpuDataType:0});return{name:"AttentionProbs",shaderCache:{hint:`${p};${void 0!==s};${void 0!==r};${e}`,inputDependencies:k},getRunData:()=>({outputs:x,dispatchGroup:C,programUniforms:I}),getShaderSource:e=>{let a=In("q",t.dataType,t.dims,p),i=[a,In("key",n.dataType,n.dims,p)];if(w){let e=In("past_key",r.dataType,r.dims,p);i.push(e)}s&&i.push(In("attention_bias",s.dataType,s.dims));let l=A?In("seq_lens",A.dataType,A.dims):void 0;l&&i.push(l);let d=o?In("total_sequence_length_input",o.dataType,o.dims):void 0;d&&i.push(d);let g=wn("output",t.dataType,u),m=[g];c&&m.push(wn("present_key",t.dataType,h,p));let C=dn(1,p);return`\n  const TILE_SIZE = 12u;\n\n  var<workgroup> tileQ: array<${a.type.storage}, 144>;\n  var<workgroup> tileK: array<${a.type.storage}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...i,...m)}\n  ${e.mainStart([b,b,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let kvHeadIdx = ${1===f?"headIdx":"headIdx / uniforms.n_reps"};\n    let kv_num_heads = ${1===f?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let sequence_length = uniforms.M;\n    var total_sequence_length = uniforms.N;\n    ${Gr(l,d,!0)}\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n    ${w&&c?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\n    ${c?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}\n    var value = ${C}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n      ${w&&c?"\n              if (n + local_id.y < past_sequence_length) {\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\n              }":"\n          if (n + local_id.y < uniforms.kv_sequence_length) {\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n          }"}\n      ${c?"if (n + local_id.y < present_sequence_length) {\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\n      }":""}\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n          value += ${C}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(p){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${p}`)}})()};\n        output[outputIdx] = ${g.type.value} (sum * uniforms.alpha) + ${s?"attention_bias[outputIdx]":"0.0"};\n    }\n  }`}}},Qr=(e,t,n,r,s,a,i=void 0,A=void 0)=>{let o=a+s.kvSequenceLength,l=s.nReps?s.nReps:1,u=s.vHiddenSize*l,c=e>1&&r,d=s.kvNumHeads?s.kvNumHeads:s.numHeads,h=c?[s.batchSize,d,o,s.headSize]:void 0,f=[s.batchSize,s.sequenceLength,u],g=12,p={x:Math.ceil(s.vHeadSize/g),y:Math.ceil(s.sequenceLength/g),z:s.batchSize*s.numHeads},m=[{type:12,data:s.sequenceLength},{type:12,data:o},{type:12,data:s.vHeadSize},{type:12,data:s.numHeads},{type:12,data:s.headSize},{type:12,data:u},{type:12,data:a},{type:12,data:s.kvSequenceLength},{type:12,data:l}],b=c&&r&&Nt.size(r.dims)>0,C=["type","type"];b&&C.push("type"),i&&C.push("type"),A&&C.push("type");let I=[{dims:f,dataType:t.dataType,gpuDataType:0}];c&&I.push({dims:h,dataType:t.dataType,gpuDataType:0});return{name:"AttentionScore",shaderCache:{hint:`${void 0!==r};${e}`,inputDependencies:C},getRunData:()=>({outputs:I,dispatchGroup:p,programUniforms:m}),getShaderSource:e=>{let s=In("probs",t.dataType,t.dims),a=[s,In("v",n.dataType,n.dims)];b&&a.push(In("past_value",r.dataType,r.dims));let o=i?In("seq_lens",i.dataType,i.dims):void 0;i&&a.push(o);let u=A?In("total_sequence_length_input",A.dataType,A.dims):void 0;A&&a.push(u);let d=[wn("output",t.dataType,f)];c&&d.push(wn("present_value",t.dataType,h));return`\n  const TILE_SIZE = 12u;\n  var<workgroup> tileQ: array<${s.type.value}, 144>;\n  var<workgroup> tileV: array<${s.type.value}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...a,...d)}\n  ${e.mainStart([g,g,1])}\n   let headIdx = workgroup_id.z % uniforms.num_heads;\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let kvHeadIdx = ${1===l?"headIdx":"headIdx / uniforms.n_reps"};\n   let kv_num_heads = ${1===l?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\n   let m = global_id.y;\n   let n = global_id.x;\n   let sequence_length = uniforms.M;\n   var total_sequence_length = uniforms.K;\n   ${Gr(o,u,!0)}\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\n   ${b&&c?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\n   ${c?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}\n   var value = ${s.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n        ${b&&c?"\n        if (w + local_id.y < past_sequence_length) {\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\n        }\n      ":"\n            if (w + local_id.y < uniforms.kv_sequence_length) {\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\n            }"}\n        ${c?"\n            if (w + local_id.y < present_sequence_length) {\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\n        }":""}\n      }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + headIdx * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`}}},zr=(e,t,n,r,s,a,i,A,o,l,u=void 0,c=void 0)=>{let d=Math.min(e.outputCount,1+(i?1:0)+(A?1:0)),h=d>1?l.pastSequenceLength:0,f=h+l.kvSequenceLength,g=o&&Nt.size(o.dims)>0?o:void 0,p=[t,n];d>1&&i&&Nt.size(i.dims)>0&&p.push(i),g&&p.push(g),u&&p.push(u),c&&p.push(c);let m=e.compute(Pr(d,t,n,i,g,l,h,u,c),{inputs:p,outputs:d>1?[-1,1]:[-1]})[0];e.compute(Fr(m,l.batchSize,l.numHeads,h,l.sequenceLength,f,u,c),{inputs:u&&c?[m,u,c]:[m],outputs:[]});let b=[m,r];d>1&&A&&Nt.size(A.dims)>0&&b.push(A),u&&b.push(u),c&&b.push(c),e.compute(Qr(d,m,r,A,l,h,u,c),{inputs:b,outputs:d>1?[0,2]:[0]})},Or=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],r=t.sequenceLength,s=t.inputHiddenSize,a=t.headSize,i=12,A={x:Math.ceil(t.headSize/i),y:Math.ceil(t.sequenceLength/i),z:t.batchSize*t.numHeads},o=[e.inputs[0],e.inputs[1],e.inputs[2]],l=[{type:12,data:r},{type:12,data:s},{type:12,data:a},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}];return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:A,programUniforms:l}),getShaderSource:e=>{let t=wn("output_q",o[0].dataType,n),r=wn("output_k",o[0].dataType,n),s=wn("output_v",o[0].dataType,n),a=In("input",o[0].dataType,o[0].dims),A=In("weight",o[1].dataType,o[1].dims),l=In("bias",o[2].dataType,o[2].dims),u=a.type.storage;return`\n  const TILE_SIZE = 12u;\n  var<workgroup> tileInput: array<${u}, 144>;\n  var<workgroup> tileWeightQ: array<${u}, 144>;\n  var<workgroup> tileWeightK: array<${u}, 144>;\n  var<workgroup> tileWeightV: array<${u}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}]).declareVariables(a,A,l,t,r,s)}\n  ${e.mainStart([i,i,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${u}(0);\n    var valueK = ${u}(0);\n    var valueV = ${u}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`}},{inputs:o,outputs:[-1,-1,-1]})},Rr=(e,t)=>{let n=Nr(e.inputs,t),[r,s,a]=Or(e,n);return zr(e,r,s,a,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n)}})),Ll=te((()=>{xe(),yl(),Bl(),Gl(),Fl(),Lr=(e,t)=>{if(!e||5!==e.length)throw new Error("BatchNormalization requires 5 inputs");let n=(e,t,n)=>{let r=t.length;if(r!==e.length)throw new Error(`${n}: num dimensions != ${r}`);t.forEach(((t,r)=>{if(t!==e[r])throw new Error(`${n}: dim[${r}] do not match`)}))};if(e[0].dims.length>1){let r="NHWC"===t.format?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,r,"Invalid input scale"),n(e[2].dims,r,"Invalid input B"),n(e[3].dims,r,"Invalid input mean"),n(e[4].dims,r,"Invalid input var")}else n(e[1].dims,[1],"Invalid input scale"),n(e[2].dims,[1],"Invalid input B"),n(e[3].dims,[1],"Invalid input mean"),n(e[4].dims,[1],"Invalid input var")},Wr=(e,t)=>{let{epsilon:n,spatial:r,format:s}=t,a=e[0].dims,i=r?fn(a[a.length-1]):1,A="NHWC"===s&&a.length>1?i:1,o=Nt.size(a)/i,l=r,u=l?a.length:a,c=In("x",e[0].dataType,e[0].dims,i),d=In("scale",e[1].dataType,e[1].dims,A),h=In("bias",e[2].dataType,e[2].dims,A),f=In("inputMean",e[3].dataType,e[3].dims,A),g=In("inputVar",e[4].dataType,e[4].dims,A),p=wn("y",e[0].dataType,u,i);return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${r}_${i}`,inputDependencies:l?["rank","type","type","type","type"]:void 0},getShaderSource:e=>`\n  const epsilon = ${n};\n  ${e.registerUniform("outputSize","u32").declareVariables(c,d,h,f,g,p)}\n  ${e.mainStart()}\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${p.offsetToIndices(`global_idx * ${i}`)};\n    ${(()=>{let e="";if(r)e=`let cOffset = ${1===a.length?"0u":"NHWC"===s?`outputIndices[${a.length-1}] / ${i}`:"outputIndices[1]"};`;else if("NCHW"===s)e=`\n            ${p.indicesSet("outputIndices","0","0")}\n            let cOffset = ${p.indicesToOffset("outputIndices")};`;else{e=`var cIndices = ${d.type.indices}(0);\n                       cIndices[0] = outputIndices[${a.length-1}];`;for(let t=1;t<d.rank;t++)e+=`cIndices[${t}] = outputIndices[${t}];`;e+=`let cOffset = ${d.indicesToOffset("cIndices")};`}return e})()}\n    let scale = ${d.getByOffset("cOffset")};\n    let bias = ${h.getByOffset("cOffset")};\n    let inputMean = ${f.getByOffset("cOffset")};\n    let inputVar = ${g.getByOffset("cOffset")};\n    let x = ${c.getByOffset("global_idx")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${p.setByOffset("global_idx","value")}\n  }`,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:l?[{type:12,data:o},...hn(a)]:[{type:12,data:o}]})}},_r=e=>on(e),Vr=(e,t)=>{let{inputs:n,outputCount:r}=e,s=_r({...t,outputCount:r});if(E.webgpu.validateInputContent&&Lr(n,s),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(Wr(n,s))}})),Wl=te((()=>{Bl(),Fl(),Hr=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Ur=e=>{let t=e[0].dims,n=e[0].dims[2],r=Nt.size(t)/4,s=e[0].dataType,a=In("input",s,t,4),i=In("bias",s,[n],4),A=In("residual",s,t,4),o=wn("output",s,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:e=>`\n  const channels = ${n}u / 4;\n  ${e.declareVariables(a,i,A,o)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(r)}\n    let value = ${a.getByOffset("global_idx")}\n      + ${i.getByOffset("global_idx % channels")} + ${A.getByOffset("global_idx")};\n    ${o.setByOffset("global_idx","value")}\n  }`}},jr=e=>{Hr(e.inputs),e.compute(Ur(e.inputs))}})),_l=te((()=>{yl(),Bl(),Gl(),Fl(),Yr=(e,t,n,r,s,a,i)=>{let A=Math.ceil(t/4),o="";o="string"==typeof s?`${s}(a)`:s("a");let l=In("inputData",n,[A],4),u=wn("outputData",r,[A],4),c=[{name:"vec_size",type:"u32"}];return i&&c.push(...i),`\n      ${e.registerUniforms(c).declareVariables(l,u)}\n\n  ${a??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${l.getByOffset("global_idx")};\n    ${u.setByOffset("global_idx",o)}\n  }`},Kr=(e,t,n,r,s,a=e.dataType,i,A)=>{let o=[{type:12,data:Math.ceil(Nt.size(e.dims)/4)}];return i&&o.push(...i),{name:t,shaderCache:{hint:s,inputDependencies:["type"]},getShaderSource:t=>Yr(t,Nt.size(e.dims),e.dataType,a,n,r,A),getRunData:t=>({outputs:[{dims:e.dims,dataType:a}],dispatchGroup:{x:Math.ceil(Nt.size(t[0].dims)/64/4)},programUniforms:o})}},Xr=e=>{e.compute(Kr(e.inputs[0],"Abs","abs"))},qr=e=>{e.compute(Kr(e.inputs[0],"Acos","acos"))},Zr=e=>{e.compute(Kr(e.inputs[0],"Acosh","acosh"))},Jr=e=>{e.compute(Kr(e.inputs[0],"Asin","asin"))},$r=e=>{e.compute(Kr(e.inputs[0],"Asinh","asinh"))},es=e=>{e.compute(Kr(e.inputs[0],"Atan","atan"))},ts=e=>{e.compute(Kr(e.inputs[0],"Atanh","atanh"))},ns=e=>on(e),rs=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(Kr(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},ss=e=>{let t,n,r=e.length>=2&&0!==e[1].data,s=e.length>=3&&0!==e[2].data;switch(e[0].dataType){case 1:t=r?e[1].getFloat32Array()[0]:-34028234663852886e22,n=s?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=r?e[1].getUint16Array()[0]:64511,n=s?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return on({min:t,max:n})},as=(e,t)=>{let n=t||ss(e.inputs),r=dn(e.inputs[0].dataType);e.compute(Kr(e.inputs[0],"Clip",(e=>`clamp(${e}, vec4<${r}>(uniforms.min), vec4<${r}>(uniforms.max))`),void 0,n.cacheKey,void 0,[{type:e.inputs[0].dataType,data:n.min},{type:e.inputs[0].dataType,data:n.max}],[{name:"min",type:r},{name:"max",type:r}]),{inputs:[0]})},is=e=>{e.compute(Kr(e.inputs[0],"Ceil","ceil"))},As=e=>{e.compute(Kr(e.inputs[0],"Cos","cos"))},os=e=>{e.compute(Kr(e.inputs[0],"Cosh","cosh"))},ls=e=>on(e),us=(e,t)=>{let n=dn(e.inputs[0].dataType);e.compute(Kr(e.inputs[0],"Elu",(e=>`elu_vf32(${e})`),`\n  const elu_alpha_ = ${n}(${t.alpha});\n\n  fn elu_f32(a: ${n}) -> ${n} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},cs=(e="f32")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,ds=e=>{let t=dn(e.inputs[0].dataType);e.compute(Kr(e.inputs[0],"Erf",(e=>`erf_vf32(${e})`),cs(t)))},hs=e=>{e.compute(Kr(e.inputs[0],"Exp","exp"))},fs=e=>{e.compute(Kr(e.inputs[0],"Floor","floor"))},gs=e=>{let t=dn(e.inputs[0].dataType);e.compute(Kr(e.inputs[0],"Gelu",(e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`),cs(t)))},ps=(e,t)=>{let n=dn(e.inputs[0].dataType);e.compute(Kr(e.inputs[0],"LeakyRelu",(e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<${n}>(0.0))`),`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},ms=e=>{e.compute(Kr(e.inputs[0],"Not",(e=>`!${e}`)))},bs=e=>{e.compute(Kr(e.inputs[0],"Neg",(e=>`-${e}`)))},Cs=e=>{e.compute(Kr(e.inputs[0],"Reciprocal",(e=>`1.0/${e}`)))},Is=e=>{let t=dn(e.inputs[0].dataType);e.compute(Kr(e.inputs[0],"Relu",(e=>`select(vec4<${t}>(0.0), ${e}, ${e} > vec4<${t}>(0.0))`)))},ws=e=>{e.compute(Kr(e.inputs[0],"Sigmoid",(e=>`(1.0 / (1.0 + exp(-${e})))`)))},ks=e=>on(e),xs=(e,t)=>{let n=dn(e.inputs[0].dataType);e.compute(Kr(e.inputs[0],"HardSigmoid",(e=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${e} + vec4<${n}>(${t.beta})))`),void 0,t.cacheKey))},ys=e=>{e.compute(Kr(e.inputs[0],"Sin","sin"))},vs=e=>{e.compute(Kr(e.inputs[0],"Sinh","sinh"))},Es=e=>{e.compute(Kr(e.inputs[0],"Sqrt","sqrt"))},Bs=e=>{e.compute(Kr(e.inputs[0],"Tan","tan"))},Ms=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,Ds=e=>{e.compute(Kr(e.inputs[0],"Tanh",Ms))},Ts=(e="f32")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${Ms("v")};\n}\n`,Ss=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,Ns=e=>{let t=dn(e.inputs[0].dataType);e.compute(Kr(e.inputs[0],"FastGelu",Ss,Ts(t),void 0,e.inputs[0].dataType))},Gs=(e,t)=>{let n=dn(e.inputs[0].dataType);return e.compute(Kr(e.inputs[0],"ThresholdedRelu",(e=>`select(vec4<${n}>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},Fs=e=>{e.compute(Kr(e.inputs[0],"Log","log"))},Ps=(e,t)=>`\nconst alpha = vec4<${e}>(${t});\nconst one = ${e}(1.0);\nconst zero = ${e}(0.0);\n\nfn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {\n  let v = x *alpha;\n  var x1 : vec4<${e}>;\n  for (var i = 0; i < 4; i = i + 1) {\n    if (v[i] >= zero) {\n      x1[i] = one / (one + exp(-v[i]));\n    } else {\n      x1[i] = one - one / (one + exp(v[i]));\n    }\n  }\n  return x * x1;\n}\n`,Qs=e=>`quick_gelu_impl(${e})`,zs=(e,t)=>{let n=dn(e.inputs[0].dataType);e.compute(Kr(e.inputs[0],"QuickGelu",Qs,Ps(n,t.alpha),t.cacheKey,e.inputs[0].dataType))}})),Vl=te((()=>{Bl(),Fl(),_l(),Os=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Rs=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=In("input",e[0].dataType,e[0].dims,4),r=In("bias",e[0].dataType,[e[0].dims[2]],4),s=wn("output",e[0].dataType,t,4),a=Nt.size(t)/4,i=cn(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:t=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${t.declareVariables(n,r,s)}\n\n  ${cs(i)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${s.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Ls=e=>{Os(e.inputs),e.compute(Rs(e.inputs))}})),Hl=te((()=>{yl(),Bl(),Fl(),Ws=(e,t,n,r,s,a,i,A,o,l,u,c)=>{let d,h;"string"==typeof A?d=h=(e,t)=>`${A}((${e}),(${t}))`:"function"==typeof A?d=h=A:(d=A.scalar,h=A.vector);let f,g=wn("outputData",u,r.length,4),p=In("aData",o,t.length,4),m=In("bData",l,n.length,4);if(s)if(a){let e=1===Nt.size(t),r=1===Nt.size(n),s=t.length>0&&t[t.length-1]%4==0,a=n.length>0&&n[n.length-1]%4==0;f=e||r?g.setByOffset("global_idx",h(e?`${p.type.value}(${p.getByOffset("0")}.x)`:p.getByOffset("global_idx"),r?`${m.type.value}(${m.getByOffset("0")}.x)`:m.getByOffset("global_idx"))):`\n            let outputIndices = ${g.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${p.broadcastedIndicesToOffset("outputIndices",g)};\n            let offsetB = ${m.broadcastedIndicesToOffset("outputIndices",g)};\n            ${g.setByOffset("global_idx",h(i||s?p.getByOffset("offsetA / 4u"):`${p.type.value}(${p.getByOffset("offsetA / 4u")}[offsetA % 4u])`,i||a?m.getByOffset("offsetB / 4u"):`${m.type.value}(${m.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else f=g.setByOffset("global_idx",h(p.getByOffset("global_idx"),m.getByOffset("global_idx")));else{if(!a)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let e=(e,t,n="")=>{let r=`aData[indexA${t}][componentA${t}]`,s=`bData[indexB${t}][componentB${t}]`;return`\n            let outputIndices${t} = ${g.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offsetA${t} = ${p.broadcastedIndicesToOffset(`outputIndices${t}`,g)};\n            let offsetB${t} = ${m.broadcastedIndicesToOffset(`outputIndices${t}`,g)};\n            let indexA${t} = offsetA${t} / 4u;\n            let indexB${t} = offsetB${t} / 4u;\n            let componentA${t} = offsetA${t} % 4u;\n            let componentB${t} = offsetB${t} % 4u;\n            ${e}[${t}] = ${n}(${d(r,s)});\n          `};f=9===u?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("outputData[global_idx]",0)}\n            ${e("outputData[global_idx]",1)}\n            ${e("outputData[global_idx]",2)}\n            ${e("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(p,m,g)}\n\n        ${c??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${f}\n      }`},_s=(e,t,n,r,s,a,i=n.dataType)=>{let A=n.dims.map((e=>Number(e)??1)),o=r.dims.map((e=>Number(e)??1)),l=!Nt.areEqual(A,o),u=A,c=Nt.size(A),d=!1,h=!1,f=[l];if(l){let e=St.calcShape(A,o,!1);if(!e)throw new Error("Can't perform binary op on the given tensors");u=e.slice(),c=Nt.size(u);let t=1===Nt.size(A),n=1===Nt.size(o),r=A.length>0&&A[A.length-1]%4==0,s=o.length>0&&o[o.length-1]%4==0;f.push(t),f.push(n),f.push(r),f.push(s);let a=1;for(let e=1;e<u.length;e++){let t=A[A.length-e];if(t!==o[o.length-e])break;a*=t}a%4==0?(h=!0,d=!0):(t||n||r||s)&&(d=!0)}else d=!0;return f.push(d),{name:e,shaderCache:{hint:t+f.map((e=>e.toString())).join("_"),inputDependencies:["rank","rank"]},getShaderSource:e=>Ws(e,A,o,u,d,l,h,s,n.dataType,r.dataType,i,a),getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:Math.ceil(c/64/4)},programUniforms:[{type:12,data:Math.ceil(Nt.size(u)/4)},...hn(A,o,u)]})}},Vs=(e,t,n,r,s,a)=>{e.compute(_s(t,s??"",e.inputs[0],e.inputs[1],n,r,a))},Hs=e=>{Vs(e,"Add",((e,t)=>`${e}+${t}`))},Us=e=>{Vs(e,"Div",((e,t)=>`${e}/${t}`))},js=e=>{Vs(e,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},Ys=e=>{Vs(e,"Mul",((e,t)=>`${e}*${t}`))},Ks=e=>{let t=In("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;Vs(e,"Pow",{scalar:(e,t)=>`pow_custom(${e},${t})`,vector:(e,t)=>`pow_vector_custom(${e},${t})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${"i32"===t?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Xs=e=>{Vs(e,"Sub",((e,t)=>`${e}-${t}`))},qs=e=>{Vs(e,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},Zs=e=>{Vs(e,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},Js=e=>{Vs(e,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},$s=e=>{Vs(e,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}})),Ul=te((()=>{yl(),Bl(),Gl(),Fl(),ea=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let n=e[0],r=n.dataType,s=n.dims.length;e.forEach(((e,a)=>{if(0!==a){if(e.dataType!==r)throw new Error("input tensors should be one type");if(e.dims.length!==s)throw new Error("input tensors should have the same shape");e.dims.forEach(((e,r)=>{if(r!==t&&e!==n.dims[r])throw new Error("non concat dimensions must match")}))}}))},ta=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,na=(e,t)=>{let n=e.length,r=[];for(let s=0;s<n;++s){let a=t.setByOffset("global_idx",e[s].getByIndices("indices"));1===n?r.push(a):0===s?r.push(`if (inputIndex == ${s}u) { ${a} }`):s===n-1?r.push(`else { ${a} }`):r.push(`else if (inputIndex == ${s}) { ${a} }`)}return r.join("\n")},ra=(e,t,n,r)=>{let s=Nt.size(n),a=new Array(e.length),i=new Array(e.length),A=0,o=[],l=[],u=[{type:12,data:s}];for(let n=0;n<e.length;++n)A+=e[n].dims[t],a[n]=A,l.push(e[n].dims.length),i[n]=In(`input${n}`,r,l[n]),o.push("rank"),u.push({type:12,data:a[n]});for(let t=0;t<e.length;++t)u.push(...hn(e[t].dims));u.push(...hn(n));let c=wn("output",r,n.length),d=c.indicesGet("indices",t),h=Array.from(Array(a.length).keys()).map((e=>`uniforms.sizeInConcatAxis${e}`)).join(",");return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:o},getRunData:()=>({outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:u}),getShaderSource:t=>`\n\n  ${(()=>{t.registerUniform("outputSize","u32");for(let n=0;n<e.length;n++)t.registerUniform(`sizeInConcatAxis${n}`,"u32");return t.declareVariables(...i,c)})()}\n\n  ${ta(a.length,h)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${c.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${d});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${a.length}u>(${h});\n      ${d} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${na(i,c)}\n  }`}},sa=(e,t)=>{let n=e.inputs,r=n[0].dims,s=Nt.normalizeAxis(t.axis,r.length);ea(n,s);let a=r.slice();a[s]=n.reduce(((e,t)=>e+(t.dims.length>s?t.dims[s]:0)),0);let i=n.filter((e=>Nt.size(e.dims)>0));e.compute(ra(i,s,a,n[0].dataType),{inputs:i})},aa=e=>on({axis:e.axis})})),jl=te((()=>{yl(),Bl(),ia=(e,t,n="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${n}(uniforms.clip_min)), ${t}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"Tanh":return"let e2x = exp(-2.0 * abs(value));\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\n        ";case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},Aa=(e,t)=>{"Clip"===e.activation?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):"HardSigmoid"===e.activation?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):"LeakyRelu"===e.activation&&t.push({type:1,data:e.alpha})},oa=(e,t)=>{"Clip"===e.activation?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):"HardSigmoid"===e.activation?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):"LeakyRelu"===e.activation&&t.push({name:"alpha",type:"f32"})},la=e=>{let t=e?.activation||"";if("HardSigmoid"===t){let[n,r]=e?.activation_params||[.2,.5];return{activation:t,alpha:n,beta:r}}if("Clip"===t){let[n,r]=e?.activation_params||[Pt,Qt];return{activation:t,clipMax:r,clipMin:n}}if("LeakyRelu"===t){let[n]=e?.activation_params||[.01];return{activation:t,alpha:n}}return{activation:t}}})),Yl=te((()=>{ua=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},ca=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `})),Kl=te((()=>{da=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`})),Xl=te((()=>{yl(),Bl(),Fl(),jl(),ha=(e,t,n,r,s)=>{let a=r-n;return`\n      ${Array.from({length:n}).map(((n,i)=>`\n      if (${bn(t.shape,i,t.rank)} != 1) {\n        ${t.indicesSet(e,i,bn(s,i+a,r))}\n      } else {\n        ${t.indicesSet(e,i,0)}\n      }`)).join("")}\n`},fa=(e,t,n,r,s=!1,a)=>{let i=e[0].dims,A=e[1].dims,o=i[i.length-2],l=A[A.length-1],u=i[i.length-1],c=fn(l),d=fn(u),h=fn(o),f=Nt.size(n)/c/h,g=e.length>2,p=r?r.slice(0,-2):n.slice(0,-2),m=[Nt.size(p),o,l],b=[{type:12,data:f},{type:12,data:o},{type:12,data:l},{type:12,data:u}];Aa(t,b),b.push(...hn(p,i,A)),g&&b.push(...hn(e[2].dims)),b.push(...hn(m));return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${c};${d};${h};${s}`,inputDependencies:g?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:b}),getShaderSource:r=>{let a=xn("batch_dims",e[0].dataType,p.length),o=In("a",e[0].dataType,i.length,d),l=In("b",e[1].dataType,A.length,c),u=wn("output",e[0].dataType,m.length,c),f=cn(u.type.tensor),b=ia(t,u.type.value,f),C=[o,l],I="";if(g){let t=s?c:1;C.push(In("bias",e[2].dataType,e[2].dims.length,t)),I=""+(s?`value += bias[col / ${t}];`:`value += ${u.type.value}(bias[row + i]);`)}let w=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];oa(t,w);return`\n  ${r.registerUniforms(w).registerInternalVariables(a).declareVariables(...C,u)}\n  ${r.mainStart()}\n    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let col = (global_idx % (uniforms.N / ${c})) * ${c};\n    var index1 = global_idx / (uniforms.N / ${c});\n    let stride1 = uniforms.M / ${h};\n    let row = (index1 % stride1) * ${h};\n    let batch = index1 / stride1;\n\n    ${2===n.length?"":`let batch_indices = ${a.offsetToIndices("batch")};`}\n\n    var a_indices: ${o.type.indices};\n    ${ha("a_indices",o,o.rank-2,a.rank,"batch_indices")}\n    ${o.indicesSet("a_indices",o.rank-2,0)}\n    ${o.indicesSet("a_indices",o.rank-1,0)}\n    let a_offset = ${o.indicesToOffset("a_indices")};\n\n    var b_indices: ${l.type.indices};\n    ${ha("b_indices",l,l.rank-2,a.rank,"batch_indices")}\n    ${l.indicesSet("b_indices",l.rank-2,0)}\n    ${l.indicesSet("b_indices",l.rank-1,0)}\n    let b_offset = ${l.indicesToOffset("b_indices")};\n    var values: array<${u.type.value}, ${h}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${d}) {\n      ${(()=>{let e=`var a_data: ${o.type.value};`;for(let t=0;t<d;t++)e+=`\n              let b_data${t} = b[(b_offset + (k + ${t}) * uniforms.N + col) / ${c}];`;for(let t=0;t<h;t++){e+=`a_data = a[(a_offset + (row + ${t}) * uniforms.K + k) / ${d}];`;for(let n=0;n<d;n++)e+=`\n            values[${t}] = fma(${l.type.value}(a_data${1===d?"":`[${n}]`}), b_data${n}, values[${t}]);\n`}return e})()}\n    }\n    for (var i = 0u; i < ${h}u; i++) {\n      var value = values[i];\n      ${I}\n      ${b}\n      let cur_indices = ${u.type.indices}(batch, row + i, col);\n      let offset = ${u.indicesToOffset("cur_indices")};\n      ${u.setByOffset(`offset / ${c}`,"value")};\n    }\n  }\n  `}}}})),ql=te((()=>{yl(),Bl(),Fl(),jl(),Xl(),Yl(),ga=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,pa=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,ma=(e,t,n="f32",r,s=!1,a=32,i=!1,A=32)=>{let o=t[1]*e[1],l=t[0]*e[0],u=s?o:a,c=s?a:o,d=u/t[0],h=a/t[1];if((!s||4!==d||4!==e[1])&&(s||3!==d&&4!==d)||u%t[0]!==0||a%t[1]!==0||4!==e[0])throw new Error(`If transposeA ${s} is true, innerElementSize ${d} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${d} must be 3 or 4.\n  tileAWidth ${u} must be divisible by workgroupSize[0]${t[0]}. tileInner ${a} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${d}<${n}>, ${u/d}>, ${c}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${l/e[0]}>, ${a}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${d};\nconst tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${i?"0":"i32(globalId.z)"};\n  ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${o};\n\n  let num_tiles = ${i?`${Math.ceil(A/a)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n  var kStart = ${i?`i32(globalId.z) * ${A}`:"0"};\n\n  var acc: array<vec4<${n}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${h};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${ga(s,r)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${3===d?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${pa(s,d)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},ba=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,Ca=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Ia=(e,t,n="f32",r,s=!1,a=32,i=!1,A=32,o=!1)=>{let l=e[1]*t[1],u=e[0]*t[0],c=s?l:a,d=s?a:l;if(d%t[1]!==0||c%t[0]!==0||a%t[1]!==0)throw new Error(`tileAHight ${d} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${a} must be divisible by workgroupSize[1]${t[1]}`);let h=d/t[1],f=c/t[0],g=a/t[1],p=o?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${l};\n    let globalColStart = i32(workgroupId.x) * ${u};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${d}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n          ${ba(s,r)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${a}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${r?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${n}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${s?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${l};\n\nlet tileRowA = i32(localId.y) * ${h};\nlet tileColA = i32(localId.x) * ${f};\nlet tileRowB = i32(localId.y) * ${g};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${ba(s,r)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${r?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${n}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Ca(s)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${n}, ${c}>, ${d}>;\n  var<workgroup> mm_Bsub : array<array<${n}, ${u}>, ${a}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${i?"0":"i32(globalId.z)"};\n    ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\n    let num_tiles = ${i?`${Math.ceil(A/a)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n    var kStart = ${i?`i32(globalId.z) * ${A}`:"0"};\n\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\n    ${p}\n  }\n`},wa=(e,t,n,r,s=!1)=>{let[a,i,A,o]=r,l=cn(r[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${ua(e,l)} {\n      var value = ${ua(e,l)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        var aIndices: ${i.type.indices};\n        ${ha("aIndices",i,i.rank-2,a.rank,"batchIndices")}\n        ${i.indicesSet("aIndices",i.rank-2,"u32(row)")}\n        ${i.indicesSet("aIndices",i.rank-1,"u32(colIn)")}\n        value = ${i.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${ua(e,l)} {\n      var value = ${ua(e,l)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        var bIndices: ${A.type.indices};\n        ${ha("bIndices",A,A.rank-2,a.rank,"batchIndices")}\n        ${A.indicesSet("bIndices",A.rank-2,"u32(row)")}\n        ${A.indicesSet("bIndices",A.rank-1,"u32(colIn)")}\n        value = ${A.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${ua(e,l)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${s?"bias[colIn]":`${ua(e,l)}(bias[row])`};`:""}\n        ${n}\n        ${o.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},ka=(e,t,n,r,s=!1,a)=>{let i=e[0].dims,A=e[1].dims,o=i.slice(0,-2),l=A.slice(0,-2),u=r?r.slice(0,-2):n.slice(0,-2),c=Nt.size(u),d=i[i.length-2],h=i[i.length-1],f=A[A.length-1],g=h%4==0&&f%4==0,p=d<=8?[4,1,1]:[4,4,1],m=[8,8,1],b=[Math.ceil(f/m[0]/p[0]),Math.ceil(d/m[1]/p[1]),Math.ceil(c/m[2]/p[2])],C=g?4:1,I=[...o,d,h/C],w=I.length,k=[...l,h,f/C],x=k.length,y=[c,d,f/C],v=[{type:6,data:d},{type:6,data:f},{type:6,data:h}];Aa(t,v),v.push(...hn(u,I,k));let E=["rank","rank"],B=e.length>2;B&&(v.push(...hn(e[2].dims)),E.push("rank")),v.push(...hn(y));return{name:"MatMul",shaderCache:{hint:`${p};${t.activation};${g};${s}`,inputDependencies:E},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:e[0].dataType}],dispatchGroup:{x:b[0],y:b[1],z:b[2]},programUniforms:v}),getShaderSource:n=>{let r=u.length,a=xn("batchDims",e[0].dataType,r,1),i=cn(e[0].dataType),A=In("a",e[0].dataType,w,C),o=In("b",e[1].dataType,x,C),l=wn("result",e[0].dataType,y.length,C),c=[A,o];if(B){let t=s?C:1;c.push(In("bias",e[2].dataType,e[2].dims.length,t))}let d=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];oa(t,d);let h=cn(l.type.tensor),f=ia(t,l.type.value,h),b=wa(C,B,f,[a,A,o,l],s);return`\n  ${n.registerUniforms(d).registerInternalVariables(a).declareVariables(...c,l)}\n  ${b}\n  ${g?ma(p,m,i,a):Ia(p,m,i,a)}\n                   `}}}})),Zl=te((()=>{yl(),El(),Fl(),jl(),Yl(),Kl(),ql(),xa=(e,t,n,r,s=!1,a,i=4,A=4,o=4,l="f32")=>{let u=e=>{switch(e){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}},c=e?"\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ":"\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ",d=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",h=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",f=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",g=e?"row":"col",p=e?"col":"row",m=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${g} / outWidth;\n    let outCol = ${g} % outWidth;\n\n    let WRow = ${p} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${p} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${p} % inChannels;\n    var resData = ${ua(i,l)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${h} && xCol >= 0 && xCol < ${f}) {\n      ${c}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${l}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(i)}\n    }\n    return resData;`,b=e?t&&r?`\n    let col = colIn * ${i};\n    ${m}`:`\n    let col = colIn * ${i};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${m}\n    }\n    return ${ua(i,l)}(0.0);`:r&&n?`\n    let col = colIn * ${i};\n    ${m}`:`\n    let col = colIn * ${i};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${m}\n    }\n    return ${ua(i,l)}(0.0);`,C=e?r&&n?u(A):`\n    let col = colIn * ${A};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${u(A)}\n    }\n    return ${ua(A,l)}(0.0);`:`\n    let col = colIn * ${A};\n    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {\n      ${u(A)}\n    }\n    return ${ua(A,l)}(0.0);`,I=ua(o,l),w=ua(e?i:A,l),k=ua(e?A:i,l),x=ia(a,I,l);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${w} {\n      ${e?b:C}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${k} {\n      ${e?C:b}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${I}) {\n      let col = colIn * ${o};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${d}\n      ${ca(s)}\n      ${x}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},ya=(e,t,n,r,s,a,i,A,o)=>{let l="NHWC"===t.format,u=l?e[0].dims[3]:e[0].dims[1],c=n[0],d=l?n[2]:n[3],h=l?n[1]:n[2],f=l?n[3]:n[1],g=l&&(u%4==0||u%3==0)&&f%4==0,p=l?f:d*h,m=l?d*h:f,b=[8,8,1],C=r<=8?[4,1,1]:[4,4,1],I=[Math.ceil(p/b[0]/C[0]),Math.ceil(m/b[1]/C[1]),Math.ceil(c/b[2]/C[2])];Dt("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${I}`));let w=g?l&&u%4!=0?3:4:1,k=b[1]*C[1],x=b[0]*C[0],y=Math.max(b[0]*w,b[1]),v=r%k===0,E=s%x===0,B=a%y===0,M=g?[w,4,4]:[1,1,1],D=[{type:6,data:r},{type:6,data:s},{type:6,data:a},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];Aa(t,D),D.push(...hn(e[0].dims,e[1].dims));let T=["rank","rank"];i&&(D.push(...hn(e[2].dims)),T.push("rank")),D.push(...hn(n));return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${w};${g};${v};${E};${B};${k};${x};${y}`,inputDependencies:T},getRunData:()=>({outputs:[{dims:o?o(n):n,dataType:e[0].dataType}],dispatchGroup:{x:I[0],y:I[1],z:I[2]},programUniforms:D}),getShaderSource:r=>{let s=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];oa(t,s);let a=g?4:1,o=cn(e[0].dataType),u=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${g?`vec4<${o}>`:o}) {\n        result[flatIndex] = ${g?`vec4<${o}>`:o}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${g?`vec4<${o}>`:o}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${g?"/ 4":""}, value);\n      }`,c=[In("x",e[0].dataType,e[0].dims.length,3===w?1:w),In("w",e[1].dataType,e[1].dims.length,a)],d=wn("result",e[0].dataType,n.length,a);if(i){let t=In("bias",e[2].dataType,e[2].dims.length,a);c.push(t),u+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${g?`vec4<${o}>`:o} {\n          return bias[coords.${l?"w":"y"}${g?"/ 4":""}];\n        }`}return`\n        ${da("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${r.registerUniforms(s).declareVariables(...c,d)}\n        ${u}\n        ${xa(l,v,E,B,i,t,M[0],M[1],M[2],o)}\n        ${g?ma(C,b,o,void 0,!l,y):Ia(C,b,o,void 0,!l,y,!1,void 0,A)}`}}}})),Jl=te((()=>{yl(),El(),Bl(),Fl(),jl(),Yl(),va=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t},Ea=e=>"number"==typeof e?[e,e,e]:e,Ba=(e,t)=>t<=1?e:e+(e-1)*(t-1),Ma=(e,t,n,r=1)=>{let s=Ba(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)},Da=(e,t,n,r,s)=>{null==s&&(s=Ma(e,t[0],r[0]));let a=[0,0,0,n];for(let n=0;n<3;n++)e[n]+2*s>=t[n]&&(a[n]=Math.trunc((e[n]-t[n]+2*s)/r[n]+1));return a},Ta=(e,t,n,r,s,a,i,A,o,l)=>{let u,c,d,h;if("VALID"===e&&(e=0),"number"==typeof e){u={top:e,bottom:e,left:e,right:e,front:e,back:e};let f=Da([t,n,r,1],[A,o,l],1,[s,a,i],e);c=f[0],d=f[1],h=f[2]}else if(Array.isArray(e)){if(!e.every(((e,t,n)=>e===n[0])))throw Error(`Unsupported padding parameter: ${e}`);u={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let f=Da([t,n,r,1],[A,o,l],1,[s,a,i],e[0]);c=f[0],d=f[1],h=f[2]}else{if("SAME_UPPER"!==e)throw Error(`Unknown padding parameter: ${e}`);{c=Math.ceil(t/s),d=Math.ceil(n/a),h=Math.ceil(r/i);let e=(c-1)*s+A-t,f=(d-1)*a+o-n,g=(h-1)*i+l-r,p=Math.floor(e/2),m=e-p,b=Math.floor(f/2),C=f-b,I=Math.floor(g/2);u={top:b,bottom:C,left:I,right:g-I,front:p,back:m}}}return{padInfo:u,outDepth:c,outHeight:d,outWidth:h}},Sa=(e,t,n,r,s,a=!1,i="channelsLast")=>{let A,o,l,u,c;if("channelsLast"===i)[A,o,l,u,c]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[A,c,o,l,u]=e}let[d,,h,f,g]=t,[p,m,b]=Ea(n),[C,I,w]=Ea(r),k=Ba(h,C),x=Ba(f,I),y=Ba(g,w),{padInfo:v,outDepth:E,outHeight:B,outWidth:M}=Ta(s,o,l,u,p,m,b,k,x,y),D=a?d*c:d,T=[0,0,0,0,0];return"channelsFirst"===i?T=[A,D,E,B,M]:"channelsLast"===i&&(T=[A,E,B,M,D]),{batchSize:A,dataFormat:i,inDepth:o,inHeight:l,inWidth:u,inChannels:c,outDepth:E,outHeight:B,outWidth:M,outChannels:D,padInfo:v,strideDepth:p,strideHeight:m,strideWidth:b,filterDepth:h,filterHeight:f,filterWidth:g,effectiveFilterDepth:k,effectiveFilterHeight:x,effectiveFilterWidth:y,dilationDepth:C,dilationHeight:I,dilationWidth:w,inShape:e,outShape:T,filterShape:t}},Na=(e,t,n,r,s,a)=>{let i="channelsLast"===a;i?e[0].dims[3]:e[0].dims[1];let A={x:n.map(((e,t)=>t))},o=[Math.ceil(va(A.x.map((e=>n[e])))/64),1,1];Dt("verbose",(()=>`[conv3d_naive_webgpu] dispatch = ${o}`));let l=[{type:12,data:Nt.size(n)},{type:12,data:r},{type:12,data:s},{type:12,data:t.strides},{type:12,data:t.dilations}];Aa(t,l),l.push(...hn(e[0].dims,e[1].dims));let u=["rank","rank"],c=3===e.length;c&&(l.push(...hn(e[2].dims)),u.push("rank")),l.push(...hn(n));return{name:"Conv3DNaive",shaderCache:{hint:`${t.cacheKey};${i};1;${c}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:o[0],y:o[1],z:o[2]},programUniforms:l}),getShaderSource:a=>{let A=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:r.length},{name:"pads",type:"u32",length:s.length},{name:"strides",type:"u32",length:t.strides.length},{name:"dilations",type:"u32",length:t.dilations.length}];oa(t,A);let o=cn(e[0].dataType),l=In("x",e[0].dataType,e[0].dims.length,1),u=In("W",e[1].dataType,e[1].dims.length,1),d=[l,u],h=wn("result",e[0].dataType,n.length,1),f="";if(c){let t=In("bias",e[2].dataType,e[2].dims.length,1);d.push(t),f+=`\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${o} {\n          return bias[${bn("coords",i?4:1,5)}];\n        }`}let g=ua(1,o),p=ia(t,g,o);return`\n            ${f}\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${l.getByIndices("aIndices")};\n            }\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${u.getByIndices("aIndices")};\n            }\n          ${a.registerUniforms(A).declareVariables(...d,h)}\n          ${a.mainStart()}\n          ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n              let coords = ${h.offsetToIndices("global_idx")};\n              let batch = ${bn("coords",0,l.rank)};\n              let d2 = ${bn("coords",i?l.rank-1:1,l.rank)};\n              let xFRCCorner = vec3<u32>(${bn("coords",i?1:2,l.rank)},\n              ${bn("coords",i?2:3,l.rank)},\n              ${bn("coords",i?3:4,l.rank)}) * uniforms.strides - uniforms.pads;\n              let xFCorner = xFRCCorner.x;\n              let xRCorner = xFRCCorner.y;\n              let xCCorner = xFRCCorner.z;\n              let xShapeY = ${bn("uniforms.x_shape",i?1:2,l.rank)};\n              let xShapeZ = ${bn("uniforms.x_shape",i?2:3,l.rank)};\n              let xShapeW = ${bn("uniforms.x_shape",i?3:4,l.rank)};\n              let xShapeU = ${bn("uniforms.x_shape",i?4:1,l.rank)};\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\n              let inputDepthVec4Remainder = xShapeU % 4;\n\n              var value = 0.0;\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\n                let xF = xFCorner + wF * uniforms.dilations[0];\n                if (xF < 0 || xF >= xShapeY) {\n                  continue;\n                }\n\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\n                  let xR = xRCorner + wR * uniforms.dilations[1];\n                  if (xR < 0 || xR >= xShapeZ) {\n                    continue;\n                  }\n\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\n                    let xC = xCCorner + wC * uniforms.dilations[2];\n                    if (xC < 0 || xC >= xShapeW) {\n                      continue;\n                    }\n\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\n                      ${i?"let xValues = vec4<f32>(\n                               getX(batch, xF, xR, xC, d1),\n                               getX(batch, xF, xR, xC, d1 + 1),\n                               getX(batch, xF, xR, xC, d1 + 2),\n                               getX(batch, xF, xR, xC, d1 + 3));\n                            ":"let xValues = vec4<f32>(\n                               getX(batch, d1, xF, xR, xC),\n                               getX(batch, d1 + 1, xF, xR, xC),\n                               getX(batch, d1 + 2, xF, xR, xC),\n                               getX(batch, d1 + 3, xF, xR, xC));\n                            "}\n                            let wValues = vec4<f32>(\n                              getW(d2, d1, wF, wR, wC),\n                              getW(d2, d1 + 1, wF, wR, wC),\n                              getW(d2, d1 + 2, wF, wR, wC),\n                              getW(d2, d1 + 3, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                    if (inputDepthVec4Remainder == 1) {\n                        ${i?"value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);":"value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);"}\n                    } else if (inputDepthVec4Remainder == 2) {\n                      ${i?"let xValues = vec2<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\n                      ":"let xValues = vec2<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\n                    "}\n                    let wValues = vec2<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    } else if (inputDepthVec4Remainder == 3) {\n                      ${i?"let xValues = vec3<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\n                      ":"let xValues = vec3<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\n                    "}\n                    let wValues = vec3<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                  }\n                }\n              }\n              ${c?"value = value + getBiasByOutputCoords(coords)":""};\n              ${p}\n              result[global_idx] = f32(value);\n          }`}}}})),$l=te((()=>{yl(),Bl(),Fl(),jl(),Ga=(e,t,n,r)=>{let s=e.length>2,a=s?"value += b[output_channel];":"",i=e[0].dims,A=e[1].dims,o="NHWC"===t.format,l=o?n[3]:n[1],u=l/t.group,c=o&&u>=4?fn(l):1,d=Nt.size(n)/c,h=[{type:12,data:d},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:u}];Aa(t,h),h.push(...hn(i,[A[0],A[1],A[2],A[3]/c]));let f=s?["rank","rank","rank"]:["rank","rank"];h.push(...hn([n[0],n[1],n[2],n[3]/c]));return{name:"GroupedConv",shaderCache:{hint:`${t.cacheKey}_${c}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:h}),getShaderSource:r=>{let l=wn("output",e[0].dataType,n.length,c),u=cn(l.type.tensor),d=ia(t,l.type.value,u),h=In("x",e[0].dataType,i.length),f=In("w",e[1].dataType,A.length,c),g=[h,f];s&&g.push(In("b",e[2].dataType,e[2].dims,c));let p=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];oa(t,p);let m=o?`\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\n            let input_channel = in_channel_offset + wInChannel;\n            let xVal = ${h.get("batch","xHeight","xWidth","input_channel")};\n            let wVal = ${f.get("wHeight","wWidth","wInChannel","output_channel")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `:`\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n        let input_channel = in_channel_offset + wInChannel;\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\n              continue;\n            }\n\n            let xVal = ${h.get("batch","input_channel","xHeight","xWidth")};\n            let wVal = ${f.get("output_channel","wInChannel","wHeight","wWidth")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `;return`\n  ${r.registerUniforms(p).declareVariables(...g,l)}\n\n  ${r.mainStart()}\n    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let outputIndices = ${l.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${o?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${o?1:2}], outputIndices[${o?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel * ${c} / uniforms.output_channels_per_group;\n    var in_channel_offset = group_id * uniforms.w_shape[${o?2:1}];\n\n    var value: ${l.type.value} = ${l.type.value}(0);\n    ${m}\n    ${a}\n    ${d}\n    ${l.setByOffset("global_idx","value")}\n  }`}}},Fa=(e,t,n,r)=>{let s=e.length>2,a=fn(n[3]),i=fn(n[2]),A=Nt.size(n)/a/i,o=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/a],l=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/a],u=[n[0],n[1],n[2],n[3]/a],c=[{type:12,data:A},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];Aa(t,c),c.push(...hn(o,l,u));let d=(i-1)*t.strides[1]+l[1];return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${a};${i};${d};${l[0]};${l[1]}`,inputDependencies:s?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(A/64)},programUniforms:c}),getShaderSource:n=>{let r=wn("output",e[0].dataType,u.length,a),A=cn(r.type.tensor),c=ia(t,r.type.value,A),h=In("x",e[0].dataType,o.length,a),f=In("w",e[1].dataType,l.length,a),g=[h,f];s&&g.push(In("b",e[2].dataType,e[2].dims,a));let p=s?"value += b[output_channel];":"",m=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return oa(t,m),`\n  ${n.registerUniforms(m).declareVariables(...g,r)}\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${i}u;\n    let col = (index1 % width1) * ${i}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${h.type.value}, ${d}>;\n    var values: array<${r.type.value}, ${i}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w's height/width.\n    for (var w_height: u32 = 0u; w_height < ${l[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${d}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${h.get("batch","u32(x_height)","u32(x_width)","input_channel")};\n          } else {\n            x_vals[i] = ${h.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${l[1]}; w_width++) {\n          let w_val = ${f.get("w_height","w_width","0","output_channel")};\n          for (var i = 0u; i < ${i}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${i}u; i++) {\n      var value = values[i];\n      ${p}\n      ${c}\n      ${r.set("batch","row","col + i","output_channel","value")};\n    }\n  }`}}}})),eu=te((()=>{Bl(),Zl(),Jl(),ql(),$l(),jl(),Xl(),Pl(),Pa=(e,t,n,r,s,a)=>{let i=e[0],A=e.slice(a?1:2,a?3:4),o=A.length,l=t[0],u=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),c=A.map(((e,t)=>e+r[t]+r[t+o])).map(((e,t)=>Math.floor((e-u[t]+s[t])/s[t])));return c.splice(0,0,i),c.splice(a?3:1,0,l),c},Qa=[2,3,1,0],za=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Oa=(e,t)=>{let n=e.kernelShape.slice();n.length<t[1].dims.length-2&&n.push(...Array(t[1].dims.length-2-n.length).fill(0));for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);let r=e.pads.slice();Gt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,"NHWC"===e.format,e.autoPad);let s=Object.assign({},e);return Object.assign(s,{kernelShape:n,pads:r}),s},Ra=e=>{let t=la(e),n=e.format;return{autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],format:n,dilations:e.dilations,group:e.group,kernelShape:e.kernel_shape,pads:e.pads,strides:e.strides,wIsConst:e.w_is_const(),...t,cacheKey:`${e.format};${t.activation};`}},La=(e,t,n,r)=>{let s="NHWC"===n.format,a=Pa(t[0].dims,t[1].dims,n.dilations,n.pads,n.strides,s);if(1!==n.group){let i=[t[0]];if(s){let r=e.kernelCustomData.wT??e.compute(Nn(t[1],Qa),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r),i.push(r)}else i.push(t[1]);return 3===t.length&&i.push(t[2]),void(!e.adapterInfo.isArchitecture("ampere")&&s&&t[1].dims[0]===n.group&&1===t[1].dims[1]&&1===n.dilations[0]&&1===n.dilations[1]?e.compute(Fa(i,n,a,r),{inputs:i}):e.compute(Ga(i,n,a,r),{inputs:i}))}let i=3===t.length,A=t[0].dims[s?1:2],o=t[0].dims[s?2:3],l=t[0].dims[s?3:1],u=t[1].dims[2],c=t[1].dims[3],d=a[s?1:2],h=a[s?2:3],f=a[s?3:1],g=s&&u===A&&c===o&&0===n.pads[0]&&0===n.pads[1];if(g||1===u&&1===c&&1===n.dilations[0]&&1===n.dilations[1]&&1===n.strides[0]&&1===n.strides[1]&&0===n.pads[0]&&0===n.pads[1]){let u,c,p,m=a[0],b=[];if(s){let r=e.kernelCustomData.wT??e.compute(Nn(t[1],Qa),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r),g){let e=A*o*l;u=t[0].reshape([1,m,e]),c=r.reshape([1,e,f]),p=[1,m,f]}else u=t[0].reshape([m,A*o,l]),c=r.reshape([1,l,f]),p=[m,d*h,f];b.push(u),b.push(c)}else u=t[0].reshape([m,l,A*o]),c=t[1].reshape([1,f,l]),p=[m,f,d*h],b.push(c),b.push(u);i&&b.push(t[2]);let C=p[2],I=b[0].dims[b[0].dims.length-1];return void(C<8&&I<8?e.compute(fa(b,n,a,p,s,r),{inputs:b}):e.compute(ka(b,n,a,p,s,r),{inputs:b}))}let p=e.kernelCustomData.wT??e.compute(Nn(t[1],Qa),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=p);let m=[t[0],p];i&&m.push(t[2]);let b=s?d*h:f,C=s?f:d*h,I=u*c*l;e.compute(ya(m,n,a,b,C,I,i,!0,r),{inputs:m})},Wa=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);let s=[0,t.pads[0],0,t.pads[1]],a=[1].concat(t.strides),i=[1].concat(t.dilations),A=[1].concat(t.kernelShape),o=Oa({...t,pads:s,strides:a,dilations:i,kernelShape:A},r);La(e,r,o,(e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]]))},_a=(e,t,n)=>{let r="NHWC"===n.format?"channelsLast":"channelsFirst",s=Oa(n,t),a="NOTSET"===n.autoPad?n.pads:n.autoPad,i=Sa(t[0].dims,t[1].dims,n.strides,n.dilations,a,!1,r);e.compute(Na(t,s,i.outShape,[i.filterDepth,i.filterHeight,i.filterWidth],[i.padInfo.front,i.padInfo.top,i.padInfo.left],r))},Va=(e,t)=>{if(za(e.inputs,t),3===e.inputs[0].dims.length)Wa(e,t);else if(5===e.inputs[0].dims.length)_a(e,e.inputs,t);else{let n=Oa(t,e.inputs);La(e,e.inputs,n)}}})),tu=te((()=>{yl(),El(),Bl(),Fl(),Ha=(e,t,n)=>{let r=e.length>2,s=t.outputShape,a="NHWC"===t.format,i=t.group,A=e[1].dims,o=A[2]/i,l=A[3],u=a?fn(o):1,c=a&&1===l&&o>=4,d=c?4*Math.floor(o/4):Math.floor(o/u)*u,h=o-d,f=a?fn(l):1,g=a?1===l?u:f:1,p=Nt.size(s)/f,m=[Math.ceil(p/64),1,1];Dt("verbose",(()=>`[conv2d_backprop_webgpu] dispatch = ${m}`));let b=["rank","rank"],C=[t.strides[0],t.strides[1]],I=[t.kernelShape[a?1:2],t.kernelShape[a?2:3]],w=[t.dilations[0],t.dilations[1]],k=[I[0]+(t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)),I[1]+(t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1))],x=[k[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),k[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],y=[{type:12,data:p},{type:12,data:C},{type:12,data:I},{type:12,data:w},{type:12,data:k},{type:6,data:x},{type:12,data:d},{type:12,data:o},{type:12,data:l},...hn(e[0].dims,e[1].dims)];r&&(y.push(...hn(e[2].dims)),b.push("rank")),y.push(...hn(s));return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};${u}${g}${f}${c}${h}`,inputDependencies:b},getRunData:()=>({dispatchGroup:{x:m[0],y:m[1],z:m[2]},outputs:[{dims:n?n(s):s,dataType:e[0].dataType}],programUniforms:y}),getShaderSource:t=>{let n=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:C.length},{name:"filter_dims",type:"u32",length:I.length},{name:"dilations",type:"u32",length:I.length},{name:"effective_filter_dims",type:"u32",length:k.length},{name:"pads",type:"i32",length:x.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],i=cn(e[0].dataType),A=a?1:2,o=a?2:3,l=a?3:1,d=In("W",e[1].dataType,e[1].dims.length,g),p=In("Dy",e[0].dataType,e[0].dims.length,u),m=[p,d];r&&m.push(In("bias",e[2].dataType,[s[l]].length,f));let b=wn("result",e[0].dataType,s.length,f),w=`\n            let outputIndices = ${b.offsetToIndices(`global_idx * ${f}`)};\n            let batch = ${b.indicesGet("outputIndices",0)};\n            let d1 = ${b.indicesGet("outputIndices",l)};\n            let r = ${b.indicesGet("outputIndices",A)};\n            let c = ${b.indicesGet("outputIndices",o)};\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n            let dyRCorner = dyCorner.x;\n            let dyCCorner = dyCorner.y;\n            let groupId = d1 / uniforms.output_channels_per_group;\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n            // ? = to be determined. : = across all values in that axis.\n            var dotProd = ${b.type.value}(0.0);\n            var wR: u32 = 0;\n            if (uniforms.dilations.x == 1) {\n              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0\n              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);\n            }\n            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n              if (wR % uniforms.dilations.x != 0) {\n                continue;\n              }\n              let dyR = (${i}(dyRCorner) + ${i}(wR)) / ${i}(uniforms.strides[0]);\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n              if (dyR < 0.0 || dyR >= ${i}(uniforms.Dy_shape[${A}]) || fract(dyR) > 0.0 ||\n                  wRPerm < 0) {\n                continue;\n              }\n              let idyR: u32 = u32(dyR);\n              var wC: u32 = 0;\n              if (uniforms.dilations.y == 1) {\n                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0\n                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);\n              }\n              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n                if (wC % uniforms.dilations.y != 0) {\n                  continue;\n                }\n                let dyC = (${i}(dyCCorner) + ${i}(wC)) / ${i}(uniforms.strides.y);\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n                if (dyC < 0.0 || dyC >= ${i}(uniforms.Dy_shape[${o}]) ||\n                    fract(dyC) > 0.0 || wCPerm < 0) {\n                  continue;\n                }\n                let idyC: u32 = u32(dyC);\n                var inputChannel = groupId * uniforms.input_channels_per_group;\n                ${c?`\n                var x_offset = ${p.indicesToOffset(`${p.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${u};\n                var w_offset = ${d.indicesToOffset(`${d.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${g};\n                  `:""}\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${c?4:u}) {\n                  ${(()=>{let e="";if(c)4===u?e+=`\n        let xValue = ${p.getByOffset("x_offset")};\n        let wValue = ${d.getByOffset("w_offset")};\n        dotProd = dotProd + dot(xValue, wValue);\n        x_offset += 1u;\n        w_offset += 1u;`:2===u?e+=`\n          dotProd = dotProd + dot(vec4<${i}>(${p.getByOffset("x_offset")}, ${p.getByOffset("x_offset + 1u")}), vec4<${i}>(${d.getByOffset("w_offset")}, ${d.getByOffset("w_offset + 1u")}));\n          x_offset += 2u;\n          w_offset += 2u;`:1===u&&(e+=`\n          dotProd = dotProd + dot(vec4<${i}>(${p.getByOffset("x_offset")}, ${p.getByOffset("x_offset + 1u")}, ${p.getByOffset("x_offset + 2u")}, ${p.getByOffset("x_offset + 3u")}), vec4<${i}>(${d.getByOffset("w_offset")}, ${d.getByOffset("w_offset + 1u")}, ${d.getByOffset("w_offset + 2u")}, ${d.getByOffset("w_offset + 3u")}));\n          x_offset += 4u;\n          w_offset += 4u;`);else if(e+=`\n                  let xValue = ${a?p.getByOffset(`${p.indicesToOffset(`${p.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${u}`):p.get("batch","inputChannel","idyR","idyC")};\n        `,1===u)e+=`\n          let w_offset = ${d.indicesToOffset(`${d.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\n          let wValue = ${d.getByOffset(`w_offset / ${g}`)};\n          dotProd = dotProd + xValue * wValue;`;else for(let t=0;t<u;t++)e+=`\n            let wValue${t} = ${d.getByOffset(`${d.indicesToOffset(`${d.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${t}, wOutChannel)`)} / ${g}`)};\n            dotProd = dotProd + xValue[${t}] * wValue${t};`;return e})()}\n                  inputChannel = inputChannel + ${c?4:u};\n                }\n                ${(()=>{if(0===h)return"";if(!c)throw new Error(`packInputAs4 ${c} is not true.`);let e="";if(1===u){e+="dotProd = dotProd";for(let t=0;t<h;t++)e+=`\n            + ${p.getByOffset(`x_offset + ${t}`)} * ${d.getByOffset(`w_offset + ${t}`)}`;e+=";"}else if(2===u){if(2!==h)throw new Error(`Invalid inputChannelsRemainder ${h}.`);e+=`\n          let xValue = ${p.getByOffset("x_offset")};\n          let wValue = ${d.getByOffset("w_offset")};\n          dotProd = dotProd + dot(xValue, wValue);`}return e})()}\n                wC = wC + uniforms.strides.y - 1;\n              }\n              wR = wR + uniforms.strides[0] - 1;\n            }\n            let value = dotProd${r?` + bias[d1 / ${f}]`:""};\n            ${b.setByOffset("global_idx","value")};\n          `;return`\n    ${t.registerUniforms(n).declareVariables(...m,b)}\n      ${t.mainStart()}\n      ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};\n    ${w}}`}}}})),nu=te((()=>{tu(),jl(),Pl(),Ua=(e,t,n,r,s,a)=>(e-1)*t+n+(r-1)*s+1-a,ja=(e,t,n,r,s)=>{let a=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=a,n[s]=e-a):"SAME_LOWER"===t&&(n[r]=e-a,n[s]=a)},Ya=(e,t,n,r,s,a,i,A,o,l)=>{let u=e.length-2,c=0===l.length;o.length<u&&o.push(...Array(u-o.length).fill(0));let d=e[0],h=t[A?3:1]*s;for(let s=0,d=e.length-u-(A?1:0);s<u;++s,++d){let A=e[d],h=c?A*i[s]:l[s],f=Ua(A,i[s],a[s],t[d],n[s],h);ja(f,r,a,s,s+u),c&&l.push(i[s]*(A-1)+o[s]+(t[d]-1)*n[s]+1-a[s]-a[s+u])}l.splice(0,0,d),l.splice(A?3:1,0,h)},Ka=(e,t)=>{let n=e.kernelShape.slice();if(0===e.kernelShape.length||0===e.kernelShape.reduce(((e,t)=>e*t),1)){n.length=0;for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e])}let r="NHWC"===e.format;n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);let s=e.pads.slice(),a=e.outputShape.slice(),i=e.outputPadding.slice(),A=t[0].dims,o=e.dilations.slice();if(0===o.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;o=new Array(e).fill(1)}let l=e.strides.slice();if(0===l.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;l=new Array(e).fill(1)}Ya(A,n,o,e.autoPad,e.group,s,l,r,i,a);let u=Object.assign({},e);return Object.assign(u,{kernelShape:n,pads:s,outputPadding:i,outputShape:a,dilations:o,strides:l}),u},Xa=e=>{let t=la(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],s=e.dilations,a=e.group,i=e.kernelShape,A=e.pads,o=e.strides,l=e.wIsConst();return{autoPad:r,format:n,dilations:s,group:a,kernelShape:i,outputPadding:e.outputPadding,outputShape:e.outputShape,pads:A,strides:o,wIsConst:l,...t,cacheKey:`${e.format};${t.activation};`}},qa=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");let r=e[0].dims.length-2;if(t.dilations.reduce(((e,t)=>e+t),0)>0&&t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.reduce(((e,t)=>e+t),0)>0&&t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.reduce(((e,t)=>e+t),0)>0&&t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r&&0!==t.outputPadding.length)throw new Error(`output_padding should be ${r}D`);if(t.kernelShape.reduce(((e,t)=>e+t),0)>0&&0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Za=(e,t,n,r)=>{let s=e.kernelCustomData.wT??e.compute(Nn(t[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=s);let a=[t[0],s];3===t.length&&a.push(t[2]),e.compute(Ha(a,n,r),{inputs:a})},Ja=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);let s=t.kernelShape;(0===s.length||0===s[0])&&(s=[e.inputs[1].dims[2]]);let a=t.dilations;(0===a.length||0===a[0])&&(a=[1]);let i=t.strides;(0===i.length||0===i[0])&&(i=[1]);let A=t.pads;0===A.length&&(A=[0,0]),A=[0,A[0],0,A[1]],i=[1].concat(i),a=[1].concat(a),s=[1].concat(s);let o=t.outputPadding;o=[0].concat(o);let l=Ka({...t,pads:A,strides:i,dilations:a,kernelShape:s,outputPadding:o},r);Za(e,r,l,(e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]]))},$a=(e,t)=>{if(qa(e.inputs,t),3===e.inputs[0].dims.length)Ja(e,t);else{let n=Ka(t,e.inputs);Za(e,e.inputs,n)}}})),ru=te((()=>{yl(),Bl(),Gl(),Fl(),ei=(e,t,n,r)=>{let s=Nt.size(t),a=t.length,i=In("input",e,a),A=wn("output",e,a),o=6===n.dataType?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),l=Nt.normalizeAxis(o,a);return{name:"CumSum",shaderCache:{hint:r.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},{type:12,data:l},...hn(t,t)]}),getShaderSource:e=>{let t=` i32(${i.indicesGet("inputIndices","uniforms.axis")}) `,n=bn("uniforms.input_shape","uniforms.axis",a),s=r.reverse?t+(r.exclusive?" + 1":""):"0",o=r.reverse?n:t+(r.exclusive?"":" + 1");return`\n                ${e.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(i,A)}\n                ${e.mainStart()}\n                  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${A.offsetToIndices("global_idx")};\n                  var sum = ${A.type.value}(0);\n                  let first : i32 = ${s};\n                  let last : i32 = ${o};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${i.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${i.getByIndices("inputIndices")};\n                  }\n                  ${A.setByOffset("global_idx","sum")};\n                }`}}},ti=(e,t)=>{let n=e.inputs[0].dims,r=e.inputs[0].dataType,s=e.inputs[1];e.compute(ei(r,n,s,t),{inputs:[0]})},ni=e=>{let t=1===e.exclusive,n=1===e.reverse;return on({exclusive:t,reverse:n})}})),su=te((()=>{yl(),Bl(),Gl(),Fl(),ri=e=>{if(!e||1!==e.length)throw new Error("DepthToSpace requires 1 input.");if(4!==e[0].dims.length)throw new Error("DepthToSpace requires 4D input.")},si=(e,t,n,r)=>{let s=[];s.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`);for(let r=0;r<t;++r)s.push(n.indicesSet("a",e[r],`i[${r}]`));return s.push("return a;}"),s.join("\n")},ai=(e,t)=>{let n,r,s,a,i,A,o="NHWC"===t.format,l=t.blocksize,u="DCR"===t.mode;o?([n,r,s,a]=e.dims,i=u?[n,r,s,l,l,a/l**2]:[n,r,s,a/l**2,l,l],A=u?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,r,s,a]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],i=u?[n,l,l,a/l**2,r,s]:[n,a/l**2,l,l,r,s],A=u?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let c=e.reshape(i),d=c.dims.length,h=e.dataType,f=In("a",h,d),g=wn("output",h,d);return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:e=>{let t=o?[n,r*l,s*l,a/l**2]:[n,a/l**2,r*l,s*l],i=Nt.size(t),u=c.dims,d=Nt.sortBasedOnPerm(u,A);return{outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...hn(u,d)]}},getShaderSource:e=>`\n  ${e.registerUniform("output_size","u32").declareVariables(f,g)}\n\n  ${si(A,d,f,g)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${g.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${g.setByOffset("global_idx",f.getByIndices("aIndices"))}\n  }`}},ii=(e,t)=>{ri(e.inputs),e.compute(ai(e.inputs[0],t))},Ai=e=>on({blocksize:e.blocksize,mode:e.mode,format:e.format})})),au=te((()=>{yl(),Bl(),Gl(),Fl(),ui="^"+(li="("+(oi="[a-zA-Z]|\\.\\.\\.")+")+")+"$",ci="^"+("("+li+",)*"+li)+"$",di=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);void 0===n?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},hi=class{constructor(e,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,r]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(ci)))throw new Error("Invalid LHS term");if(n.split(",").forEach(((t,n)=>{let r=e[n].dims.slice();if(!t.match(RegExp(ui)))throw new Error("Invalid LHS term");let s=this.processTerm(t,!0,r,n);this.lhs.push(s)})),""===r)r+=[...this.symbolToInfo.entries()].filter((([e,t])=>1===t.count||"..."===e)).map((([e])=>e)).join("");else if(!r.match(RegExp(li)))throw new Error("Invalid RHS");r.match(RegExp(oi,"g"))?.forEach((e=>{if("..."===e)this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let t=this.symbolToInfo.get(e);if(void 0===t)throw new Error("Invalid RHS symbol");this.outputDims.push(t.dimValue)}})),this.rhs=this.processTerm(r,!1,this.outputDims)}addSymbol(e,t,n){let r=this.symbolToInfo.get(e);if(void 0!==r){if(r.dimValue!==t&&1!==r.count)throw new Error("Dimension mismatch");r.count++,r.inputIndices.push(n)}else r={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,r)}processTerm(e,t,n,r=-1){let s=n.length,a=!1,i=[],A=0;if(!e.match(RegExp(ui))&&!t&&""!==e)throw new Error("Invalid LHS term");let o=e.match(RegExp(oi,"g")),l=new di(r);return o?.forEach(((e,u)=>{if("..."===e){if(a)throw new Error("Only one ellipsis is allowed per input term");a=!0;let e=s-o.length+1;if(e<0)throw new Error("Ellipsis out of bounds");if(i=n.slice(A,A+e),this.hasEllipsis){if(this.ellipsisDims.length!==i.length||this.ellipsisDims.toString()!==i.toString())throw new Error("Ellipsis dimensions mismatch")}else{if(!t)throw new Error("Ellipsis must be specified in the LHS");this.hasEllipsis=!0,this.ellipsisDims=i}for(let e=0;e<i.length;e++){let t=String.fromCharCode(48+e);l.addSymbol(t,u+e),this.addSymbol(t,n[A++],r)}}else l.addSymbol(e,u+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(e,n[A++],r)})),l}},fi=e=>e+"_max",gi=(e,t,n,r)=>{let s=e.map((e=>e.length)).map(((e,n)=>In(`input${n}`,t,e))),a=Nt.size(r),i=wn("output",t,r.length),A=[...n.symbolToInfo.keys()].filter((e=>!n.rhs.symbolToIndices.has(e)));return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:e.map((()=>"rank"))},getRunData:()=>{let s=A.filter((e=>n.symbolToInfo.has(e))).map((e=>({type:12,data:n.symbolToInfo.get(e)?.dimValue||0})));s.push({type:12,data:a});let i=e.map(((e,t)=>[...hn(e)])).reduce(((e,t)=>e.concat(t)),s);return i.push(...hn(r)),{outputs:[{dims:r,dataType:t}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:i}},getShaderSource:e=>{let t=[],r=[],a=[],o=[],l=[],u=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach(((e,A)=>{if(n.rhs.symbolToIndices.has(A)){let r=n.rhs.symbolToIndices.get(A)?.[0];void 0!==r&&n.lhs.forEach(((n,a)=>{if(e.inputIndices.includes(a)){let e=n.symbolToIndices.get(A);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{t.push(`${s[a].indicesSet(`input${a}Indices`,e,i.indicesGet("outputIndices",r))}`)}))}}))}else n.lhs.forEach(((t,n)=>{if(e.inputIndices.includes(n)){let e=t.symbolToIndices.get(A);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{r.push(`${s[n].indicesSet(`input${n}Indices`,e,`${A}`)}`)})),l.push(`prod *= ${s[n].getByIndices(`input${n}Indices`)};`)}})),a.push(`for(var ${A}: u32 = 0; ${A} < uniforms.${fi(A)}; ${A}++) {`),o.push("}")}));let c=u?[...t,`let sum = ${s.map(((e,t)=>e.getByIndices(`input${t}Indices`))).join(" * ")};`]:[...t,"var sum = 0.0;",...a,...r,"var prod = 1.0;",...l,"sum += prod;",...o];return`\n            ${e.registerUniforms(A.map((e=>({name:`${fi(e)}`,type:"u32"})))).registerUniform("outputSize","u32").declareVariables(...s,i)}\n\n            ${e.mainStart()}\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${i.offsetToIndices("global_idx")};\n            ${s.map(((e,t)=>`var input${t}Indices: ${s[t].type.indices};`)).join("\n")}\n            ${c.join("\n")};\n            ${i.setByOffset("global_idx","sum")};\n          }`}}},pi=(e,t)=>{let n=new hi(e.inputs,t.equation),r=n.outputDims,s=e.inputs.map(((e,t)=>e.dims));e.compute(gi(s,e.inputs[0].dataType,n,r))},mi=e=>{let t=e.equation.replace(/\s+/g,"");return on({equation:t})}})),iu=te((()=>{yl(),Bl(),Fl(),bi=e=>{if(!e||2!==e.length)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=n.length<t.length?0:n.length-t.length,s=t.length<n.length?0:t.length-n.length;for(;r<n.length&&s<t.length;++r,++s)if(n[r]!==t[s]&&1!==n[r]&&1!==t[s])throw new Error("Expand requires shape to be broadcastable to input")},Ci=(e,t)=>{let n=e.length-t.length,r=[];for(let t=0;t<n;++t)r.push(e[t]);for(let s=0;s<t.length;++s)r.push(1===t[s]?e[s+n]:t[s]);return r},Ii=(e,t)=>e.length>t.length?Ci(e,t):Ci(t,e),wi=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=Ii(t,n),s=e[0].dataType,a=9===s||1===Nt.size(t),i=9===s||t.length>0&&t[t.length-1]%4==0?4:1,A=a||r.length>0&&r[r.length-1]%4==0?4:1,o=Math.ceil(Nt.size(r)/A),l=[{type:12,data:o},...hn(t,r)];return{name:"Expand",shaderCache:{hint:`${r.length};${i}${A}`,inputDependencies:["rank"]},getShaderSource:e=>{let n,a=In("input",s,t.length,i),o=wn("output",s,r.length,A);if(9===s){let e=(e,t,n="")=>`\n          let outputIndices${t} = ${o.offsetToIndices(`outputOffset + ${t}u`)};\n          let offset${t} = ${a.broadcastedIndicesToOffset(`outputIndices${t}`,o)};\n          let index${t} = offset${t} / 4u;\n          let component${t} = offset${t} % 4u;\n          ${e}[${t}] = ${n}(${a.getByOffset(`index${t}`)}[component${t}]);\n        `;n=`\n        let outputOffset = global_idx * ${A};\n        var data = vec4<u32>(0);\n        ${e("data",0,"u32")}\n        ${e("data",1,"u32")}\n        ${e("data",2,"u32")}\n        ${e("data",3,"u32")}\n        ${o.setByOffset("global_idx","data")}\n      }`}else n=`\n        let outputIndices = ${o.offsetToIndices(`global_idx * ${A}`)};\n        let inputOffset = ${a.broadcastedIndicesToOffset("outputIndices",o)};\n        let data = ${o.type.value}(${a.getByOffset(`inputOffset / ${i}`)});\n        ${o.setByOffset("global_idx","data")}\n      }`;return`\n    ${e.registerUniform("vec_size","u32").declareVariables(a,o)}\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${n}`},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:l})}},ki=e=>{bi(e.inputs),e.compute(wi(e.inputs),{inputs:[0]})}})),Au=te((()=>{yl(),Bl(),Fl(),_l(),xi=e=>{let t=e[0].dataType,n=Nt.size(e[0].dims),r=Nt.size(e[1].dims),s=r%4==0;return{name:"FastGeluWithBias",shaderCache:{hint:`${s}`,inputDependencies:["type","type"]},getShaderSource:e=>{let n=In("x",t,[1],4),r=In("bias",t,[1],4),a=wn("y",t,[1],4),i=e=>`\n      let bias${e}_offset: u32 = (global_idx * 4 + ${e}) % uniforms.bias_size;\n      let bias${e} = ${r.getByOffset(`bias${e}_offset / 4`)}[bias${e}_offset % 4];`,A=s?`\n      let bias = ${r.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${i(0)}${i(1)}${i(2)}${i(3)}\n      let bias = ${n.type.value}(bias0, bias1, bias2, bias3);`;return`${e.registerUniforms([{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}]).declareVariables(n,r,a)}\n\n    ${Ts(dn(t))}\n\n    ${e.mainStart(ln)}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}\n\n      let x = ${n.getByOffset("global_idx")};\n      ${A}\n      let x_in = x + bias;\n      ${a.setByOffset("global_idx",Ss("x_in"))}\n    }`},getRunData:e=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:r}],dispatchGroup:{x:Math.ceil(n/ln/4)}})}},yi=e=>{e.inputs.length<2||0===Nt.size(e.inputs[1].dims)?Ns(e):e.compute(xi(e.inputs))}})),ou=te((()=>{yl(),Bl(),Gl(),Fl(),vi=e=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.")},Ei=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n.length,a=Nt.normalizeAxis(t.axis,s),i=n.slice(0);i.splice(a,1,...r);let A=n[a],o=9===e[0].dataType?4:1,l=Math.ceil(Nt.size(i)/o),u=[{type:12,data:l},{type:6,data:A},{type:12,data:a},...hn(e[0].dims,e[1].dims,i)];return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u}),getShaderSource:t=>{let n,A=In("data",e[0].dataType,e[0].dims.length,o),l=In("inputIndices",e[1].dataType,e[1].dims.length),u=wn("output",e[0].dataType,i.length,o),c=e=>{let t=r.length,n=`var indicesIndices${e}  = ${l.type.indices}(0);`;for(let r=0;r<t;r++)n+=`${t>1?`indicesIndices${e}[${r}]`:`indicesIndices${e}`} = ${i.length>1?`outputIndices${e}[uniforms.axis + ${r}]`:`outputIndices${e}`};`;n+=`\n          var idx${e} = ${l.getByIndices(`indicesIndices${e}`)};\n          if (idx${e} < 0) {\n            idx${e} = idx${e} + uniforms.axisDimLimit;\n          }\n          var dataIndices${e} : ${A.type.indices};\n        `;for(let r=0,A=0;r<s;r++)r===a?(n+=`${s>1?`dataIndices${e}[${r}]`:`dataIndices${e}`} = u32(idx${e});`,A+=t):(n+=`${s>1?`dataIndices${e}[${r}]`:`dataIndices${e}`} = ${i.length>1?`outputIndices${e}[${A}]`:`outputIndices${e}`};`,A++);return n};if(9===e[0].dataType){let e=(e,t,n="")=>`\n          let outputIndices${t} = ${u.offsetToIndices(`outputOffset + ${t}u`)};\n          ${c(t)};\n          let offset${t} = ${A.indicesToOffset(`dataIndices${t}`)};\n          let index${t} = offset${t} / 4u;\n          let component${t} = offset${t} % 4u;\n          ${e}[${t}] = ${n}(${A.getByOffset(`index${t}`)}[component${t}]);\n        `;n=`\n        let outputOffset = global_idx * ${o};\n        var value = vec4<u32>(0);\n        ${e("value",0,"u32")}\n        ${e("value",1,"u32")}\n        ${e("value",2,"u32")}\n        ${e("value",3,"u32")}\n        ${u.setByOffset("global_idx","value")}\n      `}else n=`\n      let outputIndices = ${u.offsetToIndices("global_idx")};\n      ${c("")};\n      let value = ${A.getByIndices("dataIndices")};\n      ${u.setByOffset("global_idx","value")};\n      `;return`\n      ${t.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(A,l,u)}\n      ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${n}\n      }`}}},Bi=e=>on({axis:e.axis}),Mi=(e,t)=>{let n=e.inputs;vi(n),e.compute(Ei(e.inputs,t))}})),lu=te((()=>{yl(),Bl(),Fl(),Di=(e,t,n,r,s,a,i,A,o)=>{let l=[{type:12,data:a},{type:12,data:r},{type:12,data:s},{type:12,data:n},{type:12,data:i},{type:12,data:A},{type:12,data:o}],u=[a];l.push(...hn(t.dims,u));return e.compute({name:"computeSliceOffsets",shaderCache:{hint:`${s.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:u,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:l}),getShaderSource:e=>{let r=[In("indices_data",t.dataType,t.dims.length),wn("input_slice_offsets_data",12,1,1)],a=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:s.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`\n  ${e.registerUniforms(a).declareVariables(...r)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\n    let base_offset = batch_idx * uniforms.input_batch_stride;\n\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\n    var relative_slice_offset = 0;\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\n      if (index < 0) {\n        ${1===s.length?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}\n      }\n      ${1===n.length?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}\n    }\n\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\n  }`}},{inputs:[t],outputs:[-1]})[0]},Ti=(e,t)=>{let n=e.inputs,r=n[0].dims,s=n[0].dataType,a=n[1].dims,i=a[a.length-1],A=Nt.sizeToDimension(a,a.length-1),o=Nt.sizeFromDimension(r,t.batchDims+i),l=Nt.sizeToDimension(r,t.batchDims),u=Nt.sizeFromDimension(r,t.batchDims),c=A/l,d=new Array(i),h=o;for(let e=0;e<i;++e)d[i-1-e]=h,h*=r[t.batchDims+i-1-e];let f=Di(e,n[1],d,t.batchDims,r,A,c,u,i),g=t.batchDims+i;if(g>r.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let p=a.slice(0,-1).concat(r.slice(g)),m=Nt.size(p),b=[{type:12,data:m},{type:12,data:o},...hn(n[0].dims,f.dims,p)];e.compute({name:"GatherND",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:p,dataType:s}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:b}),getShaderSource:e=>{let t=In("data",n[0].dataType,n[0].dims.length),r=In("slice_offsets",12,f.dims.length),s=wn("output",n[0].dataType,p.length);return`\n          ${e.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(t,r,s)}\n            ${e.mainStart()}\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\n        }`}},{inputs:[n[0],f]})},Si=e=>({batchDims:e.batch_dims,cacheKey:""})})),uu=te((()=>{yl(),Bl(),Gl(),Fl(),Ni=(e,t)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=Nt.normalizeAxis(t.quantizeAxis,e[0].dims.length),r=t.blockSize,s=e[0],a=e[2],i=4===e.length?e[3]:void 0;if(a.dims.length!==s.dims.length||!s.dims.map(((e,t)=>t===n?Math.ceil(e/r)===a.dims[t]:e===a.dims[t])).reduce(((e,t)=>e&&t),!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(i){if(i.dataType!==s.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(i.dims.length!==a.dims.length||!i.dims.map(((e,t)=>e===a.dims[t])).reduce(((e,t)=>e&&t),!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},Gi=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n.length,a=Nt.normalizeAxis(t.gatherAxis,s),i=Nt.normalizeAxis(t.quantizeAxis,s),A=n.slice(0);A.splice(a,1,...r);let o=Nt.size(A),l=e[2].dataType,u=22===e[0].dataType,c=[{type:12,data:o},{type:12,data:i},{type:12,data:a},{type:12,data:t.blockSize},...hn(...e.map(((e,t)=>e.dims)),A)];return{name:"GatherBlockQuantized",shaderCache:{hint:`${t.cacheKey};${e.filter(((e,t)=>1!==t)).map((e=>e.dims.join("_"))).join(";")}`,inputDependencies:Array.from({length:e.length},((e,t)=>"rank"))},getRunData:()=>({outputs:[{dims:A,dataType:l}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:c}),getShaderSource:t=>{let s=In("data",e[0].dataType,e[0].dims.length),i=In("inputIndices",e[1].dataType,e[1].dims.length),o=In("scales",e[2].dataType,e[2].dims.length),c=e.length>3?In("zeroPoint",e[3].dataType,e[3].dims.length):void 0,d=wn("output",l,A.length),h=[s,i,o];c&&h.push(c);return`\n        ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...h,d)}\n        ${t.mainStart()}\n        let output_indices = ${d.offsetToIndices("global_idx")};\n        var indices_indices = ${i.type.indices}(0);\n        ${r.length>1?`\n          for (var i: u32 = 0; i < ${r.length}; i++) {\n            let index = ${d.indicesGet("output_indices","uniforms.gather_axis + i")};\n            ${i.indicesSet("indices_indices","i","index")};\n          }`:`indices_indices = ${d.indicesGet("output_indices","uniforms.gather_axis")};`};\n        var data_indices = ${s.type.indices}(0);\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\n          let index = ${d.indicesGet("output_indices","i")};\n          ${s.indicesSet("data_indices","i","index")};\n        }\n        var index_from_indices = ${i.getByIndices("indices_indices")};\n        if (index_from_indices < 0) {\n          index_from_indices += ${n[a]};\n        }\n        ${s.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};\n        for (var i = uniforms.gather_axis + 1; i < ${A.length}; i++) {\n          let index = ${d.indicesGet("output_indices",`i + ${r.length} - 1`)};\n          ${s.indicesSet("data_indices","i","index")};\n        }\n        let data_offset = ${s.indicesToOffset("data_indices")};\n        let data_index = data_offset % 8;\n        // Convert 4-bit packed data to 8-bit packed data.\n        let packed_4bit_quantized_data = ${s.getByOffset("data_offset / 8")};\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\n        let quantized_data_vec = ${u?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));\n        let quantized_data = quantized_data_vec[data_index / 2];\n        var scale_indices = data_indices;\n        let quantize_axis_index = ${o.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;\n        ${o.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};\n        var scale = ${o.getByIndices("scale_indices")};\n        ${c?`\n              let zero_point_indices = scale_indices;\n              let zero_point_offset = ${c.indicesToOffset("zero_point_indices")};\n              let zero_point_index = zero_point_offset % 8;\n              let packed_4bit_zero_points = ${c.getByOffset("zero_point_offset / 8")};\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\n              let zero_point_vec = ${u?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));\n              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};\n        let dequantized_data = ${dn(l)}(quantized_data - zero_point) * scale;\n        ${d.setByOffset("global_idx","dequantized_data")};\n    }`}}},Fi=(e,t)=>{let n=e.inputs;Ni(n,t),e.compute(Gi(e.inputs,t))},Pi=e=>on({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})})),cu=te((()=>{yl(),Bl(),Gl(),Fl(),Qi=e=>{if(!e||2!==e.length)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error("GatherElements requires that the data input and\n                     indices input tensors be of same rank.")},zi=(e,t)=>{let n=e[0].dims,r=e[0].dataType,s=n.length,a=e[1].dims,i=e[1].dataType,A=Nt.normalizeAxis(t.axis,s),o=n[A],l=a.slice(0),u=Nt.size(l),c=In("input",r,s),d=In("indicesInput",i,a.length),h=wn("output",r,l.length),f=[{type:12,data:u},{type:6,data:o},{type:12,data:A}];return f.push(...hn(n,a,l)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:f}),getShaderSource:e=>`\n      ${e.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(c,d,h)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${h.offsetToIndices("global_idx")};\n\n      var idx = ${d.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${c.type.indices}(outputIndices);\n      ${c.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${c.getByIndices("inputIndices")};\n\n      ${h.setByOffset("global_idx","value")};\n  }`}},Oi=e=>on({axis:e.axis}),Ri=(e,t)=>{let n=e.inputs;Qi(n),e.compute(zi(e.inputs,t))}})),du=te((()=>{yl(),Bl(),Fl(),Li=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Wi=(e,t)=>{let n=e[0].dims.slice(),r=e[1].dims.slice(),[s,a,i]=Ft.getShapeOfGemmResult(n,t.transA,r,t.transB,3===e.length?e[2].dims:void 0),A=[s,a];if(!A)throw new Error("Can't use gemm on the given tensors");let o=16,l=Math.ceil(a/o),u=Math.ceil(s/o),c=(Nt.size(A),[{type:12,data:l},{type:12,data:s},{type:12,data:a},{type:12,data:i},{type:1,data:t.alpha},{type:1,data:t.beta}]),d=["type","type"];3===e.length&&(c.push(...hn(e[2].dims)),d.push("rank")),c.push(...hn(A));return{name:"GemmShared",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:A,dataType:e[0].dataType}],dispatchGroup:{x:l*u},programUniforms:c}),getShaderSource:n=>{let r=In("a",e[0].dataType,e[0].dims),s=In("b",e[1].dataType,e[1].dims),a=null,i=[r,s];3===e.length&&(a=In("c",e[2].dataType,e[2].dims.length),i.push(a));let l=wn("output",e[0].dataType,A.length);i.push(l);let u="",c="";t.transA&&t.transB?(c=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\n      }\n      `,u="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):t.transA&&!t.transB?(c=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\n      }\n      `,u="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!t.transA&&t.transB?(c=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\n      }\n      `,u="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!t.transA&&!t.transB&&(c=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\n      }\n      `,u="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let d=1===t.alpha?"":"value *= uniforms.alpha;";return`\n  ${n.registerUniforms([{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}]).declareVariables(...i)}\n  var<workgroup> tile_a: array<array<${r.type.storage}, 16>, 16>;\n  var<workgroup> tile_b: array<array<${s.type.storage}, 16>, 16>;\n  ${n.mainStart([o,o,1])}\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * 16;\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * 16;\n    let num_tiles = (uniforms.K - 1) / 16 + 1;\n    var k_start = 0u;\n    var value = ${l.type.value}(0);\n    for (var t: u32 = 0u; t < num_tiles; t++) {\n      ${c}\n      k_start = k_start + 16;\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < 16; k++) {\n        ${u}\n      }\n      workgroupBarrier();\n    }\n\n    ${d}\n    let m = tile_row_start + local_id.y;\n    let n = tile_col_start + local_id.x;\n    ${null!=a?`let cOffset = ${a.broadcastedIndicesToOffset("vec2(m, n)",l)}; value += ${l.type.value}(uniforms.beta) * ${a.getByOffset("cOffset")};`:""}\n    if (m < uniforms.M && n < uniforms.N) {\n      output[m * uniforms.N + n] = value;\n    }\n  }`}}},_i=e=>({transA:e.transA,transB:e.transB,alpha:e.alpha,beta:e.beta,cacheKey:`${e.transA};${e.transB};${1===e.alpha}`}),Vi=(e,t)=>{Li(e.inputs),e.compute(Wi(e.inputs,t))}})),hu=te((()=>{yl(),Bl(),Gl(),Fl(),[Hi,Ui,ji,Yi]=[0,1,2,3],Ki=e=>{if(4!==e[0].dims.length)throw new Error("only 4-D tensor is supported.");if(e[0].dims.length!==e[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error("last dimension of grid must be equal to "+(e[0].dims.length-2));if(e[0].dims[0]!==e[1].dims[0])throw new Error("grid batch size must match input batch size")},Xi=e=>`\n  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {\n    var v: vec4<f32>;\n    var coeffs = gs_get_cubic_coeffs(x);\n    for (var i = 0; i < 4; i++) {\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\n    }\n    coeffs = gs_get_cubic_coeffs(y);\n    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\n    return pixel;\n  }\n`,qi=e=>`\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\n    ${0===e.alignCorners?"\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\n    ":"\n    // alignCorners: true => [-1, 1] to [0, length - 1]\n    return (n + 1.0) / 2.0 * (f32(length - 1));\n    "}\n  }\n`,Zi=e=>`\n  ${"reflection"===e.paddingMode?"\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\n        var dx = 0.0;\n        var fx = f32(x);\n        let range = x_max - x_min;\n        if (fx < x_min) {\n          dx = x_min - fx;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_min + r;\n          } else {\n            fx = x_max - r;\n          }\n        } else if (fx > x_max) {\n          dx = fx - x_max;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_max - r;\n          } else {\n            fx = x_min + r;\n          }\n        }\n        return u32(fx);\n      }":""}\n`,Ji=(e,t,n)=>`\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\n     var pixel = ${t}(0);\n     var indices = vec4<u32>(0);\n     indices[${Hi}] = batch;\n     indices[${Ui}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`\n          if (r >= 0 && r < H && c >=0 && c < W) {\n            indices[${ji}] = u32(r);\n            indices[${Yi}] = u32(c);\n          } else {\n            return ${t}(0);\n          }\n        `;case"border":return`\n          indices[${ji}] = u32(clamp(r, 0, H - 1));\n          indices[${Yi}] = u32(clamp(c, 0, W - 1));\n        `;case"reflection":return`\n          indices[${ji}] = gs_reflect(r, border[1], border[3]);\n          indices[${Yi}] = gs_reflect(c, border[0], border[2]);\n        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`\n    return ${e.getByIndices("indices")};\n  }\n`,$i=(e,t,n)=>(()=>{switch(n.mode){case"nearest":return`\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${Hi}], indices[${Ui}], border);\n        `;case"bilinear":return`\n          let x1 = i32(floor(x));\n          let y1 = i32(floor(y));\n          let x2 = x1 + 1;\n          let y2 = y1 + 1;\n\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${Hi}], indices[${Ui}], border);\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${Hi}], indices[${Ui}], border);\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${Hi}], indices[${Ui}], border);\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${Hi}], indices[${Ui}], border);\n\n          let dx2 = ${t}(f32(x2) - x);\n          let dx1 = ${t}(x - f32(x1));\n          let dy2 = ${t}(f32(y2) - y);\n          let dy1 = ${t}(y - f32(y1));\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\n        `;case"bicubic":return`\n          let x0 = i32(floor(x)) - 1;\n          let y0 = i32(floor(y)) - 1;\n          var p: mat4x4<${t}>;\n          for (var h = 0; h < 4; h++) {\n            for (var w = 0; w < 4; w++) {\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${Hi}], indices[${Ui}], border);\n            }\n          }\n\n          let dx = x - f32(x0 + 1);\n          let dy = y - f32(y0 + 1);\n          let result = gs_bicubic_interpolate(p, dx, dy);\n        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${e.setByOffset("global_idx","result")}`,eA=(e,t)=>{let n=In("x",e[0].dataType,e[0].dims.length),r=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],s=In("grid",e[1].dataType,r.length,2),a=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];"NHWC"===t.format&&(a=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[Hi,Ui,ji,Yi]=[0,3,1,2]);let i=wn("output",e[0].dataType,a.length),A=n.type.value,o=[{type:12,data:Nt.size(a)},...hn(e[0].dims,r,a)];return{name:"GridSample",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:["type","type"]},getRunData:e=>{let t=Nt.size(a);return{outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:o}},getShaderSource:e=>`\n  ${e.registerUniform("output_size","u32").declareVariables(n,s,i)}\n  \n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\n    let cubic_alpha = -0.75f;\n    let x_abs = abs(x);\n    var coeffs: vec4<f32>;\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\n    return coeffs;\n  }\n\n  ${Xi(A)}\n  ${qi(t)}\n  ${Zi(t)}\n  ${Ji(n,A,t)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let H_in = i32(uniforms.x_shape[${ji}]);\n      let W_in = i32(uniforms.x_shape[${Yi}]);\n\n      ${0===t.alignCorners?"\n      let x_min = -0.5;\n      let x_max = f32(W_in) - 0.5;\n      let y_min = -0.5;\n      let y_max = f32(H_in) - 0.5;\n      ":"\n      let x_min = 0.0;\n      let x_max = f32(W_in) - 1.0;\n      let y_min = 0.0;\n      let y_max = f32(H_in) - 1.0;\n      "};\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\n\n      let indices = ${i.offsetToIndices("global_idx")};\n      var grid_indices = vec3<u32>(indices[${Hi}], indices[${ji}], indices[${Yi}]);\n      let nxy = ${s.getByIndices("grid_indices")};\n      var x = gs_denormalize(f32(nxy[0]), W_in);\n      var y = gs_denormalize(f32(nxy[1]), H_in);\n\n      ${$i(i,A,t)}\n  }`}},tA=(e,t)=>{Ki(e.inputs),e.compute(eA(e.inputs,t))},nA=e=>on({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})})),fu=te((()=>{yl(),Bl(),Gl(),Sl(),Rl(),Fl(),Pl(),rA=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,sA=(e,t)=>{let n=e[0],r=rA(e,1),s=rA(e,2),a=rA(e,3),i=rA(e,4),A=rA(e,5),o=rA(e,6),l=rA(e,7);if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let u,c=n.dims[0],d=n.dims[1],h=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],f=d,g=0,p=0,m=Math.floor(h/t.numHeads);if(o&&l&&Nt.size(o.dims)&&Nt.size(l.dims)){if(4!==o.dims.length)throw new Error('Input "past_key" is expected to have 4 dimensions');if(o.dims[0]!==c||o.dims[1]!==t.numHeads||o.dims[3]!==m)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[0]!==c||l.dims[1]!==t.numHeads||l.dims[3]!==m)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(o.dims[2]!==l.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(4!==l.dims.length)throw new Error('Input "past_value" is expected to have 4 dimensions');g=o.dims[2],p=o.dims[2]}else if(o&&Nt.size(o.dims)||l&&Nt.size(l.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');if(r&&Nt.size(r.dims)>0){if(3!==n.dims.length)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(3===r.dims.length){if(r.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');u=2,f=r.dims[1]}else if(5===r.dims.length){if(r.dims[2]!==t.numHeads||2!==r.dims[3]||r.dims[4]!==m)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(s)throw new Error('Expect "value" be none when "key" has packed kv format.');u=5,f=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==m)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');u=0,f=r.dims[2]}}else{if(5!==n.dims.length)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==t.numHeads||3!==n.dims[3])throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');u=3}if(a&&Nt.size(a.dims)>0){if(1!==a.dims.length)throw new Error('Input "bias" is expected to have 1 dimension');if(r&&5===r.dims.length&&2===r.dims[3])throw new Error("bias is not allowed for packed kv.")}let b=g+f,C=0;if(i&&Nt.size(i.dims)>0){C=8;let e=i.dims;throw 1===e.length?e[0]===c?C=1:e[0]===3*c+2&&(C=3):2===e.length&&e[0]===c&&e[1]===b&&(C=5),8===C?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let I=!1,w=h;if(s&&Nt.size(s.dims)>0){if(3!==s.dims.length&&4!==s.dims.length)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==s.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(3===s.dims.length){if(f!==s.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');w=s.dims[2]}else{if(f!==s.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');w=s.dims[1]*s.dims[3],I=!0}}if(i&&Nt.size(i.dims)>0)throw new Error("Key padding mask is not supported");if(A&&Nt.size(A.dims)>0){if(4!==A.dims.length)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(A.dims[0]!==c||A.dims[1]!==t.numHeads||A.dims[2]!==d||A.dims[3]!==b)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:c,sequenceLength:d,pastSequenceLength:g,kvSequenceLength:f,totalSequenceLength:b,maxSequenceLength:p,inputHiddenSize:0,hiddenSize:h,vHiddenSize:w,headSize:m,vHeadSize:Math.floor(w/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:C,scale:t.scale,broadcastResPosBias:!1,passPastInKv:I,qkvFormat:u}},aA=e=>on({...e}),iA=on({perm:[0,2,1,3]}),AA=(e,t,n,r,s,a,i)=>{let A=[r,s,a],o=Nt.size(A),l=[{type:12,data:o},{type:12,data:i},{type:12,data:a}];return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:A,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:l}),getShaderSource:e=>{let r=wn("qkv_with_bias",t.dataType,A),s=In("qkv",t.dataType,A),a=In("bias",n.dataType,A);return`\n  ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}]).declareVariables(s,a,r)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`}},{inputs:[t,n],outputs:[-1]})[0]},oA=(e,t,n,r,s,a,i,A)=>{let o=a;if(i&&Nt.size(i.dims)>0){if(1===r)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return o=AA(e,a,i,t,r,n*s,A),o=o.reshape([t,r,n,s]),1===n||1===r?o:e.compute(Nn(o,iA.perm),{inputs:[o],outputs:[-1]})[0]}return 3===a.dims.length&&(o=a.reshape([t,r,n,s])),1===n||1===r?o:e.compute(Nn(o,iA.perm),{inputs:[o],outputs:[-1]})[0]},lA=(e,t)=>{let n=sA(e.inputs,t),r=e.inputs[0],s=rA(e.inputs,1),a=rA(e.inputs,2),i=rA(e.inputs,3),A=rA(e.inputs,4),o=rA(e.inputs,5),l=rA(e.inputs,6),u=rA(e.inputs,7);if(5===r.dims.length)throw new Error("Packed QKV is not implemented");if(5===s?.dims.length)throw new Error("Packed KV is not implemented");let c=s&&a&&4===s.dims.length&&4===a.dims.length,d=oA(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,r,i,0);if(c)return zr(e,d,s,a,A,void 0,l,u,o,n);if(!s||!a)throw new Error("key and value must be provided");let h=oA(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,s,i,n.hiddenSize),f=oA(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,a,i,2*n.hiddenSize);zr(e,d,h,f,A,void 0,l,u,o,n)}})),gu=te((()=>{yl(),Bl(),Gl(),Fl(),uA=e=>{if(!e||e.length<1)throw new Error("too few inputs")},cA=(e,t)=>{let n=[],r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),r=n.length),on({numOutputs:r,axis:t.axis,splitSizes:n})},dA=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${bn("uniforms.size_in_split_axis","i",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,hA=e=>{let t=e.length,n=[];for(let r=0;r<t;++r){let s=e[r].setByIndices("indices","input[global_idx]");1===t?n.push(s):0===r?n.push(`if (output_number == ${r}u) { ${s} }`):r===t-1?n.push(`else { ${s} }`):n.push(`else if (output_number == ${r}) { ${s} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${n.join("\n")}\n      }`},fA=(e,t)=>{let n=e[0].dims,r=Nt.size(n),s=e[0].dataType,a=Nt.normalizeAxis(t.axis,n.length),i=new Array(t.numOutputs),A=In("input",s,n.length),o=new Array(t.numOutputs),l=[],u=[],c=0,d=[{type:12,data:r}];for(let r=0;r<t.numOutputs;r++){c+=t.splitSizes[r],o[r]=c;let A=n.slice();A[a]=t.splitSizes[r],u.push(A),i[r]=wn(`output${r}`,s,A.length),l.push({dims:u[r],dataType:e[0].dataType})}d.push({type:12,data:o},...hn(n,...u));return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:e=>`\n  ${e.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",o.length).declareVariables(A,...i)}\n  ${dA(o.length)}\n  ${hA(i)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${A.offsetToIndices("global_idx")};\n    var index = ${A.indicesGet("indices",a)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${bn("uniforms.size_in_split_axis","output_number - 1u",o.length)};\n      ${A.indicesSet("indices",a,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`,getRunData:()=>({outputs:l,dispatchGroup:{x:Math.ceil(r/64)},programUniforms:d})}},gA=(e,t)=>{uA(e.inputs);let n=1===e.inputs.length?t:cA(e.inputs,t);e.compute(fA(e.inputs,n),{inputs:[0]})},pA=e=>{let t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return on({axis:t,numOutputs:r,splitSizes:n})}})),pu=te((()=>{yl(),Bl(),Gl(),Fl(),mA=(e,t)=>{let[n,r,s,a]=e,{numHeads:i,rotaryEmbeddingDim:A}=t;if(3!==n.dims.length&&4!==n.dims.length)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!Nt.areEqual(r.dims,[])&&!Nt.areEqual(r.dims,[1])&&2!==r.dims.length)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${r.dims.length}`);if(2!==s.dims.length)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${s.dims.length}`);if(2!==a.dims.length)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${a.dims.length}`);if(!Nt.areEqual(s.dims,a.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(A>0&&0===i)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let o=n.dims[0],l=n.dims[n.dims.length-2],u=s.dims[0],c=Nt.sizeFromDimension(n.dims,1)/l,d=0===A?2*s.dims[1]:c/i;if(A>d)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(2===r.dims.length){if(o!==r.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${r.dims[0]}`);if(l!==r.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${r.dims[1]}`)}if(d/2!==s.dims[1]&&A/2!==s.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${s.dims[1]}`);if(l>u)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},bA=(e,t)=>{let{interleaved:n,numHeads:r,rotaryEmbeddingDim:s,scale:a}=t,i=e[0].dims[0],A=Nt.sizeFromDimension(e[0].dims,1),o=e[0].dims[e[0].dims.length-2],l=A/o,u=e[2].dims[1],c=0===s?2*u:l/r,d=new Array(i,o,l/c,c-u),h=Nt.computeStrides(d),f=[{type:1,data:a},{type:12,data:d},{type:12,data:h},...3===e[0].dims.length?new Array({type:12,data:[A,l,c,1]}):[],...4===e[0].dims.length?new Array({type:12,data:[A,c,o*c,1]}):[],...hn(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)];return{name:"RotaryEmbedding",shaderCache:{hint:on({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:t=>{let r=In("input",e[0].dataType,e[0].dims.length),s=In("position_ids",e[1].dataType,e[1].dims.length),a=In("cos_cache",e[2].dataType,e[2].dims.length),i=In("sin_cache",e[3].dataType,e[3].dims.length),A=wn("output",e[0].dataType,e[0].dims.length);return t.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:d.length},{name:"global_strides",type:"u32",length:h.length},{name:"input_output_strides",type:"u32",length:h.length}]),`\n        ${t.declareVariables(r,s,a,i,A)}\n\n        ${t.mainStart(ln)}\n          let half_rotary_emb_dim = uniforms.${a.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${t.guardAgainstOutOfBoundsWorkgroupSizes("size")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${s.broadcastedIndicesToOffset("bsnh.xy",wn("",s.type.tensor,2))};\n            let position_id =\n                u32(${s.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});\n            let j = i + select(half_rotary_emb_dim, 1, ${n});\n            let re = ${r.getByOffset("i")} * ${a.get("position_id","bsnh[3]")} -\n                ${r.getByOffset("j")} * ${i.get("position_id","bsnh[3]")};\n            ${A.setByOffset("i","re")}\n            let im = ${r.getByOffset("i")} * ${i.get("position_id","bsnh[3]")} +\n                ${r.getByOffset("j")} * ${a.get("position_id","bsnh[3]")};\n            ${A.setByOffset("j","im")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${A.setByOffset("k",r.getByOffset("k"))}\n          }\n        }`},getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Nt.size(d)/ln)},programUniforms:f})}},CA=(e,t)=>{mA(e.inputs,t),e.compute(bA(e.inputs,t))}})),mu=te((()=>{Gl(),yl(),Rl(),fu(),gu(),Pl(),pu(),Fl(),IA=(e,t)=>{if(t.doRotary&&e.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=e[0],r=e[1],s=e[2],a=e[3],i=e[4];if(0!==t.doRotary&&e.length<=7)throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(-1!==t.localWindowSize)throw new Error("Local attention is not supported");if(0!==t.softcap)throw new Error("Softcap is not supported");if(0!==t.rotaryInterleaved)throw new Error("Rotary interleaved is not supported");if(t.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let A=n.dims[0],o=n.dims[1],l=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],u=o,c=0,d=!r||0===r.dims.length,h=Math.floor(d?l/(t.numHeads+2*t.kvNumHeads):l/t.numHeads);d&&(l=h*t.numHeads);let f=a&&0!==a.dims.length,g=i&&0!==i.dims.length;if(f&&4===a.dims.length&&a.dims[0]===A&&a.dims[1]!==t.kvNumHeads&&a.dims[2]===t.kvNumHeads&&a.dims[3]===h)throw new Error("BSNH pastKey/pastValue is not supported");if(f&&g){if(4!==a.dims.length)throw new Error('Input "past_key" is expected to have 4 dimensions');if(4!==i.dims.length)throw new Error('Input "past_value" is expected to have 4 dimensions');c=a.dims[2]}else if(f||g)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let p=1;if(r&&r.dims.length>0){if(3!==n.dims.length)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(3===r.dims.length){if(n.dims[2]%r.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');u=r.dims[1]}else if(5===r.dims.length){if(r.dims[2]!==t.numHeads||2!==r.dims[3]||r.dims[4]!==h)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(s)throw new Error('Expect "value" be none when "key" has packed kv format.');u=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==h)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');u=r.dims[2]}}else{if(3!==n.dims.length&&5!==n.dims.length)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(5===n.dims.length&&(n.dims[2]!==t.numHeads||3!==n.dims[3]))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');p=3}let m=!1,b=t.kvNumHeads?h*t.kvNumHeads:l;if(s&&s.dims.length>0){if(3!==s.dims.length&&4!==s.dims.length)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==s.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(3===s.dims.length){if(u!==s.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');b=s.dims[2]}else{if(u!==s.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');b=s.dims[1]*s.dims[3],m=!0}}let C=e.length>4?e[5]:void 0;if(C&&1!==C.dims.length&&C.dims[0]!==A)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:A,sequenceLength:o,pastSequenceLength:c,kvSequenceLength:u,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:l,vHiddenSize:b,headSize:h,vHeadSize:Math.floor(b/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:m,qkvFormat:p}},wA=on({perm:[0,2,1,3]}),kA=(e,t,n)=>{let r=t,s=n.kvNumHeads;return 3===t.dims.length&&0!==n.kvSequenceLength&&(r=t.reshape([n.batchSize,n.kvSequenceLength,s,n.headSize]),r=e.compute(Nn(r,wA.perm),{inputs:[r],outputs:[-1]})[0]),r},xA=(e,t,n,r)=>{let s=[e*t],a=e*t,i=[{type:12,data:a},{type:12,data:t},{type:12,data:e}];return{name:"GeneratePositionIds",shaderCache:{hint:`${e};${t}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:7}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:i}),getShaderSource:e=>{let t=In("seq_lens",n.dataType,n.dims),a=In("total_seq_lens",r.dataType,r.dims),i=wn("pos_ids",7,s);return`\n  ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}]).declareVariables(t,a,i)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let total_sequence_length = u32(${a.getByOffset("0")});\n    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;\n    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;\n    let batch_idx = global_idx / uniforms.sequence_length;\n    let sequence_idx = i32(global_idx % uniforms.sequence_length);\n    var pos_id: i32 = 0;\n    let seqlen = ${t.getByOffset("batch_idx")};\n    let total_seqlen = seqlen + 1;\n    if (is_first_prompt) {\n      if (sequence_idx < total_seqlen) {\n        pos_id = sequence_idx;\n      } else {\n        pos_id = 1;\n      }\n      ${i.setByOffset("global_idx","pos_id")}\n    } else if (is_subsequent_prompt) {\n      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);\n      if (past_seqlen + sequence_idx < total_seqlen) {\n        pos_id = past_seqlen + sequence_idx;\n      } else {\n        pos_id = 1;\n      }\n      ${i.setByOffset("global_idx","pos_id")}\n    } else if (global_idx < uniforms.batch_size) {\n      ${i.setByOffset("global_idx","seqlen")}\n    };\n  }\n  `}}},yA=(e,t)=>{let n=IA(e.inputs,t);if(5===e.inputs[0].dims.length)throw new Error("Packed QKV is not implemented");if(5===e.inputs[1]?.dims.length)throw new Error("Packed KV is not implemented");let r,s,a=e.inputs[0],i=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,A=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,o=e.inputs[3]&&0!==e.inputs[3].dims.length?e.inputs[3]:void 0,l=e.inputs[4]&&0!==e.inputs[4].dims.length?e.inputs[4]:void 0,u=e.inputs.length>4?e.inputs[5]:void 0,c=e.inputs.length>5?e.inputs[6]:void 0,d=n.kvNumHeads?n.kvNumHeads:n.numHeads,h=on({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,d*n.headSize,d*n.headSize]}),[f,g,p]=i||A?[a,i,A]:e.compute(fA([a],h),{inputs:[a],outputs:[-1,-1,-1]});if(t.doRotary){let a=e.compute(xA(n.batchSize,n.sequenceLength,u,c),{inputs:[u,c],outputs:[-1]})[0],i=e.inputs[7],A=e.inputs[8],o=on({interleaved:0!==t.rotaryInterleaved,numHeads:n.numHeads,rotaryEmbeddingDim:0,scale:t.scale}),l=[f,a,i,A],d=[-1];r=e.compute(bA(l,o),{inputs:l,outputs:d})[0],l.splice(0,1,g);let h=on({interleaved:0!==t.rotaryInterleaved,numHeads:n.kvNumHeads,rotaryEmbeddingDim:0,scale:t.scale});s=e.compute(bA(l,h),{inputs:l,outputs:d})[0]}let m=oA(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,t.doRotary?r:f,void 0,0),b=kA(e,t.doRotary?s:g,n),C=kA(e,p,n);zr(e,m,b,C,void 0,void 0,o,l,void 0,n,u,c)}})),bu=te((()=>{yl(),Bl(),Pl(),Fl(),vA=(e,t,n,r,s,a,i,A)=>{let o=fn(a),l=1===o?"f32":`vec${o}f`,u=1===o?"vec2f":`mat2x${o}f`,c=s*i,d=64;1===c&&(d=256);let h=[s,i,a/o],f=[s,i,2],g=[];g.push(...hn(h,f));return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${o};${A};${d}`,inputDependencies:["rank","type","type"]},getRunData:()=>({outputs:[{dims:f,dataType:1}],dispatchGroup:{x:c},programUniforms:g}),getShaderSource:e=>{let s=In("x",t.dataType,3,o),a=[s,In("scale",n.dataType,n.dims),In("bias",r.dataType,r.dims),wn("output",1,3,2)];return`\n  var<workgroup> workgroup_shared : array<${u}, ${d}>;\n  const workgroup_size = ${d}u;\n  ${e.declareVariables(...a)}\n  ${e.mainStart(d)}\n    let batch = workgroup_index / uniforms.x_shape[1];\n    let channel = workgroup_index % uniforms.x_shape[1];\n    let hight = uniforms.x_shape[2];\n    // initialize workgroup memory\n    var sum = ${l}(0);\n    var squared_sum = ${l}(0);\n    for (var h = local_idx; h < hight; h += workgroup_size) {\n      let value = ${l}(${s.get("batch","channel","h")});\n      sum += value;\n      squared_sum += value * value;\n    }\n    workgroup_shared[local_idx] = ${u}(sum, squared_sum);\n    workgroupBarrier();\n\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (local_idx < currSize) {\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (local_idx == 0) {\n      let sum_final = ${mn("workgroup_shared[0][0]",o)} / f32(hight * ${o});\n      let squared_sum_final = ${mn("workgroup_shared[0][1]",o)} / f32(hight * ${o});\n\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${A}));\n      let channel_scale = inv_std_dev * f32(scale[channel]);\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\n    }\n  }`}},{inputs:[t,n,r],outputs:[-1]})[0]},EA=(e,t,n)=>{let r=t[0].dims,s=r,a=r[0],i=r[1],A=Nt.sizeFromDimension(r,2),o=fn(A),l=Nt.size(s)/o,u=vA(e,t[0],t[1],t[2],a,A,i,n.epsilon),c=[a,i,A/o],d=[a,i];e.compute({name:"InstanceNormalization",shaderCache:{hint:`${o}`,inputDependencies:["type","none"]},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:[{type:12,data:l},...hn(c,d,c)]}),getShaderSource:e=>{let n=In("x",t[0].dataType,c.length,o),r=In("scale_shift",1,d.length,2),s=wn("output",t[0].dataType,c.length,o),a=[n,r,s];return`\n  ${e.registerUniform("output_size","u32").declareVariables(...a)}\n  ${e.mainStart()}\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let outputIndices = ${s.offsetToIndices("global_idx")};\n      let batch = outputIndices[0];\n      let channel = outputIndices[1];\n      let scale_shift = ${r.getByIndices("vec2<u32>(batch, channel)")};\n      let value = ${n.getByOffset("global_idx")} * ${s.type.value}(scale_shift.x) + ${s.type.value}(scale_shift.y);\n      ${s.setByOffset("global_idx","value")};\n  }`}},{inputs:[t[0],u]})},BA=(e,t,n)=>{let r=t[0].dims,s=r,a=r[0],i=r[r.length-1],A=Nt.sizeFromDimension(r,1)/i,o=fn(i),l=Nt.size(s)/o,u=[{type:12,data:A},{type:12,data:Math.floor(i/o)}],c=!1,d=[0,r.length-1];for(let e=0;e<r.length-2;e++)c=c||1!==r[e+1],d.push(e+1);c=c&&1!==r[r.length-1];let h=c?e.compute(Nn(e.inputs[0],d),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:r.length},((e,t)=>r[d[t]]))),f=vA(e,h,t[1],t[2],a,A,i,n.epsilon);e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${o}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u}),getShaderSource:e=>{let n=cn(t[0].dataType),r=1===o?"vec2f":`mat${o}x2f`,a=e=>{let t=0===e?"x":"y",r=1===o?"f32":`vec${o}f`;switch(o){case 1:return`${n}(${r}(scale.${t}))`;case 2:return`vec2<${n}>(${r}(scale[0].${t}, scale[1].${t}))`;case 4:return`vec4<${n}>(${r}(scale[0].${t}, scale[1].${t}, scale[2].${t}, scale[3].${t}))`;default:throw new Error(`Not supported compoents ${o}`)}},i=In("input",t[0].dataType,t[0].dims,o),A=wn("output",t[0].dataType,s,o);return`\n  @group(0) @binding(0) var<storage, read> input : array<${i.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scale_input : array<${r}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${A.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${e.mainStart()}\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\n    let current_channel_number = global_idx % uniforms.C;\n\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\n    let scale = scale_input[scale_offset];\n    output[global_idx] = fma(input[global_idx], ${a(0)}, ${a(1)});\n  }`}},{inputs:[t[0],f]})},MA=(e,t)=>{"NHWC"===t.format?BA(e,e.inputs,t):EA(e,e.inputs,t)}})),Cu=te((()=>{yl(),Bl(),Fl(),DA=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},TA=(e,t,n)=>{let r=t.simplified,s=e[0].dims,a=e[1],i=!r&&e[2],A=s,o=Nt.normalizeAxis(t.axis,s.length),l=Nt.sizeToDimension(s,o),u=Nt.sizeFromDimension(s,o),c=Nt.size(a.dims),d=i?Nt.size(i.dims):0;if(c!==u||i&&d!==u)throw new Error(`Size of X.shape()[axis:] == ${u}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${c} and bias size of ${d}`);let h=[];for(let e=0;e<s.length;++e)e<o?h.push(s[e]):h.push(1);let f=fn(u),g=["type","type"],p=[{type:12,data:l},{type:1,data:u},{type:12,data:Math.floor(u/f)},{type:1,data:t.epsilon}];i&&g.push("type");let m=n>1,b=n>2,C=[{dims:A,dataType:e[0].dataType}];return m&&C.push({dims:h,dataType:1}),b&&C.push({dims:h,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${f};${n};${r}`,inputDependencies:g},getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p}),getShaderSource:t=>{let n=cn(e[0].dataType),s=[In("x",e[0].dataType,e[0].dims,f),In("scale",a.dataType,a.dims,f)];i&&s.push(In("bias",i.dataType,i.dims,f)),s.push(wn("output",e[0].dataType,A,f)),m&&s.push(wn("mean_data_output",1,h)),b&&s.push(wn("inv_std_output",1,h));return`\n  ${t.registerUniforms([{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...s)}\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${gn("f32",f)};\n    var mean_square_vector = ${gn("f32",f)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${pn(n,f,"x[h + offset]")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${mn("mean_vector",f)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${mn("mean_square_vector",f)} / uniforms.norm_size ${r?"":"- mean * mean"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${pn(n,f,"x[j + offset]")};\n      let f32scale = ${pn(n,f,"scale[j]")};\n      output[j + offset] = ${s[0].type.value}((f32input ${r?"":"- mean"}) * inv_std_dev * f32scale\n        ${i?`+ ${pn(n,f,"bias[j]")}`:""}\n      );\n    }\n\n    ${m?"mean_data_output[global_idx] = mean":""};\n    ${b?"inv_std_output[global_idx] = inv_std_dev":""};\n  }`}}},SA=(e,t)=>{DA(e.inputs),e.compute(TA(e.inputs,t,e.outputCount))}})),Iu=te((()=>{Bl(),Xl(),ql(),NA=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},GA=e=>{NA(e.inputs);let t=St.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");let n=t[t.length-1],r=e.inputs[0].dims[e.inputs[0].dims.length-1];if(n<8&&r<8)e.compute(fa(e.inputs,{activation:""},t));else{let s=t[t.length-2],a=Nt.size(e.inputs[0].dims.slice(0,-2)),i=Nt.size(e.inputs[1].dims.slice(0,-2));if(1!==a&&1===s&&1===i){let s=[1,a,n],i=[e.inputs[0].reshape([1,a,r]),e.inputs[1].reshape([1,r,n])];e.compute(ka(i,{activation:""},t,s),{inputs:i})}else e.compute(ka(e.inputs,{activation:""},t))}}})),wu=te((()=>{yl(),Bl(),Gl(),Fl(),FA=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=e[0],r=n.dims.length;if(n.dims[r-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let s=Math.floor((t.k+t.blockSize-1)/t.blockSize),a=t.blockSize/8*t.bits,i=e[1];if(!Nt.areEqual(i.dims,[t.n,s,a]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let A=e[2].dims;if(Nt.size(A)!==t.n*s)throw new Error("scales input size error.");if(4===e.length){let n=e[3].dims,r=t.bits>4?t.n*s:t.n*Math.floor((s+1)/2);if(Nt.size(n)!==r)throw new Error("zeroPoints input size error.")}},PA=(e,t)=>{let n=e[0].dims,r=n.length,s=n[r-2],a=t.k,i=t.n,A=n.slice(0,r-2),o=Nt.size(A),l=e[1].dims[2]/4,u=e[0].dataType,c=fn(t.k),d=fn(l),h=fn(i),f=A.concat([s,i]),g=s>1&&i/h%2==0?2:1,p=Nt.size(f)/h/g,m=64,b=[],C=[o,s,a/c],I=Nt.convertShape(e[1].dims).slice();I.splice(-1,1,l/d),b.push(...hn(C)),b.push(...hn(I)),b.push(...hn(e[2].dims)),4===e.length&&b.push(...hn(Nt.convertShape(e[3].dims)));let w=[o,s,i/h];b.push(...hn(w));return{name:"MatMulNBits",shaderCache:{hint:`${t.blockSize};${t.bits};${c};${d};${h};${g};64`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:f,dataType:u}],dispatchGroup:{x:p},programUniforms:b}),getShaderSource:n=>{let r=C.length,s=In("a",e[0].dataType,r,c),a=In("b",12,I.length,d),i=In("scales",e[2].dataType,e[2].dims.length),A=[s,a,i],o=4===e.length?In("zero_points",12,e[3].dims.length):void 0;o&&A.push(o);let u=w.length,f=wn("output",e[0].dataType,u,h),p=cn(e[0].dataType),b=(()=>{switch(c){case 1:return`array<${p}, 8>`;case 2:return`mat4x2<${p}>`;case 4:return`mat2x4<${p}>`;default:throw new Error(`${c}-component is not supported.`)}})();return`\n        var<workgroup> workgroup_shared: array<${f.type.value}, ${g*m}>;\n        ${n.declareVariables(...A,f)}\n        ${n.mainStart([m,1,1])}\n          let output_indices = ${f.offsetToIndices(`(global_idx / 64) * ${g}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let nBlocksPerCol = uniforms.b_shape[1];\n\n          for (var block = local_id.x; block < nBlocksPerCol; block += 64) {\n            //process one block\n            var word_offset: u32 = block * ${t.blockSize/c};\n            ${(()=>{let e=`\n            var col_index = col * ${h};\n            ${o?"\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\n            var zero_point_byte_count: u32;\n            var zero_point_word_index: u32;\n            var zero_point_byte_offset: u32;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32;\n            var zero_point_word: u32;":`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${p}(8);`}\n            `;for(let t=0;t<h*g;t++)e+=`\n            let scale${t} = ${i.getByOffset("col_index * nBlocksPerCol + block")};\n            ${o?`\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            zero_point_word = ${o.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\n            let zero_point${t} = ${p}((zero_point_word) & 0xFu);`:""}\n            col_index += 1;`;return e})()}\n            for (var word: u32 = 0; word < ${l}; word += ${d}) {\n              ${(()=>{let e=`col_index = col * ${h};`;for(let t=0;t<h*g;t++)e+=`\n            let b${t}_data = ${a.getByIndices(`${a.type.indices}(col_index, block, word)`)};\n            col_index += 1;`;return e+=`\n            var b_value: u32;\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            var b_value_lower: vec4<u32>;\n            var b_value_upper: vec4<u32>;\n            var b_quantized_values: ${b};\n            var b_dequantized_values: ${b};`,e})()}\n              for (var i: u32 = 0; i < ${d}; i++) {\n                ${(()=>{let e=`\n          // reuse a data\n            var input_offset = ${s.indicesToOffset(`${s.type.indices}(batch, row, word_offset)`)};\n            var a_data: ${b};\n            for (var j: u32 = 0; j < ${8/c}; j++) {\n              a_data[j] = ${s.getByOffset("input_offset")};\n              input_offset++;\n            }\n          `;for(let t=0;t<h*g;t++)e+=`\n            b_value = ${1===d?`b${t}_data`:`b${t}_data[i]`};\n            b_value_lower = unpack4xU8(b_value & b_mask);\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\n            b_quantized_values = ${b}(${Array.from({length:4},((e,t)=>`${p}(b_value_lower[${t}]), ${p}(b_value_upper[${t}])`)).join(", ")});\n            b_dequantized_values = ${1===c?`${b}(${Array.from({length:8},((e,n)=>`(b_quantized_values[${n}] - ${o?`zero_point${t}`:"zero_point"}) * scale${t}`)).join(", ")});`:`(b_quantized_values - ${b}(${Array(8).fill(""+(o?`zero_point${t}`:"zero_point")).join(",")})) * scale${t};`};\n            workgroup_shared[local_id.x * ${g} + ${Math.floor(t/h)}]${h>1?`[${t%h}]`:""} += ${Array.from({length:8/c},((e,t)=>""+(1===c?`a_data[${t}] * b_dequantized_values[${t}]`:`dot(a_data[${t}], b_dequantized_values[${t}])`))).join(" + ")};\n          `;return e})()}\n                word_offset += ${8/c};\n              }\n            }\n          }\n          workgroupBarrier();\n\n          if (local_id.x < ${g}) {\n            var output_value: ${f.type.value} = ${f.type.value}(0);\n            var workgroup_shared_offset: u32 = local_id.x;\n            for (var b: u32 = 0u; b < 64u; b++) {\n              output_value += workgroup_shared[workgroup_shared_offset];\n              workgroup_shared_offset += ${g};\n            }\n            ${f.setByIndices(`${f.type.indices}(batch, row, col + local_id.x)`,"output_value")};\n          }\n        }`}}},QA=(e,t)=>{let n=e[0].dims,r=n.length,s=n[r-2],a=t.k,i=t.n,A=n.slice(0,r-2),o=Nt.size(A),l=e[1].dims[2]/4,u=e[0].dataType,c=fn(t.k),d=fn(l),h=A.concat([s,i]),f=i%8==0?8:i%4==0?4:1,g=128/f,p=g*d*8,m=p/c,b=p/t.blockSize,C=Nt.size(h)/f,I=[],w=[o,s,a/c],k=Nt.convertShape(e[1].dims).slice();k.splice(-1,1,l/d),I.push(...hn(w)),I.push(...hn(k)),I.push(...hn(e[2].dims)),4===e.length&&I.push(...hn(Nt.convertShape(e[3].dims)));let x=[o,s,i];I.push(...hn(x));return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${t.blockSize};${c};${d};${g};${f}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:h,dataType:u}],dispatchGroup:{x:C},programUniforms:I}),getShaderSource:n=>{let r=w.length,s=In("a",e[0].dataType,r,c),a=In("b",12,k.length,d),i=In("scales",e[2].dataType,e[2].dims.length),A=[s,a,i],o=4===e.length?In("zero_points",12,e[3].dims.length):void 0;o&&A.push(o);let l=x.length,u=wn("output",e[0].dataType,l),h=cn(e[0].dataType);return`\n        var<workgroup> sub_a: array<${s.type.value}, ${m}>;\n        var<workgroup> inter_results: array<array<${u.type.value}, ${g}>, ${f}>;\n        ${n.declareVariables(...A,u)}\n        ${n.mainStart([g,f,1])}\n          let output_indices = ${u.offsetToIndices(`workgroup_index * ${f}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let n_blocks_per_col = uniforms.b_shape[1];\n          let num_tiles =  (n_blocks_per_col - 1) / ${b} + 1;\n\n          // Loop over shared dimension.\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\n            let a_col_start = tile * ${m};\n            // load one tile A data into shared memory.\n            for (var a_offset = local_idx; a_offset < ${m}; a_offset += 128)\n            {\n              let a_col = a_col_start + a_offset;\n              if (a_col < uniforms.a_shape[2])\n              {\n                sub_a[a_offset] = ${s.getByIndices(`${s.type.indices}(batch, row, a_col)`)};\n              } else {\n                sub_a[a_offset] = ${s.type.value}(0);\n              }\n            }\n            workgroupBarrier();\n\n            // each thread process one block\n            let b_row = col + local_id.y;\n            let block = tile * ${b} + local_id.x;\n            ${o?`\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            let zero_point_word = ${o.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\n            let zero_point = ${h}((zero_point_word) & 0xFu);`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${h}(8);`}\n            let scale = ${i.getByOffset("b_row * n_blocks_per_col + block")};\n            let b_data = ${a.getByIndices(`${a.type.indices}(b_row, block, 0)`)};\n            var word_offset = local_id.x * ${t.blockSize/c};\n            for (var i: u32 = 0; i < ${d}; i++) {\n              ${(()=>{switch(c){case 1:return`\n          let a_data0 = vec4<${h}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\n          let a_data1 = vec4<${h}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`\n          let a_data0 = vec4<${h}>(sub_a[word_offset], sub_a[word_offset + 1]);\n          let a_data1 = vec4<${h}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return"\n          let a_data0 = sub_a[word_offset];\n          let a_data1 = sub_a[word_offset + 1];";default:throw new Error(`${c}-component is not supported.`)}})()}\n              let b_value = ${1===d?"b_data":"b_data[i]"};\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\n              let b_quantized_values = mat2x4<${h}>(${Array.from({length:4},((e,t)=>`${h}(b_value_lower[${t}]), ${h}(b_value_upper[${t}])`)).join(", ")});\n              let b_dequantized_values = (b_quantized_values - mat2x4<${h}>(${Array(8).fill("zero_point").join(",")})) * scale;\n              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},((e,t)=>`dot(a_data${t}, b_dequantized_values[${t}])`)).join(" + ")};\n              word_offset += ${8/c};\n            }\n            workgroupBarrier();\n          }\n\n          if (local_idx < ${f}) {\n            var output_value: ${u.type.value} = ${u.type.value}(0);\n            for (var b = 0u; b < ${g}; b++) {\n              output_value += inter_results[local_idx][b];\n            }\n            if (col + local_idx < uniforms.output_shape[2])\n            {\n              ${u.setByIndices(`${u.type.indices}(batch, row, col + local_idx)`,"output_value")}\n            }\n          }\n        }`}}},zA=(e,t)=>{FA(e.inputs,t),32===t.blockSize&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(QA(e.inputs,t)):e.compute(PA(e.inputs,t))},OA=e=>on(e)})),ku=te((()=>{yl(),Bl(),Fl(),RA=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(1!==e[0].dataType&&10!==e[0].dataType)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=2*e[0].dims.length===e[1].dims[0];if(4===e.length&&(t=2*e[3].dims[0]===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},LA=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\n            k = i32(${e.indicesGet("indices",s)}) - ${bn("uniforms.pads",s,n)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${bn("uniforms.x_shape",s,t)})) {\n              break;\n            }\n            offset += k * i32(${bn("uniforms.x_strides",s,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${r}\n            value = x[offset];\n          }\n      `},WA=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\n                k = i32(${e.indicesGet("indices",s)}) - ${bn("uniforms.pads",s,n)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${bn("uniforms.x_shape",s,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${bn("uniforms.x_shape",s,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${bn("uniforms.x_strides",s,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},_A=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\n                k = i32(${e.indicesGet("indices",s)}) - ${bn("uniforms.pads",s,n)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${bn("uniforms.x_shape",s,t)})) {\n                  k = i32(${bn("uniforms.x_shape",s,t)}) - 1;\n                }\n                offset += k * i32(${bn("uniforms.x_strides",s,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},VA=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\n                k = i32(${e.indicesGet("indices",s)}) - ${bn("uniforms.pads",s,n)};\n                if (k < 0)  {\n                  k += i32(${bn("uniforms.x_shape",s,t)}]);\n                }\n                if (k >= i32(${bn("uniforms.x_shape",s,t)})) {\n                  k -= i32(${bn("uniforms.x_shape",s,t)});\n                }\n                offset += k * i32(${bn("uniforms.x_strides",s,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},HA=(e,t,n)=>{switch(n.mode){case 0:return LA(e,t,n.pads.length);case 1:return WA(e,t,n.pads.length);case 2:return _A(e,t,n.pads.length);case 3:return VA(e,t,n.pads.length);default:throw new Error("Invalid mode")}},UA=(e,t)=>{let n=Nt.padShape(e[0].dims.slice(),t.pads),r=e[0].dims,s=[{type:12,data:Nt.size(n)},{type:6,data:t.pads}],a=e.length>=3&&e[2].data;0===t.mode&&s.push({type:a?e[2].dataType:1,data:t.value}),s.push(...hn(e[0].dims,n));return{name:"Pad",shaderCache:{hint:`${t.mode}${a}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Nt.size(n)/64)},programUniforms:s}),getShaderSource:s=>{let i=wn("output",e[0].dataType,n.length),A=In("x",e[0].dataType,r.length),o=A.type.value,l=HA(i,r.length,t),u=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return 0===t.mode&&u.push({name:"constant_value",type:a?o:"f32"}),`\n            ${s.registerUniforms(u).declareVariables(A,i)}\n            ${s.mainStart()}\n            ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n            let indices = ${i.offsetToIndices("global_idx")};\n\n            var value = ${o}(0);\n            ${l}\n            output[global_idx] = value;\n        }`}}},jA=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),r=e.length>=3&&e[2].data?10===e[2].dataType?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,s=e[0].dims.length,a=new Int32Array(2*s).fill(0);if(e.length>=4){let t=e[3].getBigInt64Array();for(let e=0;e<t.length;e++)a[Number(t[e])]=Number(n[e]),a[Number(t[e])+s]=Number(n[e+t.length])}else n.forEach(((e,t)=>a[Number(t)]=Number(e)));let i=[];return a.forEach((e=>i.push(e))),{mode:t.mode,value:r,pads:i}}return t},YA=(e,t)=>{RA(e.inputs);let n=jA(e.inputs,t);e.compute(UA(e.inputs,n),{inputs:[0]})}})),xu=te((()=>{xe(),yl(),Bl(),Fl(),KA=e=>{if(E.webgpu.validateInputContent&&(!e||1!==e.length))throw new Error("Pool ops requires 1 input.")},XA=(e,t,n)=>{let r="NHWC"===t.format,s=e.dims.slice();r&&s.splice(1,0,s.pop());let a=Object.hasOwnProperty.call(t,"dilations"),i=t.kernelShape.slice(),A=t.strides.slice(),o=a?t.dilations.slice():[],l=t.pads.slice();Gt.adjustPoolAttributes(n,s,i,A,o,l);let u=Gt.computePoolOutputShape(n,s,A,o,i,l,t.autoPad),c=Object.assign({},t);a?Object.assign(c,{kernelShape:i,strides:A,pads:l,dilations:o,cacheKey:t.cacheKey}):Object.assign(c,{kernelShape:i,strides:A,pads:l,cacheKey:t.cacheKey});let d=u.slice();return d.push(d.splice(1,1)[0]),[c,r?d:u]},qA=(e,t)=>{let n="NHWC"===t.format,r=[{type:12,data:Nt.size(e)},{type:12,data:Nt.size(t.kernelShape)}],s=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let e=t.kernelShape[t.kernelShape.length-1],n=t.strides[t.strides.length-1],a=t.pads[t.pads.length/2-1],i=t.pads[t.pads.length-1],A=!!(a+i);r.push({type:12,data:e},{type:12,data:n},{type:12,data:a},{type:12,data:i}),s.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let o=!1;if(2===t.kernelShape.length){let e=t.kernelShape[t.kernelShape.length-2],n=t.strides[t.strides.length-2],a=t.pads[t.pads.length/2-2],i=t.pads[t.pads.length-2];o=!!(a+i),r.push({type:12,data:e},{type:12,data:n},{type:12,data:a},{type:12,data:i}),s.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[r,s,!0,A,o]}{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let e=Nt.computeStrides(t.kernelShape);r.push({type:12,data:e},{type:12,data:t.pads},{type:12,data:t.strides}),s.push({name:"kernelStrides",type:"u32",length:e.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let a=t.pads.reduce(((e,t)=>e+t));return[r,s,!!a,!1,!1]}},ZA=(e,t,n,r,s,a,i,A,o,l,u,c)=>{let d="NHWC"===s.format,h=t.type.value,f=wn("output",t.type.tensor,r);if(s.kernelShape.length<=2){let r="",l="",g="",p=n-(d?2:1);if(r=u?`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${p}] = indices[${p}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${p}] < 0 || xIndices[${p}]\n                      >= uniforms.x_shape[${p}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${a}\n                }`:`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${p}] = indices[${p}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${a}\n                }`,2===s.kernelShape.length){let e=n-(d?3:2);l=c?`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${e}] < 0 || xIndices[${e}] >= uniforms.x_shape[${e}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\n                `,g="\n              }\n            "}return`\n            ${e.registerUniforms(o).declareVariables(t,f)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${f.offsetToIndices("global_idx")};\n              var xIndices = ${f.offsetToIndices("global_idx")};\n\n              var value = ${h}(${A});\n              var pad = 0;\n              ${l}\n              ${r}\n              ${g}\n              ${i}\n\n              output[global_idx] = value;\n            }`}{if(d)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let r=s.kernelShape.length,u=s.pads.length,c="";return c=l?`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${a}\n              }`:`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${a}\n            `,`\n            ${e.registerUniforms(o).declareVariables(t,f)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${f.offsetToIndices("global_idx")};\n              var xIndices = ${f.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${r}>;\n\n              var value = ${h}(${A});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${r-1}u; j++) {\n                  offsets[j] = offset / ${bn("uniforms.kernelStrides","j",r)};\n                  offset -= offsets[j] * ${bn("uniforms.kernelStrides","j",r)};\n                }\n                offsets[${r-1}] = offset;\n\n                isPad = false;\n                for (var j = ${n-r}u; j < ${n}u; j++) {\n                  xIndices[j] = indices[j] * ${bn("uniforms.strides",`j - ${n-r}u`,r)}\n                    + offsets[j - ${n-r}u] - ${bn("uniforms.pads","j - 2u",u)};\n                  ${c}\n              }\n              ${i}\n\n              output[global_idx] = value;\n            }`}},JA=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,$A=e=>`${JA(e)};${e.countIncludePad}`,eo=e=>`${JA(e)};${e.storageOrder};${e.dilations}`,to=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),no=(e,t,n,r)=>{let[s,a]=XA(t,r,n),i=In("x",t.dataType,t.dims.length),A=i.type.value,o="";s.countIncludePad?o+=`value /= ${A}(uniforms.kernelSize);`:o+=`value /= ${A}(i32(uniforms.kernelSize) - pad);`;let[l,u,c,d,h]=qA(a,s);l.push(...hn(t.dims,a));return{name:e,shaderCache:{hint:`${r.cacheKey};${c};${d};${h}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(Nt.size(a)/64)},programUniforms:l}),getShaderSource:e=>ZA(e,i,t.dims.length,a.length,s,"value += x_val;",o,0,u,c,d,h)}},ro=e=>{let t=0!==e.count_include_pad,n=to(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let r={countIncludePad:t,...n,cacheKey:""};return{...r,cacheKey:$A(r)}},so=(e,t)=>{KA(e.inputs),e.compute(no("AveragePool",e.inputs[0],!1,t))},ao={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},io=e=>{let t=e.format;return{format:t,...ao,cacheKey:t}},Ao=(e,t)=>{KA(e.inputs),e.compute(no("GlobalAveragePool",e.inputs[0],!0,t))},oo=(e,t,n,r)=>{let[s,a]=XA(t,r,n),i=In("x",t.dataType,t.dims.length),[A,o,l,u,c]=qA(a,s);return A.push(...hn(t.dims,a)),{name:e,shaderCache:{hint:`${r.cacheKey};${l};${u};${c}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(Nt.size(a)/64)},programUniforms:A}),getShaderSource:e=>ZA(e,i,t.dims.length,a.length,s,"\n      value = max(x_val, value);\n    ","",10===t.dataType?-65504:-1e5,o,l,u,c)}},lo=(e,t)=>{KA(e.inputs),e.compute(oo("MaxPool",e.inputs[0],!1,t))},uo=e=>{let t=e.storage_order,n=e.dilations,r=to(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let s={storageOrder:t,dilations:n,...r,cacheKey:""};return{...s,cacheKey:eo(s)}},co=e=>{let t=e.format;return{format:t,...ao,cacheKey:t}},ho=(e,t)=>{KA(e.inputs),e.compute(oo("GlobalMaxPool",e.inputs[0],!0,t))}})),yu=te((()=>{yl(),Bl(),Gl(),Fl(),fo=(e,t)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(3===e.length&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(6===e[0].dataType&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(0!==e[1].dims.length&&1!==e[1].dims.length&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map(((t,n)=>t===e[2].dims[n])).reduce(((e,t)=>e&&t),!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(t.blockSize>0){if(0===e[1].dims.length||1===e[1].dims.length&&1===e[1].dims[0])throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map(((n,r)=>r===t.axis||n===e[0].dims[r])).reduce(((e,t)=>e&&t),!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=e[0].dims[t.axis],r=e[1].dims[t.axis];if(t.blockSize<Math.ceil(n/r)||t.blockSize>Math.ceil(n/(r-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},go=(e,t)=>{let n=Nt.normalizeAxis(t.axis,e[0].dims.length),r=e[0].dataType,s=3===r,a=e[0].dims,i=e[1].dataType,A=Nt.size(a),o=3===r||2===r,l=o?[Math.ceil(Nt.size(e[0].dims)/4)]:e[0].dims,u=e[1].dims,c=e.length>2?e[2]:void 0,d=c?o?[Math.ceil(Nt.size(c.dims)/4)]:c.dims:void 0,h=0===u.length||1===u.length&&1===u[0],f=!1===h&&1===u.length,g=fn(A),p=h&&(!o||4===g),m=p?g:1,b=p&&!o?g:1,C=In("input",o?12:r,l.length,b),I=In("scale",i,u.length),w=c?In("zero_point",o?12:r,d.length):void 0,k=wn("output",i,a.length,m),x=[C,I];w&&x.push(w);let y=[l,u];c&&y.push(d);let v=[{type:12,data:A/m},{type:12,data:n},{type:12,data:t.blockSize},...hn(...y,a)];return{name:"DequantizeLinear",shaderCache:{hint:t.cacheKey,inputDependencies:w?["rank","rank","rank"]:["rank","rank"]},getShaderSource:e=>`\n      ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...x,k)}\n      ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          let output_indices = ${k.offsetToIndices("global_idx")};\n\n          // Set input x\n          ${o?`\n            let input = ${C.getByOffset("global_idx / 4")};\n            let x_vec = ${s?"unpack4xI8(input)":"unpack4xU8(input)"};\n            let x_value = ${1===m?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${C.getByOffset("global_idx")};`};\n\n          // Set scale input\n          ${h?`let scale_value= ${I.getByOffset("0")}`:f?`\n            let scale_index = ${k.indicesGet("output_indices","uniforms.axis")};\n            let scale_value= ${I.getByOffset("scale_index")};`:`\n            var scale_indices: ${I.type.indices} = output_indices;\n            let index = ${I.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;\n            ${I.indicesSet("scale_indices","uniforms.axis","index")};\n            let scale_value= ${I.getByIndices("scale_indices")};`};\n\n          // Set zero-point input\n          ${w?h?o?`\n                let zero_point_input = ${w.getByOffset("0")};\n                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${w.getByOffset("0")}`:f?o?`\n                let zero_point_index = ${k.indicesGet("output_indices","uniforms.axis")};\n                let zero_point_input = ${w.getByOffset("zero_point_index / 4")};\n                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`\n                let zero_point_index = ${k.indicesGet("output_indices","uniforms.axis")};\n                let zero_point_value = ${w.getByOffset("zero_point_index")};`:o?`\n                let zero_point_offset = ${I.indicesToOffset("scale_indices")};\n                let zero_point_input = ${w.getByOffset("zero_point_offset / 4")};\n                let zero_point_vec = ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${w.getByIndices("scale_indices")};`:`let zero_point_value = ${o?s?"i32":"u32":C.type.value}(0);`};\n      // Compute and write output\n      ${k.setByOffset("global_idx",`${k.type.value}(x_value - zero_point_value) * scale_value`)};\n      }`,getRunData:()=>({outputs:[{dims:a,dataType:i}],dispatchGroup:{x:Math.ceil(A/m/64),y:1,z:1},programUniforms:v})}},po=(e,t)=>{fo(e.inputs,t),e.compute(go(e.inputs,t))},mo=e=>on({axis:e.axis,blockSize:e.blockSize})})),vu=te((()=>{xe(),yl(),Fl(),bo=(e,t,n)=>{if(e===t||e<t&&n<0||e>t&&n>0)throw new Error("Range these inputs' contents are invalid.")},Co=(e,t,n,r)=>{let s=Math.abs(Math.ceil((t-e)/n)),a=[s],i=s,A=[{type:12,data:i},{type:r,data:e},{type:r,data:n},...hn(a)];return{name:"Range",shaderCache:{hint:`${r}`},getShaderSource:e=>{let t=wn("output",r,a.length),n=t.type.value,s=[{name:"outputSize",type:"u32"},{name:"start",type:n},{name:"delta",type:n}];return`\n        ${e.registerUniforms(s).declareVariables(t)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        output[global_idx] = uniforms.start + ${n}(global_idx) * uniforms.delta;\n      }`},getRunData:()=>({outputs:[{dims:a,dataType:r}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:A})}},Io=e=>{let t=0,n=0,r=0;6===e.inputs[0].dataType?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],r=e.inputs[2].getInt32Array()[0]):1===e.inputs[0].dataType&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],r=e.inputs[2].getFloat32Array()[0]),E.webgpu.validateInputContent&&bo(t,n,r),e.compute(Co(t,n,r,e.inputs[0].dataType),{inputs:[]})}})),Eu=te((()=>{yl(),Bl(),Gl(),Fl(),wo=(e,t,n,r)=>{if("none"!==e&&"i32"!==r&&"u32"!==r&&"f32"!==r)throw new Error(`Input ${r} is not supported with reduction ${e}.`);let s="{\n                var oldValue = 0;\n                loop {\n                  let newValueF32 =",a=`;\n                  let newValue = bitcast<i32>(newValueF32);\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\n                  if res.exchanged {\n                    break;\n                  }\n                  oldValue = res.old_value;\n                }\n              }`;switch(e){case"none":return`${t}=${n};`;case"add":return"i32"===r||"u32"===r?`atomicAdd(&${t}, bitcast<${r}>(${n}));`:`\n              ${s}bitcast<${r}>(oldValue) + (${n})${a}`;case"max":return"i32"===r||"u32"===r?`atomicMax(&${t}, bitcast<${r}>(${n}));`:`\n                ${s}max(bitcast<f32>(oldValue), (${n}))${a}`;case"min":return"i32"===r||"u32"===r?`atomicMin(&${t}, bitcast<${r}>(${n}));`:`${s}min(bitcast<${r}>(oldValue), (${n}))${a}`;case"mul":return`${s}(bitcast<${r}>(oldValue) * (${n}))${a}`;default:throw new Error(`Reduction ${e} is not supported.`)}},ko=(e,t)=>(1===e?"\n    let element_count_dim = uniforms.output_strides;\n    let dim_value = uniforms.output_shape;":`\n    let element_count_dim = uniforms.output_strides[${t?"i - indices_start":"i"}];\n    let dim_value = uniforms.output_shape[${t?"i - indices_start":"i"} + uniforms.last_index_dimension];`)+"\n    \n    if (index >= 0) {\n      if (index >= i32(dim_value)) {\n        index = i32(dim_value - 1);\n      }\n    } else {\n      if (index < -i32(dim_value)) {\n        index = 0;\n      } else {\n        index += i32(dim_value);\n      }\n    }\n    data_offset += u32((u32(index) * element_count_dim));",xo=(e,t,n)=>`for (var i = 0u; i < uniforms.num_updates_elements; i++) {\n        let value = updates[uniforms.num_updates_elements * ${n?"global_idx":"idx"} + i];\n        ${wo(e.reduction,"output[data_offset + i]","value",t)}\n      }`,yo=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n,a=Math.ceil(Nt.size(r)/1),i=r[r.length-1],A=Nt.sizeFromDimension(n,i),o=Nt.sizeFromDimension(r,0)/i,l=[{type:12,data:a},{type:12,data:i},{type:12,data:A},...hn(e[1].dims,e[2].dims,s)];return{name:"ScatterND",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:l}),getShaderSource:r=>{let a=In("indices",e[1].dataType,e[1].dims.length),i=In("updates",e[2].dataType,e[2].dims.length,1),A="none"!==t.reduction&&""!==t.reduction?kn("output",e[0].dataType,s.length):wn("output",e[0].dataType,s.length,1);return`\n      ${r.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(a,i,A)}\n      ${r.mainStart()}\n        ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n  var hasDuplicates = false;\n  if (${"none"===t.reduction}) {\n    for (var i = 0; i < ${o}; i = i + 1) {\n      for (var j = i + 1; j < ${o}; j = j + 1) {\n        var index_i = i32(indices[i].x);\n        var index_j = i32(indices[j].x);\n        if (index_i == index_j) {\n          hasDuplicates = true;\n          break;\n        }\n      }\n      if (hasDuplicates) {\n        break;\n      }\n    }\n  }\n\n  if (${"none"===t.reduction} && hasDuplicates) {\n    if (global_idx != 0u) {\n      return;\n    }\n    // Process each index-update pair individually when duplicates exist\n    for (var idx = 0u; idx < ${o}u; idx++) {\n      var data_offset = 0u;\n      for (var i = 0u; i < uniforms.last_index_dimension; i++) {\n        var index = i32(indices[idx * uniforms.last_index_dimension + i].x);\n        ${ko(n.length,!1)}\n      }\n      ${xo(t,A.type.value,!1)}\n    }\n    return;\n  }\n\n  var data_offset = 0u;\n  var indices_start = uniforms.last_index_dimension * global_idx;\n  var indices_end = indices_start + uniforms.last_index_dimension;\n  for (var i = indices_start; i < indices_end; i++) {\n    var index = i32(indices[i].x);\n    ${ko(n.length,!0)}\n  }\n  ${xo(t,A.type.value,!0)}\n  }`}}},vo=e=>on({reduction:e.reduction}),Eo=(e,t)=>{e.compute(yo(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}})),Bu=te((()=>{yl(),Bl(),Gl(),Fl(),Bo=(e,t)=>{if(e.every((e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")}))),e.length>0)if("linear"===t.mode){if(!(2===e.length||3===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]||5===e.length&&1===e[0]&&1===e[1]))throw new Error("For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1")}else if("cubic"===t.mode&&!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")},Mo=(e,t,n)=>{t.every((e=>e>=0&&e<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")})));let r=new Array(n).fill(1);return t.forEach(((t,n)=>r[t]=e[n])),r},Do=(e,t,n,r,s,a)=>{let[i,A,o]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],l=e[0].dims.length;if(i>0&&e.length>i&&e[i].dims.length>0)e[i].getFloat32Array().forEach((e=>a.push(e)));else if("tf_crop_and_resize"===t.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(A>0&&e.length>A&&1===e[A].dims.length&&e[A].dims[0]>0){if(e[A].getFloat32Array().forEach((e=>r.push(e))),0!==r.length&&r.length!==l&&n>=18&&r.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Bo(r,t),t.axes.length>0&&Mo(r,t.axes,l).forEach(((e,t)=>r[t]=e))}if(o>0&&e.length>o&&1===e[o].dims.length&&e[o].dims[0]>0&&(e[o].getBigInt64Array().forEach((e=>s.push(Number(e)))),0!==s.length&&s.length!==l&&n>=18&&s.length!==t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(0!==r.length&&r.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(0!==s.length&&s.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof r<"u"&&typeof s<"u"&&r.length>0&&s.length>l)throw new Error("Resize requires only of scales or sizes to be specified")},To=(e,t,n,r)=>`\n  // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n  // offset-by-one error later in floor().\n  let big = (${e}) * (${t});\n  let whole = ${r}(big / (${n}));\n  let fract = ${r}(big % (${n})) / ${r}(${n});\n  return whole + fract;\n`,So=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`\n          if (xScale < 1.0 || floor(xScale) != xScale) {\n            return ${t}(xResized) / ${t}(xScale);\n          } else {\n            ${To("xResized","lengthOriginal","lengthResized",t)}\n          }\n        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    ${To("xResized","lengthOriginal - 1","lengthResized - 1",t)}\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",No=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Go=(e,t,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),s=0===e.length?r:e.slice();return t.length>0?(t.forEach(((e,a)=>{r[e]=s[a],r[a+n]=s[t.length+a]})),r):s},Fo=(e,t,n,r)=>{let s=[];if(n.length>0)if(r.length>0){if(e.forEach((e=>s.push(e))),Math.max(...r)>e.length)throw new Error("axes is out of bound");r.forEach(((e,t)=>s[e]=n[t]))}else n.forEach((e=>s.push(e)));else{if(0===t.length)throw new Error("Resize requires either scales or sizes.");s=e.map(((e,n)=>Math.round(e*t[n])))}return s},Po=(e,t,n)=>{let r=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map((e=>t[e])),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map((e=>t[e])),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let s=e.slice();return n.axes.length>0?(n.axes.forEach((e=>t[e]=r)),n.axes.forEach((n=>s[n]=Math.round(e[n]*t[n])))):(t.fill(r,0,t.length),s.forEach(((e,n)=>s[n]=Math.round(e*t[n])))),s},Qo=(e,t,n,r,s)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {\n      var original_indices: array<${e.type.value}, ${n.length}>;\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${e.indicesGet("output_indices","i")};\n        var scale = ${bn("uniforms.scales","i",r)};\n        var roi_low = ${bn("uniforms.roi","i",s)};\n        var roi_hi = ${bn("uniforms.roi",`i + ${t.length}`,s)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${bn("uniforms.input_shape","i",t.length)};\n          var output_shape_i = ${bn("uniforms.output_shape","i",n.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,zo=(e,t,n,r,s,a,i)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${t.indicesGet("output_indices","i")};\n        var input_index: u32;\n        var scale = ${bn("uniforms.scales","i",s)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${bn("uniforms.roi","i",a)};\n          var roi_hi = ${bn("uniforms.roi",`i + ${n.length}`,a)};\n          var input_shape_i = ${bn("uniforms.input_shape","i",n.length)};\n          var output_shape_i = ${bn("uniforms.output_shape","i",r.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${i} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet("input_indices","i","input_index")}\n      }\n      return input_indices;\n    }`,Oo=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${bn("uniforms.input_shape","i",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,Ro=(e,t,n,r)=>e.rank>r?`\n    ${e.indicesSet("input_indices",t,"channel")};\n    ${e.indicesSet("input_indices",n,"batch")};\n`:"",Lo=(e,t,n,r,s)=>{let[a,i,A,o]=2===n.length?[-1,0,1,-1]:[0,2,3,1],l=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${l} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",i,`max(0, min(row, ${n[i]} - 1))`)};\n      ${e.indicesSet("input_indices",A,`max(0, min(col, ${n[A]} - 1))`)};\n      ${Ro(e,o,a,2)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${l} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${l} = originalIndices[${i}];\n      var col:${l} = originalIndices[${A}];\n      ${r?`if (row < 0 || row > (${n[i]} - 1) || col < 0 || col > (${n[A]} - 1)) {\n        return ${s};\n      }`:""};\n      row = max(0, min(row, ${n[i]} - 1));\n      col = max(0, min(col, ${n[A]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${n.length>2?`u32(originalIndices[${o}])`:"0"};\n      var batch: u32 =  ${n.length>2?`u32(originalIndices[${a}])`:"0"};\n      var x11: ${l} = getInputValue(batch, channel, row1, col1);\n      var x12: ${l} = getInputValue(batch, channel, row1, col2);\n      var x21: ${l} = getInputValue(batch, channel, row2, col1);\n      var x22: ${l} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${l} = abs(row - ${l}(row1));\n      var dx2: ${l} = abs(${l}(row2) - row);\n      var dy1: ${l} = abs(col - ${l}(col1));\n      var dy2: ${l} = abs(${l}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Wo=(e,t,n,r,s,a,i,A,o,l)=>{let u=2===n.length,[c,d]=u?[0,1]:[2,3],h=e.type.value,f=i=>{let u=i===c?"row":"col";return`\n      fn ${u}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${h} {\n        var output_index = ${t.indicesGet("output_indices",i)};\n        var originalIdx: ${h} = getOriginalCoordinateFromResizedCoordinate(output_index, ${s[i]},\n        ${r[i]}, ${n[i]}, ${a[i]}, ${a[i]} + ${n.length});\n        var fractOriginalIdx: ${h} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${A} && (originalIdx < 0 || originalIdx > (${n[i]} - 1))) {\n          return ${o};\n        }\n        var data: array<${h}, 4> = array<${h}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${u}: ${h} = originalIdx + ${h}(i);\n          if (${u} < 0 || ${u} >= ${n[i]}) {\n            ${l?"coefs[i + 1] = 0.0;\n                        continue;":A?`return ${o};`:`${u} = max(0, min(${u}, ${n[i]} - 1));`};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet("input_indices_copy",i,`u32(${u})`)};\n          data[i + 1] = ${i===c?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${f(c)};\n    ${f(d)};\n  fn getCubicInterpolationCoefs(s: ${h}) -> array<${h}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${h}, 4> = array<${h}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${h} = 1.0 - absS;\n    var twoMinusAbsS: ${h} = 2.0 - absS;\n    var onePlusAbsS: ${h} = 1.0 + absS;\n    coeffs[0] = ((${i} * onePlusAbsS - 5 * ${i}) * onePlusAbsS + 8 * ${i}) * onePlusAbsS - 4 * ${i};\n    coeffs[1] = ((${i} + 2) * absS - (${i} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${i} + 2) * oneMinusAbsS - (${i} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${i} * twoMinusAbsS - 5 * ${i}) * twoMinusAbsS + 8 * ${i}) * twoMinusAbsS - 4 * ${i};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${h}, 4>, coefs: array<${h}, 4>) -> ${h} {\n    var coefsSum: ${h} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${h} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},_o=(e,t,n,r,s)=>{let[a,i,A,o,l]=3===n.length?[-1,0,1,2,-1]:[0,2,3,4,1],u=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${u} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",i,`max(0, min(depth, ${n[i]} - 1))`)};\n      ${e.indicesSet("input_indices",A,`max(0, min(height, ${n[A]} - 1))`)};\n      ${e.indicesSet("input_indices",o,`max(0, min(width, ${n[o]} - 1))`)};\n      ${Ro(e,l,a,3)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${u} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${u} = originalIndices[${i}];\n      var height:${u} = originalIndices[${A}];\n      var width:${u} = originalIndices[${o}];\n      ${r?`if (depth < 0 || depth > (${n[i]} - 1) || height < 0 || height > (${n[A]} - 1) || width < 0 || (width > ${n[o]} - 1)) {\n      return ${s};\n        }`:""};\n\n    depth = max(0, min(depth, ${n[i]} - 1));\n      height = max(0, min(height, ${n[A]} - 1));\n      width = max(0, min(width, ${n[o]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${n.length>3?`u32(originalIndices[${l}])`:"0"};\n      var batch: u32 =  ${n.length>3?`u32(originalIndices[${a}])`:"0"};\n\n      var x111: ${u} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${u} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${u} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${u} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${u} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${u} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${u} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${u} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${u} = abs(depth - ${u}(depth1));\n      var dx2: ${u} = abs(${u}(depth2) - depth);\n      var dy1: ${u} = abs(height - ${u}(height1));\n      var dy2: ${u} = abs(${u}(height2) - height);\n      var dz1: ${u} = abs(width - ${u}(width1));\n      var dz2: ${u} = abs(${u}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},Vo=(e,t,n,r,s,a)=>{let i=e.dims,A=Go(a,t.axes,i.length),o=Fo(i,r,s,t.axes),l=r.slice();0===r.length&&(l=i.map(((e,t)=>0===e?1:o[t]/e)),"stretch"!==t.keepAspectRatioPolicy&&(o=Po(i,l,t)));let u=wn("output",e.dataType,o.length),c=In("input",e.dataType,i.length),d=Nt.size(o),h=i.length===o.length&&i.every(((e,t)=>e===o[t])),f="tf_crop_and_resize"===t.coordinateTransformMode,g=t.extrapolationValue,p=c.type.value;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${l.length>0?"cubic"===t.mode?l:l.length:""}|${s.length>0?s:""}|${A.length>0?A:""}|${h}|${"nearest"===t.mode?i.length:i}`,inputDependencies:["rank"]},getShaderSource:e=>`\n      ${h?"":`\n      ${So(t.coordinateTransformMode,p)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${Oo(c,i)};\n              ${No(t.nearestMode,n,p)};\n              ${zo(c,u,i,o,l.length,A.length,f)};\n              `;case"linear":return`\n              ${Qo(u,i,o,l.length,A.length)};\n              ${(()=>{if(2===i.length||4===i.length)return`${Lo(c,u,i,f,g)}`;if(3===i.length||5===i.length)return`${_o(c,u,i,f,g)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\n            `;case"cubic":return`\n            ${(()=>{if(2===i.length||4===i.length)return`${Wo(c,u,i,o,l,A,t.cubicCoeffA,f,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${e.registerUniform("output_size","u32").registerUniform("scales","f32",l.length).registerUniform("roi","f32",A.length).declareVariables(c,u)}\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${h?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${u.offsetToIndices("global_idx")};\n        var input_indices: ${c.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${c.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return`output[global_idx] = ${2===i.length||4===i.length?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`,getRunData:()=>({outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},{type:1,data:l},{type:1,data:A},...hn(i,o)]})}},Ho=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Uo=(e,t)=>{let n=[],r=[],s=[],a=Ho(e);if(0!==t.antialias)throw Error("Only default value (0) for Antialias attribute is supported");Do(e.inputs,t,a,n,r,s),e.compute(Vo(e.inputs[0],t,a,n,r,s),{inputs:[0]})},jo=e=>{let t=e.antialias,n=e.axes,r=e.coordinateTransformMode,s=e.cubicCoeffA,a=0!==e.excludeOutside,i=e.extrapolationValue,A=e.keepAspectRatioPolicy,o=e.mode,l=""===e.nearestMode?"simple":e.nearestMode;return on({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:s,excludeOutside:a,extrapolationValue:i,keepAspectRatioPolicy:A,mode:o,nearestMode:l})}})),Mu=te((()=>{yl(),Bl(),Fl(),Yo=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(3!==t.dims.length&&2!==t.dims.length)throw new Error("Input must be 2D or 3D");if(3!==n.dims.length&&2!==n.dims.length)throw new Error("Skip must be 2D or 3D");let s=t.dims[t.dims.length-1],a=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==s)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==a)throw new Error("Skip must have the same sequence length as input");if(1!==r.dims.length)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==s)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let t=e[3];if(1!==t.dims.length)throw new Error("Beta must be 1D");if(t.dims[t.dims.length-1]!==s)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let t=e[4];if(1!==t.dims.length)throw new Error("Bias must be 1D");if(t.dims[t.dims.length-1]!==s)throw new Error("Bias must have the same hidden size as input")}},Ko=(e,t,n,r)=>{let s=t.simplified,a=e[0].dims,i=Nt.size(a),A=a,o=i,l=a.slice(-1)[0],u=r?a.slice(0,-1).concat(1):[],c=!s&&e.length>3,d=e.length>4,h=r&&n>1,f=r&&n>2,g=n>3,p=64,m=fn(l),b=[{type:12,data:o},{type:12,data:m},{type:12,data:l},{type:1,data:t.epsilon}],C=[{dims:A,dataType:e[0].dataType}];return n>1&&C.push({dims:u,dataType:1}),n>2&&C.push({dims:u,dataType:1}),n>3&&C.push({dims:a,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${m};${h};${f};${g}`,inputDependencies:e.map(((e,t)=>"type"))},getShaderSource:t=>{let n=[In("x",e[0].dataType,e[0].dims,m),In("skip",e[1].dataType,e[1].dims,m),In("gamma",e[2].dataType,e[2].dims,m)];c&&n.push(In("beta",e[3].dataType,e[3].dims,m)),d&&n.push(In("bias",e[4].dataType,e[4].dims,m)),n.push(wn("output",e[0].dataType,A,m)),h&&n.push(wn("mean_output",1,u)),f&&n.push(wn("inv_std_output",1,u)),g&&n.push(wn("input_skip_bias_sum",e[0].dataType,A,m));let r=cn(e[0].dataType),a=cn(1,m);return`\n\n      ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...n)}\n      var<workgroup> sum_shared : array<${a}, 64>;\n      var<workgroup> sum_squared_shared : array<${a}, 64>;\n\n      ${t.mainStart([p,1,1])}\n        let ix = local_id.x;\n        let iy = global_id.x / 64;\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / 64;\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == 63) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${d?"bias[offset1d + i]":r+"(0.0)"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${g?"input_skip_bias_sum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32_value = ${pn(r,m,"value")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = 64;\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${mn("sum",m)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${mn("square_sum",m)} / f32(uniforms.hidden_size) ${s?"":"- mean * mean"} + uniforms.epsilon);\n        ${h?"mean_output[global_idx] = mean;":""}\n        ${f?"inv_std_output[global_idx] = inv_std_dev;":""}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${s?"":`- ${r}(mean)`}) *\n            ${r}(inv_std_dev) * gamma[offset1d + i]\n            ${c?"+ beta[offset1d + i]":""};\n        }\n      }`},getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(o/l)},programUniforms:b})}},Xo=(e,t)=>{Yo(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(Ko(e.inputs,t,e.outputCount,!1),{outputs:n})}})),Du=te((()=>{yl(),Bl(),Gl(),Fl(),qo=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(0!==t.axes.length){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach(((t,n)=>{if(6!==e[n+1].dataType&&7!==e[n+1].dataType)throw new Error(`Input ${n} must be an array of int32 or int64`)}))},Zo=(e,t)=>{let n=[];if(e.length>t)if(7===e[t].dataType)e[t].getBigInt64Array().forEach((e=>n.push(Number(e))));else{if(6!==e[t].dataType)throw new Error(`Input ${t} must be an array of int32 or int64`);e[t].getInt32Array().forEach((e=>n.push(Number(e))))}return n},Jo=(e,t)=>{if(e.length>1){let t=Zo(e,1),n=Zo(e,2),r=Zo(e,3);return 0===r.length&&(r=[...Array(e[0].dims.length).keys()]),on({starts:t,ends:n,axes:r})}return t},$o=(e,t,n,r,s)=>{let a=e;return e<0&&(a+=n[r[t]]),s[t]<0?Math.max(0,Math.min(a,n[r[t]]-1)):Math.max(0,Math.min(a,n[r[t]]))},el=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${n.length}; i >= 0; i--) {\n            let input_shape_i = ${bn("uniforms.input_shape","i",n.length)};\n            let steps_i = ${bn("uniforms.steps","i",n.length)};\n            let signs_i = ${bn("uniforms.signs","i",n.length)};\n            let starts_i = ${bn("uniforms.starts","i",n.length)};\n            var output_index = ${t.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,tl=(e,t)=>{let n=e[0].dims,r=Nt.size(n),s=t.axes.length>0?Nt.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],a=Zo(e,4);a.forEach((e=>0!==e||(()=>{throw new Error("step cannot be 0")}))),0===a.length&&(a=Array(s.length).fill(1));let i=t.starts.map(((e,t)=>$o(e,t,n,s,a))),A=t.ends.map(((e,t)=>$o(e,t,n,s,a)));if(s.length!==i.length||s.length!==A.length)throw new Error("start, ends and axes should have the same number of elements");if(s.length!==n.length)for(let e=0;e<n.length;++e)s.includes(e)||(i.splice(e,0,0),A.splice(e,0,n[e]),a.splice(e,0,1));let o=a.map((e=>Math.sign(e)));a.forEach(((e,t,n)=>{if(e<0){let r=(A[t]-i[t])/e,s=i[t],o=s+r*a[t];i[t]=o,A[t]=s,n[t]=-e}}));let l=n.slice(0);s.forEach(((e,t)=>{l[e]=Math.ceil((A[e]-i[e])/a[e])}));let u={dims:l,dataType:e[0].dataType},c=wn("output",e[0].dataType,l.length),d=In("input",e[0].dataType,e[0].dims.length),h=Nt.size(l),f=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:i.length},{name:"signs",type:"i32",length:o.length},{name:"steps",type:"u32",length:a.length}],g=[{type:12,data:h},{type:12,data:i},{type:6,data:o},{type:12,data:a},...hn(e[0].dims,l)];return{name:"Slice",shaderCache:{hint:`${o.length}_${i.length}_${a.length}`,inputDependencies:["rank"]},getShaderSource:e=>`\n      ${e.registerUniforms(f).declareVariables(d,c)}\n        ${el(d,c,n)}\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${c.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${c.setByOffset("global_idx",d.getByIndices("input_indices"))}\n      }`,getRunData:()=>({outputs:[u],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:g})}},nl=(e,t)=>{qo(e.inputs,t);let n=Jo(e.inputs,t);e.compute(tl(e.inputs,n),{inputs:[0]})},rl=e=>{let t=e.starts,n=e.ends,r=e.axes;return on({starts:t,ends:n,axes:r})}})),Tu=te((()=>{yl(),Bl(),Gl(),Pl(),Fl(),sl=e=>{if(!e||1!==e.length)throw new Error("Softmax op requires 1 input.")},al=(e,t)=>{let n,r=e.inputs[0],s=r.dims,a=Nt.size(s),i=s.length,A=Nt.normalizeAxis(t.axis,i),o=A<s.length-1,l=[];o?(l=Array.from({length:i},((e,t)=>t)),l[A]=i-1,l[i-1]=A,n=e.compute(Nn(r,l),{inputs:[r],outputs:[-1]})[0]):n=r;let u=n.dims,c=u[i-1],d=a/c,h=fn(c),f=c/h,g=64;1===d&&(g=256);let p=In("x",n.dataType,n.dims,h),m=wn("result",n.dataType,n.dims,h),b=p.type.value,C="f32"===cn(n.dataType)?`var threadMax = ${b}(-3.402823e+38f);`:`var threadMax = ${b}(-65504.0h);`,I=e.compute({name:"Softmax",shaderCache:{hint:`${h};${g}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:u,dataType:n.dataType}],dispatchGroup:{x:d},programUniforms:[{type:6,data:f}]}),getShaderSource:e=>`\n      var<workgroup> rowMaxShared : ${b};\n      var<workgroup> rowSumShared : ${b};\n      var<workgroup> threadShared : array<${b}, ${g}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${b} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${b}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${e.registerUniform("packedCols","i32").declareVariables(p,m)}\n      ${e.mainStart(g)}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${g};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${C}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${b}(${((e,t)=>4===t?`max(max(${e}.x, ${e}.y), max(${e}.z, ${e}.w))`:2===t?`max(${e}.x, ${e}.y)`:3===t?`max(max(${e}.x, ${e}.y), ${e}.z)`:e)("threadShared[0]",h)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${b}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${b}(${mn("threadShared[0]",h)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`},{inputs:[n],outputs:[o?-1:0]})[0];o&&e.compute(Nn(I,l),{inputs:[I]})},il=(e,t)=>{sl(e.inputs),al(e,t)},Al=e=>on({axis:e.axis})})),Su=te((()=>{yl(),Bl(),Fl(),ol=e=>Array.from(e.getBigInt64Array(),Number),ll=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 inputs.");if(1!==e[0].dataType&&10!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(7!==e[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==e[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if(ol(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},ul=(e,t)=>{let n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n},cl=(e,t)=>{let n=e[0].dims,r=t??ol(e[1]),s=ul(n,r),a=Nt.size(s),i=e[0].dataType,A=In("input",i,n.length),o=wn("output",i,s.length);return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},...hn(e[0].dims,s)]}),getShaderSource:e=>`\n      const inputShape = ${A.indices(...n)};\n      ${e.registerUniform("output_size","u32").declareVariables(A,o)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${o.offsetToIndices("global_idx")};\n      var input_indices: ${A.type.indices};\n      for (var i = 0; i < ${n.length}; i++) {\n        let input_dim_i = ${A.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${o.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${A.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${o.setByOffset("global_idx",A.getByIndices("input_indices"))}\n    }`}},dl=e=>{ll(e.inputs),e.compute(cl(e.inputs),{inputs:[0]})}})),Nu=te((()=>{yl(),Bl(),Fl(),hl=(e,t,n,r,s)=>{let a,i=wn("output_data",s,n.length,4),A=In("a_data",t[1].dataType,t[1].dims.length,4),o=In("b_data",t[2].dataType,t[2].dims.length,4),l=In("c_data",t[0].dataType,t[0].dims.length,4),u=(e,t,n)=>`select(${t}, ${e}, ${n})`;if(r){let e=(e,t,n="")=>{let r=`a_data[index_a${t}][component_a${t}]`,s=`b_data[index_b${t}][component_b${t}]`,a=`bool(c_data[index_c${t}] & (0xffu << (component_c${t} * 8)))`;return`\n            let output_indices${t} = ${i.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offset_a${t} = ${A.broadcastedIndicesToOffset(`output_indices${t}`,i)};\n            let offset_b${t} = ${o.broadcastedIndicesToOffset(`output_indices${t}`,i)};\n            let offset_c${t} = ${l.broadcastedIndicesToOffset(`output_indices${t}`,i)};\n            let index_a${t} = offset_a${t} / 4u;\n            let index_b${t} = offset_b${t} / 4u;\n            let index_c${t} = offset_c${t} / 4u;\n            let component_a${t} = offset_a${t} % 4u;\n            let component_b${t} = offset_b${t} % 4u;\n            let component_c${t} = offset_c${t} % 4u;\n            ${e}[${t}] = ${n}(${u(r,s,a)});\n          `};a=9===s?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("output_data[global_idx]",0)}\n            ${e("output_data[global_idx]",1)}\n            ${e("output_data[global_idx]",2)}\n            ${e("output_data[global_idx]",3)}\n          `}else a=i.setByOffset("global_idx",u(A.getByOffset("global_idx"),o.getByOffset("global_idx"),l.getByOffset("global_idx")));return`\n        ${e.registerUniform("vec_size","u32").declareVariables(l,A,o,i)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${a}\n      }`},fl=e=>{let t=e[1].dims,n=e[2].dims,r=e[0].dims,s=e[1].dataType,a=!(Nt.areEqual(t,n)&&Nt.areEqual(n,r)),i=t,A=Nt.size(t);if(a){let e=St.calcShape(St.calcShape(t,n,!1),r,!1);if(!e)throw new Error("Can't perform where op on the given tensors");i=e,A=Nt.size(i)}let o=Math.ceil(A/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:t=>hl(t,e,i,a,s),getRunData:()=>({outputs:[{dims:i,dataType:s}],dispatchGroup:{x:Math.ceil(A/64/4)},programUniforms:[{type:12,data:o},...hn(r,t,n,i)]})}},gl=e=>{e.compute(fl(e.inputs))}})),Gu=te((()=>{Ol(),Rl(),Ll(),Wl(),Vl(),Hl(),Ul(),eu(),nu(),ru(),su(),au(),iu(),Au(),ou(),lu(),uu(),cu(),du(),hu(),mu(),bu(),Cu(),Iu(),wu(),fu(),ku(),xu(),yu(),vu(),Eu(),zl(),Bu(),pu(),Mu(),Du(),Tu(),gu(),Su(),Pl(),_l(),Nu(),pl=new Map([["Abs",[Xr]],["Acos",[qr]],["Acosh",[Zr]],["Add",[Hs]],["ArgMax",[Tr,Sr]],["ArgMin",[Dr,Sr]],["Asin",[Jr]],["Asinh",[$r]],["Atan",[es]],["Atanh",[ts]],["Attention",[Rr]],["AveragePool",[so,ro]],["BatchNormalization",[Vr]],["BiasAdd",[jr]],["BiasSplitGelu",[Ls]],["Cast",[rs,ns]],["Ceil",[is]],["Clip",[as]],["Concat",[sa,aa]],["Conv",[Va,Ra]],["ConvTranspose",[$a,Xa]],["Cos",[As]],["Cosh",[os]],["CumSum",[ti,ni]],["DepthToSpace",[ii,Ai]],["DequantizeLinear",[po,mo]],["Div",[Us]],["Einsum",[pi,mi]],["Elu",[us,ls]],["Equal",[js]],["Erf",[ds]],["Exp",[hs]],["Expand",[ki]],["FastGelu",[yi]],["Floor",[fs]],["FusedConv",[Va,Ra]],["Gather",[Mi,Bi]],["GatherElements",[Ri,Oi]],["GatherBlockQuantized",[Fi,Pi]],["GatherND",[Ti,Si]],["Gelu",[gs]],["Gemm",[Vi,_i]],["GlobalAveragePool",[Ao,io]],["GlobalMaxPool",[ho,co]],["Greater",[qs]],["GreaterOrEqual",[Js]],["GridSample",[tA,nA]],["GroupQueryAttention",[yA]],["HardSigmoid",[xs,ks]],["InstanceNormalization",[MA]],["LayerNormalization",[SA]],["LeakyRelu",[ps,ls]],["Less",[Zs]],["LessOrEqual",[$s]],["Log",[Fs]],["MatMul",[GA]],["MatMulNBits",[zA,OA]],["MaxPool",[lo,uo]],["Mul",[Ys]],["MultiHeadAttention",[lA,aA]],["Neg",[bs]],["Not",[ms]],["Pad",[YA]],["Pow",[Ks]],["QuickGelu",[zs,ls]],["Range",[Io]],["Reciprocal",[Cs]],["ReduceMin",[xr]],["ReduceMean",[br]],["ReduceMax",[kr]],["ReduceSum",[vr]],["ReduceProd",[yr]],["ReduceL1",[Cr]],["ReduceL2",[Ir]],["ReduceLogSum",[Br]],["ReduceLogSumExp",[wr]],["ReduceSumSquare",[Er]],["Relu",[Is]],["Resize",[Uo,jo]],["RotaryEmbedding",[CA]],["ScatterND",[Eo,vo]],["Sigmoid",[ws]],["Sin",[ys]],["Sinh",[vs]],["Slice",[nl,rl]],["SkipLayerNormalization",[Xo]],["Split",[gA,pA]],["Sqrt",[Es]],["Softmax",[il,Al]],["Sub",[Xs]],["Tan",[Bs]],["Tanh",[Ds]],["ThresholdedRelu",[Gs,ls]],["Tile",[dl]],["Transpose",[Gn,Fn]],["Where",[gl]]])})),Fu=te((()=>{xe(),El(),Fl(),ml=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r,s){U(e.programInfo.name);let a=this.backend.device,i=this.backend.getComputePassEncoder();this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber);let A=[];for(let e of t)A.push({binding:A.length,resource:{buffer:e.buffer}});for(let e of n)A.push({binding:A.length,resource:{buffer:e.buffer}});s&&A.push({binding:A.length,resource:s});let o=a.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:A,label:e.programInfo.name});if("capturing"===this.backend.sessionStatus){let t={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:o,dispatchGroup:r};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(t)}i.setPipeline(e.computePipeline),i.setBindGroup(0,o),i.dispatchWorkgroups(...r),this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||"at-passes"===this.backend.queryType)&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),j(e.programInfo.name)}dispose(){}build(e,t){U(e.name);let n=this.backend.device,r=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach((e=>{n.features.has(e.feature)&&r.push(`enable ${e.extension};`)}));let s=vn(t,this.backend.device.limits),a=e.getShaderSource(s),i=`${r.join("\n")}\n${s.additionalImplementations}\n${a}`,A=n.createShaderModule({code:i,label:e.name});Dt("verbose",(()=>`[WebGPU] ${e.name} shader code: ${i}`));let o=n.createComputePipeline({compute:{module:A,entryPoint:"main"},layout:"auto",label:e.name});return j(e.name),{programInfo:e,computePipeline:o,uniformVariablesInfo:s.variablesInfo}}normalizeDispatchGroupSize(e){let t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,r="number"==typeof e?1:e.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=s&&n<=s&&r<=s)return[t,n,r];let a=t*n*r,i=Math.ceil(Math.sqrt(a));if(i>s){if(i=Math.ceil(Math.cbrt(a)),i>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[i,i,i]}return[i,i,1]}}})),Pu={};ne(Pu,{WebGpuBackend:()=>Ru});var Qu,zu,Ou,Ru,Lu=te((()=>{xe(),yl(),El(),Ml(),Nl(),Gu(),Fu(),Qu=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let r=0;r<e.length;++r){let s=e[r].dataType;switch(t[r]){case"none":n.push("");break;case"type":n.push(`${s}`);break;case"rank":{let t=e[r].dims.length;n.push(`${s};${t}`);break}case"dims":{let t=e[r].dims.join(",");n.push(`${s};${t}`);break}default:throw new Error(`unsupported input dependency: ${t[r]}`)}}return n.join("|")},zu=(e,t,n)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=":"+n+`:${Qu(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},Ou=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},Ru=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,t){this.env=e;let n=[],r={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},s=e=>t.features.has(e)&&n.push(e)&&!0;s("chromium-experimental-timestamp-query-inside-passes")||s("timestamp-query"),s("shader-f16"),s("subgroups"),this.device=await t.requestDevice(r),this.adapterInfo=new Ou(t.info||await t.requestAdapterInfo()),this.gpuDataManager=an(this),this.programManager=new ml(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Bt(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:t,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),t={};"at-passes"===this.queryType&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:2*this.pendingDispatchNumber,endOfPassWriteIndex:2*this.pendingDispatchNumber+1}),this.computePassEncoder=e.beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;let e;U(),this.endComputePass(),"none"!==this.queryType&&(this.commandEncoder.resolveQuerySet(this.querySet,0,2*this.pendingDispatchNumber,this.queryResolveBuffer,0),e=this.device.createBuffer({size:2*this.pendingDispatchNumber*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,2*this.pendingDispatchNumber*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,"none"!==this.queryType&&e.mapAsync(GPUMapMode.READ).then((()=>{let t=new BigUint64Array(e.getMappedRange()),n=this.pendingQueries.get(e);for(let e=0;e<t.length/2;e++){let r=n[e],s=r.kernelId,a=this.kernels.get(s),i=a.kernelType,A=a.kernelName,o=r.programName,l=r.inputTensorViews,u=r.outputTensorViews,c=t[2*e],d=t[2*e+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=c);let h=Number(c-this.queryTimeBase),f=Number(d-this.queryTimeBase);if(!Number.isSafeInteger(h)||!Number.isSafeInteger(f))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:l.map((e=>({dims:e.dims,dataType:gt(e.dataType)}))),outputsMetadata:u.map((e=>({dims:e.dims,dataType:gt(e.dataType)}))),kernelId:s,kernelType:i,kernelName:A,programName:o,startTime:h,endTime:f});else{let e="";l.forEach(((t,n)=>{e+=`input[${n}]: [${t.dims}] | ${gt(t.dataType)}, `}));let t="";u.forEach(((e,n)=>{t+=`output[${n}]: [${e.dims}] | ${gt(e.dataType)}, `})),console.log(`[profiling] kernel "${s}|${i}|${A}|${o}" ${e}${t}execution time: ${f-h} ns`)}V("GPU",`${o}::${c}::${d}`)}e.unmap(),this.pendingQueries.delete(e)})),j()}run(e,t,n,r,s,a){U(e.name);let i=[];for(let e=0;e<t.length;++e){let n=t[e].data;if(0===n)continue;let r=this.gpuDataManager.get(n);if(!r)throw new Error(`no GPU data for input: ${n}`);i.push(r)}let{outputs:A,dispatchGroup:o,programUniforms:l}=e.getRunData(t),u=0===n.length?A.map(((e,t)=>t)):n;if(u.length!==A.length)throw new Error(`Output size ${u.length} must be equal to ${A.length}.`);let c,d=[],h=[];for(let e=0;e<A.length;++e){if(!Number.isInteger(u[e])||u[e]<-3||u[e]>=a)throw new Error(`Invalid output index: ${u[e]}`);if(-3===u[e])continue;let t=-1===u[e],n=-2===u[e],i=t||n?s(A[e].dataType,A[e].dims):r(u[e],A[e].dataType,A[e].dims);if(d.push(i),0===i.data)continue;let o=this.gpuDataManager.get(i.data);if(!o)throw new Error(`no GPU data for output: ${i.data}`);if(t&&this.temporaryData.push(o),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(o)}h.push(o)}if(i.length!==t.length||h.length!==d.length){if(0===h.length)return j(e.name),d;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}if(l){let e=0,t=[];l.forEach((n=>{let r="number"==typeof n.data?[n.data]:n.data;if(0===r.length)return;let s,a,i=10===n.type?2:4;10===n.type?(a=r.length>4?16:r.length>2?8:r.length*i,s=r.length>4?16:i*r.length):(a=r.length<=2?r.length*i:16,s=16),e=Math.ceil(e/a)*a,t.push(e);let A=10===n.type?8:4;e+=r.length>4?Math.ceil(r.length/A)*s:r.length*i}));let n=16;e=Math.ceil(e/n)*n;let r=new ArrayBuffer(e);l.forEach(((e,n)=>{let s=t[n],a="number"==typeof e.data?[e.data]:e.data;if(6===e.type)new Int32Array(r,s,a.length).set(a);else if(12===e.type)new Uint32Array(r,s,a.length).set(a);else if(10===e.type)new Uint16Array(r,s,a.length).set(a);else{if(1!==e.type)throw new Error(`Unsupported uniform type: ${gt(e.type)}`);new Float32Array(r,s,a.length).set(a)}}));let s=this.gpuDataManager.create(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(s.buffer,0,r,0,e),this.gpuDataManager.release(s.id),c={offset:0,size:e,buffer:s.buffer}}let f=this.programManager.normalizeDispatchGroupSize(o),g=1===f[1]&&1===f[2],p=zu(e,t,g),m=this.programManager.getArtifact(p);if(m||(m=this.programManager.build(e,f),this.programManager.setArtifact(p,m),Dt("info",(()=>`[artifact] key: ${p}, programName: ${e.name}`))),l&&m.uniformVariablesInfo){if(l.length!==m.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${m.uniformVariablesInfo.length}, got ${l.length} in program "${m.programInfo.name}".`);for(let e=0;e<l.length;e++){let t=l[e],n=t.type,r="number"==typeof t.data?1:t.data.length,[s,a]=m.uniformVariablesInfo[e];if(n!==s||r!==a)throw new Error(`Uniform variable ${e} mismatch: expect type ${s} with size ${a}, got type ${n} with size ${r} in program "${m.programInfo.name}".`)}}if(Dt("info",(()=>`[ProgramManager] run "${e.name}" (key=${p}) with ${f[0]}x${f[1]}x${f[2]}`)),"none"!==this.queryType||"capturing"===this.sessionStatus){let e={kernelId:this.currentKernelId,programName:m.programInfo.name,inputTensorViews:t,outputTensorViews:d};this.pendingKernels.push(e),"capturing"===this.sessionStatus&&this.capturedPendingKernels.get(this.currentSessionId).push(e)}return this.programManager.run(m,i,h,f,c),j(e.name),d}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,r){let s=pl.get(e);if(!s)throw new Error(`kernel not implemented: ${e}`);let a={kernelType:e,kernelName:r,kernelEntry:s[0],attributes:[s[1],n]};this.kernels.set(t,a)}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let r=this.kernels.get(e);if(!r)throw new Error(`kernel not created: ${e}`);let s=r.kernelType,a=r.kernelName,i=r.kernelEntry,A=r.attributes;if(null!==this.currentKernelId)throw new Error(`kernel "[${s}] ${a}" is not allowed to be called recursively`);this.currentKernelId=e,A[0]&&(A[1]=A[0](A[1]),A[0]=void 0),Dt("info",(()=>`[WebGPU] Start to run kernel "[${s}] ${a}"...`));let o=this.env.debug;this.temporaryData=[];try{return o&&this.device.pushErrorScope("validation"),i(t,A[1]),0}catch(e){return n.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${a}" failed. ${e}`)),1}finally{o&&n.push(this.device.popErrorScope().then((e=>e?`GPU validation error for kernel "[${s}] ${a}": ${e.message}`:null)));for(let e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,r){let s=this.sessionExternalDataMapping.get(e);s||(s=new Map,this.sessionExternalDataMapping.set(e,s));let a=s.get(t),i=this.gpuDataManager.registerExternalBuffer(n,r,a);return s.set(t,[i,n]),i}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach((e=>this.gpuDataManager.unregisterExternalBuffer(e[0]))),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let r=await rn(this,e,t);return zt(r.buffer,n)}}writeTimestamp(e){"inside-passes"===this.queryType&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){this.queryType="none",("default"===this.env.webgpu.profiling?.mode||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),"none"!==this.queryType&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2*this.maxDispatchNumber}),this.queryResolveBuffer=this.device.createBuffer({size:2*this.maxDispatchNumber*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Dt("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Dt("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Dt("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),t=this.capturedPendingKernels.get(this.currentSessionId),n=e.length;this.pendingKernels=[];for(let r=0;r<n;r++){let n=this.getComputePassEncoder(),s=e[r];this.writeTimestamp(2*this.pendingDispatchNumber),n.setPipeline(s.computePipeline),n.setBindGroup(0,s.bindGroup),n.dispatchWorkgroups(...s.dispatchGroup),this.writeTimestamp(2*this.pendingDispatchNumber+1),this.pendingDispatchNumber++,"none"!==this.queryType&&this.pendingKernels.push(t[r]),(this.pendingDispatchNumber>=this.maxDispatchNumber||"at-passes"===this.queryType)&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}})),Wu={};ne(Wu,{init:()=>Hu});var _u,Vu,Hu,Uu,ju,Yu,Ku,Xu,qu,Zu,Ju,$u,ec,tc,nc,rc,sc,ac,ic,Ac,oc,lc,uc,cc,dc,hc,fc,gc,pc,mc,bc,Cc,Ic,wc,kc,xc,yc,vc=te((()=>{yl(),El(),Bl(),Tl(),_u=class e{constructor(e,t,n,r){this.module=e,this.dataType=t,this.data=n,this.dims=r}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");let e=Nt.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");let e=Nt.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");let e=Nt.size(this.dims);return 0===e?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}getUint16Array(){if(10!==this.dataType&&4!==this.dataType)throw new Error("Invalid data type");let e=Nt.size(this.dims);return 0===e?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,e)}reshape(t){if(Nt.size(t)!==Nt.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Vu=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=t.adapterInfo;let r=e.PTR_SIZE,s=n/e.PTR_SIZE,a=4===r?"i32":"i64";this.opKernelContext=Number(e.getValue(r*s++,a));let i=Number(e.getValue(r*s++,a));this.outputCount=Number(e.getValue(r*s++,a)),this.customDataOffset=Number(e.getValue(r*s++,"*")),this.customDataSize=Number(e.getValue(r*s++,a));let A=[];for(let t=0;t<i;t++){let t=Number(e.getValue(r*s++,a)),n=Number(e.getValue(r*s++,"*")),i=Number(e.getValue(r*s++,a)),o=[];for(let t=0;t<i;t++)o.push(Number(e.getValue(r*s++,a)));A.push(new _u(e,t,n,o))}this.inputs=A}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){let n=t?.inputs?.map((e=>"number"==typeof e?this.inputs[e]:e))??this.inputs,r=t?.outputs??[];return this.backend.run(e,n,r,((e,t,n)=>new _u(this.module,t,this.output(e,n),n)),((e,t)=>{let n=pt(e,t);if(!n)throw new Error(`Unsupported data type: ${e}`);let r=n>0?this.backend.gpuDataManager.create(n).id:0;return new _u(this.module,e,r,t)}),this.outputCount)}output(e,t){let n=this.module.stackSave();try{let n=this.module.PTR_SIZE,r=4===n?"i32":"i64",s=this.module.stackAlloc((1+t.length)*n);this.module.setValue(s,t.length,r);for(let e=0;e<t.length;e++)this.module.setValue(s+n*(e+1),t[e],r);return this.module._JsepOutput(this.opKernelContext,e,s)}catch(n){throw new Error(`Failed to generate kernel's output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(n)}}},Hu=async(e,t,n,r)=>{let s=t.jsepInit;if(!s)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if("webgpu"===e){let e=new(0,(Lu(),re(Pu)).WebGpuBackend);await e.initialize(n,r),s("webgpu",[e,t=>e.alloc(Number(t)),t=>e.free(t),(n,r,s,a=!1)=>{if(a)Dt("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(n)}, dst=${Number(r)}, size=${Number(s)}`)),e.memcpy(Number(n),Number(r));else{Dt("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(n)}, gpuDataId=${Number(r)}, size=${Number(s)}`));let a=t.HEAPU8.subarray(Number(n>>>0),Number(n>>>0)+Number(s));e.upload(Number(r),a)}},async(n,r,s)=>{Dt("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${r}, size=${s}`)),await e.download(Number(n),(()=>t.HEAPU8.subarray(Number(r)>>>0,Number(r+s)>>>0)))},(n,r,s)=>e.createKernel(n,Number(r),s,t.UTF8ToString(t._JsepGetNodeName(Number(r)))),t=>e.releaseKernel(t),(n,r,s,a)=>{Dt("verbose",(()=>`[WebGPU] jsepRun: sessionHandle=${s}, kernel=${n}, contextDataOffset=${r}`));let i=new Vu(t,e,Number(r));return e.computeKernel(Number(n),i,a)},()=>e.captureBegin(),()=>e.captureEnd(),()=>e.replay()])}else{let e=new qt(n);s("webnn",[e,()=>e.reserveTensorId(),t=>e.releaseTensorId(t),async(t,n,r,s,a)=>e.ensureTensor(t,n,r,s,a),(t,n)=>{e.uploadTensor(t,n)},async(t,n)=>e.downloadTensor(t,n)])}}})),Ec=te((()=>{kl(),xl(),yl(),Il(),wl(),vl(),Uu=(e,t)=>{0!==rt()._OrtInit(e,t)&&it("Can't initialize onnxruntime.")},ju=async e=>{Uu(e.wasm.numThreads,bt(e.logLevel))},Yu=async(e,t)=>{rt().asyncInit?.();{let n=(vc(),re(Wu)).init;if("webgpu"===t){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let t=e.webgpu.adapter;if(t){if("object"!=typeof t.limits||"object"!=typeof t.features||"function"!=typeof t.requestDevice)throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let n=e.webgpu.powerPreference;if(void 0!==n&&"low-power"!==n&&"high-performance"!==n)throw new Error(`Invalid powerPreference setting: "${n}"`);let r=e.webgpu.forceFallbackAdapter;if(void 0!==r&&"boolean"!=typeof r)throw new Error(`Invalid forceFallbackAdapter setting: "${r}"`);if(t=await navigator.gpu.requestAdapter({powerPreference:n,forceFallbackAdapter:r}),!t)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await n("webgpu",rt(),e,t)}if("webnn"===t){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await n("webnn",rt(),e)}}},Ku=new Map,Xu=e=>{let t=rt(),n=t.stackSave();try{let n=t.PTR_SIZE,r=t.stackAlloc(2*n);0!==t._OrtGetInputOutputCount(e,r,r+n)&&it("Can't get session input/output count.");let s=4===n?"i32":"i64";return[Number(t.getValue(r,s)),Number(t.getValue(r+n,s))]}finally{t.stackRestore(n)}},qu=(e,t)=>{let n=rt(),r=n.stackSave(),s=0;try{let r=n.PTR_SIZE,a=n.stackAlloc(2*r);0!==n._OrtGetInputOutputMetadata(e,t,a,a+r)&&it("Can't get session input/output metadata.");let i=Number(n.getValue(a,"*"));s=Number(n.getValue(a+r,"*"));let A=n.HEAP32[s/4];if(0===A)return[i,0];let o=n.HEAPU32[s/4+1],l=[];for(let e=0;e<o;e++){let t=Number(n.getValue(s+8+e*r,"*"));l.push(0!==t?n.UTF8ToString(t):Number(n.getValue(s+8+(e+o)*r,"*")))}return[i,A,l]}finally{n.stackRestore(r),0!==s&&n._OrtFree(s)}},Zu=e=>{let t=rt(),n=t._malloc(e.byteLength);if(0===n)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Ju=async(e,t)=>{let n,r,s=rt();Array.isArray(e)?[n,r]=e:e.buffer===s.HEAPU8.buffer?[n,r]=[e.byteOffset,e.byteLength]:[n,r]=Zu(e);let a=0,i=0,A=0,o=[],l=[],u=[];try{if([i,o]=await ht(t),t?.externalData&&s.mountExternalData){let e=[];for(let n of t.externalData){let t="string"==typeof n?n:n.path;e.push(kt("string"==typeof n?n:n.data).then((e=>{s.mountExternalData(t,e)})))}await Promise.all(e)}for(let e of t?.executionProviders??[])if("webnn"===("string"==typeof e?e:e.name)){if(s.shouldTransferToMLTensor=!1,"string"!=typeof e){let t=e,n=t?.context,r=t?.gpuDevice,a=t?.deviceType,i=t?.powerPreference;s.currentContext=n||(r?await s.webnnCreateMLContext(r):await s.webnnCreateMLContext({deviceType:a,powerPreference:i}))}else s.currentContext=await s.webnnCreateMLContext();break}a=await s._OrtCreateSession(n,r,i),s.webgpuOnCreateSession?.(a),0===a&&it("Can't create a session."),s.jsepOnCreateSession?.(),s.currentContext&&(s.webnnRegisterMLContext(a,s.currentContext),s.currentContext=void 0,s.shouldTransferToMLTensor=!0);let[e,c]=Xu(a),d=!!t?.enableGraphCapture,h=[],f=[],g=[],p=[],m=[];for(let t=0;t<e;t++){let[e,n,r]=qu(a,t);0===e&&it("Can't get an input name."),l.push(e);let i=s.UTF8ToString(e);h.push(i),g.push(0===n?{name:i,isTensor:!1}:{name:i,isTensor:!0,type:gt(n),shape:r})}for(let n=0;n<c;n++){let[r,i,A]=qu(a,n+e);0===r&&it("Can't get an output name."),u.push(r);let o=s.UTF8ToString(r);f.push(o),p.push(0===i?{name:o,isTensor:!1}:{name:o,isTensor:!0,type:gt(i),shape:A});{if(d&&void 0===t?.preferredOutputLocation){m.push("gpu-buffer");continue}let e="string"==typeof t?.preferredOutputLocation?t.preferredOutputLocation:t?.preferredOutputLocation?.[o]??"cpu";if("cpu"!==e&&"cpu-pinned"!==e&&"gpu-buffer"!==e&&"ml-tensor"!==e)throw new Error(`Not supported preferred output location: ${e}.`);if(d&&"gpu-buffer"!==e)throw new Error(`Not supported preferred output location: ${e}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);m.push(e)}}let b=null;return m.some((e=>"gpu-buffer"===e||"ml-tensor"===e))&&(A=s._OrtCreateBinding(a),0===A&&it("Can't create IO binding."),b={handle:A,outputPreferredLocations:m,outputPreferredLocationsEncoded:m.map((e=>wt(e)))}),Ku.set(a,[a,l,u,b,d,!1]),[a,h,f,g,p]}catch(e){throw l.forEach((e=>s._OrtFree(e))),u.forEach((e=>s._OrtFree(e))),0!==A&&0!==s._OrtReleaseBinding(A)&&it("Can't release IO binding."),0!==a&&0!==s._OrtReleaseSession(a)&&it("Can't release session."),e}finally{s._free(n),0!==i&&0!==s._OrtReleaseSessionOptions(i)&&it("Can't release session options."),o.forEach((e=>s._free(e))),s.unmountExternalData?.()}},$u=e=>{let t=rt(),n=Ku.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[r,s,a,i,A]=n;i&&(A&&0!==t._OrtClearBoundOutputs(i.handle)&&it("Can't clear bound outputs."),0!==t._OrtReleaseBinding(i.handle)&&it("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),t.webnnOnReleaseSession?.(e),t.webgpuOnReleaseSession?.(e),s.forEach((e=>t._OrtFree(e))),a.forEach((e=>t._OrtFree(e))),0!==t._OrtReleaseSession(r)&&it("Can't release session."),Ku.delete(e)},ec=async(e,t,n,r,s,a,i=!1)=>{if(!e)return void t.push(0);let A,o,l=rt(),u=l.PTR_SIZE,c=e[0],d=e[1],h=e[3],f=h;if("string"===c&&("gpu-buffer"===h||"ml-tensor"===h))throw new Error("String tensor is not supported on GPU.");if(i&&"gpu-buffer"!==h)throw new Error(`External buffer must be provided for input/output index ${a} when enableGraphCapture is true.`);if("gpu-buffer"===h){let t=e[2].gpuBuffer;o=pt(ft(c),d);{let e=l.jsepRegisterBuffer;if(!e)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');A=e(r,a,t,o)}}else if("ml-tensor"===h){let t=e[2].mlTensor;o=pt(ft(c),d);let n=l.webnnRegisterMLTensor;if(!n)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');A=n(r,t,ft(c),d)}else{let t=e[2];if(Array.isArray(t)){o=u*t.length,A=l._malloc(o),n.push(A);for(let e=0;e<t.length;e++){if("string"!=typeof t[e])throw new TypeError(`tensor data at index ${e} is not a string`);l.setValue(A+e*u,st(t[e],n),"*")}}else{let e=l.webnnIsGraphInput;if("string"!==c&&e){if(e(r,l.UTF8ToString(s))){let e=ft(c);o=pt(e,d),f="ml-tensor";let n=l.webnnCreateTemporaryTensor,s=l.webnnUploadTensor;if(!n||!s)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let a=await n(r,e,d);s(a,new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),A=a}else o=t.byteLength,A=l._malloc(o),n.push(A),l.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),A)}else o=t.byteLength,A=l._malloc(o),n.push(A),l.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),A)}}let g=l.stackSave(),p=l.stackAlloc(4*d.length);try{d.forEach(((e,t)=>l.setValue(p+t*u,e,4===u?"i32":"i64")));let e=l._OrtCreateTensor(ft(c),A,o,p,d.length,wt(f));0===e&&it(`Can't create tensor for input/output. session=${r}, index=${a}.`),t.push(e)}finally{l.stackRestore(g)}},tc=async(e,t,n,r,s,a)=>{let i=rt(),A=i.PTR_SIZE,o=Ku.get(e);if(!o)throw new Error(`cannot run inference. invalid session id: ${e}`);let l=o[0],u=o[1],c=o[2],d=o[3],h=o[4],f=o[5],g=t.length,p=r.length,m=0,b=[],C=[],I=[],w=[],k=i.stackSave(),x=i.stackAlloc(g*A),y=i.stackAlloc(g*A),v=i.stackAlloc(p*A),E=i.stackAlloc(p*A);try{[m,b]=At(a);for(let r=0;r<g;r++)await ec(n[r],C,w,e,u[t[r]],t[r],h);for(let t=0;t<p;t++)await ec(s[t],I,w,e,c[r[t]],g+r[t],h);for(let e=0;e<g;e++)i.setValue(x+e*A,C[e],"*"),i.setValue(y+e*A,u[t[e]],"*");for(let e=0;e<p;e++)i.setValue(v+e*A,I[e],"*"),i.setValue(E+e*A,c[r[e]],"*");if(d&&!f){let{handle:n,outputPreferredLocations:a,outputPreferredLocationsEncoded:A}=d;if(u.length!==g)throw new Error(`input count from feeds (${g}) is expected to be always equal to model's input count (${u.length}).`);for(let r=0;r<g;r++){let s=t[r];0!==await i._OrtBindInput(n,u[s],C[r])&&it(`Can't bind input[${r}] for session=${e}.`)}for(let t=0;t<p;t++){let o=r[t];s[t]?.[3]?0!==i._OrtBindOutput(n,c[o],I[t],0)&&it(`Can't bind pre-allocated output[${t}] for session=${e}.`):0!==i._OrtBindOutput(n,c[o],0,A[o])&&it(`Can't bind output[${t}] to ${a[t]} for session=${e}.`)}Ku.set(e,[l,u,c,d,h,!0])}let o;i.jsepOnRunStart?.(l),i.webnnOnRunStart?.(l),o=d?await i._OrtRunWithBinding(l,d.handle,p,v,m):await i._OrtRun(l,y,x,g,E,p,v,m),0!==o&&it("failed to call OrtRun().");let k=[];for(let t=0;t<p;t++){let n=Number(i.getValue(v+t*A,"*"));if(n===I[t]){k.push(s[t]);continue}let a,o=i.stackSave(),u=i.stackAlloc(4*A),c=!1,h=0;try{0!==i._OrtGetTensorData(n,u,u+A,u+2*A,u+3*A)&&it(`Can't access output tensor data on index ${t}.`);let s=4===A?"i32":"i64",o=Number(i.getValue(u,s));h=i.getValue(u+A,"*");let l=i.getValue(u+2*A,"*"),f=Number(i.getValue(u+3*A,s)),g=[];for(let e=0;e<f;e++)g.push(Number(i.getValue(l+e*A,s)));0!==i._OrtFree(l)&&it("Can't free memory for tensor dims.");let p=g.reduce(((e,t)=>e*t),1);a=gt(o);let m=d?.outputPreferredLocations[r[t]];if("string"===a){if("gpu-buffer"===m||"ml-tensor"===m)throw new Error("String tensor is not supported on GPU.");let e=[];for(let t=0;t<p;t++){let n=i.getValue(h+t*A,"*"),r=i.getValue(h+(t+1)*A,"*"),s=t===p-1?void 0:r-n;e.push(i.UTF8ToString(n,s))}k.push([a,g,e,"cpu"])}else if("gpu-buffer"===m&&p>0){let e=i.jsepGetBuffer;if(!e)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let t=e(h),r=pt(o,p);if(void 0===r||!Ct(a))throw new Error(`Unsupported data type: ${a}`);c=!0,k.push([a,g,{gpuBuffer:t,download:i.jsepCreateDownloader(t,r,a),dispose:()=>{0!==i._OrtReleaseTensor(n)&&it("Can't release tensor.")}},"gpu-buffer"])}else if("ml-tensor"===m&&p>0){let t=i.webnnEnsureTensor,r=i.webnnIsInt64Supported;if(!t||!r)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(void 0===pt(o,p)||!It(a))throw new Error(`Unsupported data type: ${a}`);if("int64"===a&&!r(e))throw new Error('preferredLocation "ml-tensor" for int64 output is not supported by current WebNN Context.');let s=await t(e,h,o,g,!1);c=!0,k.push([a,g,{mlTensor:s,download:i.webnnCreateMLTensorDownloader(h,a),dispose:()=>{i.webnnReleaseTensorId(h),i._OrtReleaseTensor(n)}},"ml-tensor"])}else{let e=new(mt(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(i.HEAPU8.subarray(h,h+e.byteLength)),k.push([a,g,e,"cpu"])}}finally{i.stackRestore(o),"string"===a&&h&&i._free(h),c||i._OrtReleaseTensor(n),i.webnnOnRunEnd?.(l)}}return d&&!h&&(0!==i._OrtClearBoundOutputs(d.handle)&&it("Can't clear bound outputs."),Ku.set(e,[l,u,c,d,h,!1])),k}finally{i.stackRestore(k),C.forEach((e=>i._OrtReleaseTensor(e))),I.forEach((e=>i._OrtReleaseTensor(e))),w.forEach((e=>i._free(e))),0!==m&&i._OrtReleaseRunOptions(m),b.forEach((e=>i._free(e)))}},nc=e=>{let t=rt(),n=Ku.get(e);if(!n)throw new Error("invalid session id");let r=n[0],s=t._OrtEndProfiling(r);0===s&&it("Can't get an profile file name."),t._OrtFree(s)},rc=e=>{let t=[];for(let n of e){let e=n[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}})),Bc=te((()=>{xe(),Ec(),Il(),Cl(),sc=()=>!!E.wasm.proxy&&typeof document<"u",ic=!1,Ac=!1,oc=!1,cc=new Map,dc=(e,t)=>{let n=cc.get(e);n?n.push(t):cc.set(e,[t])},hc=()=>{if(ic||!Ac||oc||!ac)throw new Error("worker not ready")},fc=e=>{switch(e.data.type){case"init-wasm":ic=!1,e.data.err?(oc=!0,uc[1](e.data.err)):(Ac=!0,uc[0]()),lc&&(URL.revokeObjectURL(lc),lc=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=cc.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},gc=async()=>{if(!Ac){if(ic)throw new Error("multiple calls to 'initWasm()' detected.");if(oc)throw new Error("previous call to 'initWasm()' failed.");if(ic=!0,sc())return new Promise(((e,t)=>{ac?.terminate(),je().then((([n,r])=>{try{(ac=r).onerror=e=>t(e),ac.onmessage=fc,uc=[e,t];let s={type:"init-wasm",in:E};!s.in.wasm.wasmPaths&&(n||Qe)&&(s.in.wasm.wasmPaths={wasm:new URL("ort-wasm-simd-threaded.jsep.wasm",import.meta.url).href}),ac.postMessage(s),lc=n}catch(e){t(e)}}),t)}));try{await nt(E.wasm),await ju(E),Ac=!0}catch(e){throw oc=!0,e}finally{ic=!1}}},pc=async e=>{if(sc())return hc(),new Promise(((t,n)=>{dc("init-ep",[t,n]);let r={type:"init-ep",in:{epName:e,env:E}};ac.postMessage(r)}));await Yu(E,e)},mc=async e=>sc()?(hc(),new Promise(((t,n)=>{dc("copy-from",[t,n]);let r={type:"copy-from",in:{buffer:e}};ac.postMessage(r,[e.buffer])}))):Zu(e),bc=async(e,t)=>{if(sc()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return hc(),new Promise(((n,r)=>{dc("create",[n,r]);let s={type:"create",in:{model:e,options:{...t}}},a=[];e instanceof Uint8Array&&a.push(e.buffer),ac.postMessage(s,a)}))}return Ju(e,t)},Cc=async e=>{if(sc())return hc(),new Promise(((t,n)=>{dc("release",[t,n]);let r={type:"release",in:e};ac.postMessage(r)}));$u(e)},Ic=async(e,t,n,r,s,a)=>{if(sc()){if(n.some((e=>"cpu"!==e[3])))throw new Error("input tensor on GPU is not supported for proxy.");if(s.some((e=>e)))throw new Error("pre-allocated output tensor is not supported for proxy.");return hc(),new Promise(((s,i)=>{dc("run",[s,i]);let A=n,o={type:"run",in:{sessionId:e,inputIndices:t,inputs:A,outputIndices:r,options:a}};ac.postMessage(o,rc(A))}))}return tc(e,t,n,r,s,a)},wc=async e=>{if(sc())return hc(),new Promise(((t,n)=>{dc("end-profiling",[t,n]);let r={type:"end-profiling",in:e};ac.postMessage(r)}));nc(e)}})),Mc=te((()=>{xe(),Bc(),yl(),ye(),vl(),kc=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},xc=e=>{switch(e[3]){case"cpu":return new _(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!Ct(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:s}=e[2];return _.fromGpuBuffer(n,{dataType:t,dims:e[1],download:r,dispose:s})}case"ml-tensor":{let t=e[0];if(!It(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:r,dispose:s}=e[2];return _.fromMLTensor(n,{dataType:t,dims:e[1],download:r,dispose:s})}default:throw new Error(`invalid data location: ${e[3]}`)}},yc=class{async fetchModelAndCopyToWasmMemory(e){return mc(await kt(e))}async loadModel(e,t){let n;U(),n="string"==typeof e?await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await bc(n,t),j()}async dispose(){return Cc(this.sessionId)}async run(e,t,n){U();let r=[],s=[];Object.entries(e).forEach((e=>{let t=e[0],n=e[1],a=this.inputNames.indexOf(t);if(-1===a)throw new Error(`invalid input '${t}'`);r.push(n),s.push(a)}));let a=[],i=[];Object.entries(t).forEach((e=>{let t=e[0],n=e[1],r=this.outputNames.indexOf(t);if(-1===r)throw new Error(`invalid output '${t}'`);a.push(n),i.push(r)}));let A=r.map(((e,t)=>kc(e,(()=>`input "${this.inputNames[s[t]]}"`)))),o=a.map(((e,t)=>e?kc(e,(()=>`output "${this.outputNames[i[t]]}"`)):null)),l=await Ic(this.sessionId,s,A,i,o,n),u={};for(let e=0;e<l.length;e++)u[this.outputNames[i[e]]]=a[e]??xc(l[e]);return j(),u}startProfiling(){}endProfiling(){wc(this.sessionId)}}})),Dc={};ne(Dc,{OnnxruntimeWebAssemblyBackend:()=>Sc,initializeFlags:()=>Tc,wasmBackend:()=>Nc});var Tc,Sc,Nc,Gc=te((()=>{xe(),Bc(),Mc(),Tc=()=>{("number"!=typeof E.wasm.initTimeout||E.wasm.initTimeout<0)&&(E.wasm.initTimeout=0);let e=E.wasm.simd;if("boolean"!=typeof e&&void 0!==e&&"fixed"!==e&&"relaxed"!==e&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${e}". Reset it to \`false\` and ignore SIMD feature checking.`),E.wasm.simd=!1),"boolean"!=typeof E.wasm.proxy&&(E.wasm.proxy=!1),"boolean"!=typeof E.wasm.trace&&(E.wasm.trace=!1),"number"!=typeof E.wasm.numThreads||!Number.isInteger(E.wasm.numThreads)||E.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)E.wasm.numThreads=1;else{let e=typeof navigator>"u"?ee("node:os").cpus().length:navigator.hardwareConcurrency;E.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},Sc=class{async init(e){Tc(),await gc(),await pc(e)}async createInferenceSessionHandler(e,t){let n=new yc;return await n.loadModel(e,t),n}},Nc=new Sc}));xe(),xe(),xe();var Fc=ke;{let e=(Gc(),re(Dc)).wasmBackend;I("webgpu",e,5),I("webnn",e,5),I("cpu",e,10),I("wasm",e,10)}Object.defineProperty(E.versions,"web",{value:"1.22.0-dev.20250409-89f8206ba4",enumerable:!0});var Pc,Qc,zc=Object.freeze({__proto__:null,get InferenceSession(){return K},get TRACE(){return V},get TRACE_FUNC_BEGIN(){return U},get TRACE_FUNC_END(){return j},get Tensor(){return _},default:Fc,get env(){return E},get registerBackend(){return I}}),Oc={"onnxruntime-common":e=>{e.exports=X},"onnxruntime-web":e=>{e.exports=zc},"?2ce3":()=>{},"?7a2c":()=>{},"?a42a":()=>{},"?2b25":()=>{},"?569f":()=>{},"?3f59":()=>{},"?154a":()=>{},"./node_modules/@huggingface/jinja/dist/index.js":(e,t,n)=>{n.r(t),n.d(t,{Environment:()=>te,Interpreter:()=>ne,Template:()=>ue,parse:()=>O,tokenize:()=>u});var r=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",NullLiteral:"NullLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndSet:"EndSet",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator",Macro:"Macro",EndMacro:"EndMacro",Break:"Break",Continue:"Continue"}),s=Object.freeze({set:r.Set,for:r.For,in:r.In,is:r.Is,if:r.If,else:r.Else,endset:r.EndSet,endif:r.EndIf,elif:r.ElseIf,endfor:r.EndFor,and:r.And,or:r.Or,not:r.Not,"not in":r.NotIn,macro:r.Macro,endmacro:r.EndMacro,break:r.Break,continue:r.Continue,true:r.BooleanLiteral,false:r.BooleanLiteral,none:r.NullLiteral,True:r.BooleanLiteral,False:r.BooleanLiteral,None:r.NullLiteral}),a=class{constructor(e,t){this.value=e,this.type=t}};function i(e){return/\w/.test(e)}function A(e){return/[0-9]/.test(e)}var o=[["{%",r.OpenStatement],["%}",r.CloseStatement],["{{",r.OpenExpression],["}}",r.CloseExpression],["(",r.OpenParen],[")",r.CloseParen],["{",r.OpenCurlyBracket],["}",r.CloseCurlyBracket],["[",r.OpenSquareBracket],["]",r.CloseSquareBracket],[",",r.Comma],[".",r.Dot],[":",r.Colon],["|",r.Pipe],["<=",r.ComparisonBinaryOperator],[">=",r.ComparisonBinaryOperator],["==",r.ComparisonBinaryOperator],["!=",r.ComparisonBinaryOperator],["<",r.ComparisonBinaryOperator],[">",r.ComparisonBinaryOperator],["+",r.AdditiveBinaryOperator],["-",r.AdditiveBinaryOperator],["*",r.MultiplicativeBinaryOperator],["/",r.MultiplicativeBinaryOperator],["%",r.MultiplicativeBinaryOperator],["=",r.Equals]],l=new Map([["n","\n"],["t","\t"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function u(e,t={}){const n=[],u=function(e,t={}){return e.endsWith("\n")&&(e=e.slice(0,-1)),e=e.replace(/{#.*?#}/gs,"{##}"),t.lstrip_blocks&&(e=e.replace(/^[ \t]*({[#%])/gm,"$1")),t.trim_blocks&&(e=e.replace(/([#%]})\n/g,"$1")),e.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}(e,t);let c=0;const d=e=>{let t="";for(;e(u[c]);)if("\\"!==u[c]){if(t+=u[c++],c>=u.length)throw new SyntaxError("Unexpected end of input")}else{if(++c,c>=u.length)throw new SyntaxError("Unexpected end of input");const e=u[c++],n=l.get(e);if(void 0===n)throw new SyntaxError(`Unexpected escaped character: ${e}`);t+=n}return t};e:for(;c<u.length;){const e=n.at(-1)?.type;if(void 0===e||e===r.CloseStatement||e===r.CloseExpression){let e="";for(;c<u.length&&("{"!==u[c]||"%"!==u[c+1]&&"{"!==u[c+1]);)e+=u[c++];if(e.length>0){n.push(new a(e,r.Text));continue}}d((e=>/\s/.test(e)));const t=u[c];if("-"===t||"+"===t){const e=n.at(-1)?.type;if(e===r.Text||void 0===e)throw new SyntaxError(`Unexpected character: ${t}`);switch(e){case r.Identifier:case r.NumericLiteral:case r.BooleanLiteral:case r.NullLiteral:case r.StringLiteral:case r.CloseParen:case r.CloseSquareBracket:break;default:{++c;const e=d(A);n.push(new a(`${t}${e}`,e.length>0?r.NumericLiteral:r.UnaryOperator));continue}}}for(const[e,t]of o){if(u.slice(c,c+e.length)===e){n.push(new a(e,t)),c+=e.length;continue e}}if("'"!==t&&'"'!==t)if(A(t)){const e=d(A);n.push(new a(e,r.NumericLiteral))}else{if(!i(t))throw new SyntaxError(`Unexpected character: ${t}`);{const e=d(i),t=Object.hasOwn(s,e)?s[e]:r.Identifier;t===r.In&&n.at(-1)?.type===r.Not?(n.pop(),n.push(new a("not in",r.NotIn))):n.push(new a(e,t))}}else{++c;const e=d((e=>e!==t));n.push(new a(e,r.StringLiteral)),++c}}return n}var c=class{type="Statement"},d=class extends c{constructor(e){super(),this.body=e}type="Program"},h=class extends c{constructor(e,t,n){super(),this.test=e,this.body=t,this.alternate=n}type="If"},f=class extends c{constructor(e,t,n,r){super(),this.loopvar=e,this.iterable=t,this.body=n,this.defaultBlock=r}type="For"},g=class extends c{type="Break"},p=class extends c{type="Continue"},m=class extends c{constructor(e,t,n){super(),this.assignee=e,this.value=t,this.body=n}type="Set"},b=class extends c{constructor(e,t,n){super(),this.name=e,this.args=t,this.body=n}type="Macro"},C=class extends c{type="Expression"},I=class extends C{constructor(e,t,n){super(),this.object=e,this.property=t,this.computed=n}type="MemberExpression"},w=class extends C{constructor(e,t){super(),this.callee=e,this.args=t}type="CallExpression"},k=class extends C{constructor(e){super(),this.value=e}type="Identifier"},x=class extends C{constructor(e){super(),this.value=e}type="Literal"},y=class extends x{type="NumericLiteral"},v=class extends x{type="StringLiteral"},E=class extends x{type="BooleanLiteral"},B=class extends x{type="NullLiteral"},M=class extends x{type="ArrayLiteral"},D=class extends x{type="TupleLiteral"},T=class extends x{type="ObjectLiteral"},S=class extends C{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}type="BinaryExpression"},N=class extends C{constructor(e,t){super(),this.operand=e,this.filter=t}type="FilterExpression"},G=class extends C{constructor(e,t){super(),this.iterable=e,this.test=t}type="SelectExpression"},F=class extends C{constructor(e,t,n){super(),this.operand=e,this.negate=t,this.test=n}type="TestExpression"},P=class extends C{constructor(e,t){super(),this.operator=e,this.argument=t}type="UnaryExpression"},Q=class extends C{constructor(e=void 0,t=void 0,n=void 0){super(),this.start=e,this.stop=t,this.step=n}type="SliceExpression"},z=class extends C{constructor(e,t){super(),this.key=e,this.value=t}type="KeywordArgumentExpression"};function O(e){const t=new d([]);let n=0;function s(t,r){const s=e[n++];if(!s||s.type!==t)throw new Error(`Parser Error: ${r}. ${s.type} !== ${t}.`);return s}function a(){switch(e[n].type){case r.Text:return new v(s(r.Text,"Expected text token").value);case r.OpenStatement:return function(){let t;switch(s(r.OpenStatement,"Expected opening statement token"),e[n].type){case r.Set:++n,t=function(){const t=u();if(A(r.Equals)){++n;const e=u();return new m(t,e,[])}{const i=[];for(s(r.CloseStatement,"Expected %} token");e[n]?.type!==r.OpenStatement||e[n+1]?.type!==r.EndSet;){const e=a();i.push(e)}return s(r.OpenStatement,"Expected {% token"),s(r.EndSet,"Expected endset token"),new m(t,null,i)}}(),s(r.CloseStatement,"Expected closing statement token");break;case r.If:++n,t=o(),s(r.OpenStatement,"Expected {% token"),s(r.EndIf,"Expected endif token"),s(r.CloseStatement,"Expected %} token");break;case r.Macro:++n,t=function(){const e=U();if("Identifier"!==e.type)throw new SyntaxError("Expected identifier following macro statement");const t=L();s(r.CloseStatement,"Expected closing statement token");const n=[];for(;i(r.OpenStatement,r.EndMacro);)n.push(a());return new b(e,t,n)}(),s(r.OpenStatement,"Expected {% token"),s(r.EndMacro,"Expected endmacro token"),s(r.CloseStatement,"Expected %} token");break;case r.For:++n,t=function(){const e=l(!0);if(!(e instanceof k||e instanceof D))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${e.type} instead`);s(r.In,"Expected `in` keyword following loop variable");const t=u();s(r.CloseStatement,"Expected closing statement token");const o=[];for(;i(r.OpenStatement,r.EndFor)&&i(r.OpenStatement,r.Else);)o.push(a());const c=[];if(A(r.OpenStatement,r.Else))for(++n,++n,s(r.CloseStatement,"Expected closing statement token");i(r.OpenStatement,r.EndFor);)c.push(a());return new f(e,t,o,c)}(),s(r.OpenStatement,"Expected {% token"),s(r.EndFor,"Expected endfor token"),s(r.CloseStatement,"Expected %} token");break;case r.Break:++n,s(r.CloseStatement,"Expected closing statement token"),t=new g;break;case r.Continue:++n,s(r.CloseStatement,"Expected closing statement token"),t=new p;break;default:throw new SyntaxError(`Unknown statement type: ${e[n].type}`)}return t}();case r.OpenExpression:return function(){s(r.OpenExpression,"Expected opening expression token");const e=u();return s(r.CloseExpression,"Expected closing expression token"),e}();default:throw new SyntaxError(`Unexpected token type: ${e[n].type}`)}}function i(...t){return n+t.length<=e.length&&t.some(((t,r)=>t!==e[n+r].type))}function A(...t){return n+t.length<=e.length&&t.every(((t,r)=>t===e[n+r].type))}function o(){const t=u();s(r.CloseStatement,"Expected closing statement token");const i=[],l=[];for(;e[n]?.type!==r.OpenStatement||e[n+1]?.type!==r.ElseIf&&e[n+1]?.type!==r.Else&&e[n+1]?.type!==r.EndIf;)i.push(a());if(e[n]?.type===r.OpenStatement&&e[n+1]?.type!==r.EndIf)if(++n,A(r.ElseIf))s(r.ElseIf,"Expected elseif token"),l.push(o());else for(s(r.Else,"Expected else token"),s(r.CloseStatement,"Expected closing statement token");e[n]?.type!==r.OpenStatement||e[n+1]?.type!==r.EndIf;)l.push(a());return new h(t,i,l)}function l(e=!1){const t=e?U:u,s=[t()],a=A(r.Comma);for(;a&&(++n,s.push(t()),A(r.Comma)););return a?new D(s):s[0]}function u(){return function(){const e=c();if(A(r.If)){++n;const t=c();if(A(r.Else)){++n;const r=c();return new h(t,[e],[r])}return new G(e,t)}return e}()}function c(){let t=C();for(;A(r.Or);){const r=e[n];++n;const s=C();t=new S(r,t,s)}return t}function C(){let t=x();for(;A(r.And);){const r=e[n];++n;const s=x();t=new S(r,t,s)}return t}function x(){let t;for(;A(r.Not);){const r=e[n];++n;const s=x();t=new P(r,s)}return t??function(){let t=O();for(;A(r.ComparisonBinaryOperator)||A(r.In)||A(r.NotIn);){const r=e[n];++n;const s=O();t=new S(r,t,s)}return t}()}function O(){let t=V();for(;A(r.AdditiveBinaryOperator);){const r=e[n];++n;const s=V();t=new S(r,t,s)}return t}function R(e){let t=new w(e,L());return t=_(t),A(r.OpenParen)&&(t=R(t)),t}function L(){s(r.OpenParen,"Expected opening parenthesis for arguments list");const e=function(){const e=[];for(;!A(r.CloseParen);){let t=u();if(A(r.Equals)){if(++n,!(t instanceof k))throw new SyntaxError("Expected identifier for keyword argument");const e=u();t=new z(t,e)}e.push(t),A(r.Comma)&&++n}return e}();return s(r.CloseParen,"Expected closing parenthesis for arguments list"),e}function W(){const e=[];let t=!1;for(;!A(r.CloseSquareBracket);)A(r.Colon)?(e.push(void 0),++n,t=!0):(e.push(u()),A(r.Colon)&&(++n,t=!0));if(0===e.length)throw new SyntaxError("Expected at least one argument for member/slice expression");if(t){if(e.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new Q(...e)}return e[0]}function _(t){for(;A(r.Dot)||A(r.OpenSquareBracket);){const a=e[n];let i;++n;const A=a.type!==r.Dot;if(A)i=W(),s(r.CloseSquareBracket,"Expected closing square bracket");else if(i=U(),"Identifier"!==i.type)throw new SyntaxError("Expected identifier following dot operator");t=new I(t,i,A)}return t}function V(){let t=H();for(;A(r.MultiplicativeBinaryOperator);){const r=e[n];++n;const s=H();t=new S(r,t,s)}return t}function H(){let e=function(){let e=function(){const e=_(U());return A(r.OpenParen)?R(e):e}();for(;A(r.Pipe);){++n;let t=U();if(!(t instanceof k))throw new SyntaxError("Expected identifier for the filter");A(r.OpenParen)&&(t=R(t)),e=new N(e,t)}return e}();for(;A(r.Is);){++n;const t=A(r.Not);t&&++n;let s=U();if(s instanceof E?s=new k(s.value.toString()):s instanceof B&&(s=new k("none")),!(s instanceof k))throw new SyntaxError("Expected identifier for the test");e=new F(e,t,s)}return e}function U(){const t=e[n];switch(t.type){case r.NumericLiteral:return++n,new y(Number(t.value));case r.StringLiteral:return++n,new v(t.value);case r.BooleanLiteral:return++n,new E("true"===t.value.toLowerCase());case r.NullLiteral:return++n,new B(null);case r.Identifier:return++n,new k(t.value);case r.OpenParen:{++n;const t=l();if(e[n].type!==r.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${e[n].type} instead`);return++n,t}case r.OpenSquareBracket:{++n;const e=[];for(;!A(r.CloseSquareBracket);)e.push(u()),A(r.Comma)&&++n;return++n,new M(e)}case r.OpenCurlyBracket:{++n;const e=new Map;for(;!A(r.CloseCurlyBracket);){const t=u();s(r.Colon,"Expected colon between key and value in object literal");const a=u();e.set(t,a),A(r.Comma)&&++n}return++n,new T(e)}default:throw new SyntaxError(`Unexpected token: ${t.type}`)}}for(;n<e.length;)t.body.push(a());return t}function R(e,t,n=1){void 0===t&&(t=e,e=0);const r=[];for(let s=e;s<t;s+=n)r.push(s);return r}function L(e,t,n,r=1){const s=Math.sign(r);s>=0?(t=(t??=0)<0?Math.max(e.length+t,0):Math.min(t,e.length),n=(n??=e.length)<0?Math.max(e.length+n,0):Math.min(n,e.length)):(t=(t??=e.length-1)<0?Math.max(e.length+t,-1):Math.min(t,e.length-1),n=(n??=-1)<-1?Math.max(e.length+n,-1):Math.min(n,e.length-1));const a=[];for(let i=t;s*i<s*n;i+=r)a.push(e[i]);return a}function W(e){return e.replace(/\b\w/g,(e=>e.toUpperCase()))}var _=class extends Error{},V=class extends Error{},H=class{type="RuntimeValue";value;builtins=new Map;constructor(e=void 0){this.value=e}__bool__(){return new Y(!!this.value)}},U=class extends H{type="NumericValue"},j=class extends H{type="StringValue";builtins=new Map([["upper",new J((()=>new j(this.value.toUpperCase())))],["lower",new J((()=>new j(this.value.toLowerCase())))],["strip",new J((()=>new j(this.value.trim())))],["title",new J((()=>new j(W(this.value))))],["length",new U(this.value.length)],["rstrip",new J((()=>new j(this.value.trimEnd())))],["lstrip",new J((()=>new j(this.value.trimStart())))],["startswith",new J((e=>{if(0===e.length)throw new Error("startswith() requires at least one argument");const t=e[0];if(!(t instanceof j))throw new Error("startswith() argument must be a string");return new Y(this.value.startsWith(t.value))}))],["endswith",new J((e=>{if(0===e.length)throw new Error("endswith() requires at least one argument");const t=e[0];if(!(t instanceof j))throw new Error("endswith() argument must be a string");return new Y(this.value.endsWith(t.value))}))],["split",new J((e=>{const t=e[0]??new $;if(!(t instanceof j||t instanceof $))throw new Error("sep argument must be a string or null");const n=e[1]??new U(-1);if(!(n instanceof U))throw new Error("maxsplit argument must be a number");let r=[];if(t instanceof $){const e=this.value.trimStart();for(const{0:t,index:s}of e.matchAll(/\S+/g)){if(-1!==n.value&&r.length>=n.value&&void 0!==s){r.push(t+e.slice(s+t.length));break}r.push(t)}}else{if(""===t.value)throw new Error("empty separator");r=this.value.split(t.value),-1!==n.value&&r.length>n.value&&r.push(r.splice(n.value).join(t.value))}return new q(r.map((e=>new j(e))))}))]])},Y=class extends H{type="BooleanValue"},K=class extends H{type="ObjectValue";__bool__(){return new Y(this.value.size>0)}builtins=new Map([["get",new J((([e,t])=>{if(!(e instanceof j))throw new Error(`Object key must be a string: got ${e.type}`);return this.value.get(e.value)??t??new $}))],["items",new J((()=>new q(Array.from(this.value.entries()).map((([e,t])=>new q([new j(e),t]))))))]])},X=class extends K{type="KeywordArgumentsValue"},q=class extends H{type="ArrayValue";builtins=new Map([["length",new U(this.value.length)]]);__bool__(){return new Y(this.value.length>0)}},Z=class extends q{type="TupleValue"},J=class extends H{type="FunctionValue"},$=class extends H{type="NullValue"},ee=class extends H{type="UndefinedValue"},te=class{constructor(e){this.parent=e}variables=new Map([["namespace",new J((e=>{if(0===e.length)return new K(new Map);if(1!==e.length||!(e[0]instanceof K))throw new Error("`namespace` expects either zero arguments or a single object argument");return e[0]}))]]);tests=new Map([["boolean",e=>"BooleanValue"===e.type],["callable",e=>e instanceof J],["odd",e=>{if("NumericValue"!==e.type)throw new Error(`Cannot apply test "odd" to type: ${e.type}`);return e.value%2!=0}],["even",e=>{if("NumericValue"!==e.type)throw new Error(`Cannot apply test "even" to type: ${e.type}`);return e.value%2==0}],["false",e=>"BooleanValue"===e.type&&!e.value],["true",e=>"BooleanValue"===e.type&&e.value],["none",e=>"NullValue"===e.type],["string",e=>"StringValue"===e.type],["number",e=>"NumericValue"===e.type],["integer",e=>"NumericValue"===e.type&&Number.isInteger(e.value)],["iterable",e=>"ArrayValue"===e.type||"StringValue"===e.type],["mapping",e=>"ObjectValue"===e.type],["lower",e=>{const t=e.value;return"StringValue"===e.type&&t===t.toLowerCase()}],["upper",e=>{const t=e.value;return"StringValue"===e.type&&t===t.toUpperCase()}],["none",e=>"NullValue"===e.type],["defined",e=>"UndefinedValue"!==e.type],["undefined",e=>"UndefinedValue"===e.type],["equalto",(e,t)=>e.value===t.value],["eq",(e,t)=>e.value===t.value]]);set(e,t){return this.declareVariable(e,re(t))}declareVariable(e,t){if(this.variables.has(e))throw new SyntaxError(`Variable already declared: ${e}`);return this.variables.set(e,t),t}setVariable(e,t){return this.variables.set(e,t),t}resolve(e){if(this.variables.has(e))return this;if(this.parent)return this.parent.resolve(e);throw new Error(`Unknown variable: ${e}`)}lookupVariable(e){try{return this.resolve(e).variables.get(e)??new ee}catch{return new ee}}},ne=class{global;constructor(e){this.global=e??new te}run(e){return this.evaluate(e,this.global)}evaluateBinaryExpression(e,t){const n=this.evaluate(e.left,t);switch(e.operator.value){case"and":return n.__bool__().value?this.evaluate(e.right,t):n;case"or":return n.__bool__().value?n:this.evaluate(e.right,t)}const r=this.evaluate(e.right,t);switch(e.operator.value){case"==":return new Y(n.value==r.value);case"!=":return new Y(n.value!=r.value)}if(n instanceof ee||r instanceof ee)throw new Error("Cannot perform operation on undefined values");if(n instanceof $||r instanceof $)throw new Error("Cannot perform operation on null values");if(n instanceof U&&r instanceof U)switch(e.operator.value){case"+":return new U(n.value+r.value);case"-":return new U(n.value-r.value);case"*":return new U(n.value*r.value);case"/":return new U(n.value/r.value);case"%":return new U(n.value%r.value);case"<":return new Y(n.value<r.value);case">":return new Y(n.value>r.value);case">=":return new Y(n.value>=r.value);case"<=":return new Y(n.value<=r.value)}else if(n instanceof q&&r instanceof q){if("+"===e.operator.value)return new q(n.value.concat(r.value))}else if(r instanceof q){const t=void 0!==r.value.find((e=>e.value===n.value));switch(e.operator.value){case"in":return new Y(t);case"not in":return new Y(!t)}}if((n instanceof j||r instanceof j)&&"+"===e.operator.value)return new j(n.value.toString()+r.value.toString());if(n instanceof j&&r instanceof j)switch(e.operator.value){case"in":return new Y(r.value.includes(n.value));case"not in":return new Y(!r.value.includes(n.value))}if(n instanceof j&&r instanceof K)switch(e.operator.value){case"in":return new Y(r.value.has(n.value));case"not in":return new Y(!r.value.has(n.value))}throw new SyntaxError(`Unknown operator "${e.operator.value}" between ${n.type} and ${r.type}`)}evaluateArguments(e,t){const n=[],r=new Map;for(const s of e)if("KeywordArgumentExpression"===s.type){const e=s;r.set(e.key.value,this.evaluate(e.value,t))}else{if(r.size>0)throw new Error("Positional arguments must come before keyword arguments");n.push(this.evaluate(s,t))}return[n,r]}evaluateFilterExpression(e,t){const n=this.evaluate(e.operand,t);if("Identifier"===e.filter.type){const t=e.filter;if("tojson"===t.value)return new j(se(n));if(n instanceof q)switch(t.value){case"list":return n;case"first":return n.value[0];case"last":return n.value[n.value.length-1];case"length":return new U(n.value.length);case"reverse":return new q(n.value.reverse());case"sort":return new q(n.value.sort(((e,t)=>{if(e.type!==t.type)throw new Error(`Cannot compare different types: ${e.type} and ${t.type}`);switch(e.type){case"NumericValue":return e.value-t.value;case"StringValue":return e.value.localeCompare(t.value);default:throw new Error(`Cannot compare type: ${e.type}`)}})));case"join":return new j(n.value.map((e=>e.value)).join(""));case"string":return new j(se(n));default:throw new Error(`Unknown ArrayValue filter: ${t.value}`)}else if(n instanceof j)switch(t.value){case"length":return new U(n.value.length);case"upper":return new j(n.value.toUpperCase());case"lower":return new j(n.value.toLowerCase());case"title":return new j(W(n.value));case"capitalize":return new j(n.value.charAt(0).toUpperCase()+n.value.slice(1));case"trim":return new j(n.value.trim());case"indent":return new j(n.value.split("\n").map(((e,t)=>0===t||0===e.length?e:"    "+e)).join("\n"));case"join":case"string":return n;default:throw new Error(`Unknown StringValue filter: ${t.value}`)}else{if(n instanceof U){if("abs"===t.value)return new U(Math.abs(n.value));throw new Error(`Unknown NumericValue filter: ${t.value}`)}if(n instanceof K)switch(t.value){case"items":return new q(Array.from(n.value.entries()).map((([e,t])=>new q([new j(e),t]))));case"length":return new U(n.value.size);default:throw new Error(`Unknown ObjectValue filter: ${t.value}`)}}throw new Error(`Cannot apply filter "${t.value}" to type: ${n.type}`)}if("CallExpression"===e.filter.type){const r=e.filter;if("Identifier"!==r.callee.type)throw new Error(`Unknown filter: ${r.callee.type}`);const s=r.callee.value;if("tojson"===s){const[,e]=this.evaluateArguments(r.args,t),s=e.get("indent")??new $;if(!(s instanceof U||s instanceof $))throw new Error("If set, indent must be a number");return new j(se(n,s.value))}if("join"===s){let e;if(n instanceof j)e=Array.from(n.value);else{if(!(n instanceof q))throw new Error(`Cannot apply filter "${s}" to type: ${n.type}`);e=n.value.map((e=>e.value))}const[a,i]=this.evaluateArguments(r.args,t),A=a.at(0)??i.get("separator")??new j("");if(!(A instanceof j))throw new Error("separator must be a string");return new j(e.join(A.value))}if(n instanceof q){switch(s){case"selectattr":case"rejectattr":{const e="selectattr"===s;if(n.value.some((e=>!(e instanceof K))))throw new Error(`\`${s}\` can only be applied to array of objects`);if(r.args.some((e=>"StringLiteral"!==e.type)))throw new Error(`arguments of \`${s}\` must be strings`);const[a,i,A]=r.args.map((e=>this.evaluate(e,t)));let o;if(i){const e=t.tests.get(i.value);if(!e)throw new Error(`Unknown test: ${i.value}`);o=e}else o=(...e)=>e[0].__bool__().value;const l=n.value.filter((t=>{const n=t.value.get(a.value),r=!!n&&o(n,A);return e?r:!r}));return new q(l)}case"map":{const[,e]=this.evaluateArguments(r.args,t);if(e.has("attribute")){const t=e.get("attribute");if(!(t instanceof j))throw new Error("attribute must be a string");const r=e.get("default"),s=n.value.map((e=>{if(!(e instanceof K))throw new Error("items in map must be an object");return e.value.get(t.value)??r??new ee}));return new q(s)}throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${s}`)}if(n instanceof j){if("indent"===s){const[e,s]=this.evaluateArguments(r.args,t),a=e.at(0)??s.get("width")??new U(4);if(!(a instanceof U))throw new Error("width must be a number");const i=e.at(1)??s.get("first")??new Y(!1),A=e.at(2)??s.get("blank")??new Y(!1),o=n.value.split("\n"),l=" ".repeat(a.value),u=o.map(((e,t)=>!i.value&&0===t||!A.value&&0===e.length?e:l+e));return new j(u.join("\n"))}throw new Error(`Unknown StringValue filter: ${s}`)}throw new Error(`Cannot apply filter "${s}" to type: ${n.type}`)}throw new Error(`Unknown filter: ${e.filter.type}`)}evaluateTestExpression(e,t){const n=this.evaluate(e.operand,t),r=t.tests.get(e.test.value);if(!r)throw new Error(`Unknown test: ${e.test.value}`);const s=r(n);return new Y(e.negate?!s:s)}evaluateUnaryExpression(e,t){const n=this.evaluate(e.argument,t);if("not"===e.operator.value)return new Y(!n.value);throw new SyntaxError(`Unknown operator: ${e.operator.value}`)}evalProgram(e,t){return this.evaluateBlock(e.body,t)}evaluateBlock(e,t){let n="";for(const r of e){const e=this.evaluate(r,t);"NullValue"!==e.type&&"UndefinedValue"!==e.type&&(n+=e.value)}return new j(n)}evaluateIdentifier(e,t){return t.lookupVariable(e.value)}evaluateCallExpression(e,t){const[n,r]=this.evaluateArguments(e.args,t);r.size>0&&n.push(new X(r));const s=this.evaluate(e.callee,t);if("FunctionValue"!==s.type)throw new Error(`Cannot call something that is not a function: got ${s.type}`);return s.value(n,t)}evaluateSliceExpression(e,t,n){if(!(e instanceof q||e instanceof j))throw new Error("Slice object must be an array or string");const r=this.evaluate(t.start,n),s=this.evaluate(t.stop,n),a=this.evaluate(t.step,n);if(!(r instanceof U||r instanceof ee))throw new Error("Slice start must be numeric or undefined");if(!(s instanceof U||s instanceof ee))throw new Error("Slice stop must be numeric or undefined");if(!(a instanceof U||a instanceof ee))throw new Error("Slice step must be numeric or undefined");return e instanceof q?new q(L(e.value,r.value,s.value,a.value)):new j(L(Array.from(e.value),r.value,s.value,a.value).join(""))}evaluateMemberExpression(e,t){const n=this.evaluate(e.object,t);let r,s;if(e.computed){if("SliceExpression"===e.property.type)return this.evaluateSliceExpression(n,e.property,t);r=this.evaluate(e.property,t)}else r=new j(e.property.value);if(n instanceof K){if(!(r instanceof j))throw new Error(`Cannot access property with non-string: got ${r.type}`);s=n.value.get(r.value)??n.builtins.get(r.value)}else if(n instanceof q||n instanceof j)if(r instanceof U)s=n.value.at(r.value),n instanceof j&&(s=new j(n.value.at(r.value)));else{if(!(r instanceof j))throw new Error(`Cannot access property with non-string/non-number: got ${r.type}`);s=n.builtins.get(r.value)}else{if(!(r instanceof j))throw new Error(`Cannot access property with non-string: got ${r.type}`);s=n.builtins.get(r.value)}return s instanceof H?s:new ee}evaluateSet(e,t){const n=e.value?this.evaluate(e.value,t):this.evaluateBlock(e.body,t);if("Identifier"===e.assignee.type){const r=e.assignee.value;t.setVariable(r,n)}else{if("MemberExpression"!==e.assignee.type)throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(e.assignee)}`);{const r=e.assignee,s=this.evaluate(r.object,t);if(!(s instanceof K))throw new Error("Cannot assign to member of non-object");if("Identifier"!==r.property.type)throw new Error("Cannot assign to member with non-identifier property");s.value.set(r.property.value,n)}}return new $}evaluateIf(e,t){const n=this.evaluate(e.test,t);return this.evaluateBlock(n.__bool__().value?e.body:e.alternate,t)}evaluateFor(e,t){const n=new te(t);let r,s;if("SelectExpression"===e.iterable.type){const t=e.iterable;s=this.evaluate(t.iterable,n),r=t.test}else s=this.evaluate(e.iterable,n);if(!(s instanceof q))throw new Error(`Expected iterable type in for loop: got ${s.type}`);const a=[],i=[];for(let t=0;t<s.value.length;++t){const A=new te(n),o=s.value[t];let l;if("Identifier"===e.loopvar.type)l=t=>t.setVariable(e.loopvar.value,o);else{if("TupleLiteral"!==e.loopvar.type)throw new Error(`Invalid loop variable(s): ${e.loopvar.type}`);{const t=e.loopvar;if("ArrayValue"!==o.type)throw new Error(`Cannot unpack non-iterable type: ${o.type}`);const n=o;if(t.value.length!==n.value.length)throw new Error(`Too ${t.value.length>n.value.length?"few":"many"} items to unpack`);l=e=>{for(let r=0;r<t.value.length;++r){if("Identifier"!==t.value[r].type)throw new Error(`Cannot unpack non-identifier type: ${t.value[r].type}`);e.setVariable(t.value[r].value,n.value[r])}}}}if(r){l(A);if(!this.evaluate(r,A).__bool__().value)continue}a.push(o),i.push(l)}let A="",o=!0;for(let t=0;t<a.length;++t){const r=new Map([["index",new U(t+1)],["index0",new U(t)],["revindex",new U(a.length-t)],["revindex0",new U(a.length-t-1)],["first",new Y(0===t)],["last",new Y(t===a.length-1)],["length",new U(a.length)],["previtem",t>0?a[t-1]:new ee],["nextitem",t<a.length-1?a[t+1]:new ee]]);n.setVariable("loop",new K(r)),i[t](n);try{A+=this.evaluateBlock(e.body,n).value}catch(e){if(e instanceof V)continue;if(e instanceof _)break;throw e}o=!1}if(o){A+=this.evaluateBlock(e.defaultBlock,n).value}return new j(A)}evaluateMacro(e,t){return t.setVariable(e.name.value,new J(((t,n)=>{const r=new te(n);let s;t=t.slice(),"KeywordArgumentsValue"===t.at(-1)?.type&&(s=t.pop());for(let n=0;n<e.args.length;++n){const a=e.args[n],i=t[n];if("Identifier"===a.type){const e=a;if(!i)throw new Error(`Missing positional argument: ${e.value}`);r.setVariable(e.value,i)}else{if("KeywordArgumentExpression"!==a.type)throw new Error(`Unknown argument type: ${a.type}`);{const e=a,t=i??s?.value.get(e.key.value)??this.evaluate(e.value,r);r.setVariable(e.key.value,t)}}}return this.evaluateBlock(e.body,r)}))),new $}evaluate(e,t){if(void 0===e)return new ee;switch(e.type){case"Program":return this.evalProgram(e,t);case"Set":return this.evaluateSet(e,t);case"If":return this.evaluateIf(e,t);case"For":return this.evaluateFor(e,t);case"Macro":return this.evaluateMacro(e,t);case"Break":throw new _;case"Continue":throw new V;case"NumericLiteral":return new U(Number(e.value));case"StringLiteral":return new j(e.value);case"BooleanLiteral":return new Y(e.value);case"NullLiteral":return new $(e.value);case"ArrayLiteral":return new q(e.value.map((e=>this.evaluate(e,t))));case"TupleLiteral":return new Z(e.value.map((e=>this.evaluate(e,t))));case"ObjectLiteral":{const n=new Map;for(const[r,s]of e.value){const e=this.evaluate(r,t);if(!(e instanceof j))throw new Error(`Object keys must be strings: got ${e.type}`);n.set(e.value,this.evaluate(s,t))}return new K(n)}case"Identifier":return this.evaluateIdentifier(e,t);case"CallExpression":return this.evaluateCallExpression(e,t);case"MemberExpression":return this.evaluateMemberExpression(e,t);case"UnaryExpression":return this.evaluateUnaryExpression(e,t);case"BinaryExpression":return this.evaluateBinaryExpression(e,t);case"FilterExpression":return this.evaluateFilterExpression(e,t);case"TestExpression":return this.evaluateTestExpression(e,t);default:throw new SyntaxError(`Unknown node type: ${e.type}`)}}};function re(e){switch(typeof e){case"number":return new U(e);case"string":return new j(e);case"boolean":return new Y(e);case"undefined":return new ee;case"object":return null===e?new $:Array.isArray(e)?new q(e.map(re)):new K(new Map(Object.entries(e).map((([e,t])=>[e,re(t)]))));case"function":return new J(((t,n)=>{const r=e(...t.map((e=>e.value)))??null;return re(r)}));default:throw new Error(`Cannot convert to runtime value: ${e}`)}}function se(e,t,n){const r=n??0;switch(e.type){case"NullValue":case"UndefinedValue":return"null";case"NumericValue":case"StringValue":case"BooleanValue":return JSON.stringify(e.value);case"ArrayValue":case"ObjectValue":{const n=t?" ".repeat(t):"",s="\n"+n.repeat(r),a=s+n;if("ArrayValue"===e.type){const n=e.value.map((e=>se(e,t,r+1)));return t?`[${a}${n.join(`,${a}`)}${s}]`:`[${n.join(", ")}]`}{const n=Array.from(e.value.entries()).map((([e,n])=>{const s=`"${e}": ${se(n,t,r+1)}`;return t?`${a}${s}`:s}));return t?`{${n.join(",")}${s}}`:`{${n.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${e.type}`)}}var ae="\n",ie={MultiplicativeBinaryOperator:2,AdditiveBinaryOperator:1,ComparisonBinaryOperator:0};function Ae(...e){return"{%- "+e.join(" ")+" -%}"}function oe(e,t,n){return e.map((e=>function(e,t,n){const r=n.repeat(t);switch(e.type){case"Program":return oe(e.body,t,n);case"If":return function(e,t,n){const r=n.repeat(t),s=[];let a=e;for(;a&&(s.push({test:a.test,body:a.body}),1===a.alternate.length&&"If"===a.alternate[0].type);)a=a.alternate[0];let i=r+Ae("if",le(s[0].test))+ae+oe(s[0].body,t+1,n);for(let e=1;e<s.length;e++)i+=ae+r+Ae("elif",le(s[e].test))+ae+oe(s[e].body,t+1,n);a&&a.alternate.length>0&&(i+=ae+r+Ae("else")+ae+oe(a.alternate,t+1,n));return i+=ae+r+Ae("endif"),i}(e,t,n);case"For":return function(e,t,n){const r=n.repeat(t);let s="";if("SelectExpression"===e.iterable.type){const t=e.iterable;s=`${le(t.iterable)} if ${le(t.test)}`}else s=le(e.iterable);let a=r+Ae("for",le(e.loopvar),"in",s)+ae+oe(e.body,t+1,n);e.defaultBlock.length>0&&(a+=ae+r+Ae("else")+ae+oe(e.defaultBlock,t+1,n));return a+=ae+r+Ae("endfor"),a}(e,t,n);case"Set":return function(e,t,n){const r=n.repeat(t),s=le(e.assignee),a=e.value?le(e.value):"",i=r+Ae("set",`${s}${e.value?" = "+a:""}`);if(0===e.body.length)return i;return i+ae+oe(e.body,t+1,n)+ae+r+Ae("endset")}(e,t,n);case"Macro":return function(e,t,n){const r=n.repeat(t),s=e.args.map(le).join(", ");return r+Ae("macro",`${e.name.value}(${s})`)+ae+oe(e.body,t+1,n)+ae+r+Ae("endmacro")}(e,t,n);case"Break":return r+Ae("break");case"Continue":return r+Ae("continue");default:return r+"{{- "+le(e)+" -}}"}}(e,t,n))).join(ae)}function le(e,t=-1){switch(e.type){case"Identifier":return e.value;case"NullLiteral":return"none";case"NumericLiteral":case"BooleanLiteral":return`${e.value}`;case"StringLiteral":return JSON.stringify(e.value);case"BinaryExpression":{const n=e,r=ie[n.operator.type]??0,s=le(n.left,r),a=le(n.right,r+1),i=`${s} ${n.operator.value} ${a}`;return r<t?`(${i})`:i}case"UnaryExpression":{const t=e;return t.operator.value+("not"===t.operator.value?" ":"")+le(t.argument,1/0)}case"LogicalNegationExpression":return`not ${le(e.argument,1/0)}`;case"CallExpression":{const t=e,n=t.args.map((e=>le(e,-1))).join(", ");return`${le(t.callee,-1)}(${n})`}case"MemberExpression":{const t=e;let n=le(t.object,-1);"Identifier"!==t.object.type&&(n=`(${n})`);let r=le(t.property,-1);return t.computed||"Identifier"===t.property.type||(r=`(${r})`),t.computed?`${n}[${r}]`:`${n}.${r}`}case"FilterExpression":{const t=e,n=le(t.operand,1/0);return"CallExpression"===t.filter.type?`${n} | ${le(t.filter,-1)}`:`${n} | ${t.filter.value}`}case"SelectExpression":{const t=e;return`${le(t.iterable,-1)} | select(${le(t.test,-1)})`}case"TestExpression":{const t=e;return`${le(t.operand,-1)} is${t.negate?" not":""} ${t.test.value}`}case"ArrayLiteral":case"TupleLiteral":{const t=e.value.map((e=>le(e,-1))),n="ArrayLiteral"===e.type?"[]":"()";return`${n[0]}${t.join(", ")}${n[1]}`}case"ObjectLiteral":{const t=Array.from(e.value.entries()).map((([e,t])=>`${le(e,-1)}: ${le(t,-1)}`));return`{ ${t.join(", ")} }`}case"SliceExpression":{const t=e;return`${t.start?le(t.start,-1):""}:${t.stop?le(t.stop,-1):""}${t.step?`:${le(t.step,-1)}`:""}`}case"KeywordArgumentExpression":{const t=e;return`${t.key.value}=${le(t.value,-1)}`}case"If":{const t=e,n=le(t.test,-1);return`${le(t.body[0],0)} if ${n} else ${le(t.alternate[0],-1)}`}default:throw new Error(`Unknown expression type: ${e.type}`)}}var ue=class{parsed;constructor(e){const t=u(e,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=O(t)}render(e){const t=new te;if(t.set("false",!1),t.set("true",!0),t.set("raise_exception",(e=>{throw new Error(e)})),t.set("range",R),e)for(const[n,r]of Object.entries(e))t.set(n,r);return new ne(t).run(this.parsed).value}format(e){return function(e,t="\t"){const n="number"==typeof t?" ".repeat(t):t;return oe(e.body,0,n).replace(/\n$/,"")}(this.parsed,e?.indent||"\t")}}},"./src/backends/onnx.js":(e,t,n)=>{var r;n.r(t),n.d(t,{Tensor:()=>A.Tensor,createInferenceSession:()=>p,deviceToExecutionProviders:()=>f,isONNXProxy:()=>C,isONNXTensor:()=>m});var s=n("./src/env.js"),a=n("?2ce3"),i=n("onnxruntime-web"),A=n("onnxruntime-common");const o=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),l=[];let u,c;const d=Symbol.for("onnxruntime");if(d in globalThis)c=globalThis[d];else if(s.apis.IS_NODE_ENV){switch(c=a??(r||(r=n.t(a,2))),process.platform){case"win32":l.push("dml");break;case"linux":"x64"===process.arch&&l.push("cuda")}l.push("cpu"),u=["cpu"]}else c=i,s.apis.IS_WEBNN_AVAILABLE&&l.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),s.apis.IS_WEBGPU_AVAILABLE&&l.push("webgpu"),l.push("wasm"),u=["wasm"];const h=c.InferenceSession;function f(e=null){if(!e)return u;switch(e){case"auto":return l;case"gpu":return l.filter((e=>["webgpu","cuda","dml","webnn-gpu"].includes(e)))}if(l.includes(e))return[o[e]??e];throw new Error(`Unsupported device: "${e}". Should be one of: ${l.join(", ")}.`)}let g=null;async function p(e,t,n){g&&await g;const r=h.create(e,t);g??=r;const s=await r;return s.config=n,s}function m(e){return e instanceof c.Tensor}const b=c?.env;function C(){return b?.wasm?.proxy}b?.wasm&&("undefined"!=typeof ServiceWorkerGlobalScope&&self instanceof ServiceWorkerGlobalScope||b.wasm.wasmPaths||(b.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${s.env.version}/dist/`),b.wasm.proxy=!1),b?.webgpu&&(b.webgpu.powerPreference="high-performance"),s.env.backends.onnx=b},"./src/base/feature_extraction_utils.js":(e,t,n)=>{n.r(t),n.d(t,{FeatureExtractor:()=>i,validate_audio_inputs:()=>A});var r=n("./src/utils/constants.js"),s=n("./src/utils/generic.js"),a=n("./src/utils/hub.js");class i extends s.Callable{constructor(e){super(),this.config=e}static async from_pretrained(e,t){return new this(await(0,a.getModelJSON)(e,r.FEATURE_EXTRACTOR_NAME,!0,t))}}function A(e,t){if(!(e instanceof Float32Array||e instanceof Float64Array))throw new Error(`${t} expects input to be a Float32Array or a Float64Array, but got ${e?.constructor?.name??typeof e} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}},"./src/base/image_processors_utils.js":(e,t,n)=>{n.r(t),n.d(t,{ImageProcessor:()=>C,center_to_corners_format:()=>c,post_process_instance_segmentation:()=>b,post_process_object_detection:()=>d,post_process_panoptic_segmentation:()=>m,post_process_semantic_segmentation:()=>h});var r=n("./src/utils/generic.js"),s=n("./src/utils/tensor.js"),a=n("./src/utils/maths.js");n("./src/utils/image.js");var i=n("./src/utils/core.js"),A=n("./src/utils/hub.js"),o=n("./src/utils/constants.js");function l(e,t,n=0,r=null){const s=e/t;let i=(0,a.bankers_round)(s)*t;return null!==r&&i>r&&(i=Math.floor(s)*t),i<n&&(i=Math.ceil(s)*t),i}function u([e,t],n){return[Math.max(Math.floor(e/n),1)*n,Math.max(Math.floor(t/n),1)*n]}function c([e,t,n,r]){return[e-n/2,t-r/2,e+n/2,t+r/2]}function d(e,t=.5,n=null,r=!1){const s=e.logits,i=e.pred_boxes,[A,o,l]=s.dims;if(null!==n&&n.length!==A)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let u=[];for(let e=0;e<A;++e){let A=null!==n?n[e]:null,d={boxes:[],classes:[],scores:[]},h=s[e],f=i[e];for(let e=0;e<o;++e){let n,s=h[e],i=[];if(r){n=s.sigmoid().data;for(let e=0;e<n.length;++e)n[e]>t&&i.push(e)}else{let e=(0,a.max)(s.data)[1];if(e===l-1)continue;if(n=(0,a.softmax)(s.data),n[e]<t)continue;i.push(e)}for(const t of i){let r=f[e].data;r=c(r),null!==A&&(r=r.map(((e,t)=>e*A[(t+1)%2]))),d.boxes.push(r),d.classes.push(t),d.scores.push(n[t])}}u.push(d)}return u}function h(e,t=null){const n=e.logits,r=n.dims[0];if(null!==t&&t.length!==r)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const a=[];for(let e=0;e<r;++e){const r=null!==t?t[e]:null;let i=n[e];null!==r&&(i=(0,s.interpolate)(i,r,"bilinear",!1));const[A,o]=r??i.dims.slice(-2),l=new s.Tensor("int32",new Int32Array(A*o),[A,o]),u=i[0].data,c=l.data;for(let e=1;e<i.dims[0];++e){const t=i[e].data;for(let n=0;n<t.length;++n)t[n]>u[n]&&(u[n]=t[n],c[n]=e)}const d=new Array(i.dims[0]);for(let e=0;e<c.length;++e){const t=c[e];d[t]=t}const h=d.filter((e=>void 0!==e));a.push({segmentation:l,labels:h})}return a}function f(e,t,n,r){const s=[],i=[],A=[];for(let o=0;o<e.dims[0];++o){const l=e[o],u=t[o],c=(0,a.max)(l.data)[1];if(c===r)continue;const d=(0,a.softmax)(l.data)[c];d>n&&(s.push(u),i.push(d),A.push(c))}return[s,i,A]}function g(e,t,n,r=.5,s=.8){const a=[];let i=0,A=0;const o=t[n].data;for(let t=0;t<e.length;++t)e[t]===n&&(a.push(t),++i),o[t]>=r&&++A;let l=i>0&&A>0;if(l){l=i/A>s}return[l,a]}function p(e,t,n,r,a,i=null,A=null){const[o,l]=A??e[0].dims,u=new s.Tensor("int32",new Int32Array(o*l),[o,l]),c=[];if(null!==A)for(let t=0;t<e.length;++t)e[t]=(0,s.interpolate)(e[t],A,"bilinear",!1);const d=new Int32Array(e[0].data.length),h=new Float32Array(e[0].data.length);for(let n=0;n<e.length;++n){let r=t[n];const s=e[n].data;for(let e=0;e<s.length;++e)s[e]*=r,s[e]>h[e]&&(d[e]=n,h[e]=s[e])}let f=0;const p=u.data;for(let s=0;s<n.length;++s){const i=n[s],[A,o]=g(d,e,s,r,a);if(A){++f;for(const e of o)p[e]=f;c.push({id:f,label_id:i,score:t[s]})}}return[u,c]}function m(e,t=.5,n=.5,r=.8,a=null,i=null){null===a&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),a=new Set);const A=e.class_queries_logits??e.logits,o=(e.masks_queries_logits??e.pred_masks).sigmoid();let[l,u,c]=A.dims;if(c-=1,null!==i&&i.length!==l)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let d=[];for(let e=0;e<l;++e){let l=null!==i?i[e]:null,u=A[e],h=o[e],[g,m,b]=f(u,h,t,c);if(0===b.length){let[e,t]=l??h.dims.slice(-2),n=new s.Tensor("int32",new Int32Array(e*t).fill(-1),[e,t]);d.push({segmentation:n,segments_info:[]});continue}let[C,I]=p(g,m,b,n,r,a,l);d.push({segmentation:C,segments_info:I})}return d}function b(e,t=.5,n=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class C extends r.Callable{constructor(e){super(),this.image_mean=e.image_mean??e.mean,this.image_std=e.image_std??e.std,this.resample=e.resample??2,this.do_rescale=e.do_rescale??!0,this.rescale_factor=e.rescale_factor??1/255,this.do_normalize=e.do_normalize,this.do_thumbnail=e.do_thumbnail,this.size=e.size??e.image_size,this.do_resize=e.do_resize??void 0!==this.size,this.size_divisibility=e.size_divisibility??e.size_divisor,this.do_center_crop=e.do_center_crop,this.crop_size=e.crop_size,this.do_convert_rgb=e.do_convert_rgb??!0,this.do_crop_margin=e.do_crop_margin,this.pad_size=e.pad_size,this.do_pad=e.do_pad,this.min_pixels=e.min_pixels,this.max_pixels=e.max_pixels,this.do_pad&&!this.pad_size&&this.size&&void 0!==this.size.width&&void 0!==this.size.height&&(this.pad_size=this.size),this.do_flip_channel_order=e.do_flip_channel_order??!1,this.config=e}async thumbnail(e,t,n=2){const r=e.height,s=e.width,a=t.height,i=t.width;let A=Math.min(r,a),o=Math.min(s,i);return A===r&&o===s?e:(r>s?o=Math.floor(s*A/r):s>r&&(A=Math.floor(r*o/s)),await e.resize(o,A,{resample:n}))}async crop_margin(e,t=200){const n=e.clone().grayscale(),r=(0,a.min)(n.data)[0],s=(0,a.max)(n.data)[0]-r;if(0===s)return e;const i=t/255;let A=n.width,o=n.height,l=0,u=0;const c=n.data;for(let e=0;e<n.height;++e){const t=e*n.width;for(let a=0;a<n.width;++a)(c[t+a]-r)/s<i&&(A=Math.min(A,a),o=Math.min(o,e),l=Math.max(l,a),u=Math.max(u,e))}return e=await e.crop([A,o,l,u])}pad_image(e,t,n,{mode:r="constant",center:s=!1,constant_values:a=0}={}){const[A,o,l]=t;let u,c;if("number"==typeof n?(u=n,c=n):"square"===n?u=c=Math.max(A,o):(u=n.width,c=n.height),u!==o||c!==A){const n=new Float32Array(u*c*l);if(Array.isArray(a))for(let e=0;e<n.length;++e)n[e]=a[e%l];else 0!==a&&n.fill(a);const[d,h]=s?[Math.floor((u-o)/2),Math.floor((c-A)/2)]:[0,0];for(let t=0;t<A;++t){const r=(t+h)*u,s=t*o;for(let t=0;t<o;++t){const a=(r+t+d)*l,i=(s+t)*l;for(let t=0;t<l;++t)n[a+t]=e[i+t]}}if("symmetric"===r){if(s)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const t=A-1,r=o-1;for(let s=0;s<c;++s){const a=s*u,c=(0,i.calculateReflectOffset)(s,t)*o;for(let t=0;t<u;++t){if(s<A&&t<o)continue;const u=(a+t)*l,d=(c+(0,i.calculateReflectOffset)(t,r))*l;for(let t=0;t<l;++t)n[u+t]=e[d+t]}}}e=n,t=[c,u,l]}return[e,t]}rescale(e){for(let t=0;t<e.length;++t)e[t]=this.rescale_factor*e[t]}get_resize_output_image_size(e,t){const[n,r]=e.size;let s,a;if(this.do_thumbnail){const{height:e,width:n}=t;s=Math.min(e,n)}else Number.isInteger(t)?(s=t,a=this.config.max_size??s):void 0!==t&&(s=t.shortest_edge,a=t.longest_edge);if(void 0!==s||void 0!==a){const e=void 0===s?1:Math.max(s/n,s/r),t=n*e,i=r*e,A=void 0===a?1:Math.min(a/t,a/i);let o=Math.floor(Number((t*A).toFixed(2))),l=Math.floor(Number((i*A).toFixed(2)));return void 0!==this.size_divisibility&&([o,l]=u([o,l],this.size_divisibility)),[o,l]}if(void 0!==t&&void 0!==t.width&&void 0!==t.height){let e=t.width,s=t.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let t=s/r,a=e/n;Math.abs(1-a)<Math.abs(1-t)?t=a:a=t,s=l(t*r,this.config.ensure_multiple_of),e=l(a*n,this.config.ensure_multiple_of)}return[e,s]}if(void 0!==this.size_divisibility)return u([n,r],this.size_divisibility);if(void 0!==this.min_pixels&&void 0!==this.max_pixels){return function(e,t,n=28,r=3136,s=1003520){if(e<n||t<n)throw new Error(`height:${e} or width:${t} must be larger than factor:${n}`);if(Math.max(e,t)/Math.min(e,t)>200)throw new Error("absolute aspect ratio must be smaller than 200, got "+Math.max(e,t)/Math.min(e,t));let a=Math.round(e/n)*n,i=Math.round(t/n)*n;if(a*i>s){const r=Math.sqrt(e*t/s);a=Math.floor(e/r/n)*n,i=Math.floor(t/r/n)*n}else if(a*i<r){const s=Math.sqrt(r/(e*t));a=Math.ceil(e*s/n)*n,i=Math.ceil(t*s/n)*n}return[a,i]}(r,n,this.config.patch_size*this.config.merge_size,this.min_pixels,this.max_pixels)}throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(t)}`)}async resize(e){const[t,n]=this.get_resize_output_image_size(e,this.size);return await e.resize(t,n,{resample:this.resample})}async preprocess(e,{do_normalize:t=null,do_pad:n=null,do_convert_rgb:r=null,do_convert_grayscale:a=null,do_flip_channel_order:i=null}={}){this.do_crop_margin&&(e=await this.crop_margin(e));const[A,o]=e.size;if(r??this.do_convert_rgb?e=e.rgb():a&&(e=e.grayscale()),this.do_resize&&(e=await this.resize(e)),this.do_thumbnail&&(e=await this.thumbnail(e,this.size,this.resample)),this.do_center_crop){let t,n;Number.isInteger(this.crop_size)?(t=this.crop_size,n=this.crop_size):(t=this.crop_size.width,n=this.crop_size.height),e=await e.center_crop(t,n)}const l=[e.height,e.width];let c=Float32Array.from(e.data),d=[e.height,e.width,e.channels];if(this.do_rescale&&this.rescale(c),t??this.do_normalize){let t=this.image_mean;Array.isArray(this.image_mean)||(t=new Array(e.channels).fill(t));let n=this.image_std;if(Array.isArray(this.image_std)||(n=new Array(e.channels).fill(t)),t.length!==e.channels||n.length!==e.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${t.length}) and \`image_std\` (${n.length}) must match the number of channels in the image (${e.channels}).`);for(let r=0;r<c.length;r+=e.channels)for(let s=0;s<e.channels;++s)c[r+s]=(c[r+s]-t[s])/n[s]}if(n??this.do_pad)if(this.pad_size){const t=this.pad_image(c,[e.height,e.width,e.channels],this.pad_size);[c,d]=t}else if(this.size_divisibility){const[e,t]=u([d[1],d[0]],this.size_divisibility);[c,d]=this.pad_image(c,d,{width:e,height:t})}if(i??this.do_flip_channel_order){if(3!==d[2])throw new Error("Flipping channel order is only supported for RGB images.");for(let e=0;e<c.length;e+=3){const t=c[e];c[e]=c[e+2],c[e+2]=t}}return{original_size:[o,A],reshaped_input_size:l,pixel_values:new s.Tensor("float32",c,d).permute(2,0,1)}}async _call(e,...t){Array.isArray(e)||(e=[e]);const n=await Promise.all(e.map((e=>this.preprocess(e)))),r=(0,s.stack)(n.map((e=>e.pixel_values)),0);return{pixel_values:r,original_sizes:n.map((e=>e.original_size)),reshaped_input_sizes:n.map((e=>e.reshaped_input_size))}}static async from_pretrained(e,t){return new this(await(0,A.getModelJSON)(e,o.IMAGE_PROCESSOR_NAME,!0,t))}}},"./src/base/processing_utils.js":(e,t,n)=>{n.r(t),n.d(t,{Processor:()=>i});var r=n("./src/utils/constants.js"),s=n("./src/utils/generic.js"),a=n("./src/utils/hub.js");class i extends s.Callable{static classes=["image_processor_class","tokenizer_class","feature_extractor_class"];static uses_processor_config=!1;constructor(e,t){super(),this.config=e,this.components=t}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(e,t={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(e,{tokenize:!1,...t})}batch_decode(...e){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...e)}decode(...e){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.decode(...e)}async _call(e,...t){for(const n of[this.image_processor,this.feature_extractor,this.tokenizer])if(n)return n(e,...t);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(e,t){const[n,s]=await Promise.all([this.uses_processor_config?(0,a.getModelJSON)(e,r.PROCESSOR_NAME,!0,t):{},Promise.all(this.classes.filter((e=>e in this)).map((async n=>{const r=await this[n].from_pretrained(e,t);return[n.replace(/_class$/,""),r]}))).then(Object.fromEntries)]);return new this(n,s)}}},"./src/configs.js":(e,t,n)=>{n.r(t),n.d(t,{AutoConfig:()=>o,PretrainedConfig:()=>A,getKeyValueShapes:()=>i});var r=n("./src/utils/core.js"),s=n("./src/utils/hub.js");function a(e){const t={};let n={};switch(e.model_type){case"llava":case"paligemma":case"gemma3":case"florence2":case"llava_onevision":case"idefics3":case"ultravox":case"smolvlm":n=a(e.text_config);break;case"moondream1":n=a(e.phi_config);break;case"musicgen":n=a(e.decoder);break;case"multi_modality":n=a(e.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":t.num_heads="n_head",t.num_layers="n_layer",t.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"falcon":t.num_heads="num_attention_heads",t.num_layers="num_hidden_layers",t.hidden_size="hidden_size";break;case"llama":case"olmo":case"olmo2":case"mobilellm":case"granite":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":case"phi":case"phi3":case"phi3_v":t.num_heads="num_key_value_heads",t.num_layers="num_hidden_layers",t.hidden_size="hidden_size",t.num_attention_heads="num_attention_heads";break;case"qwen3":case"gemma":case"gemma2":case"gemma3_text":case"glm":case"helium":t.num_heads="num_key_value_heads",t.num_layers="num_hidden_layers",t.dim_kv="head_dim";break;case"openelm":t.num_heads="num_kv_heads",t.num_layers="num_transformer_layers",t.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":t.num_heads="num_heads",t.num_layers="num_layers",t.hidden_size="hidden_size";break;case"bloom":t.num_heads="n_head",t.num_layers="n_layer",t.hidden_size="hidden_size";break;case"mpt":t.num_heads="n_heads",t.num_layers="n_layers",t.hidden_size="d_model";break;case"exaone":t.num_heads="num_key_value_heads",t.num_layers="num_layers",t.dim_kv="head_dim",t.num_attention_heads="num_attention_heads";break;case"t5":case"mt5":case"longt5":t.num_decoder_layers="num_decoder_layers",t.num_decoder_heads="num_heads",t.decoder_dim_kv="d_kv",t.num_encoder_layers="num_layers",t.num_encoder_heads="num_heads",t.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"lite-whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":t.num_decoder_layers="decoder_layers",t.num_decoder_heads="decoder_attention_heads",t.decoder_hidden_size="d_model",t.num_encoder_layers="encoder_layers",t.num_encoder_heads="encoder_attention_heads",t.encoder_hidden_size="d_model";break;case"speecht5":t.num_decoder_layers="decoder_layers",t.num_decoder_heads="decoder_attention_heads",t.decoder_hidden_size="hidden_size",t.num_encoder_layers="encoder_layers",t.num_encoder_heads="encoder_attention_heads",t.encoder_hidden_size="hidden_size";break;case"trocr":t.num_encoder_layers=t.num_decoder_layers="decoder_layers",t.num_encoder_heads=t.num_decoder_heads="decoder_attention_heads",t.encoder_hidden_size=t.decoder_hidden_size="d_model";break;case"musicgen_decoder":t.num_encoder_layers=t.num_decoder_layers="num_hidden_layers",t.num_encoder_heads=t.num_decoder_heads="num_attention_heads",t.encoder_hidden_size=t.decoder_hidden_size="hidden_size";break;case"moonshine":t.num_decoder_layers="decoder_num_hidden_layers",t.num_decoder_heads="decoder_num_key_value_heads",t.num_encoder_layers="encoder_num_hidden_layers",t.num_encoder_heads="encoder_num_key_value_heads",t.encoder_hidden_size=t.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const s=a(e.decoder),i="num_decoder_layers"in s,A=(0,r.pick)(e,["model_type","is_encoder_decoder"]);return i?(A.num_decoder_layers=s.num_decoder_layers,A.num_decoder_heads=s.num_decoder_heads,A.decoder_hidden_size=s.decoder_hidden_size,A.num_encoder_layers=s.num_encoder_layers,A.num_encoder_heads=s.num_encoder_heads,A.encoder_hidden_size=s.encoder_hidden_size):(A.num_layers=s.num_layers,A.num_heads=s.num_heads,A.hidden_size=s.hidden_size),A}const s={...n,...(0,r.pick)(e,["model_type","multi_query","is_encoder_decoder"])};for(const n in t)s[n]=e[t[n]];return s}function i(e,{prefix:t="past_key_values",batch_size:n=1}={}){const r={},s=e.normalized_config;if(s.is_encoder_decoder&&"num_encoder_heads"in s&&"num_decoder_heads"in s){const e=s.encoder_dim_kv??s.encoder_hidden_size/s.num_encoder_heads,a=s.decoder_dim_kv??s.decoder_hidden_size/s.num_decoder_heads,i=[n,s.num_encoder_heads,0,e],A=[n,s.num_decoder_heads,0,a];for(let e=0;e<s.num_decoder_layers;++e)r[`${t}.${e}.encoder.key`]=i,r[`${t}.${e}.encoder.value`]=i,r[`${t}.${e}.decoder.key`]=A,r[`${t}.${e}.decoder.value`]=A}else{const e=s.num_heads,a=s.num_layers,i=s.dim_kv??s.hidden_size/(s.num_attention_heads??e);if("falcon"===s.model_type){const s=[n*e,0,i];for(let e=0;e<a;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=s}else if(s.multi_query){const s=[n*e,0,2*i];for(let e=0;e<a;++e)r[`${t}.${e}.key_value`]=s}else if("bloom"===s.model_type){const s=[n*e,i,0],A=[n*e,0,i];for(let e=0;e<a;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=A}else if("openelm"===s.model_type)for(let s=0;s<a;++s){const a=[n,e[s],0,i];r[`${t}.${s}.key`]=a,r[`${t}.${s}.value`]=a}else{const s=[n,e,0,i];for(let e=0;e<a;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=s}}return r}class A{model_type=null;is_encoder_decoder=!1;max_position_embeddings;"transformers.js_config";constructor(e){Object.assign(this,e),this.normalized_config=a(this)}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:a=!1,revision:i="main"}={}){!n||n instanceof A||(n=new A(n));const o=n??await async function(e,t){return await(0,s.getModelJSON)(e,"config.json",!0,t)}(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:a,revision:i});return new this(o)}}class o{static async from_pretrained(...e){return A.from_pretrained(...e)}}},"./src/env.js":(e,t,n)=>{n.r(t),n.d(t,{apis:()=>g,env:()=>I});var r=n("?569f"),s=n("?3f59"),a=n("?154a");const i="undefined"!=typeof window&&void 0!==window.document,A="undefined"!=typeof self&&"DedicatedWorkerGlobalScope"===self.constructor?.name,o="undefined"!=typeof self&&"caches"in self,l="undefined"!=typeof navigator&&"gpu"in navigator,u="undefined"!=typeof navigator&&"ml"in navigator,c="undefined"!=typeof process,d=c&&"node"===process?.release?.name,h=!w(r),f=!w(s),g=Object.freeze({IS_BROWSER_ENV:i,IS_WEBWORKER_ENV:A,IS_WEB_CACHE_AVAILABLE:o,IS_WEBGPU_AVAILABLE:l,IS_WEBNN_AVAILABLE:u,IS_PROCESS_AVAILABLE:c,IS_NODE_ENV:d,IS_FS_AVAILABLE:h,IS_PATH_AVAILABLE:f}),p=h&&f;let m="./";if(p){const e=Object(import.meta).url;e?m=s.dirname(s.dirname(a.fileURLToPath(e))):"undefined"!=typeof __dirname&&(m=s.dirname(__dirname))}const b=p?s.join(m,"/.cache/"):null,C="/models/",I={version:"3.5.1",backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!(i||A),localModelPath:p?s.join(m,C):C,useFS:h,useBrowserCache:o,useFSCache:h,cacheDir:b,useCustomCache:!1,customCache:null};function w(e){return 0===Object.keys(e).length}},"./src/generation/configuration_utils.js":(e,t,n)=>{n.r(t),n.d(t,{GenerationConfig:()=>s});var r=n("./src/utils/core.js");class s{max_length=20;max_new_tokens=null;min_length=0;min_new_tokens=null;early_stopping=!1;max_time=null;do_sample=!1;num_beams=1;num_beam_groups=1;penalty_alpha=null;use_cache=!0;temperature=1;top_k=50;top_p=1;typical_p=1;epsilon_cutoff=0;eta_cutoff=0;diversity_penalty=0;repetition_penalty=1;encoder_repetition_penalty=1;length_penalty=1;no_repeat_ngram_size=0;bad_words_ids=null;force_words_ids=null;renormalize_logits=!1;constraints=null;forced_bos_token_id=null;forced_eos_token_id=null;remove_invalid_values=!1;exponential_decay_length_penalty=null;suppress_tokens=null;streamer=null;begin_suppress_tokens=null;forced_decoder_ids=null;guidance_scale=null;num_return_sequences=1;output_attentions=!1;output_hidden_states=!1;output_scores=!1;return_dict_in_generate=!1;pad_token_id=null;bos_token_id=null;eos_token_id=null;encoder_no_repeat_ngram_size=0;decoder_start_token_id=null;generation_kwargs={};constructor(e){Object.assign(this,(0,r.pick)(e,Object.getOwnPropertyNames(this)))}}},"./src/generation/logits_process.js":(e,t,n)=>{n.r(t),n.d(t,{ClassifierFreeGuidanceLogitsProcessor:()=>m,ForcedBOSTokenLogitsProcessor:()=>o,ForcedEOSTokenLogitsProcessor:()=>l,LogitsProcessor:()=>a,LogitsProcessorList:()=>A,LogitsWarper:()=>i,MinLengthLogitsProcessor:()=>f,MinNewTokensLengthLogitsProcessor:()=>g,NoBadWordsLogitsProcessor:()=>p,NoRepeatNGramLogitsProcessor:()=>d,RepetitionPenaltyLogitsProcessor:()=>h,SuppressTokensAtBeginLogitsProcessor:()=>u,TemperatureLogitsWarper:()=>b,TopKLogitsWarper:()=>I,TopPLogitsWarper:()=>C,WhisperTimeStampLogitsProcessor:()=>c});var r=n("./src/utils/generic.js");n("./src/utils/tensor.js");var s=n("./src/utils/maths.js");class a extends r.Callable{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class i extends r.Callable{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class A extends r.Callable{constructor(){super(),this.processors=[]}push(e){this.processors.push(e)}extend(e){this.processors.push(...e)}_call(e,t){let n=t;for(const t of this.processors)n=t(e,n);return n}[Symbol.iterator](){return this.processors.values()}}class o extends a{constructor(e){super(),this.bos_token_id=e}_call(e,t){for(let n=0;n<e.length;++n)if(1===e[n].length){const e=t[n].data;e.fill(-1/0),e[this.bos_token_id]=0}return t}}class l extends a{constructor(e,t){super(),this.max_length=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length===this.max_length-1){const e=t[n].data;e.fill(-1/0);for(const t of this.eos_token_id)e[t]=0}return t}}class u extends a{constructor(e,t){super(),this.begin_suppress_tokens=e,this.begin_index=t}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length===this.begin_index){const e=t[n].data;for(const t of this.begin_suppress_tokens)e[t]=-1/0}return t}}class c extends a{constructor(e,t){super(),this.eos_token_id=Array.isArray(e.eos_token_id)?e.eos_token_id[0]:e.eos_token_id,this.no_timestamps_token_id=e.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=t.length,t.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=e.max_initial_timestamp_index}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data;if(r[this.no_timestamps_token_id]=-1/0,e[n].length===this.begin_index-1){r.fill(-1/0),r[this.timestamp_begin]=0;continue}const a=e[n].slice(this.begin_index),i=a.length>=1&&a[a.length-1]>=this.timestamp_begin,A=a.length<2||a[a.length-2]>=this.timestamp_begin;if(i&&(A?r.subarray(this.timestamp_begin).fill(-1/0):r.subarray(0,this.eos_token_id).fill(-1/0)),e[n].length===this.begin_index&&null!==this.max_initial_timestamp_index){const e=this.timestamp_begin+this.max_initial_timestamp_index;r.subarray(e+1).fill(-1/0)}const o=(0,s.log_softmax)(r),l=Math.log(o.subarray(this.timestamp_begin).map(Math.exp).reduce(((e,t)=>e+t)));l>(0,s.max)(o.subarray(0,this.timestamp_begin))[0]&&r.subarray(0,this.timestamp_begin).fill(-1/0)}return t}}class d extends a{constructor(e){super(),this.no_repeat_ngram_size=e}getNgrams(e){const t=e.length,n=[];for(let r=0;r<t+1-this.no_repeat_ngram_size;++r){const t=[];for(let n=0;n<this.no_repeat_ngram_size;++n)t.push(e[r+n]);n.push(t.map(Number))}const r=new Map;for(const e of n){const t=e.slice(0,e.length-1),n=JSON.stringify(t),s=r.get(n)??[];s.push(e[e.length-1]),r.set(n,s)}return r}getGeneratedNgrams(e,t){const n=t.slice(t.length+1-this.no_repeat_ngram_size,t.length);return e.get(JSON.stringify(n.map(Number)))??[]}calcBannedNgramTokens(e){const t=[];if(e.length+1<this.no_repeat_ngram_size)return t;{const t=this.getNgrams(e);return this.getGeneratedNgrams(t,e)}}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data,s=this.calcBannedNgramTokens(e[n]);for(const e of s)r[e]=-1/0}return t}}class h extends a{constructor(e){super(),this.penalty=e}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data;for(const t of new Set(e[n])){const e=Number(t);r[e]<0?r[e]*=this.penalty:r[e]/=this.penalty}}return t}}class f extends a{constructor(e,t){super(),this.min_length=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length<this.min_length){const e=t[n].data;for(const t of this.eos_token_id)e[t]=-1/0}return t}}class g extends a{constructor(e,t,n){super(),this.prompt_length_to_skip=e,this.min_new_tokens=t,this.eos_token_id=Array.isArray(n)?n:[n]}_call(e,t){for(let n=0;n<e.length;++n){if(e[n].length-this.prompt_length_to_skip<this.min_new_tokens){const e=t[n].data;for(const t of this.eos_token_id)e[t]=-1/0}}return t}}class p extends a{constructor(e,t){super(),this.bad_words_ids=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data,s=e[n];for(const e of this.bad_words_ids){if(s.length<e.length-1)continue;let t=!0;for(let n=1;n<=e.length-1;++n)if(e.at(-n-1)!=s.at(-n)){t=!1;break}t&&(r[e.at(-1)]=-1/0)}}return t}}class m extends a{constructor(e){if(super(),e<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${e}.`);this.guidance_scale=e}_call(e,t){if(t.dims[0]!==2*e.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${t.dims[0]} for the logits and ${e.length} for the input ids.`);const n=e.length,r=t.slice([0,n],null),s=t.slice([n,t.dims[0]],null);for(let e=0;e<s.data.length;++e)s.data[e]+=(r.data[e]-s.data[e])*this.guidance_scale;return s}}class b extends i{constructor(e){super(),this.temperature=e}_call(e,t){const n=t.data;for(let e=0;e<n.length;++e)n[e]/=this.temperature;return t}}class C extends i{constructor(e,{filter_value:t=-1/0,min_tokens_to_keep:n=1}={}){if(super(),e<0||e>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${e}`);if(!Number.isInteger(n)||n<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${n}`);this.top_p=e,this.filter_value=t,this.min_tokens_to_keep=n}}class I extends i{constructor(e,{filter_value:t=-1/0,min_tokens_to_keep:n=1}={}){if(super(),!Number.isInteger(e)||e<0)throw new Error(`\`top_k\` must be a positive integer, but is ${e}`);this.top_k=Math.max(e,n),this.filter_value=t}}},"./src/generation/logits_sampler.js":(e,t,n)=>{n.r(t),n.d(t,{LogitsSampler:()=>i});var r=n("./src/utils/generic.js"),s=n("./src/utils/tensor.js"),a=n("./src/utils/maths.js");n("./src/generation/configuration_utils.js");class i extends r.Callable{constructor(e){super(),this.generation_config=e}async _call(e){return this.sample(e)}async sample(e){throw Error("sample should be implemented in subclasses.")}getLogits(e,t){let n=e.dims.at(-1),r=e.data;if(-1===t)r=r.slice(-n);else{let e=t*n;r=r.slice(e,e+n)}return r}randomSelect(e){let t=0;for(let n=0;n<e.length;++n)t+=e[n];let n=Math.random()*t;for(let t=0;t<e.length;++t)if(n-=e[t],n<=0)return t;return 0}static getSampler(e){if(e.do_sample)return new o(e);if(e.num_beams>1)return new l(e);if(e.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${e.num_return_sequences}.`);return new A(e)}}class A extends i{async sample(e){const t=(0,a.max)(e.data)[1];return[[BigInt(t),0]]}}class o extends i{async sample(e){let t=e.dims.at(-1);this.generation_config.top_k>0&&(t=Math.min(this.generation_config.top_k,t));const[n,r]=await(0,s.topk)(e,t),i=(0,a.softmax)(n.data);return Array.from({length:this.generation_config.num_beams},(()=>{const e=this.randomSelect(i);return[r.data[e],Math.log(i[e])]}))}}class l extends i{async sample(e){let t=e.dims.at(-1);this.generation_config.top_k>0&&(t=Math.min(this.generation_config.top_k,t));const[n,r]=await(0,s.topk)(e,t),i=(0,a.softmax)(n.data);return Array.from({length:this.generation_config.num_beams},((e,t)=>[r.data[t],Math.log(i[t])]))}}},"./src/generation/stopping_criteria.js":(e,t,n)=>{n.r(t),n.d(t,{EosTokenCriteria:()=>A,InterruptableStoppingCriteria:()=>o,MaxLengthCriteria:()=>i,StoppingCriteria:()=>s,StoppingCriteriaList:()=>a});var r=n("./src/utils/generic.js");class s extends r.Callable{_call(e,t){throw Error("StoppingCriteria needs to be subclassed")}}class a extends r.Callable{constructor(){super(),this.criteria=[]}push(e){this.criteria.push(e)}extend(e){e instanceof a?e=e.criteria:e instanceof s&&(e=[e]),this.criteria.push(...e)}_call(e,t){const n=new Array(e.length).fill(!1);for(const r of this.criteria){const s=r(e,t);for(let e=0;e<n.length;++e)n[e]||=s[e]}return n}[Symbol.iterator](){return this.criteria.values()}}class i extends s{constructor(e,t=null){super(),this.max_length=e,this.max_position_embeddings=t}_call(e){return e.map((e=>e.length>=this.max_length))}}class A extends s{constructor(e){super(),Array.isArray(e)||(e=[e]),this.eos_token_id=e}_call(e,t){return e.map((e=>{const t=e.at(-1);return this.eos_token_id.some((e=>t==e))}))}}class o extends s{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(e,t){return new Array(e.length).fill(this.interrupted)}}},"./src/generation/streamers.js":(e,t,n)=>{n.r(t),n.d(t,{BaseStreamer:()=>i,TextStreamer:()=>o,WhisperTextStreamer:()=>l});var r=n("./src/utils/core.js"),s=n("./src/tokenizers.js"),a=n("./src/env.js");class i{put(e){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const A=a.apis.IS_PROCESS_AVAILABLE?e=>process.stdout.write(e):e=>console.log(e);class o extends i{constructor(e,{skip_prompt:t=!1,callback_function:n=null,token_callback_function:r=null,skip_special_tokens:s=!0,decode_kwargs:a={},...i}={}){super(),this.tokenizer=e,this.skip_prompt=t,this.callback_function=n??A,this.token_callback_function=r,this.decode_kwargs={skip_special_tokens:s,...a,...i},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(e){if(e.length>1)throw Error("TextStreamer only supports batch size of 1");const t=this.next_tokens_are_prompt;if(t&&(this.next_tokens_are_prompt=!1,this.skip_prompt))return;const n=e[0];this.token_callback_function?.(n),this.token_cache=(0,r.mergeArrays)(this.token_cache,n);const a=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let i;t||a.endsWith("\n")?(i=a.slice(this.print_len),this.token_cache=[],this.print_len=0):a.length>0&&(0,s.is_chinese_char)(a.charCodeAt(a.length-1))?(i=a.slice(this.print_len),this.print_len+=i.length):(i=a.slice(this.print_len,a.lastIndexOf(" ")+1),this.print_len+=i.length),this.on_finalized_text(i,!1)}end(){let e;if(this.token_cache.length>0){e=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0}else e="";this.next_tokens_are_prompt=!0,this.on_finalized_text(e,!0)}on_finalized_text(e,t){e.length>0&&this.callback_function?.(e),t&&this.callback_function===A&&a.apis.IS_PROCESS_AVAILABLE&&this.callback_function?.("\n")}}class l extends o{constructor(e,{skip_prompt:t=!1,callback_function:n=null,token_callback_function:r=null,on_chunk_start:s=null,on_chunk_end:a=null,on_finalize:i=null,time_precision:A=.02,skip_special_tokens:o=!0,decode_kwargs:l={}}={}){super(e,{skip_prompt:t,skip_special_tokens:o,callback_function:n,token_callback_function:r,decode_kwargs:l}),this.timestamp_begin=e.timestamp_begin,this.on_chunk_start=s,this.on_chunk_end=a,this.on_finalize=i,this.time_precision=A,this.waiting_for_timestamp=!1}put(e){if(e.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const t=e[0];if(1===t.length){const n=Number(t[0])-this.timestamp_begin;if(n>=0){const t=n*this.time_precision;this.waiting_for_timestamp?this.on_chunk_end?.(t):this.on_chunk_start?.(t),this.waiting_for_timestamp=!this.waiting_for_timestamp,e=[[]]}}return super.put(e)}end(){super.end(),this.on_finalize?.()}}},"./src/models.js":(e,t,n)=>{n.r(t),n.d(t,{ASTForAudioClassification:()=>xn,ASTModel:()=>kn,ASTPreTrainedModel:()=>wn,AlbertForMaskedLM:()=>St,AlbertForQuestionAnswering:()=>Tt,AlbertForSequenceClassification:()=>Dt,AlbertModel:()=>Mt,AlbertPreTrainedModel:()=>Bt,AutoModel:()=>ru,AutoModelForAudioClassification:()=>ku,AutoModelForAudioFrameClassification:()=>yu,AutoModelForAudioTextToText:()=>Gu,AutoModelForCTC:()=>wu,AutoModelForCausalLM:()=>uu,AutoModelForDepthEstimation:()=>Mu,AutoModelForDocumentQuestionAnswering:()=>vu,AutoModelForImageClassification:()=>fu,AutoModelForImageFeatureExtraction:()=>Su,AutoModelForImageMatting:()=>Eu,AutoModelForImageSegmentation:()=>gu,AutoModelForImageTextToText:()=>Nu,AutoModelForImageToImage:()=>Bu,AutoModelForMaskGeneration:()=>Iu,AutoModelForMaskedLM:()=>cu,AutoModelForNormalEstimation:()=>Du,AutoModelForObjectDetection:()=>bu,AutoModelForPoseEstimation:()=>Tu,AutoModelForQuestionAnswering:()=>du,AutoModelForSemanticSegmentation:()=>pu,AutoModelForSeq2SeqLM:()=>iu,AutoModelForSequenceClassification:()=>su,AutoModelForSpeechSeq2Seq:()=>Au,AutoModelForTextToSpectrogram:()=>ou,AutoModelForTextToWaveform:()=>lu,AutoModelForTokenClassification:()=>au,AutoModelForUniversalSegmentation:()=>mu,AutoModelForVision2Seq:()=>hu,AutoModelForXVector:()=>xu,AutoModelForZeroShotObjectDetection:()=>Cu,BartForConditionalGeneration:()=>Vt,BartForSequenceClassification:()=>Ht,BartModel:()=>_t,BartPretrainedModel:()=>Wt,BaseModelOutput:()=>se,BeitForImageClassification:()=>ka,BeitModel:()=>wa,BeitPreTrainedModel:()=>Ia,BertForMaskedLM:()=>Ae,BertForQuestionAnswering:()=>ue,BertForSequenceClassification:()=>oe,BertForTokenClassification:()=>le,BertModel:()=>ie,BertPreTrainedModel:()=>ae,BlenderbotForConditionalGeneration:()=>Jt,BlenderbotModel:()=>Zt,BlenderbotPreTrainedModel:()=>qt,BlenderbotSmallForConditionalGeneration:()=>tn,BlenderbotSmallModel:()=>en,BlenderbotSmallPreTrainedModel:()=>$t,BloomForCausalLM:()=>Ns,BloomModel:()=>Ss,BloomPreTrainedModel:()=>Ts,CLIPModel:()=>jn,CLIPPreTrainedModel:()=>Un,CLIPSegForImageSegmentation:()=>lr,CLIPSegModel:()=>or,CLIPSegPreTrainedModel:()=>Ar,CLIPTextModel:()=>Yn,CLIPTextModelWithProjection:()=>Kn,CLIPVisionModel:()=>Xn,CLIPVisionModelWithProjection:()=>qn,CamembertForMaskedLM:()=>Oe,CamembertForQuestionAnswering:()=>We,CamembertForSequenceClassification:()=>Re,CamembertForTokenClassification:()=>Le,CamembertModel:()=>ze,CamembertPreTrainedModel:()=>Qe,CausalLMOutput:()=>Lu,CausalLMOutputWithPast:()=>Wu,ChineseCLIPModel:()=>nr,ChineseCLIPPreTrainedModel:()=>tr,ClapAudioModelWithProjection:()=>io,ClapModel:()=>so,ClapPreTrainedModel:()=>ro,ClapTextModelWithProjection:()=>ao,CodeGenForCausalLM:()=>Tr,CodeGenModel:()=>Dr,CodeGenPreTrainedModel:()=>Mr,CohereForCausalLM:()=>rs,CohereModel:()=>ns,CoherePreTrainedModel:()=>ts,ConvBertForMaskedLM:()=>Ee,ConvBertForQuestionAnswering:()=>De,ConvBertForSequenceClassification:()=>Be,ConvBertForTokenClassification:()=>Me,ConvBertModel:()=>ve,ConvBertPreTrainedModel:()=>ye,ConvNextForImageClassification:()=>Pi,ConvNextModel:()=>Fi,ConvNextPreTrainedModel:()=>Gi,ConvNextV2ForImageClassification:()=>Oi,ConvNextV2Model:()=>zi,ConvNextV2PreTrainedModel:()=>Qi,DFineForObjectDetection:()=>Va,DFineModel:()=>_a,DFinePreTrainedModel:()=>Wa,DPTForDepthEstimation:()=>di,DPTModel:()=>ci,DPTPreTrainedModel:()=>ui,DacDecoderModel:()=>dl,DacDecoderOutput:()=>ll,DacEncoderModel:()=>cl,DacEncoderOutput:()=>ol,DacModel:()=>ul,DacPreTrainedModel:()=>Al,DebertaForMaskedLM:()=>He,DebertaForQuestionAnswering:()=>Ye,DebertaForSequenceClassification:()=>Ue,DebertaForTokenClassification:()=>je,DebertaModel:()=>Ve,DebertaPreTrainedModel:()=>_e,DebertaV2ForMaskedLM:()=>qe,DebertaV2ForQuestionAnswering:()=>$e,DebertaV2ForSequenceClassification:()=>Ze,DebertaV2ForTokenClassification:()=>Je,DebertaV2Model:()=>Xe,DebertaV2PreTrainedModel:()=>Ke,DecisionTransformerModel:()=>Wo,DecisionTransformerPreTrainedModel:()=>Lo,DeiTForImageClassification:()=>qa,DeiTModel:()=>Xa,DeiTPreTrainedModel:()=>Ka,DepthAnythingForDepthEstimation:()=>fi,DepthAnythingPreTrainedModel:()=>hi,DepthProForDepthEstimation:()=>Ii,DepthProPreTrainedModel:()=>Ci,DetrForObjectDetection:()=>va,DetrForSegmentation:()=>Ea,DetrModel:()=>ya,DetrObjectDetectionOutput:()=>Ba,DetrPreTrainedModel:()=>xa,DetrSegmentationOutput:()=>Ma,Dinov2ForImageClassification:()=>Wi,Dinov2Model:()=>Li,Dinov2PreTrainedModel:()=>Ri,Dinov2WithRegistersForImageClassification:()=>Hi,Dinov2WithRegistersModel:()=>Vi,Dinov2WithRegistersPreTrainedModel:()=>_i,DistilBertForMaskedLM:()=>at,DistilBertForQuestionAnswering:()=>st,DistilBertForSequenceClassification:()=>nt,DistilBertForTokenClassification:()=>rt,DistilBertModel:()=>tt,DistilBertPreTrainedModel:()=>et,DonutSwinModel:()=>Ni,DonutSwinPreTrainedModel:()=>Si,EfficientNetForImageClassification:()=>Co,EfficientNetModel:()=>bo,EfficientNetPreTrainedModel:()=>mo,ElectraForMaskedLM:()=>Ne,ElectraForQuestionAnswering:()=>Pe,ElectraForSequenceClassification:()=>Ge,ElectraForTokenClassification:()=>Fe,ElectraModel:()=>Se,ElectraPreTrainedModel:()=>Te,EsmForMaskedLM:()=>ot,EsmForSequenceClassification:()=>lt,EsmForTokenClassification:()=>ut,EsmModel:()=>At,EsmPreTrainedModel:()=>it,ExaoneForCausalLM:()=>_r,ExaoneModel:()=>Wr,ExaonePreTrainedModel:()=>Lr,FalconForCausalLM:()=>no,FalconModel:()=>to,FalconPreTrainedModel:()=>eo,FastViTForImageClassification:()=>aa,FastViTModel:()=>sa,FastViTPreTrainedModel:()=>ra,Florence2ForConditionalGeneration:()=>zn,Florence2PreTrainedModel:()=>Qn,GLPNForDepthEstimation:()=>Ti,GLPNModel:()=>Di,GLPNPreTrainedModel:()=>Mi,GPT2LMHeadModel:()=>dr,GPT2Model:()=>cr,GPT2PreTrainedModel:()=>ur,GPTBigCodeForCausalLM:()=>Br,GPTBigCodeModel:()=>Er,GPTBigCodePreTrainedModel:()=>vr,GPTJForCausalLM:()=>yr,GPTJModel:()=>xr,GPTJPreTrainedModel:()=>kr,GPTNeoForCausalLM:()=>br,GPTNeoModel:()=>mr,GPTNeoPreTrainedModel:()=>pr,GPTNeoXForCausalLM:()=>wr,GPTNeoXModel:()=>Ir,GPTNeoXPreTrainedModel:()=>Cr,Gemma2ForCausalLM:()=>ls,Gemma2Model:()=>os,Gemma2PreTrainedModel:()=>As,Gemma3ForCausalLM:()=>ds,Gemma3Model:()=>cs,Gemma3PreTrainedModel:()=>us,GemmaForCausalLM:()=>is,GemmaModel:()=>as,GemmaPreTrainedModel:()=>ss,GlmForCausalLM:()=>Rr,GlmModel:()=>Or,GlmPreTrainedModel:()=>zr,GraniteForCausalLM:()=>es,GraniteModel:()=>$r,GranitePreTrainedModel:()=>Jr,GroundingDinoForObjectDetection:()=>ji,GroundingDinoPreTrainedModel:()=>Ui,GroupViTModel:()=>na,GroupViTPreTrainedModel:()=>ta,HeliumForCausalLM:()=>Qr,HeliumModel:()=>Pr,HeliumPreTrainedModel:()=>Fr,HieraForImageClassification:()=>$a,HieraModel:()=>Ja,HieraPreTrainedModel:()=>Za,HubertForCTC:()=>SA,HubertForSequenceClassification:()=>NA,HubertModel:()=>TA,HubertPreTrainedModel:()=>DA,IJepaForImageClassification:()=>Hs,IJepaModel:()=>Vs,IJepaPreTrainedModel:()=>_s,Idefics3ForConditionalGeneration:()=>Wn,Idefics3PreTrainedModel:()=>Ln,ImageMattingOutput:()=>_u,JAISLMHeadModel:()=>gr,JAISModel:()=>fr,JAISPreTrainedModel:()=>hr,JinaCLIPModel:()=>sr,JinaCLIPPreTrainedModel:()=>rr,JinaCLIPTextModel:()=>ar,JinaCLIPVisionModel:()=>ir,LiteWhisperForConditionalGeneration:()=>Bn,LlamaForCausalLM:()=>Gr,LlamaModel:()=>Nr,LlamaPreTrainedModel:()=>Sr,LlavaForConditionalGeneration:()=>Gn,LlavaOnevisionForConditionalGeneration:()=>Fn,LlavaPreTrainedModel:()=>Nn,LongT5ForConditionalGeneration:()=>zt,LongT5Model:()=>Qt,LongT5PreTrainedModel:()=>Pt,M2M100ForConditionalGeneration:()=>aA,M2M100Model:()=>sA,M2M100PreTrainedModel:()=>rA,MBartForCausalLM:()=>Xt,MBartForConditionalGeneration:()=>Yt,MBartForSequenceClassification:()=>Kt,MBartModel:()=>jt,MBartPreTrainedModel:()=>Ut,MPNetForMaskedLM:()=>bt,MPNetForQuestionAnswering:()=>wt,MPNetForSequenceClassification:()=>Ct,MPNetForTokenClassification:()=>It,MPNetModel:()=>mt,MPNetPreTrainedModel:()=>pt,MT5ForConditionalGeneration:()=>Lt,MT5Model:()=>Rt,MT5PreTrainedModel:()=>Ot,MarianMTModel:()=>nA,MarianModel:()=>tA,MarianPreTrainedModel:()=>eA,MaskFormerForInstanceSegmentation:()=>Bi,MaskFormerModel:()=>Ei,MaskFormerPreTrainedModel:()=>vi,MaskedLMOutput:()=>Ou,Metric3DForDepthEstimation:()=>ki,Metric3DPreTrainedModel:()=>wi,Metric3Dv2ForDepthEstimation:()=>yi,Metric3Dv2PreTrainedModel:()=>xi,MgpstrForSceneTextRecognition:()=>jo,MgpstrModelOutput:()=>Ho,MgpstrPreTrainedModel:()=>Uo,MimiDecoderModel:()=>il,MimiDecoderOutput:()=>rl,MimiEncoderModel:()=>al,MimiEncoderOutput:()=>nl,MimiModel:()=>sl,MimiPreTrainedModel:()=>tl,MistralForCausalLM:()=>qA,MistralModel:()=>XA,MistralPreTrainedModel:()=>KA,MobileBertForMaskedLM:()=>ht,MobileBertForQuestionAnswering:()=>gt,MobileBertForSequenceClassification:()=>ft,MobileBertModel:()=>dt,MobileBertPreTrainedModel:()=>ct,MobileLLMForCausalLM:()=>Ur,MobileLLMModel:()=>Hr,MobileLLMPreTrainedModel:()=>Vr,MobileNetV1ForImageClassification:()=>Eo,MobileNetV1ForSemanticSegmentation:()=>Bo,MobileNetV1Model:()=>vo,MobileNetV1PreTrainedModel:()=>yo,MobileNetV2ForImageClassification:()=>To,MobileNetV2ForSemanticSegmentation:()=>So,MobileNetV2Model:()=>Do,MobileNetV2PreTrainedModel:()=>Mo,MobileNetV3ForImageClassification:()=>Fo,MobileNetV3ForSemanticSegmentation:()=>Po,MobileNetV3Model:()=>Go,MobileNetV3PreTrainedModel:()=>No,MobileNetV4ForImageClassification:()=>Oo,MobileNetV4ForSemanticSegmentation:()=>Ro,MobileNetV4Model:()=>zo,MobileNetV4PreTrainedModel:()=>Qo,MobileViTForImageClassification:()=>ua,MobileViTModel:()=>la,MobileViTPreTrainedModel:()=>oa,MobileViTV2ForImageClassification:()=>ha,MobileViTV2Model:()=>da,MobileViTV2PreTrainedModel:()=>ca,ModelOutput:()=>re,ModernBertForMaskedLM:()=>he,ModernBertForSequenceClassification:()=>fe,ModernBertForTokenClassification:()=>ge,ModernBertModel:()=>de,ModernBertPreTrainedModel:()=>ce,Moondream1ForConditionalGeneration:()=>Pn,MoonshineForConditionalGeneration:()=>Tn,MoonshineModel:()=>Dn,MoonshinePreTrainedModel:()=>Mn,MptForCausalLM:()=>Ps,MptModel:()=>Fs,MptPreTrainedModel:()=>Gs,MultiModalityCausalLM:()=>Vo,MultiModalityPreTrainedModel:()=>_o,MusicgenForCausalLM:()=>ko,MusicgenForConditionalGeneration:()=>xo,MusicgenModel:()=>wo,MusicgenPreTrainedModel:()=>Io,NomicBertModel:()=>me,NomicBertPreTrainedModel:()=>pe,OPTForCausalLM:()=>Os,OPTModel:()=>zs,OPTPreTrainedModel:()=>Qs,Olmo2ForCausalLM:()=>Zr,Olmo2Model:()=>qr,Olmo2PreTrainedModel:()=>Xr,OlmoForCausalLM:()=>Kr,OlmoModel:()=>Yr,OlmoPreTrainedModel:()=>jr,OpenELMForCausalLM:()=>gs,OpenELMModel:()=>fs,OpenELMPreTrainedModel:()=>hs,OwlViTForObjectDetection:()=>pa,OwlViTModel:()=>ga,OwlViTPreTrainedModel:()=>fa,Owlv2ForObjectDetection:()=>Ca,Owlv2Model:()=>ba,Owlv2PreTrainedModel:()=>ma,PaliGemmaForConditionalGeneration:()=>Rn,PaliGemmaPreTrainedModel:()=>On,PatchTSMixerForPrediction:()=>Jo,PatchTSMixerModel:()=>Zo,PatchTSMixerPreTrainedModel:()=>qo,PatchTSTForPrediction:()=>Xo,PatchTSTModel:()=>Ko,PatchTSTPreTrainedModel:()=>Yo,Phi3ForCausalLM:()=>Ds,Phi3Model:()=>Ms,Phi3PreTrainedModel:()=>Bs,Phi3VForCausalLM:()=>Hn,Phi3VPreTrainedModel:()=>Vn,PhiForCausalLM:()=>Es,PhiModel:()=>vs,PhiPreTrainedModel:()=>ys,PreTrainedModel:()=>ne,PretrainedMixin:()=>ml,PvtForImageClassification:()=>Xs,PvtModel:()=>Ks,PvtPreTrainedModel:()=>Ys,PyAnnoteForAudioFrameClassification:()=>hA,PyAnnoteModel:()=>dA,PyAnnotePreTrainedModel:()=>cA,QuestionAnsweringModelOutput:()=>Ru,Qwen2ForCausalLM:()=>bs,Qwen2Model:()=>ms,Qwen2PreTrainedModel:()=>ps,Qwen2VLForConditionalGeneration:()=>xs,Qwen2VLPreTrainedModel:()=>ks,Qwen3ForCausalLM:()=>ws,Qwen3Model:()=>Is,Qwen3PreTrainedModel:()=>Cs,RFDetrForObjectDetection:()=>Ra,RFDetrModel:()=>Oa,RFDetrObjectDetectionOutput:()=>La,RFDetrPreTrainedModel:()=>za,RTDetrForObjectDetection:()=>Sa,RTDetrModel:()=>Ta,RTDetrObjectDetectionOutput:()=>Na,RTDetrPreTrainedModel:()=>Da,RTDetrV2ForObjectDetection:()=>Pa,RTDetrV2Model:()=>Fa,RTDetrV2ObjectDetectionOutput:()=>Qa,RTDetrV2PreTrainedModel:()=>Ga,ResNetForImageClassification:()=>ni,ResNetModel:()=>ti,ResNetPreTrainedModel:()=>ei,RoFormerForMaskedLM:()=>Ie,RoFormerForQuestionAnswering:()=>xe,RoFormerForSequenceClassification:()=>we,RoFormerForTokenClassification:()=>ke,RoFormerModel:()=>Ce,RoFormerPreTrainedModel:()=>be,RobertaForMaskedLM:()=>sn,RobertaForQuestionAnswering:()=>on,RobertaForSequenceClassification:()=>an,RobertaForTokenClassification:()=>An,RobertaModel:()=>rn,RobertaPreTrainedModel:()=>nn,SamImageSegmentationOutput:()=>$i,SamModel:()=>Ji,SamPreTrainedModel:()=>Zi,SapiensForDepthEstimation:()=>mi,SapiensForNormalEstimation:()=>bi,SapiensForSemanticSegmentation:()=>pi,SapiensPreTrainedModel:()=>gi,SegformerForImageClassification:()=>co,SegformerForSemanticSegmentation:()=>ho,SegformerModel:()=>uo,SegformerPreTrainedModel:()=>lo,Seq2SeqLMOutput:()=>Fu,SequenceClassifierOutput:()=>Pu,SiglipModel:()=>Jn,SiglipPreTrainedModel:()=>Zn,SiglipTextModel:()=>$n,SiglipVisionModel:()=>er,SmolVLMForConditionalGeneration:()=>_n,SnacDecoderModel:()=>pl,SnacEncoderModel:()=>gl,SnacModel:()=>fl,SnacPreTrainedModel:()=>hl,SpeechT5ForSpeechToText:()=>VA,SpeechT5ForTextToSpeech:()=>HA,SpeechT5HifiGan:()=>UA,SpeechT5Model:()=>_A,SpeechT5PreTrainedModel:()=>WA,SqueezeBertForMaskedLM:()=>yt,SqueezeBertForQuestionAnswering:()=>Et,SqueezeBertForSequenceClassification:()=>vt,SqueezeBertModel:()=>xt,SqueezeBertPreTrainedModel:()=>kt,StableLmForCausalLM:()=>po,StableLmModel:()=>go,StableLmPreTrainedModel:()=>fo,Starcoder2ForCausalLM:()=>$A,Starcoder2Model:()=>JA,Starcoder2PreTrainedModel:()=>ZA,StyleTextToSpeech2Model:()=>LA,StyleTextToSpeech2PreTrainedModel:()=>RA,Swin2SRForImageSuperResolution:()=>li,Swin2SRModel:()=>oi,Swin2SRPreTrainedModel:()=>Ai,SwinForImageClassification:()=>ai,SwinForSemanticSegmentation:()=>ii,SwinModel:()=>si,SwinPreTrainedModel:()=>ri,T5ForConditionalGeneration:()=>Ft,T5Model:()=>Gt,T5PreTrainedModel:()=>Nt,TableTransformerForObjectDetection:()=>ja,TableTransformerModel:()=>Ua,TableTransformerObjectDetectionOutput:()=>Ya,TableTransformerPreTrainedModel:()=>Ha,TokenClassifierOutput:()=>zu,TrOCRForCausalLM:()=>YA,TrOCRPreTrainedModel:()=>jA,UltravoxModel:()=>el,UltravoxPreTrainedModel:()=>$o,UniSpeechForCTC:()=>bA,UniSpeechForSequenceClassification:()=>CA,UniSpeechModel:()=>mA,UniSpeechPreTrainedModel:()=>pA,UniSpeechSatForAudioFrameClassification:()=>yA,UniSpeechSatForCTC:()=>kA,UniSpeechSatForSequenceClassification:()=>xA,UniSpeechSatModel:()=>wA,UniSpeechSatPreTrainedModel:()=>IA,ViTForImageClassification:()=>Ws,ViTMAEModel:()=>Zs,ViTMAEPreTrainedModel:()=>qs,ViTMSNForImageClassification:()=>ea,ViTMSNModel:()=>$s,ViTMSNPreTrainedModel:()=>Js,ViTModel:()=>Ls,ViTPreTrainedModel:()=>Rs,VisionEncoderDecoderModel:()=>Sn,VitMatteForImageMatting:()=>Aa,VitMattePreTrainedModel:()=>ia,VitPoseForPoseEstimation:()=>js,VitPosePreTrainedModel:()=>Us,VitsModel:()=>oo,VitsModelOutput:()=>Vu,VitsPreTrainedModel:()=>Ao,Wav2Vec2BertForCTC:()=>BA,Wav2Vec2BertForSequenceClassification:()=>MA,Wav2Vec2BertModel:()=>EA,Wav2Vec2BertPreTrainedModel:()=>vA,Wav2Vec2ForAudioFrameClassification:()=>uA,Wav2Vec2ForCTC:()=>oA,Wav2Vec2ForSequenceClassification:()=>lA,Wav2Vec2Model:()=>AA,Wav2Vec2PreTrainedModel:()=>iA,WavLMForAudioFrameClassification:()=>OA,WavLMForCTC:()=>PA,WavLMForSequenceClassification:()=>QA,WavLMForXVector:()=>zA,WavLMModel:()=>FA,WavLMPreTrainedModel:()=>GA,WeSpeakerResNetModel:()=>gA,WeSpeakerResNetPreTrainedModel:()=>fA,WhisperForConditionalGeneration:()=>En,WhisperModel:()=>vn,WhisperPreTrainedModel:()=>yn,XLMForQuestionAnswering:()=>fn,XLMForSequenceClassification:()=>dn,XLMForTokenClassification:()=>hn,XLMModel:()=>un,XLMPreTrainedModel:()=>ln,XLMRobertaForMaskedLM:()=>mn,XLMRobertaForQuestionAnswering:()=>In,XLMRobertaForSequenceClassification:()=>bn,XLMRobertaForTokenClassification:()=>Cn,XLMRobertaModel:()=>pn,XLMRobertaPreTrainedModel:()=>gn,XLMWithLMHeadModel:()=>cn,XVectorOutput:()=>Qu,YolosForObjectDetection:()=>Xi,YolosModel:()=>Ki,YolosObjectDetectionOutput:()=>qi,YolosPreTrainedModel:()=>Yi});var r=n("./src/configs.js"),s=n("./src/backends/onnx.js"),a=n("./src/utils/dtypes.js"),i=n("./src/utils/generic.js"),A=n("./src/utils/core.js"),o=n("./src/utils/hub.js"),l=n("./src/utils/constants.js"),u=n("./src/generation/logits_process.js"),c=n("./src/generation/configuration_utils.js"),d=n("./src/utils/tensor.js"),h=n("./src/utils/image.js"),f=n("./src/utils/maths.js"),g=n("./src/generation/stopping_criteria.js"),p=n("./src/generation/logits_sampler.js"),m=n("./src/env.js"),b=n("./src/models/whisper/generation_whisper.js"),C=n("./src/models/whisper/common_whisper.js");const I=0,w=1,k=2,x=3,y=4,v=5,E=6,B=7,M=8,D=9,T=10,S=11,N=new Map,G=new Map,F=new Map;async function P(e,t,n){return Object.fromEntries(await Promise.all(Object.keys(t).map((async i=>{const{buffer_or_path:A,session_options:l,session_config:u}=await async function(e,t,n){let i=n.config?.["transformers.js_config"]??{},A=n.device??i.device;A&&"string"!=typeof A&&(A.hasOwnProperty(t)?A=A[t]:(console.warn(`device not specified for "${t}". Using the default device.`),A=null));const l=A??(m.apis.IS_NODE_ENV?"cpu":"wasm"),u=(0,s.deviceToExecutionProviders)(l),c=i.device_config??{};c.hasOwnProperty(l)&&(i={...i,...c[l]});let d=n.dtype??i.dtype;if("string"!=typeof d&&(d&&d.hasOwnProperty(t)?d=d[t]:(d=a.DEFAULT_DEVICE_DTYPE_MAPPING[l]??a.DATA_TYPES.fp32,console.warn(`dtype not specified for "${t}". Using the default dtype (${d}) for this device (${l}).`))),d===a.DATA_TYPES.auto){let e=i.dtype;"string"!=typeof e&&(e=e?.[t]),d=e&&e!==a.DATA_TYPES.auto&&a.DATA_TYPES.hasOwnProperty(e)?e:a.DEFAULT_DEVICE_DTYPE_MAPPING[l]??a.DATA_TYPES.fp32}const h=d;if(!a.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(h))throw new Error(`Invalid dtype: ${h}. Should be one of: ${Object.keys(a.DATA_TYPES).join(", ")}`);if(h===a.DATA_TYPES.fp16&&"webgpu"===l&&!await(0,a.isWebGpuFp16Supported)())throw new Error(`The device (${l}) does not support fp16.`);const f=i.kv_cache_dtype,g=f?"string"==typeof f?f:f[h]??"float32":void 0;if(g&&!["float32","float16"].includes(g))throw new Error(`Invalid kv_cache_dtype: ${g}. Should be one of: float32, float16`);const p={dtype:h,kv_cache_dtype:g,device:l},b=`${t}${a.DEFAULT_DTYPE_SUFFIX_MAPPING[h]}.onnx`,C=`${n.subfolder??""}/${b}`,I={...n.session_options};I.executionProviders??=u;const w=i.free_dimension_overrides;w?I.freeDimensionOverrides??=w:l.startsWith("webnn")&&!I.freeDimensionOverrides&&console.warn(`WebNN does not currently support dynamic shapes and requires 'free_dimension_overrides' to be set in config.json, preferably as a field within config["transformers.js_config"]["device_config"]["${l}"]. When 'free_dimension_overrides' is not set, you may experience significant performance degradation.`);const k=m.apis.IS_NODE_ENV&&m.env.useFSCache,x=(0,o.getModelFile)(e,C,!0,n,k),y=n.use_external_data_format??i.use_external_data_format;let v=[];if(y){let r;r="object"==typeof y?y.hasOwnProperty(b)?y[b]:!!y.hasOwnProperty(t)&&y[t]:y;const s=+r;if(s>o.MAX_EXTERNAL_DATA_CHUNKS)throw new Error(`The number of external data chunks (${s}) exceeds the maximum allowed value (${o.MAX_EXTERNAL_DATA_CHUNKS}).`);for(let t=0;t<s;++t){const r=`${b}_data${0===t?"":"_"+t}`,s=`${n.subfolder??""}/${r}`;v.push(new Promise((async(t,a)=>{const i=await(0,o.getModelFile)(e,s,!0,n,k);t(i instanceof Uint8Array?{path:r,data:i}:r)})))}}else void 0!==I.externalData&&(v=I.externalData.map((async t=>{if("string"==typeof t.data){const r=await(0,o.getModelFile)(e,t.data,!0,n);return{...t,data:r}}return t})));if(v.length>0){const e=await Promise.all(v);m.apis.IS_NODE_ENV||(I.externalData=e)}if("webgpu"===l){const e=(0,r.getKeyValueShapes)(n.config,{prefix:"present"});if(Object.keys(e).length>0&&!(0,s.isONNXProxy)()){const t={};for(const n in e)t[n]="gpu-buffer";I.preferredOutputLocation=t}}return{buffer_or_path:await x,session_options:I,session_config:p}}(e,t[i],n);return[i,await(0,s.createInferenceSession)(A,l,u)]}))))}async function Q(e,t,n){return Object.fromEntries(await Promise.all(Object.keys(t).map((async r=>[r,await(0,o.getModelJSON)(e,t[r],!1,n)]))))}let z=Promise.resolve();async function O(e,t){const n=function(e,t){const n=Object.create(null),r=[];for(const a of e.inputNames){const e=t[a];e instanceof d.Tensor?n[a]=(0,s.isONNXProxy)()?e.clone():e:r.push(a)}if(r.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${r.join(", ")}.`);const a=Object.keys(t).length,i=e.inputNames.length;if(a>i){let n=Object.keys(t).filter((t=>!e.inputNames.includes(t)));console.warn(`WARNING: Too many inputs were provided (${a} > ${i}). The following inputs will be ignored: "${n.join(", ")}".`)}return n}(e,t);try{const t=Object.fromEntries(Object.entries(n).map((([e,t])=>[e,t.ort_tensor]))),r=()=>e.run(t);return R(await(m.apis.IS_BROWSER_ENV||m.apis.IS_WEBWORKER_ENV?z=z.then(r):r()))}catch(e){const t=Object.fromEntries(Object.entries(n).map((([e,t])=>{const n={type:t.type,dims:t.dims,location:t.location};return"gpu-buffer"!==n.location&&(n.data=t.data),[e,n]})));throw console.error(`An error occurred during model execution: "${e}".`),console.error("Inputs given to model:",t),e}}function R(e){for(let t in e)(0,s.isONNXTensor)(e[t])?e[t]=new d.Tensor(e[t]):"object"==typeof e[t]&&R(e[t]);return e}function L(e){if(e instanceof d.Tensor)return e;if(0===e.length)throw Error("items must be non-empty");if(Array.isArray(e[0])){if(e.some((t=>t.length!==e[0].length)))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new d.Tensor("int64",BigInt64Array.from(e.flat().map((e=>BigInt(e)))),[e.length,e[0].length])}return new d.Tensor("int64",BigInt64Array.from(e.map((e=>BigInt(e)))),[1,e.length])}function W(e){return new d.Tensor("bool",[e],[1])}async function _(e,t){let{encoder_outputs:n,input_ids:r,decoder_input_ids:s,...a}=t;if(!n){const r=(0,A.pick)(t,e.sessions.model.inputNames);n=(await V(e,r)).last_hidden_state}a.input_ids=s,a.encoder_hidden_states=n,e.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(a.encoder_attention_mask=t.attention_mask);return await U(e,a,!0)}async function V(e,t){const n=e.sessions.model,r=(0,A.pick)(t,n.inputNames);if(n.inputNames.includes("inputs_embeds")&&!r.inputs_embeds){if(!t.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");r.inputs_embeds=await e.encode_text({input_ids:t.input_ids})}if(n.inputNames.includes("token_type_ids")&&!r.token_type_ids){if(!r.input_ids)throw new Error("Both `input_ids` and `token_type_ids` are missing in the model inputs.");r.token_type_ids=(0,d.zeros_like)(r.input_ids)}if(n.inputNames.includes("pixel_mask")&&!r.pixel_mask){if(!r.pixel_values)throw new Error("Both `pixel_values` and `pixel_mask` are missing in the model inputs.");const e=r.pixel_values.dims;r.pixel_mask=(0,d.ones)([e[0],e[2],e[3]])}return await O(n,r)}async function H(e,t){const n=await e.encode(t);return await e.decode(n)}async function U(e,t,n=!1){const r=e.sessions[n?"decoder_model_merged":"model"],{past_key_values:s,...a}=t;if(r.inputNames.includes("use_cache_branch")&&(a.use_cache_branch=W(!!s)),r.inputNames.includes("position_ids")&&a.attention_mask&&!a.position_ids){const t=["paligemma","gemma3_text","gemma3"].includes(e.config.model_type)?1:0;a.position_ids=function(e,t=null,n=0){const{input_ids:r,inputs_embeds:s,attention_mask:a}=e,{data:i,dims:A}=Z(a,n);let o=new d.Tensor("int64",i,A);if(t){const e=-(r??s).dims.at(1);o=o.slice(null,[e,null])}return o}(a,s,t)}e.addPastKeyValues(a,s);const i=(0,A.pick)(a,r.inputNames);return await O(r,i)}function j({modality_token_id:e,inputs_embeds:t,modality_features:n,input_ids:r,attention_mask:s}){const a=r.tolist().map((t=>t.reduce(((t,n,r)=>(n==e&&t.push(r),t)),[]))),i=a.reduce(((e,t)=>e+t.length),0),A=n.dims[0];if(i!==A)throw new Error(`Number of tokens and features do not match: tokens: ${i}, features ${A}`);let o=0;for(let e=0;e<a.length;++e){const r=a[e],s=t[e];for(let e=0;e<r.length;++e)s[r[e]].data.set(n[o++].data)}return{inputs_embeds:t,attention_mask:s}}function Y({image_token_id:e,inputs_embeds:t,image_features:n,input_ids:r,attention_mask:s}){return j({modality_token_id:e,inputs_embeds:t,modality_features:n,input_ids:r,attention_mask:s})}async function K(e,{encode_function:t,merge_function:n,modality_input_name:r,modality_output_name:s,input_ids:a=null,attention_mask:i=null,position_ids:A=null,inputs_embeds:o=null,past_key_values:l=null,generation_config:u=null,logits_processor:c=null,...h}){const f=h[r];if(!o)if(o=await e.encode_text({input_ids:a,...h}),f&&1!==a.dims[1]){const e=await t({[r]:f,...h});({inputs_embeds:o,attention_mask:i}=n({[s]:e,inputs_embeds:o,input_ids:a,attention_mask:i}))}else if(l&&f&&1===a.dims[1]){const e=a.dims[1],t=Object.values(l)[0].dims.at(-2);i=(0,d.cat)([(0,d.ones)([a.dims[0],t]),i.slice(null,[i.dims[1]-e,i.dims[1]])],1)}if(!A&&"qwen2_vl"===e.config.model_type){const{image_grid_thw:t,video_grid_thw:n}=h;[A]=e.get_rope_index(a,t,n,i)}return await U(e,{inputs_embeds:o,past_key_values:l,attention_mask:i,position_ids:A,generation_config:u,logits_processor:c},!0)}async function X(e,t){return await K(e,{...t,modality_input_name:"audio_values",modality_output_name:"audio_features",encode_function:e.encode_audio.bind(e),merge_function:e._merge_input_ids_with_audio_features.bind(e)})}async function q(e,t){return await K(e,{...t,modality_input_name:"pixel_values",modality_output_name:"image_features",encode_function:e.encode_image.bind(e),merge_function:e._merge_input_ids_with_image_features.bind(e)})}function Z(e,t=0){const[n,r]=e.dims,s=e.data,a=new BigInt64Array(s.length);for(let e=0;e<n;++e){const n=e*r;let i=BigInt(t);for(let e=0;e<r;++e){const t=n+e;0n===s[t]?a[t]=BigInt(1):(a[t]=i,i+=s[t])}}return{data:a,dims:e.dims}}function J(e,t,n,r){if(n.past_key_values){const t=Object.values(n.past_key_values)[0].dims.at(-2),{input_ids:r,attention_mask:s}=n;if(s&&s.dims[1]>r.dims[1]);else if(t<r.dims[1])n.input_ids=r.slice(null,[t,null]);else if(null!=e.config.image_token_index&&r.data.some((t=>t==e.config.image_token_index))){const s=e.config.num_image_tokens;if(!s)throw new Error("`num_image_tokens` is missing in the model configuration.");const a=r.dims[1]-(t-s);n.input_ids=r.slice(null,[-a,null]),n.attention_mask=(0,d.ones)([1,t+a])}}return n}function $(e,t,n,r){return n.past_key_values&&(t=t.map((e=>[e.at(-1)]))),{...n,decoder_input_ids:L(t)}}function ee(e,...t){return e.config.is_encoder_decoder?$(e,...t):J(e,...t)}function te(e,t,n,r){const s=!!n.past_key_values;if(null!==r.guidance_scale&&r.guidance_scale>1&&(s?n.input_ids=(0,d.cat)([n.input_ids,n.input_ids],0):(n.input_ids=(0,d.cat)([n.input_ids,(0,d.full_like)(n.input_ids,BigInt(r.pad_token_id))],0),n.attention_mask=(0,d.cat)([n.attention_mask,(0,d.full_like)(n.attention_mask,0n)],0))),!s&&n.pixel_values||(n.pixel_values=(0,d.full)([0,0,3,384,384],1)),s){const e=0,t=1,r=1;n.images_seq_mask=new d.Tensor("bool",new Array(e+t).fill(!0).fill(!1,0,t),[r,e+t]),n.images_emb_mask=new d.Tensor("bool",new Array(e).fill(!1),[r,1,e])}return n}class ne extends i.Callable{main_input_name="input_ids";forward_params=["input_ids","attention_mask"];constructor(e,t,n){super(),this.config=e,this.sessions=t,this.configs=n;const r=F.get(this.constructor),s=N.get(r);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,s){case y:this.can_generate=!0,this._forward=U,this._prepare_inputs_for_generation=J;break;case k:case x:case B:this.can_generate=!0,this._forward=_,this._prepare_inputs_for_generation=$;break;case w:this._forward=_;break;case E:this.can_generate=!0,this._forward=q,this._prepare_inputs_for_generation=ee;break;case T:this.can_generate=!0,this._forward=X,this._prepare_inputs_for_generation=ee;break;case D:this.can_generate=!0,this._prepare_inputs_for_generation=ee;break;case M:this.can_generate=!0,this._prepare_inputs_for_generation=te;break;case S:this._forward=H;break;default:this._forward=V}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){const e=[];for(const t of Object.values(this.sessions))t?.handler?.dispose&&e.push(t.handler.dispose());return await Promise.all(e)}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:s=null,local_files_only:a=!1,revision:i="main",model_file_name:A=null,subfolder:o="onnx",device:u=null,dtype:c=null,use_external_data_format:d=null,session_options:h={}}={}){let f={progress_callback:t,config:n,cache_dir:s,local_files_only:a,revision:i,model_file_name:A,subfolder:o,device:u,dtype:c,use_external_data_format:d,session_options:h};const g=F.get(this),p=N.get(g);let m;if(n=f.config=await r.AutoConfig.from_pretrained(e,f),p===y)m=await Promise.all([P(e,{model:f.model_file_name??"model"},f),Q(e,{generation_config:"generation_config.json"},f)]);else if(p===k||p===x)m=await Promise.all([P(e,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},f),Q(e,{generation_config:"generation_config.json"},f)]);else if(p===v)m=await Promise.all([P(e,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},f)]);else if(p===w)m=await Promise.all([P(e,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},f)]);else if(p===E){const t={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};n.is_encoder_decoder&&(t.model="encoder_model"),m=await Promise.all([P(e,t,f),Q(e,{generation_config:"generation_config.json"},f)])}else if(p===T){const t={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",decoder_model_merged:"decoder_model_merged"};m=await Promise.all([P(e,t,f),Q(e,{generation_config:"generation_config.json"},f)])}else if(p===B)m=await Promise.all([P(e,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},f),Q(e,{generation_config:"generation_config.json"},f)]);else if(p===M)m=await Promise.all([P(e,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},f),Q(e,{generation_config:"generation_config.json"},f)]);else if(p===D)m=await Promise.all([P(e,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"model",vision_encoder:"vision_encoder"},f),Q(e,{generation_config:"generation_config.json"},f)]);else if(p===S)m=await Promise.all([P(e,{encoder_model:"encoder_model",decoder_model:"decoder_model"},f)]);else{if(p!==I){const e=g??n?.model_type;"custom"!==e&&console.warn(`Model type for '${e}' not found, assuming encoder-only architecture. Please report this at ${l.GITHUB_ISSUE_URL}.`)}m=await Promise.all([P(e,{model:f.model_file_name??"model"},f)])}return new this(n,...m)}async _call(e){return await this.forward(e)}async forward(e){return await this._forward(this,e)}get generation_config(){return this.configs?.generation_config??null}_get_logits_warper(e){const t=new u.LogitsProcessorList;return null!==e.temperature&&1!==e.temperature&&t.push(new u.TemperatureLogitsWarper(e.temperature)),null!==e.top_k&&0!==e.top_k&&t.push(new u.TopKLogitsWarper(e.top_k)),null!==e.top_p&&e.top_p<1&&t.push(new u.TopPLogitsWarper(e.top_p)),t}_get_logits_processor(e,t,n=null){const r=new u.LogitsProcessorList;if(null!==e.repetition_penalty&&1!==e.repetition_penalty&&r.push(new u.RepetitionPenaltyLogitsProcessor(e.repetition_penalty)),null!==e.no_repeat_ngram_size&&e.no_repeat_ngram_size>0&&r.push(new u.NoRepeatNGramLogitsProcessor(e.no_repeat_ngram_size)),null!==e.bad_words_ids&&r.push(new u.NoBadWordsLogitsProcessor(e.bad_words_ids,e.eos_token_id)),null!==e.min_length&&null!==e.eos_token_id&&e.min_length>0&&r.push(new u.MinLengthLogitsProcessor(e.min_length,e.eos_token_id)),null!==e.min_new_tokens&&null!==e.eos_token_id&&e.min_new_tokens>0&&r.push(new u.MinNewTokensLengthLogitsProcessor(t,e.min_new_tokens,e.eos_token_id)),null!==e.forced_bos_token_id&&r.push(new u.ForcedBOSTokenLogitsProcessor(e.forced_bos_token_id)),null!==e.forced_eos_token_id&&r.push(new u.ForcedEOSTokenLogitsProcessor(e.max_length,e.forced_eos_token_id)),null!==e.begin_suppress_tokens){const n=t>1||null===e.forced_bos_token_id?t:t+1;r.push(new u.SuppressTokensAtBeginLogitsProcessor(e.begin_suppress_tokens,n))}return null!==e.guidance_scale&&e.guidance_scale>1&&r.push(new u.ClassifierFreeGuidanceLogitsProcessor(e.guidance_scale)),null!==n&&r.extend(n),r}_prepare_generation_config(e,t,n=c.GenerationConfig){const r={...this.config};for(const e of["decoder","generator","text_config"])e in r&&Object.assign(r,r[e]);const s=new n(r);return Object.assign(s,this.generation_config??{}),e&&Object.assign(s,e),t&&Object.assign(s,(0,A.pick)(t,Object.getOwnPropertyNames(s))),s}_get_stopping_criteria(e,t=null){const n=new g.StoppingCriteriaList;return null!==e.max_length&&n.push(new g.MaxLengthCriteria(e.max_length,this.config.max_position_embeddings??null)),null!==e.eos_token_id&&n.push(new g.EosTokenCriteria(e.eos_token_id)),t&&n.extend(t),n}_validate_model_class(){if(!this.can_generate){const e=[Ml,Nl,Bl,kl],t=F.get(this.constructor),n=new Set,r=this.config.model_type;for(const t of e){const e=t.get(r);e&&n.add(e[0])}let s=`The current model class (${t}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw n.size>0&&(s+=` Please use the following class instead: ${[...n].join(", ")}`),Error(s)}}prepare_inputs_for_generation(...e){return this._prepare_inputs_for_generation(this,...e)}_update_model_kwargs_for_generation({generated_input_ids:e,outputs:t,model_inputs:n,is_encoder_decoder:r}){return n.past_key_values=this.getPastKeyValues(t,n.past_key_values),n.input_ids=new d.Tensor("int64",e.flat(),[e.length,1]),r||(n.attention_mask=(0,d.cat)([n.attention_mask,(0,d.ones)([n.attention_mask.dims[0],1])],1)),n.position_ids=null,n}_prepare_model_inputs({inputs:e,bos_token_id:t,model_kwargs:n}){const r=(0,A.pick)(n,this.forward_params),s=this.main_input_name;if(s in r){if(e)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else r[s]=e;return{inputs_tensor:r[s],model_inputs:r,model_input_name:s}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:e,model_inputs:t,model_input_name:n,generation_config:r}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!t.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:e,pixel_values:n,attention_mask:r,...s}=t,a=await this._prepare_inputs_embeds(t);t={...s,...(0,A.pick)(a,["inputs_embeds","attention_mask"])}}let{last_hidden_state:s}=await V(this,t);if(null!==r.guidance_scale&&r.guidance_scale>1)s=(0,d.cat)([s,(0,d.full_like)(s,0)],0),"attention_mask"in t&&(t.attention_mask=(0,d.cat)([t.attention_mask,(0,d.zeros_like)(t.attention_mask)],0));else if(t.decoder_input_ids){const e=L(t.decoder_input_ids).dims[0];if(e!==s.dims[0]){if(1!==s.dims[0])throw new Error(`The encoder outputs have a different batch size (${s.dims[0]}) than the decoder inputs (${e}).`);s=(0,d.cat)(Array.from({length:e},(()=>s)),0)}}return t.encoder_outputs=s,t}_prepare_decoder_input_ids_for_generation({batch_size:e,model_input_name:t,model_kwargs:n,decoder_start_token_id:r,bos_token_id:s,generation_config:a}){let{decoder_input_ids:i,...A}=n;if(!(i instanceof d.Tensor)){if(i)Array.isArray(i[0])||(i=Array.from({length:e},(()=>i)));else if(r??=s,"musicgen"===this.config.model_type)i=Array.from({length:e*this.config.decoder.num_codebooks},(()=>[r]));else if(Array.isArray(r)){if(r.length!==e)throw new Error(`\`decoder_start_token_id\` expcted to have length ${e} but got ${r.length}`);i=r}else i=Array.from({length:e},(()=>[r]));i=L(i)}return n.decoder_attention_mask=(0,d.ones_like)(i),{input_ids:i,model_inputs:A}}async generate({inputs:e=null,generation_config:t=null,logits_processor:n=null,stopping_criteria:r=null,streamer:s=null,...a}){this._validate_model_class(),t=this._prepare_generation_config(t,a);let{inputs_tensor:i,model_inputs:A,model_input_name:o}=this._prepare_model_inputs({inputs:e,model_kwargs:a});const l=this.config.is_encoder_decoder;let u;l&&("encoder_outputs"in A||(A=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:i,model_inputs:A,model_input_name:o,generation_config:t}))),l?({input_ids:u,model_inputs:A}=this._prepare_decoder_input_ids_for_generation({batch_size:A[o].dims.at(0),model_input_name:o,model_kwargs:A,decoder_start_token_id:t.decoder_start_token_id,bos_token_id:t.bos_token_id,generation_config:t})):u=A[o];let c=u.dims.at(-1);null!==t.max_new_tokens&&(t.max_length=c+t.max_new_tokens);const h=this._get_logits_processor(t,c,n),f=this._get_stopping_criteria(t,r),g=A[o].dims.at(0),m=p.LogitsSampler.getSampler(t),b=new Array(g).fill(0),C=u.tolist();let I;s&&s.put(C);let w={};for(;;){if(A=this.prepare_inputs_for_generation(C,A,t),I=await this.forward(A),t.output_attentions&&t.return_dict_in_generate){const e=this.getAttentions(I);for(const t in e)t in w||(w[t]=[]),w[t].push(e[t])}const e=h(C,I.logits.slice(null,-1,null)),n=[];for(let t=0;t<e.dims.at(0);++t){const r=e[t],s=await m(r);for(const[e,r]of s){const s=BigInt(e);b[t]+=r,C[t].push(s),n.push([s]);break}}s&&s.put(n);if(f(C).every((e=>e)))break;A=this._update_model_kwargs_for_generation({generated_input_ids:n,outputs:I,model_inputs:A,is_encoder_decoder:l})}s&&s.end();const k=this.getPastKeyValues(I,A.past_key_values,!0),x=new d.Tensor("int64",C.flat(),[C.length,C[0].length]);if(t.return_dict_in_generate)return{sequences:x,past_key_values:k,...w};for(const e of Object.values(I))"gpu-buffer"===e.location&&e.dispose();return x}getPastKeyValues(e,t,n=!1){const r=Object.create(null);for(const s in e)if(s.startsWith("present")){const a=s.replace("present","past_key_values"),i=s.includes("encoder");if(r[a]=i&&t?t[a]:e[s],t&&(!i||n)){const e=t[a];"gpu-buffer"===e.location&&e.dispose()}}return r}getAttentions(e){const t={};for(const n of["cross_attentions","encoder_attentions","decoder_attentions"])for(const r in e)r.startsWith(n)&&(n in t||(t[n]=[]),t[n].push(e[r]));return t}addPastKeyValues(e,t){if(t)Object.assign(e,t);else{const t=this.sessions.decoder_model_merged??this.sessions.model,n=t?.config?.kv_cache_dtype??"float32",s="float16"===n?new d.DataTypeMap.float16:[],a=(e[this.main_input_name]??e.attention_mask)?.dims?.[0]??1,i=(0,r.getKeyValueShapes)(this.config,{batch_size:a});for(const t in i)e[t]=new d.Tensor(n,s,i[t])}}async encode_image({pixel_values:e}){const t=(await O(this.sessions.vision_encoder,{pixel_values:e})).image_features;return this.config.num_image_tokens||(console.warn(`The number of image tokens was not set in the model configuration. Setting it to the number of features detected by the vision encoder (${t.dims[1]}).`),this.config.num_image_tokens=t.dims[1]),t}async encode_text({input_ids:e}){return(await O(this.sessions.embed_tokens,{input_ids:e})).inputs_embeds}async encode_audio({audio_values:e}){return(await O(this.sessions.audio_encoder,{audio_values:e})).audio_features}}class re{}class se extends re{constructor({last_hidden_state:e,hidden_states:t=null,attentions:n=null}){super(),this.last_hidden_state=e,this.hidden_states=t,this.attentions=n}}class ae extends ne{}class ie extends ae{}class Ae extends ae{async _call(e){return new Ou(await super._call(e))}}class oe extends ae{async _call(e){return new Pu(await super._call(e))}}class le extends ae{async _call(e){return new zu(await super._call(e))}}class ue extends ae{async _call(e){return new Ru(await super._call(e))}}class ce extends ne{}class de extends ce{}class he extends ce{async _call(e){return new Ou(await super._call(e))}}class fe extends ce{async _call(e){return new Pu(await super._call(e))}}class ge extends ce{async _call(e){return new zu(await super._call(e))}}class pe extends ne{}class me extends pe{}class be extends ne{}class Ce extends be{}class Ie extends be{async _call(e){return new Ou(await super._call(e))}}class we extends be{async _call(e){return new Pu(await super._call(e))}}class ke extends be{async _call(e){return new zu(await super._call(e))}}class xe extends be{async _call(e){return new Ru(await super._call(e))}}class ye extends ne{}class ve extends ye{}class Ee extends ye{async _call(e){return new Ou(await super._call(e))}}class Be extends ye{async _call(e){return new Pu(await super._call(e))}}class Me extends ye{async _call(e){return new zu(await super._call(e))}}class De extends ye{async _call(e){return new Ru(await super._call(e))}}class Te extends ne{}class Se extends Te{}class Ne extends Te{async _call(e){return new Ou(await super._call(e))}}class Ge extends Te{async _call(e){return new Pu(await super._call(e))}}class Fe extends Te{async _call(e){return new zu(await super._call(e))}}class Pe extends Te{async _call(e){return new Ru(await super._call(e))}}class Qe extends ne{}class ze extends Qe{}class Oe extends Qe{async _call(e){return new Ou(await super._call(e))}}class Re extends Qe{async _call(e){return new Pu(await super._call(e))}}class Le extends Qe{async _call(e){return new zu(await super._call(e))}}class We extends Qe{async _call(e){return new Ru(await super._call(e))}}class _e extends ne{}class Ve extends _e{}class He extends _e{async _call(e){return new Ou(await super._call(e))}}class Ue extends _e{async _call(e){return new Pu(await super._call(e))}}class je extends _e{async _call(e){return new zu(await super._call(e))}}class Ye extends _e{async _call(e){return new Ru(await super._call(e))}}class Ke extends ne{}class Xe extends Ke{}class qe extends Ke{async _call(e){return new Ou(await super._call(e))}}class Ze extends Ke{async _call(e){return new Pu(await super._call(e))}}class Je extends Ke{async _call(e){return new zu(await super._call(e))}}class $e extends Ke{async _call(e){return new Ru(await super._call(e))}}class et extends ne{}class tt extends et{}class nt extends et{async _call(e){return new Pu(await super._call(e))}}class rt extends et{async _call(e){return new zu(await super._call(e))}}class st extends et{async _call(e){return new Ru(await super._call(e))}}class at extends et{async _call(e){return new Ou(await super._call(e))}}class it extends ne{}class At extends it{}class ot extends it{async _call(e){return new Ou(await super._call(e))}}class lt extends it{async _call(e){return new Pu(await super._call(e))}}class ut extends it{async _call(e){return new zu(await super._call(e))}}class ct extends ne{}class dt extends ct{}class ht extends ct{async _call(e){return new Ou(await super._call(e))}}class ft extends ct{async _call(e){return new Pu(await super._call(e))}}class gt extends ct{async _call(e){return new Ru(await super._call(e))}}class pt extends ne{}class mt extends pt{}class bt extends pt{async _call(e){return new Ou(await super._call(e))}}class Ct extends pt{async _call(e){return new Pu(await super._call(e))}}class It extends pt{async _call(e){return new zu(await super._call(e))}}class wt extends pt{async _call(e){return new Ru(await super._call(e))}}class kt extends ne{}class xt extends kt{}class yt extends kt{async _call(e){return new Ou(await super._call(e))}}class vt extends kt{async _call(e){return new Pu(await super._call(e))}}class Et extends kt{async _call(e){return new Ru(await super._call(e))}}class Bt extends ne{}class Mt extends Bt{}class Dt extends Bt{async _call(e){return new Pu(await super._call(e))}}class Tt extends Bt{async _call(e){return new Ru(await super._call(e))}}class St extends Bt{async _call(e){return new Ou(await super._call(e))}}class Nt extends ne{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"]}class Gt extends Nt{}class Ft extends Nt{}class Pt extends ne{}class Qt extends Pt{}class zt extends Pt{}class Ot extends ne{}class Rt extends Ot{}class Lt extends Ot{}class Wt extends ne{}class _t extends Wt{}class Vt extends Wt{}class Ht extends Wt{async _call(e){return new Pu(await super._call(e))}}class Ut extends ne{}class jt extends Ut{}class Yt extends Ut{}class Kt extends Ut{async _call(e){return new Pu(await super._call(e))}}class Xt extends Ut{}class qt extends ne{}class Zt extends qt{}class Jt extends qt{}class $t extends ne{}class en extends $t{}class tn extends $t{}class nn extends ne{}class rn extends nn{}class sn extends nn{async _call(e){return new Ou(await super._call(e))}}class an extends nn{async _call(e){return new Pu(await super._call(e))}}class An extends nn{async _call(e){return new zu(await super._call(e))}}class on extends nn{async _call(e){return new Ru(await super._call(e))}}class ln extends ne{}class un extends ln{}class cn extends ln{async _call(e){return new Ou(await super._call(e))}}class dn extends ln{async _call(e){return new Pu(await super._call(e))}}class hn extends ln{async _call(e){return new zu(await super._call(e))}}class fn extends ln{async _call(e){return new Ru(await super._call(e))}}class gn extends ne{}class pn extends gn{}class mn extends gn{async _call(e){return new Ou(await super._call(e))}}class bn extends gn{async _call(e){return new Pu(await super._call(e))}}class Cn extends gn{async _call(e){return new zu(await super._call(e))}}class In extends gn{async _call(e){return new Ru(await super._call(e))}}class wn extends ne{}class kn extends wn{}class xn extends wn{}class yn extends ne{requires_attention_mask=!1;main_input_name="input_features";forward_params=["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"]}class vn extends yn{}class En extends yn{_prepare_generation_config(e,t){return super._prepare_generation_config(e,t,b.WhisperGenerationConfig)}_retrieve_init_tokens(e){const t=[e.decoder_start_token_id];let n=e.language;const r=e.task;if(e.is_multilingual){n||(console.warn("No language specified - defaulting to English (en)."),n="en");const s=`<|${(0,C.whisper_language_to_code)(n)}|>`;t.push(e.lang_to_id[s]),t.push(e.task_to_id[r??"transcribe"])}else if(n||r)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!e.return_timestamps&&e.no_timestamps_token_id&&t.at(-1)!==e.no_timestamps_token_id?t.push(e.no_timestamps_token_id):e.return_timestamps&&t.at(-1)===e.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),t.pop()),t.filter((e=>null!=e))}async generate({inputs:e=null,generation_config:t=null,logits_processor:n=null,stopping_criteria:r=null,...s}){t=this._prepare_generation_config(t,s);const a=s.decoder_input_ids??this._retrieve_init_tokens(t);if(t.return_timestamps&&(n??=new u.LogitsProcessorList,n.push(new u.WhisperTimeStampLogitsProcessor(t,a))),t.begin_suppress_tokens&&(n??=new u.LogitsProcessorList,n.push(new u.SuppressTokensAtBeginLogitsProcessor(t.begin_suppress_tokens,a.length))),t.return_token_timestamps){if(!t.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");"translate"===t.task&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),t.output_attentions=!0,t.return_dict_in_generate=!0}const i=await super.generate({inputs:e,generation_config:t,logits_processor:n,decoder_input_ids:a,...s});return t.return_token_timestamps&&(i.token_timestamps=this._extract_token_timestamps(i,t.alignment_heads,t.num_frames)),i}_extract_token_timestamps(e,t,n=null,r=.02){if(!e.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");null==n&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let s=this.config.median_filter_width;void 0===s&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),s=7);const a=e.cross_attentions,i=Array.from({length:this.config.decoder_layers},((e,t)=>(0,d.cat)(a.map((e=>e[t])),2))),o=(0,d.stack)(t.map((([e,t])=>{if(e>=i.length)throw new Error(`Layer index ${e} is out of bounds for cross attentions (length ${i.length}).`);return n?i[e].slice(null,t,null,[0,n]):i[e].slice(null,t)}))).transpose(1,0,2,3),[l,u]=(0,d.std_mean)(o,-2,0,!0),c=o.clone();for(let e=0;e<c.dims[0];++e){const t=c[e];for(let n=0;n<t.dims[0];++n){const r=t[n],a=l[e][n][0].data,i=u[e][n][0].data;for(let e=0;e<r.dims[0];++e){let t=r[e].data;for(let e=0;e<t.length;++e)t[e]=(t[e]-i[e])/a[e];t.set((0,f.medianFilter)(t,s))}}}const h=[(0,d.mean)(c,1)],g=e.sequences.dims,p=new d.Tensor("float32",new Float32Array(g[0]*g[1]),g);for(let e=0;e<g[0];++e){const t=h[e].neg().squeeze_(0),[n,s]=(0,f.dynamic_time_warping)(t.tolist()),a=Array.from({length:n.length-1},((e,t)=>n[t+1]-n[t])),i=(0,A.mergeArrays)([1],a).map((e=>!!e)),o=[];for(let e=0;e<i.length;++e)i[e]&&o.push(s[e]*r);p[e].data.set(o,1)}return p}}class Bn extends En{}class Mn extends ne{requires_attention_mask=!1;main_input_name="input_values";forward_params=["input_values","decoder_input_ids","past_key_values"]}class Dn extends Mn{}class Tn extends Mn{}class Sn extends ne{main_input_name="pixel_values";forward_params=["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"]}class Nn extends ne{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class Gn extends Nn{_merge_input_ids_with_image_features({inputs_embeds:e,image_features:t,input_ids:n,attention_mask:r}){const s=this.config.image_token_index,a=n.tolist().map((e=>e.findIndex((e=>e==s)))),i=a.every((e=>-1===e)),A=a.every((e=>-1!==e));if(!i&&!A)throw new Error("Every input should contain either 0 or 1 image token.");if(i)return{inputs_embeds:e,attention_mask:r};const o=[],l=[];for(let n=0;n<a.length;++n){const s=a[n],i=e[n],A=t[n],u=r[n];o.push((0,d.cat)([i.slice([0,s]),A,i.slice([s+1,i.dims[0]])],0)),l.push((0,d.cat)([u.slice([0,s]),(0,d.ones)([A.dims[0]]),u.slice([s+1,u.dims[0]])],0))}return{inputs_embeds:(0,d.stack)(o,0),attention_mask:(0,d.stack)(l,0)}}}class Fn extends Gn{}class Pn extends Gn{}class Qn extends ne{forward_params=["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"];main_input_name="inputs_embeds"}class zn extends Qn{_merge_input_ids_with_image_features({inputs_embeds:e,image_features:t,input_ids:n,attention_mask:r}){return{inputs_embeds:(0,d.cat)([t,e],1),attention_mask:(0,d.cat)([(0,d.ones)(t.dims.slice(0,2)),r],1)}}async _prepare_inputs_embeds({input_ids:e,pixel_values:t,inputs_embeds:n,attention_mask:r}){if(!e&&!t)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let s,a;return e&&(s=await this.encode_text({input_ids:e})),t&&(a=await this.encode_image({pixel_values:t})),s&&a?({inputs_embeds:n,attention_mask:r}=this._merge_input_ids_with_image_features({inputs_embeds:s,image_features:a,input_ids:e,attention_mask:r})):n=s||a,{inputs_embeds:n,attention_mask:r}}async forward({input_ids:e,pixel_values:t,attention_mask:n,decoder_input_ids:r,decoder_attention_mask:s,encoder_outputs:a,past_key_values:i,inputs_embeds:A,decoder_inputs_embeds:o}){if(A||({inputs_embeds:A,attention_mask:n}=await this._prepare_inputs_embeds({input_ids:e,pixel_values:t,inputs_embeds:A,attention_mask:n})),!a){let{last_hidden_state:e}=await V(this,{inputs_embeds:A,attention_mask:n});a=e}if(!o){if(!r)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");o=await this.encode_text({input_ids:r})}const l={inputs_embeds:o,attention_mask:s,encoder_attention_mask:n,encoder_hidden_states:a,past_key_values:i};return await U(this,l,!0)}}class On extends ne{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class Rn extends On{_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),n=e.image_features.view(-1,t);return Y({image_token_id:this.config.image_token_index,...e,image_features:n})}}class Ln extends ne{forward_params=["input_ids","attention_mask","pixel_values","pixel_attention_mask","position_ids","past_key_values"]}class Wn extends Ln{async encode_image({pixel_values:e,pixel_attention_mask:t}){return(await O(this.sessions.vision_encoder,{pixel_values:e,pixel_attention_mask:t})).image_features}_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),n=e.image_features.view(-1,t);return Y({image_token_id:this.config.image_token_id,...e,image_features:n})}}class _n extends Wn{}class Vn extends ne{forward_params=["input_ids","inputs_embeds","attention_mask","position_ids","pixel_values","image_sizes","past_key_values"]}class Hn extends Vn{async forward({input_ids:e=null,attention_mask:t=null,pixel_values:n=null,image_sizes:r=null,position_ids:s=null,inputs_embeds:a=null,past_key_values:i=null,generation_config:A=null,logits_processor:o=null,...l}){if(!a){let t;if(n&&1!==e.dims[1]){if(!r)throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");({image_features:t}=await O(this.sessions.vision_encoder,{pixel_values:n,image_sizes:r}))}else{const e=this.config.normalized_config.hidden_size;t=new d.Tensor("float32",[],[0,e])}({inputs_embeds:a}=await O(this.sessions.prepare_inputs_embeds,{input_ids:e,image_features:t}))}return await U(this,{inputs_embeds:a,past_key_values:i,attention_mask:t,position_ids:s,generation_config:A,logits_processor:o},!1)}}class Un extends ne{}class jn extends Un{}class Yn extends Un{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class Kn extends Un{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class Xn extends Un{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"vision_model"})}}class qn extends Un{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"vision_model"})}}class Zn extends ne{}class Jn extends Zn{}class $n extends Zn{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class er extends Un{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"vision_model"})}}class tr extends ne{}class nr extends tr{}class rr extends ne{}class sr extends rr{async forward(e){const t=!e.input_ids,n=!e.pixel_values;if(t&&n)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(t&&(e.input_ids=(0,d.ones)([e.pixel_values.dims[0],1])),n){const{image_size:t}=this.config.vision_config;e.pixel_values=(0,d.full)([0,3,t,t],0)}const{text_embeddings:r,image_embeddings:s,l2norm_text_embeddings:a,l2norm_image_embeddings:i}=await super.forward(e),A={};return t||(A.text_embeddings=r,A.l2norm_text_embeddings=a),n||(A.image_embeddings=s,A.l2norm_image_embeddings=i),A}}class ar extends rr{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class ir extends rr{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"vision_model"})}}class Ar extends ne{}class or extends Ar{}class lr extends Ar{}class ur extends ne{}class cr extends ur{}class dr extends ur{}class hr extends ne{}class fr extends hr{}class gr extends hr{}class pr extends ne{}class mr extends pr{}class br extends pr{}class Cr extends ne{}class Ir extends Cr{}class wr extends Cr{}class kr extends ne{}class xr extends kr{}class yr extends kr{}class vr extends ne{}class Er extends vr{}class Br extends vr{}class Mr extends ne{}class Dr extends Mr{}class Tr extends Mr{}class Sr extends ne{}class Nr extends Sr{}class Gr extends Sr{}class Fr extends ne{}class Pr extends Fr{}class Qr extends Fr{}class zr extends ne{}class Or extends zr{}class Rr extends zr{}class Lr extends ne{}class Wr extends Lr{}class _r extends Lr{}class Vr extends ne{}class Hr extends Vr{}class Ur extends Vr{}class jr extends ne{}class Yr extends jr{}class Kr extends jr{}class Xr extends ne{}class qr extends Xr{}class Zr extends Xr{}class Jr extends ne{}class $r extends Jr{}class es extends Jr{}class ts extends ne{}class ns extends ts{}class rs extends ts{}class ss extends ne{}class as extends ss{}class is extends ss{}class As extends ne{}class os extends As{}class ls extends As{}class us extends ne{}class cs extends us{}class ds extends us{}class hs extends ne{}class fs extends hs{}class gs extends hs{}class ps extends ne{}class ms extends ps{}class bs extends ps{}class Cs extends ne{}class Is extends Cs{}class ws extends Cs{}class ks extends ne{forward_params=["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"]}class xs extends ks{get_rope_index(e,t,n,r){const{vision_config:s,image_token_id:a,video_token_id:i,vision_start_token_id:A}=this.config,o=s.spatial_merge_size??2,l=[];if(t||n){let s=e.tolist();r||(r=(0,d.ones_like)(e));const u=r.tolist(),c=Array.from({length:3},(t=>Array.from({length:e.dims[0]},(t=>Array.from({length:e.dims[1]},(e=>1)))))),h=t?t.tolist():[],g=n?n.tolist():[];let p=0,m=0;for(let e=0;e<s.length;++e){const t=s[e].filter(((t,n)=>1==u[e][n])),n=t.reduce(((e,t,n)=>(t==A&&e.push(n),e)),[]),r=n.map((e=>t[e+1])),d=r.filter((e=>e==a)).length,b=r.filter((e=>e==i)).length;let C=[],I=0,w=d,k=b;for(let e=0;e<r.length;++e){const e=t.findIndex(((e,t)=>t>I&&e==a)),n=t.findIndex(((e,t)=>t>I&&e==i)),r=w>0&&-1!==e?e:t.length+1,s=k>0&&-1!==n?n:t.length+1;let A,l,u,c;r<s?([l,u,c]=h[p],++p,--w,A=r):([l,u,c]=g[m],++m,--k,A=s);const[d,b,x]=[Number(l),Math.floor(Number(u)/o),Math.floor(Number(c)/o)],y=A-I,v=C.length>0?(0,f.max)(C.at(-1))[0]+1:0;C.push(Array.from({length:3*y},((e,t)=>v+t%y)));const E=y+v,B=d*b*x,M=Array.from({length:B},((e,t)=>E+Math.floor(t/(b*x)))),D=Array.from({length:B},((e,t)=>E+Math.floor(t/x)%b)),T=Array.from({length:B},((e,t)=>E+t%x));C.push([M,D,T].flat()),I=A+B}if(I<t.length){const e=C.length>0?(0,f.max)(C.at(-1))[0]+1:0,n=t.length-I;C.push(Array.from({length:3*n},((t,r)=>e+r%n)))}const x=C.reduce(((e,t)=>e+t.length),0),y=new Array(x);let v=0;for(let e=0;e<3;++e)for(let t=0;t<C.length;++t){const n=C[t],r=n.length/3;for(let t=e*r;t<(e+1)*r;++t)y[v++]=n[t]}let E=0;const B=u[e];for(let t=0;t<B.length;++t)if(1==B[t]){for(let n=0;n<3;++n)c[n][e][t]=y[n*x/3+E];++E}const M=(0,f.max)(y)[0];l.push(M+1-s[e].length)}return[new d.Tensor("int64",c.flat(1/0),[3,e.dims[0],e.dims[1]]),new d.Tensor("int64",l,[l.length,1])]}if(r){const{data:e,dims:t}=Z(r),n=BigInt64Array.from({length:3*e.length},((t,n)=>e[n%e.length])),s=Array.from({length:t[0]},((n,r)=>(0,f.max)(e.subarray(t[1]*r,t[1]*(r+1)))[0]+1n+BigInt(t[1])));return[new d.Tensor("int64",n,[3,...t]),new d.Tensor("int64",s,[s.length,1])]}{const[t,n]=e.dims,r=BigInt64Array.from({length:3*t*n},((e,r)=>BigInt(Math.floor(r%n/t))));return[new d.Tensor("int64",r,[3,...e.dims]),(0,d.zeros)([t,1])]}}async encode_image({pixel_values:e,image_grid_thw:t}){return(await O(this.sessions.vision_encoder,{pixel_values:e,grid_thw:t})).image_features}_merge_input_ids_with_image_features(e){return Y({image_token_id:this.config.image_token_id,...e})}prepare_inputs_for_generation(e,t,n){if(t.attention_mask&&!t.position_ids)if(t.past_key_values){t.pixel_values=null;const e=BigInt(Object.values(t.past_key_values)[0].dims.at(-2)),n=t.rope_deltas.map((t=>e+t));t.position_ids=(0,d.stack)([n,n,n],0)}else[t.position_ids,t.rope_deltas]=this.get_rope_index(t.input_ids,t.image_grid_thw,t.video_grid_thw,t.attention_mask);return t}}class ys extends ne{}class vs extends ys{}class Es extends ys{}class Bs extends ne{}class Ms extends Bs{}class Ds extends Bs{}class Ts extends ne{}class Ss extends Ts{}class Ns extends Ts{}class Gs extends ne{}class Fs extends Gs{}class Ps extends Gs{}class Qs extends ne{}class zs extends Qs{}class Os extends Qs{}class Rs extends ne{}class Ls extends Rs{}class Ws extends Rs{async _call(e){return new Pu(await super._call(e))}}class _s extends ne{}class Vs extends _s{}class Hs extends _s{async _call(e){return new Pu(await super._call(e))}}class Us extends ne{}class js extends Us{}class Ys extends ne{}class Ks extends Ys{}class Xs extends Ys{async _call(e){return new Pu(await super._call(e))}}class qs extends ne{}class Zs extends qs{}class Js extends ne{}class $s extends Js{}class ea extends Js{async _call(e){return new Pu(await super._call(e))}}class ta extends ne{}class na extends ta{}class ra extends ne{}class sa extends ra{}class aa extends ra{async _call(e){return new Pu(await super._call(e))}}class ia extends ne{}class Aa extends ia{async _call(e){return new _u(await super._call(e))}}class oa extends ne{}class la extends oa{}class ua extends oa{async _call(e){return new Pu(await super._call(e))}}class ca extends ne{}class da extends ca{}class ha extends ca{async _call(e){return new Pu(await super._call(e))}}class fa extends ne{}class ga extends fa{}class pa extends fa{}class ma extends ne{}class ba extends ma{}class Ca extends ma{}class Ia extends ne{}class wa extends Ia{}class ka extends Ia{async _call(e){return new Pu(await super._call(e))}}class xa extends ne{}class ya extends xa{}class va extends xa{async _call(e){return new Ba(await super._call(e))}}class Ea extends xa{async _call(e){return new Ma(await super._call(e))}}class Ba extends re{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class Ma extends re{constructor({logits:e,pred_boxes:t,pred_masks:n}){super(),this.logits=e,this.pred_boxes=t,this.pred_masks=n}}class Da extends ne{}class Ta extends Da{}class Sa extends Da{async _call(e){return new Na(await super._call(e))}}class Na extends re{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class Ga extends ne{}class Fa extends Ga{}class Pa extends Ga{async _call(e){return new Qa(await super._call(e))}}class Qa extends Na{}class za extends ne{}class Oa extends za{}class Ra extends za{async _call(e){return new La(await super._call(e))}}class La extends Na{}class Wa extends ne{}class _a extends Wa{}class Va extends Wa{async _call(e){return new Na(await super._call(e))}}class Ha extends ne{}class Ua extends Ha{}class ja extends Ha{async _call(e){return new Ya(await super._call(e))}}class Ya extends Ba{}class Ka extends ne{}class Xa extends Ka{}class qa extends Ka{async _call(e){return new Pu(await super._call(e))}}class Za extends ne{}class Ja extends Za{}class $a extends Za{async _call(e){return new Pu(await super._call(e))}}class ei extends ne{}class ti extends ei{}class ni extends ei{async _call(e){return new Pu(await super._call(e))}}class ri extends ne{}class si extends ri{}class ai extends ri{async _call(e){return new Pu(await super._call(e))}}class ii extends ri{}class Ai extends ne{}class oi extends Ai{}class li extends Ai{}class ui extends ne{}class ci extends ui{}class di extends ui{}class hi extends ne{}class fi extends hi{}class gi extends ne{}class pi extends gi{}class mi extends gi{}class bi extends gi{}class Ci extends ne{}class Ii extends Ci{}class wi extends ne{}class ki extends wi{}class xi extends ne{}class yi extends xi{}class vi extends ne{}class Ei extends vi{}class Bi extends vi{}class Mi extends ne{}class Di extends Mi{}class Ti extends Mi{}class Si extends ne{}class Ni extends Si{}class Gi extends ne{}class Fi extends Gi{}class Pi extends Gi{async _call(e){return new Pu(await super._call(e))}}class Qi extends ne{}class zi extends Qi{}class Oi extends Qi{async _call(e){return new Pu(await super._call(e))}}class Ri extends ne{}class Li extends Ri{}class Wi extends Ri{async _call(e){return new Pu(await super._call(e))}}class _i extends ne{}class Vi extends _i{}class Hi extends _i{async _call(e){return new Pu(await super._call(e))}}class Ui extends ne{}class ji extends Ui{}class Yi extends ne{}class Ki extends Yi{}class Xi extends Yi{async _call(e){return new qi(await super._call(e))}}class qi extends re{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class Zi extends ne{}class Ji extends Zi{async get_image_embeddings({pixel_values:e}){return await V(this,{pixel_values:e})}async forward(e){if(e.image_embeddings&&e.image_positional_embeddings||(e={...e,...await this.get_image_embeddings(e)}),!e.input_labels&&e.input_points){const t=e.input_points.dims.slice(0,-1),n=t.reduce(((e,t)=>e*t),1);e.input_labels=new d.Tensor("int64",new BigInt64Array(n).fill(1n),t)}const t={image_embeddings:e.image_embeddings,image_positional_embeddings:e.image_positional_embeddings};return e.input_points&&(t.input_points=e.input_points),e.input_labels&&(t.input_labels=e.input_labels),e.input_boxes&&(t.input_boxes=e.input_boxes),await O(this.sessions.prompt_encoder_mask_decoder,t)}async _call(e){return new $i(await super._call(e))}}class $i extends re{constructor({iou_scores:e,pred_masks:t}){super(),this.iou_scores=e,this.pred_masks=t}}class eA extends ne{}class tA extends eA{}class nA extends eA{}class rA extends ne{}class sA extends rA{}class aA extends rA{}class iA extends ne{}class AA extends iA{}class oA extends iA{async _call(e){return new Lu(await super._call(e))}}class lA extends iA{async _call(e){return new Pu(await super._call(e))}}class uA extends iA{async _call(e){return new zu(await super._call(e))}}class cA extends ne{}class dA extends cA{}class hA extends cA{async _call(e){return new zu(await super._call(e))}}class fA extends ne{}class gA extends fA{}class pA extends ne{}class mA extends pA{}class bA extends pA{async _call(e){return new Lu(await super._call(e))}}class CA extends pA{async _call(e){return new Pu(await super._call(e))}}class IA extends ne{}class wA extends IA{}class kA extends IA{async _call(e){return new Lu(await super._call(e))}}class xA extends IA{async _call(e){return new Pu(await super._call(e))}}class yA extends IA{async _call(e){return new zu(await super._call(e))}}class vA extends ne{}class EA extends vA{}class BA extends vA{async _call(e){return new Lu(await super._call(e))}}class MA extends vA{async _call(e){return new Pu(await super._call(e))}}class DA extends ne{}class TA extends iA{}class SA extends iA{async _call(e){return new Lu(await super._call(e))}}class NA extends iA{async _call(e){return new Pu(await super._call(e))}}class GA extends ne{}class FA extends GA{}class PA extends GA{async _call(e){return new Lu(await super._call(e))}}class QA extends GA{async _call(e){return new Pu(await super._call(e))}}class zA extends GA{async _call(e){return new Qu(await super._call(e))}}class OA extends GA{async _call(e){return new zu(await super._call(e))}}class RA extends ne{}class LA extends RA{}class WA extends ne{}class _A extends WA{}class VA extends WA{}class HA extends WA{async generate_speech(e,t,{threshold:n=.5,minlenratio:r=0,maxlenratio:s=20,vocoder:a=null}={}){const i={input_ids:e},{encoder_outputs:A,encoder_attention_mask:o}=await V(this,i),l=A.dims[1]/this.config.reduction_factor,u=Math.floor(l*s),c=Math.floor(l*r),h=this.config.num_mel_bins;let f=[],g=null,p=null,m=0;for(;;){++m;const e=W(!!p);let r;r=p?p.output_sequence_out:new d.Tensor("float32",new Float32Array(h),[1,1,h]);let s={use_cache_branch:e,output_sequence:r,encoder_attention_mask:o,speaker_embeddings:t,encoder_hidden_states:A};this.addPastKeyValues(s,g),p=await O(this.sessions.decoder_model_merged,s),g=this.getPastKeyValues(p,g);const{prob:a,spectrum:i}=p;if(f.push(i),m>=c&&(Array.from(a.data).filter((e=>e>=n)).length>0||m>=u))break}const b=(0,d.cat)(f),{waveform:C}=await O(a.sessions.model,{spectrogram:b});return{spectrogram:b,waveform:C}}}class UA extends ne{main_input_name="spectrogram"}class jA extends ne{}class YA extends jA{}class KA extends ne{}class XA extends KA{}class qA extends KA{}class ZA extends ne{}class JA extends ZA{}class $A extends ZA{}class eo extends ne{}class to extends eo{}class no extends eo{}class ro extends ne{}class so extends ro{}class ao extends ro{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class io extends ro{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"audio_model"})}}class Ao extends ne{}class oo extends Ao{async _call(e){return new Vu(await super._call(e))}}class lo extends ne{}class uo extends lo{}class co extends lo{}class ho extends lo{}class fo extends ne{}class go extends fo{}class po extends fo{}class mo extends ne{}class bo extends mo{}class Co extends mo{async _call(e){return new Pu(await super._call(e))}}class Io extends ne{}class wo extends Io{}class ko extends Io{}class xo extends ne{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"];_apply_and_filter_by_delay_pattern_mask(e){const[t,n]=e.dims,r=this.config.decoder.num_codebooks,s=n-r;let a=0;for(let t=0;t<e.size;++t){if(e.data[t]===this.config.decoder.pad_token_id)continue;const i=t%n-Math.floor(t/n)%r;i>0&&i<=s&&(e.data[a++]=e.data[t])}const i=Math.floor(t/r),A=a/(i*r);return new d.Tensor(e.type,e.data.slice(0,a),[i,r,A])}prepare_inputs_for_generation(e,t,n){let r=structuredClone(e);for(let e=0;e<r.length;++e)for(let t=0;t<r[e].length;++t)e%this.config.decoder.num_codebooks>=t&&(r[e][t]=BigInt(this.config.decoder.pad_token_id));null!==n.guidance_scale&&n.guidance_scale>1&&(r=r.concat(r));return super.prepare_inputs_for_generation(r,t,n)}async generate(e){const t=await super.generate(e),n=this._apply_and_filter_by_delay_pattern_mask(t).unsqueeze_(0),{audio_values:r}=await O(this.sessions.encodec_decode,{audio_codes:n});return r}}class yo extends ne{}class vo extends yo{}class Eo extends yo{async _call(e){return new Pu(await super._call(e))}}class Bo extends yo{}class Mo extends ne{}class Do extends Mo{}class To extends Mo{async _call(e){return new Pu(await super._call(e))}}class So extends Mo{}class No extends ne{}class Go extends No{}class Fo extends No{async _call(e){return new Pu(await super._call(e))}}class Po extends No{}class Qo extends ne{}class zo extends Qo{}class Oo extends Qo{async _call(e){return new Pu(await super._call(e))}}class Ro extends Qo{}class Lo extends ne{}class Wo extends Lo{}class _o extends ne{}class Vo extends _o{forward_params=["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"];constructor(...e){super(...e),this._generation_mode="text"}async forward(e){const t=this._generation_mode??"text";let n;if("text"!==t&&e.past_key_values){const t=this.sessions.gen_img_embeds,r=(0,A.pick)({image_ids:e.input_ids},t.inputNames);n=await O(t,r)}else{const t=this.sessions.prepare_inputs_embeds,r=(0,A.pick)(e,t.inputNames);n=await O(t,r)}const r={...e,...n},s=await U(this,r),a=this.sessions["text"===t?"lm_head":"gen_head"];if(!a)throw new Error(`Unable to find "${a}" generation head`);const i=await O(a,(0,A.pick)(s,a.inputNames));return{...n,...s,...i}}async generate(e){return this._generation_mode="text",super.generate(e)}async generate_images(e){this._generation_mode="image";const t=(e.inputs??e[this.main_input_name]).dims[1],n=(await super.generate(e)).slice(null,[t,null]),r=this.sessions.image_decode,{decoded_image:s}=await O(r,{generated_tokens:n}),a=s.add_(1).mul_(127.5).clamp_(0,255).to("uint8"),i=[];for(const e of a){const t=h.RawImage.fromTensor(e);i.push(t)}return i}}class Ho extends re{constructor({char_logits:e,bpe_logits:t,wp_logits:n}){super(),this.char_logits=e,this.bpe_logits=t,this.wp_logits=n}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class Uo extends ne{}class jo extends Uo{async _call(e){return new Ho(await super._call(e))}}class Yo extends ne{}class Ko extends Yo{}class Xo extends Yo{}class qo extends ne{}class Zo extends qo{}class Jo extends qo{}class $o extends ne{forward_params=["input_ids","attention_mask","position_ids","audio_values","past_key_values"]}class el extends $o{_merge_input_ids_with_audio_features(e){const t=e.audio_features.dims.at(-1),n=e.audio_features.view(-1,t);return function({audio_token_id:e,inputs_embeds:t,audio_features:n,input_ids:r,attention_mask:s}){return j({modality_token_id:e,inputs_embeds:t,modality_features:n,input_ids:r,attention_mask:s})}({audio_token_id:this.config.ignore_index,...e,audio_features:n})}}class tl extends ne{main_input_name="input_values";forward_params=["input_values"]}class nl extends re{constructor({audio_codes:e}){super(),this.audio_codes=e}}class rl extends re{constructor({audio_values:e}){super(),this.audio_values=e}}class sl extends tl{async encode(e){return new nl(await O(this.sessions.encoder_model,e))}async decode(e){return new rl(await O(this.sessions.decoder_model,e))}}class al extends tl{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"encoder_model"})}}class il extends tl{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"decoder_model"})}}class Al extends ne{main_input_name="input_values";forward_params=["input_values"]}class ol extends re{constructor({audio_codes:e}){super(),this.audio_codes=e}}class ll extends re{constructor({audio_values:e}){super(),this.audio_values=e}}class ul extends Al{async encode(e){return new ol(await O(this.sessions.encoder_model,e))}async decode(e){return new ll(await O(this.sessions.decoder_model,e))}}class cl extends Al{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"encoder_model"})}}class dl extends Al{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"decoder_model"})}}class hl extends ne{main_input_name="input_values";forward_params=["input_values"]}class fl extends hl{async encode(e){return await O(this.sessions.encoder_model,e)}async decode(e){return await O(this.sessions.decoder_model,e)}}class gl extends hl{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"encoder_model"})}}class pl extends hl{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"decoder_model"})}}class ml{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:s=null,local_files_only:a=!1,revision:i="main",model_file_name:A=null,subfolder:o="onnx",device:l=null,dtype:u=null,use_external_data_format:c=null,session_options:d={}}={}){const h={progress_callback:t,config:n,cache_dir:s,local_files_only:a,revision:i,model_file_name:A,subfolder:o,device:l,dtype:u,use_external_data_format:c,session_options:d};if(h.config=await r.AutoConfig.from_pretrained(e,h),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);const f=h.config.model_type;for(const t of this.MODEL_CLASS_MAPPINGS){let n=t.get(f);if(!n){for(const e of t.values())if(e[0]===f){n=e;break}if(!n)continue}return await n[1].from_pretrained(e,h)}if(this.BASE_IF_FAIL)return nu.has(f)||console.warn(`Unknown model class "${f}", attempting to construct from base class.`),await ne.from_pretrained(e,h);throw Error(`Unsupported model type: ${f}`)}}const bl=new Map([["bert",["BertModel",ie]],["modernbert",["ModernBertModel",de]],["nomic_bert",["NomicBertModel",me]],["roformer",["RoFormerModel",Ce]],["electra",["ElectraModel",Se]],["esm",["EsmModel",At]],["convbert",["ConvBertModel",ve]],["camembert",["CamembertModel",ze]],["deberta",["DebertaModel",Ve]],["deberta-v2",["DebertaV2Model",Xe]],["mpnet",["MPNetModel",mt]],["albert",["AlbertModel",Mt]],["distilbert",["DistilBertModel",tt]],["roberta",["RobertaModel",rn]],["xlm",["XLMModel",un]],["xlm-roberta",["XLMRobertaModel",pn]],["clap",["ClapModel",so]],["clip",["CLIPModel",jn]],["clipseg",["CLIPSegModel",or]],["chinese_clip",["ChineseCLIPModel",nr]],["siglip",["SiglipModel",Jn]],["jina_clip",["JinaCLIPModel",sr]],["mobilebert",["MobileBertModel",dt]],["squeezebert",["SqueezeBertModel",xt]],["wav2vec2",["Wav2Vec2Model",AA]],["wav2vec2-bert",["Wav2Vec2BertModel",EA]],["unispeech",["UniSpeechModel",mA]],["unispeech-sat",["UniSpeechSatModel",wA]],["hubert",["HubertModel",TA]],["wavlm",["WavLMModel",FA]],["audio-spectrogram-transformer",["ASTModel",kn]],["vits",["VitsModel",oo]],["pyannote",["PyAnnoteModel",dA]],["wespeaker-resnet",["WeSpeakerResNetModel",gA]],["detr",["DetrModel",ya]],["rt_detr",["RTDetrModel",Ta]],["rt_detr_v2",["RTDetrV2Model",Fa]],["rf_detr",["RFDetrModel",Oa]],["d_fine",["DFineModel",_a]],["table-transformer",["TableTransformerModel",Ua]],["vit",["ViTModel",Ls]],["ijepa",["IJepaModel",Vs]],["pvt",["PvtModel",Ks]],["vit_msn",["ViTMSNModel",$s]],["vit_mae",["ViTMAEModel",Zs]],["groupvit",["GroupViTModel",na]],["fastvit",["FastViTModel",sa]],["mobilevit",["MobileViTModel",la]],["mobilevitv2",["MobileViTV2Model",da]],["owlvit",["OwlViTModel",ga]],["owlv2",["Owlv2Model",ba]],["beit",["BeitModel",wa]],["deit",["DeiTModel",Xa]],["hiera",["HieraModel",Ja]],["convnext",["ConvNextModel",Fi]],["convnextv2",["ConvNextV2Model",zi]],["dinov2",["Dinov2Model",Li]],["dinov2_with_registers",["Dinov2WithRegistersModel",Vi]],["resnet",["ResNetModel",ti]],["swin",["SwinModel",si]],["swin2sr",["Swin2SRModel",oi]],["donut-swin",["DonutSwinModel",Ni]],["yolos",["YolosModel",Ki]],["dpt",["DPTModel",ci]],["glpn",["GLPNModel",Di]],["hifigan",["SpeechT5HifiGan",UA]],["efficientnet",["EfficientNetModel",bo]],["decision_transformer",["DecisionTransformerModel",Wo]],["patchtst",["PatchTSTForPrediction",Ko]],["patchtsmixer",["PatchTSMixerForPrediction",Zo]],["mobilenet_v1",["MobileNetV1Model",vo]],["mobilenet_v2",["MobileNetV2Model",Do]],["mobilenet_v3",["MobileNetV3Model",Go]],["mobilenet_v4",["MobileNetV4Model",zo]],["maskformer",["MaskFormerModel",Ei]],["mgp-str",["MgpstrForSceneTextRecognition",jo]],["style_text_to_speech_2",["StyleTextToSpeech2Model",LA]]]),Cl=new Map([["t5",["T5Model",Gt]],["longt5",["LongT5Model",Qt]],["mt5",["MT5Model",Rt]],["bart",["BartModel",_t]],["mbart",["MBartModel",jt]],["marian",["MarianModel",tA]],["whisper",["WhisperModel",vn]],["m2m_100",["M2M100Model",sA]],["blenderbot",["BlenderbotModel",Zt]],["blenderbot-small",["BlenderbotSmallModel",en]]]),Il=new Map([["mimi",["MimiModel",sl]],["dac",["DacModel",ul]],["snac",["SnacModel",fl]]]),wl=new Map([["bloom",["BloomModel",Ss]],["jais",["JAISModel",fr]],["gpt2",["GPT2Model",cr]],["gptj",["GPTJModel",xr]],["gpt_bigcode",["GPTBigCodeModel",Er]],["gpt_neo",["GPTNeoModel",mr]],["gpt_neox",["GPTNeoXModel",Ir]],["codegen",["CodeGenModel",Dr]],["llama",["LlamaModel",Nr]],["exaone",["ExaoneModel",Wr]],["olmo",["OlmoModel",Yr]],["olmo2",["Olmo2Model",qr]],["mobilellm",["MobileLLMModel",Hr]],["granite",["GraniteModel",$r]],["cohere",["CohereModel",ns]],["gemma",["GemmaModel",as]],["gemma2",["Gemma2Model",os]],["gemma3_text",["Gemma3Model",cs]],["helium",["HeliumModel",Pr]],["glm",["GlmModel",Or]],["openelm",["OpenELMModel",fs]],["qwen2",["Qwen2Model",ms]],["qwen3",["Qwen3Model",Is]],["phi",["PhiModel",vs]],["phi3",["Phi3Model",Ms]],["mpt",["MptModel",Fs]],["opt",["OPTModel",zs]],["mistral",["MistralModel",XA]],["starcoder2",["Starcoder2Model",JA]],["falcon",["FalconModel",to]],["stablelm",["StableLmModel",go]]]),kl=new Map([["speecht5",["SpeechT5ForSpeechToText",VA]],["whisper",["WhisperForConditionalGeneration",En]],["lite-whisper",["LiteWhisperForConditionalGeneration",Bn]],["moonshine",["MoonshineForConditionalGeneration",Tn]]]),xl=new Map([["speecht5",["SpeechT5ForTextToSpeech",HA]]]),yl=new Map([["vits",["VitsModel",oo]],["musicgen",["MusicgenForConditionalGeneration",xo]]]),vl=new Map([["bert",["BertForSequenceClassification",oe]],["modernbert",["ModernBertForSequenceClassification",fe]],["roformer",["RoFormerForSequenceClassification",we]],["electra",["ElectraForSequenceClassification",Ge]],["esm",["EsmForSequenceClassification",lt]],["convbert",["ConvBertForSequenceClassification",Be]],["camembert",["CamembertForSequenceClassification",Re]],["deberta",["DebertaForSequenceClassification",Ue]],["deberta-v2",["DebertaV2ForSequenceClassification",Ze]],["mpnet",["MPNetForSequenceClassification",Ct]],["albert",["AlbertForSequenceClassification",Dt]],["distilbert",["DistilBertForSequenceClassification",nt]],["roberta",["RobertaForSequenceClassification",an]],["xlm",["XLMForSequenceClassification",dn]],["xlm-roberta",["XLMRobertaForSequenceClassification",bn]],["bart",["BartForSequenceClassification",Ht]],["mbart",["MBartForSequenceClassification",Kt]],["mobilebert",["MobileBertForSequenceClassification",ft]],["squeezebert",["SqueezeBertForSequenceClassification",vt]]]),El=new Map([["bert",["BertForTokenClassification",le]],["modernbert",["ModernBertForTokenClassification",ge]],["roformer",["RoFormerForTokenClassification",ke]],["electra",["ElectraForTokenClassification",Fe]],["esm",["EsmForTokenClassification",ut]],["convbert",["ConvBertForTokenClassification",Me]],["camembert",["CamembertForTokenClassification",Le]],["deberta",["DebertaForTokenClassification",je]],["deberta-v2",["DebertaV2ForTokenClassification",Je]],["mpnet",["MPNetForTokenClassification",It]],["distilbert",["DistilBertForTokenClassification",rt]],["roberta",["RobertaForTokenClassification",An]],["xlm",["XLMForTokenClassification",hn]],["xlm-roberta",["XLMRobertaForTokenClassification",Cn]]]),Bl=new Map([["t5",["T5ForConditionalGeneration",Ft]],["longt5",["LongT5ForConditionalGeneration",zt]],["mt5",["MT5ForConditionalGeneration",Lt]],["bart",["BartForConditionalGeneration",Vt]],["mbart",["MBartForConditionalGeneration",Yt]],["marian",["MarianMTModel",nA]],["m2m_100",["M2M100ForConditionalGeneration",aA]],["blenderbot",["BlenderbotForConditionalGeneration",Jt]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",tn]]]),Ml=new Map([["bloom",["BloomForCausalLM",Ns]],["gpt2",["GPT2LMHeadModel",dr]],["jais",["JAISLMHeadModel",gr]],["gptj",["GPTJForCausalLM",yr]],["gpt_bigcode",["GPTBigCodeForCausalLM",Br]],["gpt_neo",["GPTNeoForCausalLM",br]],["gpt_neox",["GPTNeoXForCausalLM",wr]],["codegen",["CodeGenForCausalLM",Tr]],["llama",["LlamaForCausalLM",Gr]],["exaone",["ExaoneForCausalLM",_r]],["olmo",["OlmoForCausalLM",Kr]],["olmo2",["Olmo2ForCausalLM",Zr]],["mobilellm",["MobileLLMForCausalLM",Ur]],["granite",["GraniteForCausalLM",es]],["cohere",["CohereForCausalLM",rs]],["gemma",["GemmaForCausalLM",is]],["gemma2",["Gemma2ForCausalLM",ls]],["gemma3_text",["Gemma3ForCausalLM",ds]],["helium",["HeliumForCausalLM",Qr]],["glm",["GlmForCausalLM",Rr]],["openelm",["OpenELMForCausalLM",gs]],["qwen2",["Qwen2ForCausalLM",bs]],["qwen3",["Qwen3ForCausalLM",ws]],["phi",["PhiForCausalLM",Es]],["phi3",["Phi3ForCausalLM",Ds]],["mpt",["MptForCausalLM",Ps]],["opt",["OPTForCausalLM",Os]],["mbart",["MBartForCausalLM",Xt]],["mistral",["MistralForCausalLM",qA]],["starcoder2",["Starcoder2ForCausalLM",$A]],["falcon",["FalconForCausalLM",no]],["trocr",["TrOCRForCausalLM",YA]],["stablelm",["StableLmForCausalLM",po]],["phi3_v",["Phi3VForCausalLM",Hn]]]),Dl=new Map([["multi_modality",["MultiModalityCausalLM",Vo]]]),Tl=new Map([["bert",["BertForMaskedLM",Ae]],["modernbert",["ModernBertForMaskedLM",he]],["roformer",["RoFormerForMaskedLM",Ie]],["electra",["ElectraForMaskedLM",Ne]],["esm",["EsmForMaskedLM",ot]],["convbert",["ConvBertForMaskedLM",Ee]],["camembert",["CamembertForMaskedLM",Oe]],["deberta",["DebertaForMaskedLM",He]],["deberta-v2",["DebertaV2ForMaskedLM",qe]],["mpnet",["MPNetForMaskedLM",bt]],["albert",["AlbertForMaskedLM",St]],["distilbert",["DistilBertForMaskedLM",at]],["roberta",["RobertaForMaskedLM",sn]],["xlm",["XLMWithLMHeadModel",cn]],["xlm-roberta",["XLMRobertaForMaskedLM",mn]],["mobilebert",["MobileBertForMaskedLM",ht]],["squeezebert",["SqueezeBertForMaskedLM",yt]]]),Sl=new Map([["bert",["BertForQuestionAnswering",ue]],["roformer",["RoFormerForQuestionAnswering",xe]],["electra",["ElectraForQuestionAnswering",Pe]],["convbert",["ConvBertForQuestionAnswering",De]],["camembert",["CamembertForQuestionAnswering",We]],["deberta",["DebertaForQuestionAnswering",Ye]],["deberta-v2",["DebertaV2ForQuestionAnswering",$e]],["mpnet",["MPNetForQuestionAnswering",wt]],["albert",["AlbertForQuestionAnswering",Tt]],["distilbert",["DistilBertForQuestionAnswering",st]],["roberta",["RobertaForQuestionAnswering",on]],["xlm",["XLMForQuestionAnswering",fn]],["xlm-roberta",["XLMRobertaForQuestionAnswering",In]],["mobilebert",["MobileBertForQuestionAnswering",gt]],["squeezebert",["SqueezeBertForQuestionAnswering",Et]]]),Nl=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Sn]],["idefics3",["Idefics3ForConditionalGeneration",Wn]],["smolvlm",["SmolVLMForConditionalGeneration",_n]]]),Gl=new Map([["llava",["LlavaForConditionalGeneration",Gn]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",Fn]],["moondream1",["Moondream1ForConditionalGeneration",Pn]],["florence2",["Florence2ForConditionalGeneration",zn]],["qwen2-vl",["Qwen2VLForConditionalGeneration",xs]],["idefics3",["Idefics3ForConditionalGeneration",Wn]],["smolvlm",["SmolVLMForConditionalGeneration",_n]],["paligemma",["PaliGemmaForConditionalGeneration",Rn]]]),Fl=new Map([["ultravox",["UltravoxModel",el]]]),Pl=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Sn]]]),Ql=new Map([["vit",["ViTForImageClassification",Ws]],["ijepa",["IJepaForImageClassification",Hs]],["pvt",["PvtForImageClassification",Xs]],["vit_msn",["ViTMSNForImageClassification",ea]],["fastvit",["FastViTForImageClassification",aa]],["mobilevit",["MobileViTForImageClassification",ua]],["mobilevitv2",["MobileViTV2ForImageClassification",ha]],["beit",["BeitForImageClassification",ka]],["deit",["DeiTForImageClassification",qa]],["hiera",["HieraForImageClassification",$a]],["convnext",["ConvNextForImageClassification",Pi]],["convnextv2",["ConvNextV2ForImageClassification",Oi]],["dinov2",["Dinov2ForImageClassification",Wi]],["dinov2_with_registers",["Dinov2WithRegistersForImageClassification",Hi]],["resnet",["ResNetForImageClassification",ni]],["swin",["SwinForImageClassification",ai]],["segformer",["SegformerForImageClassification",co]],["efficientnet",["EfficientNetForImageClassification",Co]],["mobilenet_v1",["MobileNetV1ForImageClassification",Eo]],["mobilenet_v2",["MobileNetV2ForImageClassification",To]],["mobilenet_v3",["MobileNetV3ForImageClassification",Fo]],["mobilenet_v4",["MobileNetV4ForImageClassification",Oo]]]),zl=new Map([["detr",["DetrForObjectDetection",va]],["rt_detr",["RTDetrForObjectDetection",Sa]],["rt_detr_v2",["RTDetrV2ForObjectDetection",Pa]],["rf_detr",["RFDetrForObjectDetection",Ra]],["d_fine",["DFineForObjectDetection",Va]],["table-transformer",["TableTransformerForObjectDetection",ja]],["yolos",["YolosForObjectDetection",Xi]]]),Ol=new Map([["owlvit",["OwlViTForObjectDetection",pa]],["owlv2",["Owlv2ForObjectDetection",Ca]],["grounding-dino",["GroundingDinoForObjectDetection",ji]]]),Rl=new Map([["detr",["DetrForSegmentation",Ea]],["clipseg",["CLIPSegForImageSegmentation",lr]]]),Ll=new Map([["segformer",["SegformerForSemanticSegmentation",ho]],["sapiens",["SapiensForSemanticSegmentation",pi]],["swin",["SwinForSemanticSegmentation",ii]],["mobilenet_v1",["MobileNetV1ForSemanticSegmentation",Bo]],["mobilenet_v2",["MobileNetV2ForSemanticSegmentation",So]],["mobilenet_v3",["MobileNetV3ForSemanticSegmentation",Po]],["mobilenet_v4",["MobileNetV4ForSemanticSegmentation",Ro]]]),Wl=new Map([["detr",["DetrForSegmentation",Ea]],["maskformer",["MaskFormerForInstanceSegmentation",Bi]]]),_l=new Map([["sam",["SamModel",Ji]]]),Vl=new Map([["wav2vec2",["Wav2Vec2ForCTC",oA]],["wav2vec2-bert",["Wav2Vec2BertForCTC",BA]],["unispeech",["UniSpeechForCTC",bA]],["unispeech-sat",["UniSpeechSatForCTC",kA]],["wavlm",["WavLMForCTC",PA]],["hubert",["HubertForCTC",SA]]]),Hl=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",lA]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",MA]],["unispeech",["UniSpeechForSequenceClassification",CA]],["unispeech-sat",["UniSpeechSatForSequenceClassification",xA]],["wavlm",["WavLMForSequenceClassification",QA]],["hubert",["HubertForSequenceClassification",NA]],["audio-spectrogram-transformer",["ASTForAudioClassification",xn]]]),Ul=new Map([["wavlm",["WavLMForXVector",zA]]]),jl=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",yA]],["wavlm",["WavLMForAudioFrameClassification",OA]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",uA]],["pyannote",["PyAnnoteForAudioFrameClassification",hA]]]),Yl=new Map([["vitmatte",["VitMatteForImageMatting",Aa]]]),Kl=new Map([["patchtst",["PatchTSTForPrediction",Xo]],["patchtsmixer",["PatchTSMixerForPrediction",Jo]]]),Xl=new Map([["swin2sr",["Swin2SRForImageSuperResolution",li]]]),ql=new Map([["dpt",["DPTForDepthEstimation",di]],["depth_anything",["DepthAnythingForDepthEstimation",fi]],["glpn",["GLPNForDepthEstimation",Ti]],["sapiens",["SapiensForDepthEstimation",mi]],["depth_pro",["DepthProForDepthEstimation",Ii]],["metric3d",["Metric3DForDepthEstimation",ki]],["metric3dv2",["Metric3Dv2ForDepthEstimation",yi]]]),Zl=new Map([["sapiens",["SapiensForNormalEstimation",bi]]]),Jl=new Map([["vitpose",["VitPoseForPoseEstimation",js]]]),$l=new Map([["clip",["CLIPVisionModelWithProjection",qn]],["siglip",["SiglipVisionModel",er]],["jina_clip",["JinaCLIPVisionModel",ir]]]),eu=[[bl,I],[Cl,w],[wl,y],[Il,S],[vl,I],[El,I],[Bl,k],[kl,k],[Ml,y],[Dl,M],[Tl,I],[Sl,I],[Nl,x],[Gl,E],[Fl,T],[Ql,I],[Rl,I],[Wl,I],[Ll,I],[Yl,I],[Kl,I],[Xl,I],[ql,I],[Zl,I],[Jl,I],[zl,I],[Ol,I],[_l,v],[Vl,I],[Hl,I],[xl,k],[yl,I],[Ul,I],[jl,I],[$l,I]];for(const[e,t]of eu)for(const[n,r]of e.values())N.set(n,t),F.set(r,n),G.set(n,r);const tu=[["MusicgenForConditionalGeneration",xo,B],["Phi3VForCausalLM",Hn,D],["CLIPTextModelWithProjection",Kn,I],["SiglipTextModel",$n,I],["JinaCLIPTextModel",ar,I],["ClapTextModelWithProjection",ao,I],["ClapAudioModelWithProjection",io,I],["DacEncoderModel",cl,I],["DacDecoderModel",dl,I],["MimiEncoderModel",al,I],["MimiDecoderModel",il,I],["SnacEncoderModel",gl,I],["SnacDecoderModel",pl,I]];for(const[e,t,n]of tu)N.set(e,n),F.set(t,e),G.set(e,t);const nu=new Map([["modnet",Rl],["birefnet",Rl],["isnet",Rl],["ben",Rl]]);for(const[e,t]of nu.entries())t.set(e,["PreTrainedModel",ne]),N.set(e,I),F.set(ne,e),G.set(e,ne);class ru extends ml{static MODEL_CLASS_MAPPINGS=eu.map((e=>e[0]));static BASE_IF_FAIL=!0}class su extends ml{static MODEL_CLASS_MAPPINGS=[vl]}class au extends ml{static MODEL_CLASS_MAPPINGS=[El]}class iu extends ml{static MODEL_CLASS_MAPPINGS=[Bl]}class Au extends ml{static MODEL_CLASS_MAPPINGS=[kl]}class ou extends ml{static MODEL_CLASS_MAPPINGS=[xl]}class lu extends ml{static MODEL_CLASS_MAPPINGS=[yl]}class uu extends ml{static MODEL_CLASS_MAPPINGS=[Ml]}class cu extends ml{static MODEL_CLASS_MAPPINGS=[Tl]}class du extends ml{static MODEL_CLASS_MAPPINGS=[Sl]}class hu extends ml{static MODEL_CLASS_MAPPINGS=[Nl]}class fu extends ml{static MODEL_CLASS_MAPPINGS=[Ql]}class gu extends ml{static MODEL_CLASS_MAPPINGS=[Rl]}class pu extends ml{static MODEL_CLASS_MAPPINGS=[Ll]}class mu extends ml{static MODEL_CLASS_MAPPINGS=[Wl]}class bu extends ml{static MODEL_CLASS_MAPPINGS=[zl]}class Cu extends ml{static MODEL_CLASS_MAPPINGS=[Ol]}class Iu extends ml{static MODEL_CLASS_MAPPINGS=[_l]}class wu extends ml{static MODEL_CLASS_MAPPINGS=[Vl]}class ku extends ml{static MODEL_CLASS_MAPPINGS=[Hl]}class xu extends ml{static MODEL_CLASS_MAPPINGS=[Ul]}class yu extends ml{static MODEL_CLASS_MAPPINGS=[jl]}class vu extends ml{static MODEL_CLASS_MAPPINGS=[Pl]}class Eu extends ml{static MODEL_CLASS_MAPPINGS=[Yl]}class Bu extends ml{static MODEL_CLASS_MAPPINGS=[Xl]}class Mu extends ml{static MODEL_CLASS_MAPPINGS=[ql]}class Du extends ml{static MODEL_CLASS_MAPPINGS=[Zl]}class Tu extends ml{static MODEL_CLASS_MAPPINGS=[Jl]}class Su extends ml{static MODEL_CLASS_MAPPINGS=[$l]}class Nu extends ml{static MODEL_CLASS_MAPPINGS=[Gl]}class Gu extends ml{static MODEL_CLASS_MAPPINGS=[Fl]}class Fu extends re{constructor({logits:e,past_key_values:t,encoder_outputs:n,decoder_attentions:r=null,cross_attentions:s=null}){super(),this.logits=e,this.past_key_values=t,this.encoder_outputs=n,this.decoder_attentions=r,this.cross_attentions=s}}class Pu extends re{constructor({logits:e,...t}){super(),this.logits=e;const n=Object.values(t);n.length>0&&(this.attentions=n)}}class Qu extends re{constructor({logits:e,embeddings:t}){super(),this.logits=e,this.embeddings=t}}class zu extends re{constructor({logits:e}){super(),this.logits=e}}class Ou extends re{constructor({logits:e}){super(),this.logits=e}}class Ru extends re{constructor({start_logits:e,end_logits:t}){super(),this.start_logits=e,this.end_logits=t}}class Lu extends re{constructor({logits:e}){super(),this.logits=e}}class Wu extends re{constructor({logits:e,past_key_values:t}){super(),this.logits=e,this.past_key_values=t}}class _u extends re{constructor({alphas:e}){super(),this.alphas=e}}class Vu extends re{constructor({waveform:e,spectrogram:t}){super(),this.waveform=e,this.spectrogram=t}}},"./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js":(e,t,n)=>{n.r(t),n.d(t,{ASTFeatureExtractor:()=>a});var r=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var s=n("./src/utils/audio.js");class a extends r.FeatureExtractor{constructor(e){super(e);const t=this.config.sampling_rate,n=(0,s.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);this.mel_filters=n,this.window=(0,s.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(e,t){return(0,s.spectrogram)(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e){(0,r.validate_audio_inputs)(e,"ASTFeatureExtractor");const t=await this._extract_fbank_features(e,this.config.max_length);if(this.config.do_normalize){const e=2*this.std,n=t.data;for(let t=0;t<n.length;++t)n[t]=(n[t]-this.mean)/e}return{input_values:t.unsqueeze_(0)}}}},"./src/models/auto/feature_extraction_auto.js":(e,t,n)=>{n.r(t),n.d(t,{AutoFeatureExtractor:()=>i});var r=n("./src/utils/constants.js"),s=n("./src/utils/hub.js");n("./src/base/feature_extraction_utils.js");var a=n("./src/models/feature_extractors.js");class i{static async from_pretrained(e,t={}){const n=await(0,s.getModelJSON)(e,r.FEATURE_EXTRACTOR_NAME,!0,t),i=n.feature_extractor_type,A=a[i];if(!A)throw new Error(`Unknown feature_extractor_type: '${i}'. Please report this at ${r.GITHUB_ISSUE_URL}.`);return new A(n)}}},"./src/models/auto/image_processing_auto.js":(e,t,n)=>{n.r(t),n.d(t,{AutoImageProcessor:()=>A});var r=n("./src/utils/constants.js"),s=n("./src/utils/hub.js"),a=n("./src/base/image_processors_utils.js"),i=n("./src/models/image_processors.js");class A{static async from_pretrained(e,t={}){const n=await(0,s.getModelJSON)(e,r.IMAGE_PROCESSOR_NAME,!0,t),A=n.image_processor_type??n.feature_extractor_type;let o=i[A];return o||(void 0!==A&&console.warn(`Image processor type '${A}' not found, assuming base ImageProcessor. Please report this at ${r.GITHUB_ISSUE_URL}.`),o=a.ImageProcessor),new o(n)}}},"./src/models/auto/processing_auto.js":(e,t,n)=>{n.r(t),n.d(t,{AutoProcessor:()=>l});var r=n("./src/utils/constants.js"),s=n("./src/utils/hub.js"),a=n("./src/base/processing_utils.js"),i=n("./src/models/processors.js"),A=n("./src/models/image_processors.js"),o=n("./src/models/feature_extractors.js");class l{static async from_pretrained(e,t={}){const n=await(0,s.getModelJSON)(e,r.IMAGE_PROCESSOR_NAME,!0,t),{image_processor_type:l,feature_extractor_type:u,processor_class:c}=n;if(c&&i[c])return i[c].from_pretrained(e,t);if(!l&&!u)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const d={};if(l){const e=A[l];if(!e)throw new Error(`Unknown image_processor_type: '${l}'.`);d.image_processor=new e(n)}if(u){const e=A[u];if(e)d.image_processor=new e(n);else{const e=o[u];if(!e)throw new Error(`Unknown feature_extractor_type: '${u}'.`);d.feature_extractor=new e(n)}}return new a.Processor({},d)}}},"./src/models/beit/image_processing_beit.js":(e,t,n)=>{n.r(t),n.d(t,{BeitFeatureExtractor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/bit/image_processing_bit.js":(e,t,n)=>{n.r(t),n.d(t,{BitImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/chinese_clip/image_processing_chinese_clip.js":(e,t,n)=>{n.r(t),n.d(t,{ChineseCLIPFeatureExtractor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/clap/feature_extraction_clap.js":(e,t,n)=>{n.r(t),n.d(t,{ClapFeatureExtractor:()=>a});var r=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var s=n("./src/utils/audio.js");class a extends r.FeatureExtractor{constructor(e){super(e),this.mel_filters=(0,s.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,s.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,s.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(e,t,n,r){let s;const a=e.length-t;if(a>0){if("rand_trunc"!==n)throw new Error(`Truncation strategy "${n}" not implemented`);{const n=Math.floor(Math.random()*(a+1));e=e.subarray(n,n+t),s=await this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples)}}else{if(a<0){let n=new Float64Array(t);if(n.set(e),"repeat"===r)for(let r=e.length;r<t;r+=e.length)n.set(e.subarray(0,Math.min(e.length,t-r)),r);else if("repeatpad"===r)for(let t=e.length;t<-a;t+=e.length)n.set(e,t);e=n}if("fusion"===n)throw new Error(`Truncation strategy "${n}" not implemented`);s=await this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples)}return s.unsqueeze_(0)}async _extract_fbank_features(e,t,n=null){return(0,s.spectrogram)(e,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:t,log_mel:"dB",max_num_frames:n,do_pad:!1,transpose:!0})}async _call(e,{max_length:t=null}={}){(0,r.validate_audio_inputs)(e,"ClapFeatureExtractor");return{input_features:(await this._get_input_mel(e,t??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}},"./src/models/clip/image_processing_clip.js":(e,t,n)=>{n.r(t),n.d(t,{CLIPFeatureExtractor:()=>a,CLIPImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/convnext/image_processing_convnext.js":(e,t,n)=>{n.r(t),n.d(t,{ConvNextFeatureExtractor:()=>a,ConvNextImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{constructor(e){super(e),this.crop_pct=this.config.crop_pct??.875}async resize(e){const t=this.size?.shortest_edge;if(void 0===t)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(t<384){const n=Math.floor(t/this.crop_pct),[r,s]=this.get_resize_output_image_size(e,{shortest_edge:n});e=await e.resize(r,s,{resample:this.resample}),e=await e.center_crop(t,t)}else e=await e.resize(t,t,{resample:this.resample});return e}}class a extends s{}},"./src/models/dac/feature_extraction_dac.js":(e,t,n)=>{n.r(t),n.d(t,{DacFeatureExtractor:()=>s});var r=n("./src/models/encodec/feature_extraction_encodec.js");class s extends r.EncodecFeatureExtractor{}},"./src/models/deit/image_processing_deit.js":(e,t,n)=>{n.r(t),n.d(t,{DeiTFeatureExtractor:()=>a,DeiTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/detr/image_processing_detr.js":(e,t,n)=>{n.r(t),n.d(t,{DetrFeatureExtractor:()=>i,DetrImageProcessor:()=>a});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class a extends r.ImageProcessor{async _call(e){const t=await super._call(e),n=[t.pixel_values.dims[0],64,64],r=(0,s.full)(n,1n);return{...t,pixel_mask:r}}post_process_object_detection(...e){return(0,r.post_process_object_detection)(...e)}post_process_panoptic_segmentation(...e){return(0,r.post_process_panoptic_segmentation)(...e)}post_process_instance_segmentation(...e){return(0,r.post_process_instance_segmentation)(...e)}}class i extends a{}},"./src/models/donut/image_processing_donut.js":(e,t,n)=>{n.r(t),n.d(t,{DonutFeatureExtractor:()=>a,DonutImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{pad_image(e,t,n,r={}){const[s,a,i]=t;let A=this.image_mean;Array.isArray(this.image_mean)||(A=new Array(i).fill(A));let o=this.image_std;Array.isArray(o)||(o=new Array(i).fill(A));const l=A.map(((e,t)=>-e/o[t]));return super.pad_image(e,t,n,{center:!0,constant_values:l,...r})}}class a extends s{}},"./src/models/dpt/image_processing_dpt.js":(e,t,n)=>{n.r(t),n.d(t,{DPTFeatureExtractor:()=>a,DPTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/efficientnet/image_processing_efficientnet.js":(e,t,n)=>{n.r(t),n.d(t,{EfficientNetImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{constructor(e){super(e),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map((e=>e*e)))}}},"./src/models/encodec/feature_extraction_encodec.js":(e,t,n)=>{n.r(t),n.d(t,{EncodecFeatureExtractor:()=>a});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js");class a extends r.FeatureExtractor{async _call(e){(0,r.validate_audio_inputs)(e,"EncodecFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=this.config.feature_size;if(e.length%t!==0)throw new Error(`The length of the audio data must be a multiple of the number of channels (${t}).`);const n=[1,t,e.length/t];return{input_values:new s.Tensor("float32",e,n)}}}},"./src/models/feature_extractors.js":(e,t,n)=>{n.r(t),n.d(t,{ASTFeatureExtractor:()=>r.ASTFeatureExtractor,ClapFeatureExtractor:()=>a.ClapFeatureExtractor,DacFeatureExtractor:()=>i.DacFeatureExtractor,EncodecFeatureExtractor:()=>s.EncodecFeatureExtractor,ImageFeatureExtractor:()=>g.ImageProcessor,MoonshineFeatureExtractor:()=>A.MoonshineFeatureExtractor,PyAnnoteFeatureExtractor:()=>o.PyAnnoteFeatureExtractor,SeamlessM4TFeatureExtractor:()=>l.SeamlessM4TFeatureExtractor,SnacFeatureExtractor:()=>u.SnacFeatureExtractor,SpeechT5FeatureExtractor:()=>c.SpeechT5FeatureExtractor,Wav2Vec2FeatureExtractor:()=>d.Wav2Vec2FeatureExtractor,WeSpeakerFeatureExtractor:()=>h.WeSpeakerFeatureExtractor,WhisperFeatureExtractor:()=>f.WhisperFeatureExtractor});var r=n("./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js"),s=n("./src/models/encodec/feature_extraction_encodec.js"),a=n("./src/models/clap/feature_extraction_clap.js"),i=n("./src/models/dac/feature_extraction_dac.js"),A=n("./src/models/moonshine/feature_extraction_moonshine.js"),o=n("./src/models/pyannote/feature_extraction_pyannote.js"),l=n("./src/models/seamless_m4t/feature_extraction_seamless_m4t.js"),u=n("./src/models/snac/feature_extraction_snac.js"),c=n("./src/models/speecht5/feature_extraction_speecht5.js"),d=n("./src/models/wav2vec2/feature_extraction_wav2vec2.js"),h=n("./src/models/wespeaker/feature_extraction_wespeaker.js"),f=n("./src/models/whisper/feature_extraction_whisper.js"),g=n("./src/base/image_processors_utils.js")},"./src/models/florence2/processing_florence2.js":(e,t,n)=>{n.r(t),n.d(t,{Florence2Processor:()=>i});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");class i extends r.Processor{static tokenizer_class=a.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;constructor(e,t){super(e,t);const{tasks_answer_post_processing_type:n,task_prompts_without_inputs:r,task_prompts_with_input:s}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(n??{})),this.task_prompts_without_inputs=new Map(Object.entries(r??{})),this.task_prompts_with_input=new Map(Object.entries(s??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(e){"string"==typeof e&&(e=[e]);const t=[];for(const n of e)if(this.task_prompts_without_inputs.has(n))t.push(this.task_prompts_without_inputs.get(n));else{for(const[e,r]of this.task_prompts_with_input)if(n.includes(e)){t.push(r.replaceAll("{input}",n).replaceAll(e,""));break}t.length!==e.length&&t.push(n)}return t}post_process_generation(e,t,n){const r=this.tasks_answer_post_processing_type.get(t)??"pure_text";let s;switch(e=e.replaceAll("<s>","").replaceAll("</s>",""),r){case"pure_text":s=e;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const a="ocr"===r?"quad_boxes":"bboxes",i=e.matchAll(this.regexes[a]),A=[],o=[];for(const[e,t,...r]of i)A.push(t?t.trim():A.at(-1)??""),o.push(r.map(((e,t)=>(Number(e)+.5)/this.size_per_bin*n[t%2])));s={labels:A,[a]:o};break;default:throw new Error(`Task "${t}" (of type "${r}") not yet implemented.`)}return{[t]:s}}async _call(e,t=null,n={}){if(!e&&!t)throw new Error("Either text or images must be provided");return{...await this.image_processor(e,n),...t?this.tokenizer(t,n):{}}}}},"./src/models/glpn/image_processing_glpn.js":(e,t,n)=>{n.r(t),n.d(t,{GLPNFeatureExtractor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/grounding_dino/image_processing_grounding_dino.js":(e,t,n)=>{n.r(t),n.d(t,{GroundingDinoImageProcessor:()=>a});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class a extends r.ImageProcessor{async _call(e){const t=await super._call(e),n=t.pixel_values.dims,r=(0,s.ones)([n[0],n[2],n[3]]);return{...t,pixel_mask:r}}}},"./src/models/grounding_dino/processing_grounding_dino.js":(e,t,n)=>{n.r(t),n.d(t,{GroundingDinoProcessor:()=>o});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js"),i=n("./src/base/image_processors_utils.js");function A(e,t){const n=e.dims.at(-1)-1,r=e.tolist();r.fill(!1,0,1),r.fill(!1,n);const s=t.tolist();return r.map(((e,t)=>e?t:null)).filter((e=>null!==e)).map((e=>s[e]))}class o extends r.Processor{static tokenizer_class=a.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;async _call(e,t,n={}){const r=e?await this.image_processor(e,n):{};return{...t?this.tokenizer(t,n):{},...r}}post_process_grounded_object_detection(e,t,{box_threshold:n=.25,text_threshold:r=.25,target_sizes:s=null}={}){const{logits:a,pred_boxes:o}=e,l=a.dims[0];if(null!==s&&s.length!==l)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const u=a.dims.at(1),c=a.sigmoid(),d=c.max(-1).tolist(),h=o.tolist().map((e=>e.map((e=>(0,i.center_to_corners_format)(e))))),f=[];for(let e=0;e<l;++e){const a=null!==s?s[e]:null;null!==a&&(h[e]=h[e].map((e=>e.map(((e,t)=>e*a[(t+1)%2])))));const i=d[e],o=[],l=[],g=[];for(let s=0;s<u;++s){const a=i[s];if(a<=n)continue;const u=h[e][s],d=c[e][s];o.push(a),g.push(u);const f=A(d.gt(r),t[e]);l.push(f)}f.push({scores:o,boxes:g,labels:this.batch_decode(l)})}return f}}},"./src/models/idefics3/image_processing_idefics3.js":(e,t,n)=>{n.r(t),n.d(t,{Idefics3ImageProcessor:()=>a});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class a extends r.ImageProcessor{constructor(e){super(e),this.do_image_splitting=e.do_image_splitting??!0,this.max_image_size=e.max_image_size}get_resize_for_vision_encoder(e,t){let[n,r]=e.dims.slice(-2);const s=r/n;return r>=n?(r=Math.ceil(r/t)*t,n=Math.floor(r/s),n=Math.ceil(n/t)*t):(n=Math.ceil(n/t)*t,r=Math.floor(n*s),r=Math.ceil(r/t)*t),{height:n,width:r}}async _call(e,{do_image_splitting:t=null,return_row_col_info:n=!1}={}){let r;if(Array.isArray(e)){if(0===e.length||!e[0])throw new Error("No images provided.");r=Array.isArray(e[0])?e:[e]}else r=[[e]];let a=[],i=[],A=[];const o=[],l=[];for(const e of r){let n=await Promise.all(e.map((e=>this.preprocess(e))));o.push(...n.map((e=>e.original_size))),l.push(...n.map((e=>e.reshaped_input_size))),n.forEach((e=>e.pixel_values.unsqueeze_(0)));const{longest_edge:r}=this.max_image_size;let u;if(t??this.do_image_splitting){let e=new Array(n.length),t=new Array(n.length);u=await Promise.all(n.map((async(n,a)=>{const i=this.get_resize_for_vision_encoder(n.pixel_values,r),A=await(0,s.interpolate_4d)(n.pixel_values,{size:[i.height,i.width]}),{frames:o,num_splits_h:l,num_splits_w:u}=await this.split_image(A,this.max_image_size);return e[a]=l,t[a]=u,(0,s.cat)(o,0)}))),i.push(e),A.push(t)}else{const e=[r,r];u=await Promise.all(n.map((t=>(0,s.interpolate_4d)(t.pixel_values,{size:e})))),i.push(new Array(n.length).fill(0)),A.push(new Array(n.length).fill(0))}a.push((0,s.cat)(u,0))}const u=a.length,[c,d,h,f]=a[0].dims;let g,p;if(1===u)g=a[0].unsqueeze_(0),p=(0,s.full)([u,c,h,f],!0);else{const e=Math.max(...a.map((e=>e.dims.at(0))));p=(0,s.full)([u,e,h,f],!0);const t=p.data,n=e*h*f;for(let r=0;r<u;++r){const i=a[r].dims[0];if(i<e){a[r]=(0,s.cat)([a[r],(0,s.full)([e-i,d,h,f],0)],0);const A=r*n+i*h*f,o=(r+1)*n;t.fill(!1,A,o)}}g=(0,s.stack)(a,0)}return{pixel_values:g,pixel_attention_mask:p,original_sizes:o,reshaped_input_sizes:l,...n?{rows:i,cols:A}:{}}}async split_image(e,{longest_edge:t}){const n=t,r=t,a=[],[i,A]=e.dims.slice(-2);let o=0,l=0;if(i>n||A>r){o=Math.ceil(i/n),l=Math.ceil(A/r);const t=Math.ceil(i/o),u=Math.ceil(A/l);for(let n=0;n<o;++n)for(let r=0;r<l;++r){let c,d,h,f;n===o-1?(d=i-t,f=i):(d=n*t,f=(n+1)*t),r===l-1?(c=A-u,h=A):(c=r*u,h=(r+1)*u);const g=[d,c],p=[f,h],m=await(0,s.slice)(e,g,p,[2,3]);a.push(m)}const c=n,d=r;i===c&&A===d||(e=await(0,s.interpolate_4d)(e,{size:[c,d]}))}return a.push(e),{frames:a,num_splits_h:o,num_splits_w:l}}}},"./src/models/idefics3/processing_idefics3.js":(e,t,n)=>{n.r(t),n.d(t,{Idefics3Processor:()=>o});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");n("./src/utils/image.js");var i=n("./src/utils/core.js");function A(e,t,n,r,s,a){return 0===e&&0===t?function(e,t,n,r){return`${t}${r}`+n.repeat(e)+`${t}`}(n,r,s,a):function(e,t,n,r,s,a){let i="";for(let a=0;a<t;++a){for(let t=0;t<n;++t)i+=r+`<row_${a+1}_col_${t+1}>`+s.repeat(e);i+="\n"}return i+=`\n${r}${a}`+s.repeat(e)+`${r}`,i}(n,e,t,r,s,a)}class o extends r.Processor{static image_processor_class=s.AutoImageProcessor;static tokenizer_class=a.AutoTokenizer;static uses_processor_config=!0;fake_image_token="<fake_token_around_image>";image_token="<image>";global_img_token="<global-img>";async _call(e,t=null,n={}){let r;n.return_row_col_info??=!0,t&&(r=await this.image_processor(t,n)),Array.isArray(e)||(e=[e]);const s=r.rows??[new Array(e.length).fill(0)],a=r.cols??[new Array(e.length).fill(0)],o=this.config.image_seq_len,l=[],u=[];for(let t=0;t<e.length;++t){const n=e[t],r=s[t],c=a[t];l.push((0,i.count)(n,this.image_token));const d=r.map(((e,t)=>A(e,c[t],o,this.fake_image_token,this.image_token,this.global_img_token))),h=n.split(this.image_token);if(0===h.length)throw new Error("The image token should be present in the text.");let f=h[0];for(let e=0;e<d.length;++e)f+=d[e]+h[e+1];u.push(f)}return{...this.tokenizer(u),...r}}}},"./src/models/image_processors.js":(e,t,n)=>{n.r(t),n.d(t,{BeitFeatureExtractor:()=>r.BeitFeatureExtractor,BitImageProcessor:()=>s.BitImageProcessor,CLIPFeatureExtractor:()=>i.CLIPFeatureExtractor,CLIPImageProcessor:()=>i.CLIPImageProcessor,ChineseCLIPFeatureExtractor:()=>a.ChineseCLIPFeatureExtractor,ConvNextFeatureExtractor:()=>A.ConvNextFeatureExtractor,ConvNextImageProcessor:()=>A.ConvNextImageProcessor,DPTFeatureExtractor:()=>c.DPTFeatureExtractor,DPTImageProcessor:()=>c.DPTImageProcessor,DeiTFeatureExtractor:()=>o.DeiTFeatureExtractor,DeiTImageProcessor:()=>o.DeiTImageProcessor,DetrFeatureExtractor:()=>l.DetrFeatureExtractor,DetrImageProcessor:()=>l.DetrImageProcessor,DonutFeatureExtractor:()=>u.DonutFeatureExtractor,DonutImageProcessor:()=>u.DonutImageProcessor,EfficientNetImageProcessor:()=>d.EfficientNetImageProcessor,GLPNFeatureExtractor:()=>h.GLPNFeatureExtractor,GroundingDinoImageProcessor:()=>f.GroundingDinoImageProcessor,Idefics3ImageProcessor:()=>g.Idefics3ImageProcessor,JinaCLIPImageProcessor:()=>m.JinaCLIPImageProcessor,LlavaOnevisionImageProcessor:()=>b.LlavaOnevisionImageProcessor,Mask2FormerImageProcessor:()=>C.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>I.MaskFormerFeatureExtractor,MaskFormerImageProcessor:()=>I.MaskFormerImageProcessor,MobileNetV1FeatureExtractor:()=>w.MobileNetV1FeatureExtractor,MobileNetV1ImageProcessor:()=>w.MobileNetV1ImageProcessor,MobileNetV2FeatureExtractor:()=>k.MobileNetV2FeatureExtractor,MobileNetV2ImageProcessor:()=>k.MobileNetV2ImageProcessor,MobileNetV3FeatureExtractor:()=>x.MobileNetV3FeatureExtractor,MobileNetV3ImageProcessor:()=>x.MobileNetV3ImageProcessor,MobileNetV4FeatureExtractor:()=>y.MobileNetV4FeatureExtractor,MobileNetV4ImageProcessor:()=>y.MobileNetV4ImageProcessor,MobileViTFeatureExtractor:()=>v.MobileViTFeatureExtractor,MobileViTImageProcessor:()=>v.MobileViTImageProcessor,NougatImageProcessor:()=>E.NougatImageProcessor,OwlViTFeatureExtractor:()=>M.OwlViTFeatureExtractor,OwlViTImageProcessor:()=>M.OwlViTImageProcessor,Owlv2ImageProcessor:()=>B.Owlv2ImageProcessor,Phi3VImageProcessor:()=>D.Phi3VImageProcessor,PvtImageProcessor:()=>T.PvtImageProcessor,Qwen2VLImageProcessor:()=>S.Qwen2VLImageProcessor,RTDetrImageProcessor:()=>N.RTDetrImageProcessor,SamImageProcessor:()=>G.SamImageProcessor,SegformerFeatureExtractor:()=>F.SegformerFeatureExtractor,SegformerImageProcessor:()=>F.SegformerImageProcessor,SiglipImageProcessor:()=>P.SiglipImageProcessor,SmolVLMImageProcessor:()=>Q.SmolVLMImageProcessor,Swin2SRImageProcessor:()=>z.Swin2SRImageProcessor,VLMImageProcessor:()=>p.VLMImageProcessor,ViTFeatureExtractor:()=>O.ViTFeatureExtractor,ViTImageProcessor:()=>O.ViTImageProcessor,VitMatteImageProcessor:()=>R.VitMatteImageProcessor,VitPoseImageProcessor:()=>L.VitPoseImageProcessor,YolosFeatureExtractor:()=>W.YolosFeatureExtractor,YolosImageProcessor:()=>W.YolosImageProcessor});var r=n("./src/models/beit/image_processing_beit.js"),s=n("./src/models/bit/image_processing_bit.js"),a=n("./src/models/chinese_clip/image_processing_chinese_clip.js"),i=n("./src/models/clip/image_processing_clip.js"),A=n("./src/models/convnext/image_processing_convnext.js"),o=n("./src/models/deit/image_processing_deit.js"),l=n("./src/models/detr/image_processing_detr.js"),u=n("./src/models/donut/image_processing_donut.js"),c=n("./src/models/dpt/image_processing_dpt.js"),d=n("./src/models/efficientnet/image_processing_efficientnet.js"),h=n("./src/models/glpn/image_processing_glpn.js"),f=n("./src/models/grounding_dino/image_processing_grounding_dino.js"),g=n("./src/models/idefics3/image_processing_idefics3.js"),p=n("./src/models/janus/image_processing_janus.js"),m=n("./src/models/jina_clip/image_processing_jina_clip.js"),b=n("./src/models/llava_onevision/image_processing_llava_onevision.js"),C=n("./src/models/mask2former/image_processing_mask2former.js"),I=n("./src/models/maskformer/image_processing_maskformer.js"),w=n("./src/models/mobilenet_v1/image_processing_mobilenet_v1.js"),k=n("./src/models/mobilenet_v2/image_processing_mobilenet_v2.js"),x=n("./src/models/mobilenet_v3/image_processing_mobilenet_v3.js"),y=n("./src/models/mobilenet_v4/image_processing_mobilenet_v4.js"),v=n("./src/models/mobilevit/image_processing_mobilevit.js"),E=n("./src/models/nougat/image_processing_nougat.js"),B=n("./src/models/owlv2/image_processing_owlv2.js"),M=n("./src/models/owlvit/image_processing_owlvit.js"),D=n("./src/models/phi3_v/image_processing_phi3_v.js"),T=n("./src/models/pvt/image_processing_pvt.js"),S=n("./src/models/qwen2_vl/image_processing_qwen2_vl.js"),N=n("./src/models/rt_detr/image_processing_rt_detr.js"),G=n("./src/models/sam/image_processing_sam.js"),F=n("./src/models/segformer/image_processing_segformer.js"),P=n("./src/models/siglip/image_processing_siglip.js"),Q=n("./src/models/smolvlm/image_processing_smolvlm.js"),z=n("./src/models/swin2sr/image_processing_swin2sr.js"),O=n("./src/models/vit/image_processing_vit.js"),R=n("./src/models/vitmatte/image_processing_vitmatte.js"),L=n("./src/models/vitpose/image_processing_vitpose.js"),W=n("./src/models/yolos/image_processing_yolos.js")},"./src/models/janus/image_processing_janus.js":(e,t,n)=>{n.r(t),n.d(t,{VLMImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{constructor(e){super({do_pad:!0,pad_size:{width:e.image_size,height:e.image_size},...e}),this.constant_values=this.config.background_color.map((e=>e*this.rescale_factor))}pad_image(e,t,n,r){return super.pad_image(e,t,n,{constant_values:this.constant_values,center:!0,...r})}}},"./src/models/janus/processing_janus.js":(e,t,n)=>{n.r(t),n.d(t,{VLChatProcessor:()=>l});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js"),i=n("./src/utils/core.js"),A=n("./src/utils/tensor.js"),o=n("./src/utils/image.js");class l extends r.Processor{static image_processor_class=s.AutoImageProcessor;static tokenizer_class=a.AutoTokenizer;static uses_processor_config=!0;constructor(e,t){super(e,t),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(e,{images:t=null,chat_template:n="default"}={}){t?Array.isArray(t)||(t=[t]):t=await Promise.all(e.filter((e=>e.images)).flatMap((e=>e.images)).map((e=>o.RawImage.read(e))));const r=this.tokenizer,s=e=>r.encode(e,{add_special_tokens:!1}),a=r.apply_chat_template(e,{tokenize:!1,add_generation_prompt:!0,chat_template:n}).split(this.image_tag),l=a.length-1;if(t.length!==l)throw new Error(`Number of images provided (${t.length}) does not match number of "${this.image_tag}" image tags (${l})`);const[u,c,d]=r.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let h=s(a[0]),f=new Array(h.length).fill(!1);for(let e=1;e<a.length;++e){const t=new Array(this.num_image_tokens).fill(u),n=s(a[e]);h=(0,i.mergeArrays)(h,[c],t,[d],n);const r=new Array(this.num_image_tokens).fill(!0);f=(0,i.mergeArrays)(f,[!1],r,[!1],new Array(n.length).fill(!1))}const g=[1,h.length],p={input_ids:new A.Tensor("int64",h,g),attention_mask:new A.Tensor("int64",new Array(h.length).fill(1),g),images_seq_mask:new A.Tensor("bool",f,g),images_emb_mask:new A.Tensor("bool",new Array(l*this.num_image_tokens).fill(!0),[1,l,this.num_image_tokens])};if(t&&t.length>0){const e=await this.image_processor(t);return e.pixel_values.unsqueeze_(0),{...p,...e}}return p}}},"./src/models/jina_clip/image_processing_jina_clip.js":(e,t,n)=>{n.r(t),n.d(t,{JinaCLIPImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{constructor(e){const{resize_mode:t,fill_color:n,interpolation:r,size:s,...a}=e;super({...a,size:"squash"===t?{width:s,height:s}:"shortest"===t?{shortest_edge:s}:{longest_edge:s},resample:"bicubic"===r?3:2,do_center_crop:!0,crop_size:s,do_normalize:!0})}}},"./src/models/jina_clip/processing_jina_clip.js":(e,t,n)=>{n.r(t),n.d(t,{JinaCLIPProcessor:()=>i});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");class i extends r.Processor{static tokenizer_class=a.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;async _call(e=null,t=null,n={}){if(!e&&!t)throw new Error("Either text or images must be provided");return{...e?this.tokenizer(e,n):{},...t?await this.image_processor(t,n):{}}}}},"./src/models/llava_onevision/image_processing_llava_onevision.js":(e,t,n)=>{n.r(t),n.d(t,{LlavaOnevisionImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/mask2former/image_processing_mask2former.js":(e,t,n)=>{n.r(t),n.d(t,{Mask2FormerImageProcessor:()=>s});var r=n("./src/models/maskformer/image_processing_maskformer.js");class s extends r.MaskFormerImageProcessor{}},"./src/models/maskformer/image_processing_maskformer.js":(e,t,n)=>{n.r(t),n.d(t,{MaskFormerFeatureExtractor:()=>a,MaskFormerImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_panoptic_segmentation(...e){return(0,r.post_process_panoptic_segmentation)(...e)}post_process_instance_segmentation(...e){return(0,r.post_process_instance_segmentation)(...e)}}class a extends s{}},"./src/models/mgp_str/processing_mgp_str.js":(e,t,n)=>{n.r(t),n.d(t,{MgpstrProcessor:()=>o});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js"),i=n("./src/utils/maths.js");const A={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class o extends r.Processor{static tokenizer_class=a.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(e,t){if(!A.hasOwnProperty(t))throw new Error(`Format ${t} is not supported.`);const[n,r]=A[t],s=this[n].bind(this),[a,o]=e.dims,l=[],u=[],c=e.tolist();for(let e=0;e<a;++e){const t=c[e],n=[],s=[];for(let e=1;e<o;++e){const[a,A]=(0,i.max)((0,i.softmax)(t[e]));if(s.push(a),A==r)break;n.push(A)}const a=s.length>0?s.reduce(((e,t)=>e*t),1):0;u.push(n),l.push(a)}return[s(u),l]}char_decode(e){return this.char_tokenizer.batch_decode(e).map((e=>e.replaceAll(" ","")))}bpe_decode(e){return this.bpe_tokenizer.batch_decode(e)}wp_decode(e){return this.wp_tokenizer.batch_decode(e).map((e=>e.replaceAll(" ","")))}batch_decode([e,t,n]){const[r,s]=this._decode_helper(e,"char"),[a,A]=this._decode_helper(t,"bpe"),[o,l]=this._decode_helper(n,"wp"),u=[],c=[];for(let e=0;e<r.length;++e){const[t,n]=(0,i.max)([s[e],A[e],l[e]]);u.push([r[e],a[e],o[e]][n]),c.push(t)}return{generated_text:u,scores:c,char_preds:r,bpe_preds:a,wp_preds:o}}static async from_pretrained(...e){const t=await super.from_pretrained(...e),n=await a.AutoTokenizer.from_pretrained("Xenova/gpt2"),r=await a.AutoTokenizer.from_pretrained("Xenova/bert-base-uncased");return t.components={image_processor:t.image_processor,char_tokenizer:t.tokenizer,bpe_tokenizer:n,wp_tokenizer:r},t}async _call(e,t=null){const n=await this.image_processor(e);return t&&(n.labels=this.tokenizer(t).input_ids),n}}},"./src/models/mobilenet_v1/image_processing_mobilenet_v1.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV1FeatureExtractor:()=>a,MobileNetV1ImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/mobilenet_v2/image_processing_mobilenet_v2.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV2FeatureExtractor:()=>a,MobileNetV2ImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/mobilenet_v3/image_processing_mobilenet_v3.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV3FeatureExtractor:()=>a,MobileNetV3ImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/mobilenet_v4/image_processing_mobilenet_v4.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV4FeatureExtractor:()=>a,MobileNetV4ImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/mobilevit/image_processing_mobilevit.js":(e,t,n)=>{n.r(t),n.d(t,{MobileViTFeatureExtractor:()=>a,MobileViTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/moonshine/feature_extraction_moonshine.js":(e,t,n)=>{n.r(t),n.d(t,{MoonshineFeatureExtractor:()=>a});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js");class a extends r.FeatureExtractor{async _call(e){(0,r.validate_audio_inputs)(e,"MoonshineFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=[1,e.length];return{input_values:new s.Tensor("float32",e,t)}}}},"./src/models/moonshine/processing_moonshine.js":(e,t,n)=>{n.r(t),n.d(t,{MoonshineProcessor:()=>i});var r=n("./src/models/auto/feature_extraction_auto.js"),s=n("./src/tokenizers.js"),a=n("./src/base/processing_utils.js");class i extends a.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=r.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/nougat/image_processing_nougat.js":(e,t,n)=>{n.r(t),n.d(t,{NougatImageProcessor:()=>s});var r=n("./src/models/donut/image_processing_donut.js");class s extends r.DonutImageProcessor{}},"./src/models/owlv2/image_processing_owlv2.js":(e,t,n)=>{n.r(t),n.d(t,{Owlv2ImageProcessor:()=>s});var r=n("./src/models/owlvit/image_processing_owlvit.js");class s extends r.OwlViTImageProcessor{}},"./src/models/owlvit/image_processing_owlvit.js":(e,t,n)=>{n.r(t),n.d(t,{OwlViTFeatureExtractor:()=>a,OwlViTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_object_detection(...e){return(0,r.post_process_object_detection)(...e)}}class a extends s{}},"./src/models/owlvit/processing_owlvit.js":(e,t,n)=>{n.r(t),n.d(t,{OwlViTProcessor:()=>i});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");class i extends r.Processor{static tokenizer_class=a.AutoTokenizer;static image_processor_class=s.AutoImageProcessor}},"./src/models/paligemma/processing_paligemma.js":(e,t,n)=>{n.r(t),n.d(t,{PaliGemmaProcessor:()=>A});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");const i="<image>";class A extends r.Processor{static tokenizer_class=a.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;static uses_processor_config=!1;async _call(e,t=null,n={}){t||(console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model."),t=""),Array.isArray(e)||(e=[e]),Array.isArray(t)||(t=[t]);const r=this.tokenizer.bos_token,s=this.image_processor.config.image_seq_length;let a;t.some((e=>e.includes(i)))?a=t.map((e=>{const t=e.replaceAll(i,i.repeat(s)),n=t.lastIndexOf(i),a=-1===n?0:n+7;return t.slice(0,a)+r+t.slice(a)+"\n"})):(console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special image tokens in the text, as many tokens as there are images per each text. It is recommended to add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images each text has and add special tokens."),a=t.map((t=>function(e,t,n,r,s){return`${r.repeat(n*s)}${t}${e}\n`}(t,r,s,i,e.length))));const A=this.tokenizer(a,n);return{...await this.image_processor(e,n),...A}}}},"./src/models/phi3_v/image_processing_phi3_v.js":(e,t,n)=>{n.r(t),n.d(t,{Phi3VImageProcessor:()=>u});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");const a=336,i=[2,3],{ceil:A,floor:o,sqrt:l}=Math;class u extends r.ImageProcessor{constructor(e){super({...e,do_normalize:!0,do_pad:!0,pad_size:"custom",do_convert_rgb:!0,do_resize:!0}),this._num_crops=e.num_crops}calc_num_image_tokens_from_image_size(e,t){const{num_img_tokens:n}=this.config;return o((o(t/a)*o(e/a)+1)*n+1+(o(t/a)+1)*l(n))}get_resize_output_image_size(e,t){const n=this._num_crops,[r,s]=e.size;let a=r/s,i=1;for(;i*Math.ceil(i/a)<=n;)i+=1;i-=1;const A=Math.floor(336*i);return[A,Math.floor(A/a)]}pad_image(e,t,n,r={}){const[s,i]=t,o=a*A(s/a),l=a*A(i/a),u=[1,1,1].map(((e,t)=>(e-this.image_mean[t])/this.image_std[t]));return super.pad_image(e,t,{width:l,height:o},{center:!0,constant_values:u,...r})}async _call(e,{num_crops:t=null}={}){if(this._num_crops=t??=this.config.num_crops,t<4||l(t)%1!=0)throw new Error("num_crops must be a square number >= 4");Array.isArray(e)||(e=[e]);const n=e.length,r=await Promise.all(e.map((e=>this.preprocess(e)))),u=r.map((e=>e.original_size)),c=r.map((e=>e.reshaped_input_size)),d=[];for(const{pixel_values:e}of r){e.unsqueeze_(0);const[n,r]=e.dims.slice(-2),A=await(0,s.interpolate_4d)(e,{size:[a,a],mode:"bicubic"});if(t>0){const u=[],c=l(t),h=o(r/c),f=o(n/c);for(let t=0;t<c;++t)for(let a=0;a<c;++a){let A,o,l,d;t===c-1?(o=n-f,d=n):(o=t*f,d=(t+1)*f),a===c-1?(A=r-h,l=r):(A=a*h,l=(a+1)*h);const g=[o,A],p=[d,l],m=await(0,s.slice)(e,g,p,i);u.push(m)}const g=await(0,s.interpolate_4d)((0,s.cat)(u,0),{size:[a,a],mode:"bicubic"});d.push((0,s.cat)([A,g],0))}else d.push(A)}const h=(0,s.stack)(d,0),f=c.map((e=>e.map((e=>a*A(e/a)))));return{pixel_values:h,original_sizes:u,reshaped_input_sizes:c,image_sizes:new s.Tensor("int64",f.flat(),[n,2]),num_img_tokens:f.map((([e,t])=>this.calc_num_image_tokens_from_image_size(t,e)))}}}},"./src/models/phi3_v/processing_phi3_v.js":(e,t,n)=>{n.r(t),n.d(t,{Phi3VProcessor:()=>o});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");n("./src/utils/image.js");const i="<|image|>",A=/<\|image_\d+\|>/g;class o extends r.Processor{static image_processor_class=s.AutoImageProcessor;static tokenizer_class=a.AutoTokenizer;async _call(e,t=null,{padding:n=!0,truncation:r=!0,num_crops:s=null}={}){let a,o;if(Array.isArray(e)||(e=[e]),t){o=await this.image_processor(t,{num_crops:s});const{num_img_tokens:l}=o,u=e.map(((e,t)=>e.split(A).join(i.repeat(l[t]))));a=this.tokenizer(u,{padding:n,truncation:r});const c=this.tokenizer.model.convert_tokens_to_ids([i])[0];a.input_ids.map_((e=>e==c?-e:e))}else a=this.tokenizer(e);return{...a,...o}}}},"./src/models/processors.js":(e,t,n)=>{n.r(t),n.d(t,{Florence2Processor:()=>r.Florence2Processor,GroundingDinoProcessor:()=>s.GroundingDinoProcessor,Idefics3Processor:()=>a.Idefics3Processor,JinaCLIPProcessor:()=>A.JinaCLIPProcessor,MgpstrProcessor:()=>o.MgpstrProcessor,MoonshineProcessor:()=>l.MoonshineProcessor,OwlViTProcessor:()=>u.OwlViTProcessor,PaliGemmaProcessor:()=>d.PaliGemmaProcessor,Phi3VProcessor:()=>c.Phi3VProcessor,PyAnnoteProcessor:()=>h.PyAnnoteProcessor,Qwen2VLProcessor:()=>f.Qwen2VLProcessor,SamProcessor:()=>g.SamProcessor,SmolVLMProcessor:()=>p.SmolVLMProcessor,SpeechT5Processor:()=>m.SpeechT5Processor,UltravoxProcessor:()=>b.UltravoxProcessor,VLChatProcessor:()=>i.VLChatProcessor,Wav2Vec2Processor:()=>C.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>I.Wav2Vec2ProcessorWithLM,WhisperProcessor:()=>w.WhisperProcessor});var r=n("./src/models/florence2/processing_florence2.js"),s=n("./src/models/grounding_dino/processing_grounding_dino.js"),a=n("./src/models/idefics3/processing_idefics3.js"),i=n("./src/models/janus/processing_janus.js"),A=n("./src/models/jina_clip/processing_jina_clip.js"),o=n("./src/models/mgp_str/processing_mgp_str.js"),l=n("./src/models/moonshine/processing_moonshine.js"),u=n("./src/models/owlvit/processing_owlvit.js"),c=n("./src/models/phi3_v/processing_phi3_v.js"),d=n("./src/models/paligemma/processing_paligemma.js"),h=n("./src/models/pyannote/processing_pyannote.js"),f=n("./src/models/qwen2_vl/processing_qwen2_vl.js"),g=n("./src/models/sam/processing_sam.js"),p=n("./src/models/smolvlm/processing_smolvlm.js"),m=n("./src/models/speecht5/processing_speecht5.js"),b=n("./src/models/ultravox/processing_ultravox.js"),C=n("./src/models/wav2vec2/processing_wav2vec2.js"),I=n("./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js"),w=n("./src/models/whisper/processing_whisper.js")},"./src/models/pvt/image_processing_pvt.js":(e,t,n)=>{n.r(t),n.d(t,{PvtImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/pyannote/feature_extraction_pyannote.js":(e,t,n)=>{n.r(t),n.d(t,{PyAnnoteFeatureExtractor:()=>i});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js"),a=n("./src/utils/maths.js");class i extends r.FeatureExtractor{async _call(e){(0,r.validate_audio_inputs)(e,"PyAnnoteFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=[1,1,e.length];return{input_values:new s.Tensor("float32",e,t)}}samples_to_frames(e){return(e-this.config.offset)/this.config.step}post_process_speaker_diarization(e,t){const n=t/this.samples_to_frames(t)/this.config.sampling_rate,r=[];for(const t of e.tolist()){const e=[];let s=-1;for(let n=0;n<t.length;++n){const r=(0,a.softmax)(t[n]),[i,A]=(0,a.max)(r),[o,l]=[n,n+1];A!==s?(s=A,e.push({id:A,start:o,end:l,score:i})):(e.at(-1).end=l,e.at(-1).score+=i)}r.push(e.map((({id:e,start:t,end:r,score:s})=>({id:e,start:t*n,end:r*n,confidence:s/(r-t)}))))}return r}}},"./src/models/pyannote/processing_pyannote.js":(e,t,n)=>{n.r(t),n.d(t,{PyAnnoteProcessor:()=>a});var r=n("./src/base/processing_utils.js"),s=n("./src/models/pyannote/feature_extraction_pyannote.js");class a extends r.Processor{static feature_extractor_class=s.PyAnnoteFeatureExtractor;async _call(e){return await this.feature_extractor(e)}post_process_speaker_diarization(...e){return this.feature_extractor.post_process_speaker_diarization(...e)}get sampling_rate(){return this.feature_extractor.config.sampling_rate}}},"./src/models/qwen2_vl/image_processing_qwen2_vl.js":(e,t,n)=>{n.r(t),n.d(t,{Qwen2VLImageProcessor:()=>a});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class a extends r.ImageProcessor{async _call(e,...t){const{pixel_values:n,original_sizes:r,reshaped_input_sizes:a}=await super._call(e,...t);let i=n;const{temporal_patch_size:A,merge_size:o,patch_size:l}=this.config;1===i.dims[0]&&(i=(0,s.cat)(Array.from({length:A},(()=>i)),0));const u=i.dims[0]/A,c=i.dims[1],d=Math.floor(i.dims[2]/l),h=Math.floor(i.dims[3]/l);return{pixel_values:i.view(u,A,c,Math.floor(d/o),o,l,Math.floor(h/o),o,l).permute(0,3,6,4,7,2,1,5,8).view(u*d*h,c*A*l*l),image_grid_thw:new s.Tensor("int64",[u,d,h],[1,3]),original_sizes:r,reshaped_input_sizes:a}}}},"./src/models/qwen2_vl/processing_qwen2_vl.js":(e,t,n)=>{n.r(t),n.d(t,{Qwen2VLProcessor:()=>i});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");n("./src/utils/image.js");class i extends r.Processor{static image_processor_class=s.AutoImageProcessor;static tokenizer_class=a.AutoTokenizer;async _call(e,t=null,...n){let r,s;if(Array.isArray(e)||(e=[e]),t&&(r=await this.image_processor(t),s=r.image_grid_thw),s){let t=this.image_processor.config.merge_size**2,n=0;const r=s.tolist();e=e.map((e=>{for(;e.includes("<|image_pad|>");){const s=Number(r[n++].reduce(((e,t)=>e*t),1n));e=e.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(s/t)))}return e.replaceAll("<|placeholder|>","<|image_pad|>")}))}return{...this.tokenizer(e),...r}}}},"./src/models/rt_detr/image_processing_rt_detr.js":(e,t,n)=>{n.r(t),n.d(t,{RTDetrImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_object_detection(...e){return(0,r.post_process_object_detection)(...e)}}},"./src/models/sam/image_processing_sam.js":(e,t,n)=>{n.r(t),n.d(t,{SamImageProcessor:()=>i});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/core.js"),a=n("./src/utils/tensor.js");class i extends r.ImageProcessor{reshape_input_points(e,t,n,r=!1){e=structuredClone(e);let i=(0,s.calculateDimensions)(e);if(3===i.length)r||(i=[1,...i]),e=[e];else if(4!==i.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let r=0;r<e.length;++r){let s=t[r],a=n[r],i=[a[0]/s[0],a[1]/s[1]];for(let t=0;t<e[r].length;++t)for(let n=0;n<e[r][t].length;++n)for(let s=0;s<e[r][t][n].length;++s)e[r][t][n][s]*=i[s%2]}return new a.Tensor("float32",Float32Array.from(e.flat(1/0)),i)}add_input_labels(e,t){let n=(0,s.calculateDimensions)(e);if(2===n.length)n=[1,...n],e=[e];else if(3!==n.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(n.some(((e,n)=>e!==t.dims[n])))throw Error(`The first ${n.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new a.Tensor("int64",e.flat(1/0).map(BigInt),n)}async _call(e,{input_points:t=null,input_labels:n=null,input_boxes:r=null}={}){const s=await super._call(e);if(t&&(s.input_points=this.reshape_input_points(t,s.original_sizes,s.reshaped_input_sizes)),n){if(!s.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");s.input_labels=this.add_input_labels(n,s.input_points)}return r&&(s.input_boxes=this.reshape_input_points(r,s.original_sizes,s.reshaped_input_sizes,!0)),s}async post_process_masks(e,t,n,{mask_threshold:r=0,binarize:s=!0,pad_size:i=null}={}){const A=[],o=[(i=i??this.pad_size).height,i.width];for(let i=0;i<t.length;++i){const l=t[i],u=n[i];let c=await(0,a.interpolate_4d)(e[i],{mode:"bilinear",size:o});if(c=c.slice(null,null,[0,u[0]],[0,u[1]]),c=await(0,a.interpolate_4d)(c,{mode:"bilinear",size:l}),s){const e=c.data,t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)e[n]>r&&(t[n]=1);c=new a.Tensor("bool",t,c.dims)}A.push(c)}return A}generate_crop_boxes(e,t,{crop_n_layers:n=0,overlap_ratio:r=512/1500,points_per_crop:s=32,crop_n_points_downscale_factor:a=1}={}){}}},"./src/models/sam/processing_sam.js":(e,t,n)=>{n.r(t),n.d(t,{SamProcessor:()=>a});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js");class a extends r.Processor{static image_processor_class=s.AutoImageProcessor;async _call(...e){return await this.image_processor(...e)}post_process_masks(...e){return this.image_processor.post_process_masks(...e)}reshape_input_points(...e){return this.image_processor.reshape_input_points(...e)}}},"./src/models/seamless_m4t/feature_extraction_seamless_m4t.js":(e,t,n)=>{n.r(t),n.d(t,{SeamlessM4TFeatureExtractor:()=>i});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js"),a=n("./src/utils/audio.js");class i extends r.FeatureExtractor{constructor(e){super(e);const t=this.config.sampling_rate,n=(0,a.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);this.mel_filters=n,this.window=(0,a.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(e,t){return e=e.map((e=>32768*e)),(0,a.spectrogram)(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e,{padding:t=!0,pad_to_multiple_of:n=2,do_normalize_per_mel_bins:a=!0,return_attention_mask:i=!0}={}){(0,r.validate_audio_inputs)(e,"SeamlessM4TFeatureExtractor");let A,o=await this._extract_fbank_features(e,this.config.max_length);if(a){const[e,t]=o.dims,n=o.data;for(let r=0;r<t;++r){let s=0;for(let a=0;a<e;++a)s+=n[a*t+r];const a=s/e;let i=0;for(let s=0;s<e;++s)i+=(n[s*t+r]-a)**2;i/=e-1;const A=Math.sqrt(i+1e-7);for(let s=0;s<e;++s){const e=s*t+r;n[e]=(n[e]-a)/A}}}if(t){const[e,t]=o.dims,r=o.data,a=e%n;if(a>0){const n=new Float32Array(t*(e+a));n.set(r),n.fill(this.config.padding_value,r.length);const l=e+a;o=new s.Tensor(o.type,n,[l,t]),i&&(A=new s.Tensor("int64",new BigInt64Array(l),[1,l]),A.data.fill(1n,0,e))}}const[l,u]=o.dims,c=this.config.stride;if(0!==l%c)throw new Error(`The number of frames (${l}) must be a multiple of the stride (${c}).`);const d=o.view(1,Math.floor(l/c),u*c),h={input_features:d};if(i){const e=d.dims[1],t=new BigInt64Array(e);if(A){const e=A.data;for(let n=1,r=0;n<l;n+=c,++r)t[r]=e[n]}else t.fill(1n);h.attention_mask=new s.Tensor("int64",t,[1,e])}return h}}},"./src/models/segformer/image_processing_segformer.js":(e,t,n)=>{n.r(t),n.d(t,{SegformerFeatureExtractor:()=>a,SegformerImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_semantic_segmentation(...e){return(0,r.post_process_semantic_segmentation)(...e)}}class a extends s{}},"./src/models/siglip/image_processing_siglip.js":(e,t,n)=>{n.r(t),n.d(t,{SiglipImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/smolvlm/image_processing_smolvlm.js":(e,t,n)=>{n.r(t),n.d(t,{SmolVLMImageProcessor:()=>r.Idefics3ImageProcessor});var r=n("./src/models/idefics3/image_processing_idefics3.js")},"./src/models/smolvlm/processing_smolvlm.js":(e,t,n)=>{n.r(t),n.d(t,{SmolVLMProcessor:()=>r.Idefics3Processor});var r=n("./src/models/idefics3/processing_idefics3.js")},"./src/models/snac/feature_extraction_snac.js":(e,t,n)=>{n.r(t),n.d(t,{SnacFeatureExtractor:()=>s});var r=n("./src/models/dac/feature_extraction_dac.js");class s extends r.DacFeatureExtractor{}},"./src/models/speecht5/feature_extraction_speecht5.js":(e,t,n)=>{n.r(t),n.d(t,{SpeechT5FeatureExtractor:()=>s});var r=n("./src/base/feature_extraction_utils.js");class s extends r.FeatureExtractor{}},"./src/models/speecht5/processing_speecht5.js":(e,t,n)=>{n.r(t),n.d(t,{SpeechT5Processor:()=>i});var r=n("./src/base/processing_utils.js"),s=n("./src/tokenizers.js"),a=n("./src/models/auto/feature_extraction_auto.js");class i extends r.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=a.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/swin2sr/image_processing_swin2sr.js":(e,t,n)=>{n.r(t),n.d(t,{Swin2SRImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{pad_image(e,t,n,r={}){const[s,a,i]=t;return super.pad_image(e,t,{width:a+(n-a%n)%n,height:s+(n-s%n)%n},{mode:"symmetric",center:!1,constant_values:-1,...r})}}},"./src/models/ultravox/processing_ultravox.js":(e,t,n)=>{n.r(t),n.d(t,{UltravoxProcessor:()=>i});var r=n("./src/models/auto/feature_extraction_auto.js"),s=n("./src/tokenizers.js"),a=n("./src/base/processing_utils.js");class i extends a.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=r.AutoFeatureExtractor;static uses_processor_config=!0;async _call(e,t=null,n={}){if(Array.isArray(e))throw new Error("Batched inputs are not supported yet.");let r={};if(t){const s=t.length,{input_features:a}=await this.feature_extractor(t,{...n,max_length:s}),i=Math.round(s/this.config.encoder_ds_factor+1e-4),A=1+Math.ceil(i/this.config.stack_factor);r.audio_token_len=[A],r.audio_values=a;const o=this.config.audio_placeholder;if(!e.includes(o))throw new Error(`The input text does not contain the image token ${o}.`);e=e.replaceAll(o,o.repeat(A))}return{...this.tokenizer(e,{add_special_tokens:!1,...n}),...r}}}},"./src/models/vit/image_processing_vit.js":(e,t,n)=>{n.r(t),n.d(t,{ViTFeatureExtractor:()=>a,ViTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/vitmatte/image_processing_vitmatte.js":(e,t,n)=>{n.r(t),n.d(t,{VitMatteImageProcessor:()=>a});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class a extends r.ImageProcessor{async _call(e,t){Array.isArray(e)||(e=[e]),Array.isArray(t)||(t=[t]);const n=await Promise.all(e.map((e=>this.preprocess(e)))),r=await Promise.all(t.map((e=>this.preprocess(e,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})))),a=(0,s.stack)(n.map(((e,t)=>(0,s.cat)([e.pixel_values,r[t].pixel_values],0))),0);return{pixel_values:a,original_sizes:n.map((e=>e.original_size)),reshaped_input_sizes:n.map((e=>e.reshaped_input_size))}}}},"./src/models/vitpose/image_processing_vitpose.js":(e,t,n)=>{n.r(t),n.d(t,{VitPoseImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_pose_estimation(e,t,{threshold:n=null}={}){const r=e.tolist(),[s,a,i,A]=e.dims,o=[];for(let e=0;e<s;++e){const s=r[e],a=t[e],l=[];for(let e=0;e<a.length;++e){const t=a[e],r=[],o=[],u=[],c=t.at(-2)/A,d=t.at(-1)/i;for(let e=0;e<s.length;++e){let[t,a]=[0,0],i=0,A=-1/0;const l=s[e];for(let e=0;e<l.length;++e){const n=l[e];for(let r=0;r<n.length;++r){const s=n[r];i+=s,A=Math.max(A,s),t+=(r+.5)*s,a+=e*s}}if(null!=n&&A<n)continue;const h=[c*t/i,d*a/i];r.push(h),u.push(e),o.push(A)}l.push({bbox:t,scores:o,labels:u,keypoints:r})}o.push(l)}return o}}},"./src/models/wav2vec2/feature_extraction_wav2vec2.js":(e,t,n)=>{n.r(t),n.d(t,{Wav2Vec2FeatureExtractor:()=>a});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js");class a extends r.FeatureExtractor{_zero_mean_unit_var_norm(e){const t=e.reduce(((e,t)=>e+t),0),n=t/e.length,r=e.reduce(((e,t)=>e+(t-n)**2),0)/e.length;return e.map((e=>(e-n)/Math.sqrt(r+1e-7)))}async _call(e){(0,r.validate_audio_inputs)(e,"Wav2Vec2FeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));let t=e;this.config.do_normalize&&(t=this._zero_mean_unit_var_norm(t));const n=[1,t.length];return{input_values:new s.Tensor("float32",t,n),attention_mask:new s.Tensor("int64",new BigInt64Array(t.length).fill(1n),n)}}}},"./src/models/wav2vec2/processing_wav2vec2.js":(e,t,n)=>{n.r(t),n.d(t,{Wav2Vec2Processor:()=>i});var r=n("./src/tokenizers.js"),s=n("./src/models/auto/feature_extraction_auto.js"),a=n("./src/base/processing_utils.js");class i extends a.Processor{static tokenizer_class=r.AutoTokenizer;static feature_extractor_class=s.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js":(e,t,n)=>{n.r(t),n.d(t,{Wav2Vec2ProcessorWithLM:()=>i});var r=n("./src/tokenizers.js"),s=n("./src/models/auto/feature_extraction_auto.js"),a=n("./src/base/processing_utils.js");class i extends a.Processor{static tokenizer_class=r.AutoTokenizer;static feature_extractor_class=s.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/wespeaker/feature_extraction_wespeaker.js":(e,t,n)=>{n.r(t),n.d(t,{WeSpeakerFeatureExtractor:()=>a});var r=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var s=n("./src/utils/audio.js");class a extends r.FeatureExtractor{constructor(e){super(e);const t=this.config.sampling_rate,n=(0,s.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);this.mel_filters=n,this.window=(0,s.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(e){return e=e.map((e=>32768*e)),(0,s.spectrogram)(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(e){(0,r.validate_audio_inputs)(e,"WeSpeakerFeatureExtractor");const t=(await this._extract_fbank_features(e)).unsqueeze_(0);if(null===this.config.fbank_centering_span){const e=t.mean(1).data,n=t.data,[r,s,a]=t.dims;for(let t=0;t<r;++t){const r=t*s*a,i=t*a;for(let t=0;t<s;++t){const s=r+t*a;for(let t=0;t<a;++t)n[s+t]-=e[i+t]}}}return{input_features:t}}}},"./src/models/whisper/common_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WHISPER_LANGUAGE_MAPPING:()=>s,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>a,whisper_language_to_code:()=>i});const r=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],s=new Map(r),a=new Map([...r.map((([e,t])=>[t,e])),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function i(e){e=e.toLowerCase();let t=a.get(e);if(void 0===t){const n=e.match(/^<\|([a-z]{2})\|>$/);if(n&&(e=n[1]),!s.has(e)){const t=2===e.length?s.keys():s.values();throw new Error(`Language "${e}" is not supported. Must be one of: ${JSON.stringify(Array.from(t))}`)}t=e}return t}},"./src/models/whisper/feature_extraction_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WhisperFeatureExtractor:()=>i});var r=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var s=n("./src/utils/audio.js"),a=n("./src/utils/maths.js");class i extends r.FeatureExtractor{constructor(e){super(e),this.config.mel_filters??=(0,s.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=(0,s.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(e){const t=await(0,s.spectrogram)(e,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:Math.min(Math.floor(e.length/this.config.hop_length),this.config.nb_max_frames)}),n=t.data,r=(0,a.max)(n)[0];for(let e=0;e<n.length;++e)n[e]=(Math.max(n[e],r-8)+4)/4;return t}async _call(e,{max_length:t=null}={}){let n;(0,r.validate_audio_inputs)(e,"WhisperFeatureExtractor");const s=t??this.config.n_samples;e.length>s?(e.length>this.config.n_samples&&console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),n=e.slice(0,s)):(n=new Float32Array(s),n.set(e));return{input_features:(await this._extract_fbank_features(n)).unsqueeze_(0)}}}},"./src/models/whisper/generation_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WhisperGenerationConfig:()=>s});var r=n("./src/generation/configuration_utils.js");class s extends r.GenerationConfig{return_timestamps=null;return_token_timestamps=null;num_frames=null;alignment_heads=null;task=null;language=null;no_timestamps_token_id=null;prompt_ids=null;is_multilingual=null;lang_to_id=null;task_to_id=null;max_initial_timestamp_index=1}},"./src/models/whisper/processing_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WhisperProcessor:()=>i});var r=n("./src/models/auto/feature_extraction_auto.js"),s=n("./src/tokenizers.js"),a=n("./src/base/processing_utils.js");class i extends a.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=r.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/yolos/image_processing_yolos.js":(e,t,n)=>{n.r(t),n.d(t,{YolosFeatureExtractor:()=>a,YolosImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_object_detection(...e){return(0,r.post_process_object_detection)(...e)}}class a extends s{}},"./src/ops/registry.js":(e,t,n)=>{n.r(t),n.d(t,{TensorOpRegistry:()=>o});var r=n("./src/backends/onnx.js"),s=n("./src/utils/tensor.js"),a=n("./src/env.js");const i=a.apis.IS_BROWSER_ENV||a.apis.IS_WEBWORKER_ENV,A=async(e,t,n)=>{const a=await(0,r.createInferenceSession)(new Uint8Array(e),t);let A=Promise.resolve();return async e=>{const t=(0,r.isONNXProxy)(),o=Object.fromEntries(Object.entries(e).map((([e,n])=>[e,(t?n.clone():n).ort_tensor]))),l=await(A=i?A.then((()=>a.run(o))):a.run(o));return Array.isArray(n)?n.map((e=>new s.Tensor(l[e]))):new s.Tensor(l[n])}};class o{static session_options={};static get nearest_interpolate_4d(){return this._nearest_interpolate_4d||(this._nearest_interpolate_4d=A([8,10,18,0,58,129,1,10,41,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,18,10,4,109,111,100,101,34,7,110,101,97,114,101,115,116,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,21],this.session_options,"y")),this._nearest_interpolate_4d}static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=A([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=A([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=A([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=A([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=A([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=A([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}static get slice(){return this._slice||(this._slice=A([8,7,18,0,58,96,10,25,10,1,120,10,1,115,10,1,101,10,1,97,10,1,116,18,1,121,34,5,83,108,105,99,101,18,1,114,90,9,10,1,120,18,4,10,2,8,1,90,9,10,1,115,18,4,10,2,8,7,90,9,10,1,101,18,4,10,2,8,7,90,9,10,1,97,18,4,10,2,8,7,90,9,10,1,116,18,4,10,2,8,7,98,9,10,1,121,18,4,10,2,8,1,66,2,16,13],this.session_options,"y")),this._slice}}},"./src/pipelines.js":(e,t,n)=>{n.r(t),n.d(t,{AudioClassificationPipeline:()=>M,AutomaticSpeechRecognitionPipeline:()=>T,BackgroundRemovalPipeline:()=>F,DepthEstimationPipeline:()=>W,DocumentQuestionAnsweringPipeline:()=>O,FeatureExtractionPipeline:()=>E,FillMaskPipeline:()=>C,ImageClassificationPipeline:()=>N,ImageFeatureExtractionPipeline:()=>B,ImageSegmentationPipeline:()=>G,ImageToImagePipeline:()=>L,ImageToTextPipeline:()=>S,ObjectDetectionPipeline:()=>Q,Pipeline:()=>g,QuestionAnsweringPipeline:()=>b,SummarizationPipeline:()=>w,Text2TextGenerationPipeline:()=>I,TextClassificationPipeline:()=>p,TextGenerationPipeline:()=>y,TextToAudioPipeline:()=>R,TokenClassificationPipeline:()=>m,TranslationPipeline:()=>k,ZeroShotAudioClassificationPipeline:()=>D,ZeroShotClassificationPipeline:()=>v,ZeroShotImageClassificationPipeline:()=>P,ZeroShotObjectDetectionPipeline:()=>z,pipeline:()=>H});var r=n("./src/tokenizers.js"),s=n("./src/models.js"),a=n("./src/models/auto/processing_auto.js");n("./src/base/processing_utils.js");var i=n("./src/utils/generic.js"),A=n("./src/utils/core.js"),o=n("./src/utils/maths.js"),l=n("./src/utils/audio.js"),u=n("./src/utils/tensor.js"),c=n("./src/utils/image.js");async function d(e){return Array.isArray(e)||(e=[e]),await Promise.all(e.map((e=>c.RawImage.read(e))))}async function h(e,t){return Array.isArray(e)||(e=[e]),await Promise.all(e.map((e=>"string"==typeof e||e instanceof URL?(0,l.read_audio)(e,t):e instanceof Float64Array?new Float32Array(e):e)))}function f(e,t){t&&(e=e.map((e=>0|e)));const[n,r,s,a]=e;return{xmin:n,ymin:r,xmax:s,ymax:a}}class g extends i.Callable{constructor({task:e,model:t,tokenizer:n=null,processor:r=null}){super(),this.task=e,this.model=t,this.tokenizer=n,this.processor=r}async dispose(){await this.model.dispose()}}class p extends g{constructor(e){super(e)}async _call(e,{top_k:t=1}={}){const n=this.tokenizer(e,{padding:!0,truncation:!0}),r=await this.model(n),s="multi_label_classification"===this.model.config.problem_type?e=>e.sigmoid():e=>new u.Tensor("float32",(0,o.softmax)(e.data),e.dims),a=this.model.config.id2label,i=[];for(const e of r.logits){const n=s(e),r=await(0,u.topk)(n,t),A=r[0].tolist(),o=r[1].tolist().map(((e,t)=>({label:a?a[e]:`LABEL_${e}`,score:A[t]})));1===t?i.push(...o):i.push(o)}return Array.isArray(e)||1===t?i:i[0]}}class m extends g{constructor(e){super(e)}async _call(e,{ignore_labels:t=["O"]}={}){const n=Array.isArray(e),r=this.tokenizer(n?e:[e],{padding:!0,truncation:!0}),s=(await this.model(r)).logits,a=this.model.config.id2label,i=[];for(let e=0;e<s.dims[0];++e){const n=r.input_ids[e],A=s[e],l=[];for(let e=0;e<A.dims[0];++e){const r=A[e],s=(0,o.max)(r.data)[1],i=a?a[s]:`LABEL_${s}`;if(t.includes(i))continue;const u=this.tokenizer.decode([n[e].item()],{skip_special_tokens:!0});if(""===u)continue;const c=(0,o.softmax)(r.data);l.push({entity:i,score:c[s],index:e,word:u})}i.push(l)}return n?i:i[0]}}class b extends g{constructor(e){super(e)}async _call(e,t,{top_k:n=1}={}){const r=this.tokenizer(e,{text_pair:t,padding:!0,truncation:!0}),{start_logits:s,end_logits:a}=await this.model(r),i=r.input_ids.tolist(),l=r.attention_mask.tolist(),u=this.tokenizer.all_special_ids,c=[];for(let e=0;e<s.dims[0];++e){const t=i[e],r=t.findIndex((e=>e==this.tokenizer.sep_token_id));l[e].map(((e,n)=>1==e&&(0===n||n>r&&-1===u.findIndex((e=>e==t[n])))));const d=s[e].tolist(),h=a[e].tolist();for(let n=1;n<d.length;++n)(0==l[e]||n<=r||-1!==u.findIndex((e=>e==t[n])))&&(d[n]=-1/0,h[n]=-1/0);const f=(0,o.softmax)(d).map(((e,t)=>[e,t])),g=(0,o.softmax)(h).map(((e,t)=>[e,t]));f[0][0]=0,g[0][0]=0;const p=(0,A.product)(f,g).filter((e=>e[0][1]<=e[1][1])).map((e=>[e[0][1],e[1][1],e[0][0]*e[1][0]])).sort(((e,t)=>t[2]-e[2]));for(let e=0;e<Math.min(p.length,n);++e){const[n,r,s]=p[e],a=t.slice(n,r+1),i=this.tokenizer.decode(a,{skip_special_tokens:!0});c.push({answer:i,score:s})}}return 1===n?c[0]:c}}class C extends g{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=this.tokenizer(e,{padding:!0,truncation:!0}),{logits:r}=await this.model(n),s=[],a=n.input_ids.tolist();for(let e=0;e<a.length;++e){const n=a[e],i=n.findIndex((e=>e==this.tokenizer.mask_token_id));if(-1===i)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const A=r[e][i],l=await(0,u.topk)(new u.Tensor("float32",(0,o.softmax)(A.data),A.dims),t),c=l[0].tolist(),d=l[1].tolist();s.push(d.map(((e,t)=>{const r=n.slice();return r[i]=e,{score:c[t],token:Number(e),token_str:this.tokenizer.decode([e]),sequence:this.tokenizer.decode(r,{skip_special_tokens:!0})}})))}return Array.isArray(e)?s:s[0]}}class I extends g{_key="generated_text";constructor(e){super(e)}async _call(e,t={}){Array.isArray(e)||(e=[e]),this.model.config.prefix&&(e=e.map((e=>this.model.config.prefix+e)));const n=this.model.config.task_specific_params;n&&n[this.task]&&n[this.task].prefix&&(e=e.map((e=>n[this.task].prefix+e)));const r=this.tokenizer,s={padding:!0,truncation:!0};let a;a=this instanceof k&&"_build_translation_inputs"in r?r._build_translation_inputs(e,s,t):r(e,s);const i=await this.model.generate({...a,...t});return r.batch_decode(i,{skip_special_tokens:!0}).map((e=>({[this._key]:e})))}}class w extends I{_key="summary_text";constructor(e){super(e)}}class k extends I{_key="translation_text";constructor(e){super(e)}}function x(e){return Array.isArray(e)&&e.every((e=>"role"in e&&"content"in e))}class y extends g{constructor(e){super(e)}async _call(e,t={}){let n,r=!1,s=!1;if("string"==typeof e)n=e=[e];else if(Array.isArray(e)&&e.every((e=>"string"==typeof e)))r=!0,n=e;else{if(x(e))e=[e];else{if(!Array.isArray(e)||!e.every(x))throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");r=!0}s=!0,n=e.map((e=>this.tokenizer.apply_chat_template(e,{tokenize:!1,add_generation_prompt:!0})))}const a=t.add_special_tokens??!1,i=!s&&(t.return_full_text??!0);this.tokenizer.padding_side="left";const A=this.tokenizer(n,{add_special_tokens:a,padding:!0,truncation:!0}),o=await this.model.generate({...A,...t}),l=this.tokenizer.batch_decode(o,{skip_special_tokens:!0});let u;!i&&A.input_ids.dims.at(-1)>0&&(u=this.tokenizer.batch_decode(A.input_ids,{skip_special_tokens:!0}).map((e=>e.length)));const c=Array.from({length:e.length},(e=>[]));for(let t=0;t<l.length;++t){const n=Math.floor(t/o.dims[0]*e.length);u&&(l[t]=l[t].slice(u[n])),c[n].push({generated_text:s?[...e[n],{role:"assistant",content:l[t]}]:l[t]})}return r||1!==c.length?c:c[0]}}class v extends g{constructor(e){super(e),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map((([e,t])=>[e.toLowerCase(),t]))),this.entailment_id=this.label2id.entailment,void 0===this.entailment_id&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,void 0===this.contradiction_id&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(e,t,{hypothesis_template:n="This example is {}.",multi_label:r=!1}={}){const s=Array.isArray(e);s||(e=[e]),Array.isArray(t)||(t=[t]);const a=t.map((e=>n.replace("{}",e))),i=r||1===t.length,A=[];for(const n of e){const e=[];for(const t of a){const r=this.tokenizer(n,{text_pair:t,padding:!0,truncation:!0}),s=await this.model(r);i?e.push([s.logits.data[this.contradiction_id],s.logits.data[this.entailment_id]]):e.push(s.logits.data[this.entailment_id])}const r=i?e.map((e=>(0,o.softmax)(e)[1])):(0,o.softmax)(e),s=r.map(((e,t)=>[e,t])).sort(((e,t)=>t[0]-e[0]));A.push({sequence:n,labels:s.map((e=>t[e[1]])),scores:s.map((e=>e[0]))})}return s?A:A[0]}}class E extends g{constructor(e){super(e)}async _call(e,{pooling:t="none",normalize:n=!1,quantize:r=!1,precision:s="binary"}={}){const a=this.tokenizer(e,{padding:!0,truncation:!0}),i=await this.model(a);let A=i.last_hidden_state??i.logits??i.token_embeddings;if("none"===t);else if("mean"===t)A=(0,u.mean_pooling)(A,a.attention_mask);else{if("cls"!==t)throw Error(`Pooling method '${t}' not supported.`);A=A.slice(null,0)}return n&&(A=A.normalize(2,-1)),r&&(A=(0,u.quantize_embeddings)(A,s)),A}}class B extends g{constructor(e){super(e)}async _call(e,{pool:t=null}={}){const n=await d(e),{pixel_values:r}=await this.processor(n),s=await this.model({pixel_values:r});let a;if(t){if(!("pooler_output"in s))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");a=s.pooler_output}else a=s.last_hidden_state??s.logits??s.image_embeds;return a}}class M extends g{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=this.processor.feature_extractor.config.sampling_rate,r=await h(e,n),s=this.model.config.id2label,a=[];for(const e of r){const n=await this.processor(e),r=(await this.model(n)).logits[0],i=await(0,u.topk)(new u.Tensor("float32",(0,o.softmax)(r.data),r.dims),t),A=i[0].tolist(),l=i[1].tolist().map(((e,t)=>({label:s?s[e]:`LABEL_${e}`,score:A[t]})));a.push(l)}return Array.isArray(e)?a:a[0]}}class D extends g{constructor(e){super(e)}async _call(e,t,{hypothesis_template:n="This is a sound of {}."}={}){const r=!Array.isArray(e);r&&(e=[e]);const s=t.map((e=>n.replace("{}",e))),a=this.tokenizer(s,{padding:!0,truncation:!0}),i=this.processor.feature_extractor.config.sampling_rate,A=await h(e,i),l=[];for(const e of A){const n=await this.processor(e),r=await this.model({...a,...n}),s=(0,o.softmax)(r.logits_per_audio.data);l.push([...s].map(((e,n)=>({score:e,label:t[n]}))))}return r?l[0]:l}}class T extends g{constructor(e){super(e)}async _call(e,t={}){switch(this.model.config.model_type){case"whisper":case"lite-whisper":return this._call_whisper(e,t);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(e,t);case"moonshine":return this._call_moonshine(e,t);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(e,t){t.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),t.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const n=!Array.isArray(e);n&&(e=[e]);const r=this.processor.feature_extractor.config.sampling_rate,s=await h(e,r),a=[];for(const e of s){const t=await this.processor(e),n=(await this.model(t)).logits[0],r=[];for(const e of n)r.push((0,o.max)(e.data)[1]);const s=this.tokenizer.decode(r);a.push({text:s})}return n?a[0]:a}async _call_whisper(e,t){const n=t.return_timestamps??!1,r=t.chunk_length_s??0,s=t.force_full_sequences??!1;let a=t.stride_length_s??null;const i={...t};"word"===n&&(i.return_token_timestamps=!0,i.return_timestamps=!1);const A=!Array.isArray(e);A&&(e=[e]);const l=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,u=this.processor.feature_extractor.config.hop_length,c=this.processor.feature_extractor.config.sampling_rate,d=await h(e,c),f=[];for(const e of d){let t=[];if(r>0){if(null===a)a=r/6;else if(r<=a)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const n=c*r,s=c*a,i=n-2*s;let A=0;for(;;){const r=A+n,a=e.subarray(A,r),o=await this.processor(a),l=0===A,u=r>=e.length;if(t.push({stride:[a.length,l?0:s,u?0:s],input_features:o.input_features,is_last:u}),u)break;A+=i}}else t=[{stride:[e.length,0,0],input_features:(await this.processor(e)).input_features,is_last:!0}];for(const e of t){i.num_frames=Math.floor(e.stride[0]/u);const t=await this.model.generate({inputs:e.input_features,...i});"word"===n?(e.tokens=t.sequences.tolist()[0],e.token_timestamps=t.token_timestamps.tolist()[0].map((e=>(0,o.round)(e,2)))):e.tokens=t[0].tolist(),e.stride=e.stride.map((e=>e/c))}const[A,d]=this.tokenizer._decode_asr(t,{time_precision:l,return_timestamps:n,force_full_sequences:s});f.push({text:A,...d})}return A?f[0]:f}async _call_moonshine(e,t){const n=!Array.isArray(e);n&&(e=[e]);const r=this.processor.feature_extractor.config.sampling_rate,s=await h(e,r),a=[];for(const e of s){const n=await this.processor(e),s=6*Math.floor(e.length/r),i=await this.model.generate({max_new_tokens:s,...t,...n}),A=this.processor.batch_decode(i,{skip_special_tokens:!0})[0];a.push({text:A})}return n?a[0]:a}}class S extends g{constructor(e){super(e)}async _call(e,t={}){const n=Array.isArray(e),r=await d(e),{pixel_values:s}=await this.processor(r),a=[];for(const e of s){e.dims=[1,...e.dims];const n=await this.model.generate({inputs:e,...t}),r=this.tokenizer.batch_decode(n,{skip_special_tokens:!0}).map((e=>({generated_text:e.trim()})));a.push(r)}return n?a:a[0]}}class N extends g{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=await d(e),{pixel_values:r}=await this.processor(n),s=await this.model({pixel_values:r}),a=this.model.config.id2label,i=[];for(const e of s.logits){const n=await(0,u.topk)(new u.Tensor("float32",(0,o.softmax)(e.data),e.dims),t),r=n[0].tolist(),s=n[1].tolist().map(((e,t)=>({label:a?a[e]:`LABEL_${e}`,score:r[t]})));i.push(s)}return Array.isArray(e)?i:i[0]}}class G extends g{constructor(e){super(e),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(e,{threshold:t=.5,mask_threshold:n=.5,overlap_mask_area_threshold:r=.8,label_ids_to_fuse:s=null,target_sizes:a=null,subtask:i=null}={}){if(Array.isArray(e)&&1!==e.length)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const A=await d(e),o=A.map((e=>[e.height,e.width])),l=await this.processor(A),{inputNames:u,outputNames:h}=this.model.sessions.model;if(!u.includes("pixel_values")){if(1!==u.length)throw Error(`Expected a single input name, but got ${u.length} inputs: ${u}.`);const e=u[0];if(e in l)throw Error(`Input name ${e} already exists in the inputs.`);l[e]=l.pixel_values}const f=await this.model(l);let g=null;if(null!==i)g=this.subtasks_mapping[i];else if(this.processor.image_processor)for(const[e,t]of Object.entries(this.subtasks_mapping))if(t in this.processor.image_processor){g=this.processor.image_processor[t].bind(this.processor.image_processor),i=e;break}const p=this.model.config.id2label,m=[];if(i)if("panoptic"===i||"instance"===i){const e=g(f,t,n,r,s,a??o)[0],i=e.segmentation;for(const t of e.segments_info){const e=new Uint8ClampedArray(i.data.length);for(let n=0;n<i.data.length;++n)i.data[n]===t.id&&(e[n]=255);const n=new c.RawImage(e,i.dims[1],i.dims[0],1);m.push({score:t.score,label:p[t.label_id],mask:n})}}else{if("semantic"!==i)throw Error(`Subtask ${i} not supported.`);{const{segmentation:e,labels:t}=g(f,a??o)[0];for(const n of t){const t=new Uint8ClampedArray(e.data.length);for(let r=0;r<e.data.length;++r)e.data[r]===n&&(t[r]=255);const r=new c.RawImage(t,e.dims[1],e.dims[0],1);m.push({score:null,label:p[n],mask:r})}}}else{const e=1e-5,t=f[h[0]];for(let n=0;n<o.length;++n){const r=o[n],s=t[n];s.data.some((t=>t<-1e-5||t>1+e))&&s.sigmoid_();const a=await c.RawImage.fromTensor(s.mul_(255).to("uint8")).resize(r[1],r[0]);m.push({label:null,score:null,mask:a})}}return m}}class F extends G{constructor(e){super(e)}async _call(e,t={}){if(Array.isArray(e)&&1!==e.length)throw Error("Background removal pipeline currently only supports a batch size of 1.");const n=await d(e),r=await super._call(e,t),s=n.map(((e,t)=>{const n=e.clone();return n.putAlpha(r[t].mask),n}));return s}}class P extends g{constructor(e){super(e)}async _call(e,t,{hypothesis_template:n="This is a photo of {}"}={}){const r=Array.isArray(e),s=await d(e),a=t.map((e=>n.replace("{}",e))),i=this.tokenizer(a,{padding:"siglip"!==this.model.config.model_type||"max_length",truncation:!0}),{pixel_values:A}=await this.processor(s),l=await this.model({...i,pixel_values:A}),u="siglip"===this.model.config.model_type?e=>e.sigmoid().data:e=>(0,o.softmax)(e.data),c=[];for(const e of l.logits_per_image){const n=[...u(e)].map(((e,n)=>({score:e,label:t[n]})));n.sort(((e,t)=>t.score-e.score)),c.push(n)}return r?c:c[0]}}class Q extends g{constructor(e){super(e)}async _call(e,{threshold:t=.9,percentage:n=!1}={}){const r=Array.isArray(e);if(r&&1!==e.length)throw Error("Object detection pipeline currently only supports a batch size of 1.");const s=await d(e),a=n?null:s.map((e=>[e.height,e.width])),{pixel_values:i,pixel_mask:A}=await this.processor(s),o=await this.model({pixel_values:i,pixel_mask:A}),l=this.processor.image_processor.post_process_object_detection(o,t,a),u=this.model.config.id2label,c=l.map((e=>e.boxes.map(((t,r)=>({score:e.scores[r],label:u[e.classes[r]],box:f(t,!n)})))));return r?c:c[0]}}class z extends g{constructor(e){super(e)}async _call(e,t,{threshold:n=.1,top_k:r=null,percentage:s=!1}={}){const a=Array.isArray(e),i=await d(e),A=this.tokenizer(t,{padding:!0,truncation:!0}),o=await this.processor(i),l=[];for(let e=0;e<i.length;++e){const a=i[e],u=s?null:[[a.height,a.width]],c=o.pixel_values[e].unsqueeze_(0),d=await this.model({...A,pixel_values:c});let h;if("post_process_grounded_object_detection"in this.processor){const e=this.processor.post_process_grounded_object_detection(d,A.input_ids,{box_threshold:n,text_threshold:n,target_sizes:u})[0];h=e.boxes.map(((t,n)=>({score:e.scores[n],label:e.labels[n],box:f(t,!s)})))}else{const e=this.processor.image_processor.post_process_object_detection(d,n,u,!0)[0];h=e.boxes.map(((n,r)=>({score:e.scores[r],label:t[e.classes[r]],box:f(n,!s)})))}h.sort(((e,t)=>t.score-e.score)),null!==r&&(h=h.slice(0,r)),l.push(h)}return a?l:l[0]}}class O extends g{constructor(e){super(e)}async _call(e,t,n={}){const r=(await d(e))[0],{pixel_values:s}=await this.processor(r),a=`<s_docvqa><s_question>${t}</s_question><s_answer>`,i=this.tokenizer(a,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,A=await this.model.generate({inputs:s,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:i,...n}),o=this.tokenizer.batch_decode(A)[0].match(/<s_answer>(.*?)<\/s_answer>/);let l=null;return o&&o.length>=2&&(l=o[1].trim()),[{answer:l}]}}class R extends g{DEFAULT_VOCODER_ID="Xenova/speecht5_hifigan";constructor(e){super(e),this.vocoder=e.vocoder??null}async _call(e,{speaker_embeddings:t=null}={}){return this.processor?this._call_text_to_spectrogram(e,{speaker_embeddings:t}):this._call_text_to_waveform(e)}async _call_text_to_waveform(e){const t=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:n}=await this.model(t),r=this.model.config.sampling_rate;return new l.RawAudio(n.data,r)}async _call_text_to_spectrogram(e,{speaker_embeddings:t}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await s.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),("string"==typeof t||t instanceof URL)&&(t=new Float32Array(await(await fetch(t)).arrayBuffer())),t instanceof Float32Array)t=new u.Tensor("float32",t,[1,t.length]);else if(!(t instanceof u.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:n}=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:r}=await this.model.generate_speech(n,t,{vocoder:this.vocoder}),a=this.processor.feature_extractor.config.sampling_rate;return new l.RawAudio(r.data,a)}}class L extends g{constructor(e){super(e)}async _call(e){const t=await d(e),n=await this.processor(t),r=await this.model(n),s=[];for(const e of r.reconstruction){const t=e.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");s.push(c.RawImage.fromTensor(t))}return s.length>1?s:s[0]}}class W extends g{constructor(e){super(e)}async _call(e){const t=await d(e),n=await this.processor(t),{predicted_depth:r}=await this.model(n),s=[];for(let e=0;e<t.length;++e){const n=r[e],[a,i]=n.dims.slice(-2),[A,o]=t[e].size,l=(await(0,u.interpolate_4d)(n.view(1,1,a,i),{size:[o,A],mode:"bilinear"})).view(o,A),d=l.min().item(),h=l.max().item(),f=l.sub(d).div_(h-d).mul_(255).to("uint8").unsqueeze(0),g=c.RawImage.fromTensor(f);s.push({predicted_depth:l,depth:g})}return s.length>1?s:s[0]}}const _=Object.freeze({"text-classification":{tokenizer:r.AutoTokenizer,pipeline:p,model:s.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:r.AutoTokenizer,pipeline:m,model:s.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:r.AutoTokenizer,pipeline:b,model:s.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:r.AutoTokenizer,pipeline:C,model:s.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:r.AutoTokenizer,pipeline:w,model:s.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:r.AutoTokenizer,pipeline:k,model:s.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:r.AutoTokenizer,pipeline:I,model:s.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:r.AutoTokenizer,pipeline:y,model:s.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:r.AutoTokenizer,pipeline:v,model:s.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:M,model:s.AutoModelForAudioClassification,processor:a.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:r.AutoTokenizer,pipeline:D,model:s.AutoModel,processor:a.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:r.AutoTokenizer,pipeline:T,model:[s.AutoModelForSpeechSeq2Seq,s.AutoModelForCTC],processor:a.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:r.AutoTokenizer,pipeline:R,model:[s.AutoModelForTextToWaveform,s.AutoModelForTextToSpectrogram],processor:[a.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:r.AutoTokenizer,pipeline:S,model:s.AutoModelForVision2Seq,processor:a.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:N,model:s.AutoModelForImageClassification,processor:a.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:G,model:[s.AutoModelForImageSegmentation,s.AutoModelForSemanticSegmentation,s.AutoModelForUniversalSegmentation],processor:a.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"background-removal":{pipeline:F,model:[s.AutoModelForImageSegmentation,s.AutoModelForSemanticSegmentation,s.AutoModelForUniversalSegmentation],processor:a.AutoProcessor,default:{model:"Xenova/modnet"},type:"image"},"zero-shot-image-classification":{tokenizer:r.AutoTokenizer,pipeline:P,model:s.AutoModel,processor:a.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:Q,model:s.AutoModelForObjectDetection,processor:a.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:r.AutoTokenizer,pipeline:z,model:s.AutoModelForZeroShotObjectDetection,processor:a.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:r.AutoTokenizer,pipeline:O,model:s.AutoModelForDocumentQuestionAnswering,processor:a.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:L,model:s.AutoModelForImageToImage,processor:a.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:W,model:s.AutoModelForDepthEstimation,processor:a.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:r.AutoTokenizer,pipeline:E,model:s.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:a.AutoProcessor,pipeline:B,model:[s.AutoModelForImageFeatureExtraction,s.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),V=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function H(e,t=null,{progress_callback:n=null,config:r=null,cache_dir:s=null,local_files_only:a=!1,revision:i="main",device:o=null,dtype:l=null,subfolder:u="onnx",use_external_data_format:c=null,model_file_name:d=null,session_options:h={}}={}){e=V[e]??e;const f=_[e.split("_",1)[0]];if(!f)throw Error(`Unsupported pipeline: ${e}. Must be one of [${Object.keys(_)}]`);t||(t=f.default.model,console.log(`No model specified. Using default model: "${t}".`));const g={progress_callback:n,config:r,cache_dir:s,local_files_only:a,revision:i,device:o,dtype:l,subfolder:u,use_external_data_format:c,model_file_name:d,session_options:h},p=new Map([["tokenizer",f.tokenizer],["model",f.model],["processor",f.processor]]),m=await async function(e,t,n){const r=Object.create(null),s=[];for(const[a,i]of e.entries()){if(!i)continue;let e;e=Array.isArray(i)?new Promise((async(e,r)=>{let s;for(const a of i){if(null===a)return void e(null);try{return void e(await a.from_pretrained(t,n))}catch(e){if(e.message?.includes("Unsupported model type"))s=e;else{if(!e.message?.includes("Could not locate file"))return void r(e);s=e}}}r(s)})):i.from_pretrained(t,n),r[a]=e,s.push(e)}await Promise.all(s);for(const[e,t]of Object.entries(r))r[e]=await t;return r}(p,t,g);m.task=e,(0,A.dispatchCallback)(n,{status:"ready",task:e,model:t});return new(0,f.pipeline)(m)}},"./src/tokenizers.js":(e,t,n)=>{n.r(t),n.d(t,{AlbertTokenizer:()=>ye,AutoTokenizer:()=>pt,BartTokenizer:()=>Oe,BertTokenizer:()=>xe,BlenderbotSmallTokenizer:()=>ut,BlenderbotTokenizer:()=>lt,BloomTokenizer:()=>_e,CLIPTokenizer:()=>at,CamembertTokenizer:()=>Ge,CodeGenTokenizer:()=>st,CodeLlamaTokenizer:()=>Ue,CohereTokenizer:()=>ft,ConvBertTokenizer:()=>Te,DebertaTokenizer:()=>Be,DebertaV2Tokenizer:()=>Me,DistilBertTokenizer:()=>Ne,ElectraTokenizer:()=>Pe,EsmTokenizer:()=>qe,FalconTokenizer:()=>Ke,GPT2Tokenizer:()=>ze,GPTNeoXTokenizer:()=>Xe,GemmaTokenizer:()=>Je,Grok1Tokenizer:()=>$e,HerbertTokenizer:()=>De,LlamaTokenizer:()=>He,M2M100Tokenizer:()=>nt,MBart50Tokenizer:()=>Le,MBartTokenizer:()=>Re,MPNetTokenizer:()=>Ye,MarianTokenizer:()=>At,MgpstrTokenizer:()=>gt,MobileBertTokenizer:()=>ve,NllbTokenizer:()=>tt,NougatTokenizer:()=>dt,PreTrainedTokenizer:()=>ke,Qwen2Tokenizer:()=>Ze,RoFormerTokenizer:()=>Se,RobertaTokenizer:()=>We,SiglipTokenizer:()=>it,SpeechT5Tokenizer:()=>ct,SqueezeBertTokenizer:()=>Ee,T5Tokenizer:()=>Qe,TokenizerModel:()=>x,VitsTokenizer:()=>ht,Wav2Vec2CTCTokenizer:()=>ot,WhisperTokenizer:()=>rt,XLMRobertaTokenizer:()=>je,XLMTokenizer:()=>Fe,is_chinese_char:()=>m});var r=n("./src/utils/generic.js"),s=n("./src/utils/core.js"),a=n("./src/utils/hub.js"),i=n("./src/utils/maths.js"),A=n("./src/utils/tensor.js"),o=n("./src/utils/data-structures.js"),l=n("./node_modules/@huggingface/jinja/dist/index.js"),u=n("./src/models/whisper/common_whisper.js");async function c(e,t){const n=await Promise.all([(0,a.getModelJSON)(e,"tokenizer.json",!0,t),(0,a.getModelJSON)(e,"tokenizer_config.json",!0,t)]);return null!==t.legacy&&(n[1].legacy=t.legacy),n}function d(e,t=!0){if(void 0!==e.Regex){let t=e.Regex.replace(/\\([#&~])/g,"$1");for(const[e,n]of w)t=t.replaceAll(e,n);return new RegExp(t,"gu")}if(void 0!==e.String){const n=(0,s.escapeRegExp)(e.String);return new RegExp(t?n:`(${n})`,"gu")}return console.warn("Unknown pattern type:",e),null}function h(e){return new Map(Object.entries(e))}function f(e){const t=e.dims;switch(t.length){case 1:return e.tolist();case 2:if(1!==t[0])throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return e.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${t.length}.`)}}function g(e){return e.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function p(e){return e.replace(/\p{M}/gu,"")}function m(e){return e>=19968&&e<=40959||e>=13312&&e<=19903||e>=131072&&e<=173791||e>=173824&&e<=177983||e>=177984&&e<=178207||e>=178208&&e<=183983||e>=63744&&e<=64255||e>=194560&&e<=195103}const b="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",C=new RegExp(`^[${b}]+$`,"gu"),I=".,!?",w=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],[` ?[^(\\s|[${I}])]+`,` ?[^\\s${I}]+`]]);class k{constructor(e){this.content=e.content,this.id=e.id,this.single_word=e.single_word??!1,this.lstrip=e.lstrip??!1,this.rstrip=e.rstrip??!1,this.special=e.special??!1,this.normalized=e.normalized??null}}class x extends r.Callable{constructor(e){super(),this.config=e,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(e,...t){switch(e.type){case"WordPiece":return new y(e);case"Unigram":return new v(e,...t);case"BPE":return new M(e);default:if(e.vocab)return Array.isArray(e.vocab)?new v(e,...t):"object"==typeof e.vocab&&e.continuing_subword_prefix&&e.unk_token?new y(e):new D(e,...t);throw new Error(`Unknown TokenizerModel type: ${e.type}`)}}_call(e){return e=this.encode(e),this.fuse_unk&&(e=function(e,t,n){const r=[];let s=0;for(;s<e.length;)if(r.push(e[s]),(t.get(e[s])??n)===n)for(;++s<e.length&&(t.get(e[s])??n)===n;)t.get(r.at(-1))!==n&&(r[r.length-1]+=e[s]);else++s;return r}(e,this.tokens_to_ids,this.unk_token_id)),e}encode(e){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(e){return e.map((e=>this.tokens_to_ids.get(e)??this.unk_token_id))}convert_ids_to_tokens(e){return e.map((e=>this.vocab[e]??this.unk_token))}}class y extends x{constructor(e){super(e),this.tokens_to_ids=h(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.max_input_chars_per_word=e.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){const t=[];for(const n of e){const e=[...n];if(e.length>this.max_input_chars_per_word){t.push(this.unk_token);continue}let r=!1,s=0;const a=[];for(;s<e.length;){let t=e.length,n=null;for(;s<t;){let r=e.slice(s,t).join("");if(s>0&&(r=this.config.continuing_subword_prefix+r),this.tokens_to_ids.has(r)){n=r;break}--t}if(null===n){r=!0;break}a.push(n),s=t}r?t.push(this.unk_token):t.push(...a)}return t}}class v extends x{constructor(e,t){super(e);const n=e.vocab.length;this.vocab=new Array(n),this.scores=new Array(n);for(let t=0;t<n;++t)[this.vocab[t],this.scores[t]]=e.vocab[t];this.unk_token_id=e.unk_id,this.unk_token=this.vocab[e.unk_id],this.tokens_to_ids=new Map(this.vocab.map(((e,t)=>[e,t]))),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=t.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,i.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new o.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(e){const t=e.chars;let n=0;for(;n<t.length;){let r=!1;const a=t.slice(n).join(""),i=this.trie.commonPrefixSearch(a);for(const t of i){const a=this.tokens_to_ids.get(t),i=this.scores[a],A=(0,s.len)(t);e.insert(n,A,i,a),r||1!==A||(r=!0)}r||e.insert(n,1,this.unk_score,this.unk_token_id),n+=1}}tokenize(e){const t=new o.TokenLattice(e,this.bos_token_id,this.eos_token_id);return this.populateNodes(t),t.tokens()}encode(e){const t=[];for(const n of e){const e=this.tokenize(n);t.push(...e)}return t}}const E=(()=>{const e=[...Array.from({length:"~".charCodeAt(0)-"!".charCodeAt(0)+1},((e,t)=>t+"!".charCodeAt(0))),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},((e,t)=>t+"".charCodeAt(0))),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},((e,t)=>t+"".charCodeAt(0)))],t=e.slice();let n=0;for(let r=0;r<256;++r)e.includes(r)||(e.push(r),t.push(256+n),n+=1);const r=t.map((e=>String.fromCharCode(e)));return Object.fromEntries(e.map(((e,t)=>[e,r[t]])))})(),B=(0,s.reverseDictionary)(E);class M extends x{constructor(e){super(e),this.tokens_to_ids=h(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e;const t=Array.isArray(e.merges[0]);this.merges=t?e.merges:e.merges.map((e=>e.split(" ",2))),this.bpe_ranks=new Map(this.merges.map(((e,t)=>[JSON.stringify(e),t]))),this.end_of_word_suffix=e.end_of_word_suffix,this.continuing_subword_suffix=e.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.max_length_to_cache=256,this.cache_capacity=1e4,this.cache=new o.LRUCache(this.cache_capacity)}clear_cache(){this.cache.clear()}bpe(e){if(0===e.length)return[];const t=this.cache.get(e);if(void 0!==t)return t;const n=Array.from(e);this.end_of_word_suffix&&(n[n.length-1]+=this.end_of_word_suffix);let r=[];if(n.length>1){const e=new o.PriorityQueue(((e,t)=>e.score<t.score));let t={token:n[0],bias:0,prev:null,next:null},s=t;for(let t=1;t<n.length;++t){const r={bias:t/n.length,token:n[t],prev:s,next:null};s.next=r,this._add_node(e,s),s=r}for(;!e.isEmpty();){const n=e.pop();if(n.deleted||!n.next||n.next.deleted)continue;if(n.deleted=!0,n.next.deleted=!0,n.prev){const e={...n.prev};n.prev.deleted=!0,n.prev=e,e.prev?e.prev.next=e:t=e}const r={token:n.token+n.next.token,bias:n.bias,prev:n.prev,next:n.next.next};r.prev?(r.prev.next=r,this._add_node(e,r.prev)):t=r,r.next&&(r.next.prev=r,this._add_node(e,r))}for(let e=t;null!==e;e=e.next)r.push(e.token)}else r=n;if(this.continuing_subword_suffix)for(let e=0;e<r.length-1;++e)r[e]+=this.continuing_subword_suffix;return e.length<this.max_length_to_cache&&this.cache.put(e,r),r}_add_node(e,t){const n=this.bpe_ranks.get(JSON.stringify([t.token,t.next.token]));void 0!==n&&(t.score=n+t.bias,e.push(t))}encode(e){const t=[];for(const n of e){if(this.ignore_merges&&this.tokens_to_ids.has(n)){t.push(n);continue}const e=this.bpe(n);for(const n of e)if(this.tokens_to_ids.has(n))t.push(n);else if(this.byte_fallback){const e=Array.from(this.text_encoder.encode(n)).map((e=>`<0x${e.toString(16).toUpperCase().padStart(2,"0")}>`));e.every((e=>this.tokens_to_ids.has(e)))?t.push(...e):t.push(this.unk_token)}else t.push(this.unk_token)}return t}}class D extends x{constructor(e,t){super(e),this.tokens_to_ids=h(t.target_lang?e.vocab[t.target_lang]:e.vocab),this.bos_token=t.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=t.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=t.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=t.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){return e}}class T extends r.Callable{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"BertNormalizer":return new _(e);case"Precompiled":return new fe(e);case"Sequence":return new W(e);case"Replace":return new S(e);case"NFC":return new G(e);case"NFD":return new F(e);case"NFKC":return new P(e);case"NFKD":return new Q(e);case"Strip":return new z(e);case"StripAccents":return new O(e);case"Lowercase":return new R(e);case"Prepend":return new L(e);default:throw new Error(`Unknown Normalizer type: ${e.type}`)}}normalize(e){throw Error("normalize should be implemented in subclass.")}_call(e){return this.normalize(e)}}class S extends T{normalize(e){const t=d(this.config.pattern);return null===t?e:e.replaceAll(t,this.config.content)}}class N extends T{form=void 0;normalize(e){return e=e.normalize(this.form)}}class G extends N{form="NFC"}class F extends N{form="NFD"}class P extends N{form="NFKC"}class Q extends N{form="NFKD"}class z extends T{normalize(e){return this.config.strip_left&&this.config.strip_right?e=e.trim():(this.config.strip_left&&(e=e.trimStart()),this.config.strip_right&&(e=e.trimEnd())),e}}class O extends T{normalize(e){return e=p(e)}}class R extends T{normalize(e){return e=e.toLowerCase()}}class L extends T{normalize(e){return e=this.config.prepend+e}}class W extends T{constructor(e){super(e),this.normalizers=e.normalizers.map((e=>T.fromConfig(e)))}normalize(e){return this.normalizers.reduce(((e,t)=>t.normalize(e)),e)}}class _ extends T{_tokenize_chinese_chars(e){const t=[];for(let n=0;n<e.length;++n){const r=e[n];m(r.charCodeAt(0))?(t.push(" "),t.push(r),t.push(" ")):t.push(r)}return t.join("")}stripAccents(e){return e.normalize("NFD").replace(/\p{Mn}/gu,"")}_is_control(e){switch(e){case"\t":case"\n":case"\r":return!1;default:return/^\p{Cc}|\p{Cf}|\p{Co}|\p{Cs}$/u.test(e)}}_clean_text(e){const t=[];for(const n of e){const e=n.charCodeAt(0);0===e||65533===e||this._is_control(n)||(/^\s$/.test(n)?t.push(" "):t.push(n))}return t.join("")}normalize(e){return this.config.clean_text&&(e=this._clean_text(e)),this.config.handle_chinese_chars&&(e=this._tokenize_chinese_chars(e)),this.config.lowercase?(e=e.toLowerCase(),!1!==this.config.strip_accents&&(e=this.stripAccents(e))):this.config.strip_accents&&(e=this.stripAccents(e)),e}}class V extends r.Callable{static fromConfig(e){if(null===e)return null;switch(e.type){case"BertPreTokenizer":return new H(e);case"Sequence":return new ge(e);case"Whitespace":return new pe(e);case"WhitespaceSplit":return new me(e);case"Metaspace":return new de(e);case"ByteLevel":return new U(e);case"Split":return new j(e);case"Punctuation":return new Y(e);case"Digits":return new K(e);case"Replace":return new be(e);default:throw new Error(`Unknown PreTokenizer type: ${e.type}`)}}pre_tokenize_text(e,t){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(e,t){return(Array.isArray(e)?e.map((e=>this.pre_tokenize_text(e,t))):this.pre_tokenize_text(e,t)).flat()}_call(e,t){return this.pre_tokenize(e,t)}}class H extends V{constructor(e){super(),this.pattern=new RegExp(`[^\\s${b}]+|[${b}]`,"gu")}pre_tokenize_text(e,t){return e.trim().match(this.pattern)||[]}}class U extends V{constructor(e){super(),this.config=e,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=/'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu,this.byte_encoder=E,this.text_encoder=new TextEncoder}pre_tokenize_text(e,t){this.add_prefix_space&&!e.startsWith(" ")&&(e=" "+e);return(this.use_regex?e.match(this.pattern)||[]:[e]).map((e=>Array.from(this.text_encoder.encode(e),(e=>this.byte_encoder[e])).join("")))}}class j extends V{constructor(e){super(),this.config=e,this.pattern=d(this.config.pattern,this.config.invert)}pre_tokenize_text(e,t){return null===this.pattern?[]:this.config.invert?e.match(this.pattern)||[]:"removed"===this.config.behavior?.toLowerCase()?e.split(this.pattern).filter((e=>e)):function(e,t){const n=[];let r=0;for(const s of e.matchAll(t)){const t=s[0];r<s.index&&n.push(e.slice(r,s.index)),t.length>0&&n.push(t),r=s.index+t.length}return r<e.length&&n.push(e.slice(r)),n}(e,this.pattern)}}class Y extends V{constructor(e){super(),this.config=e,this.pattern=new RegExp(`[^${b}]+|[${b}]+`,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class K extends V{constructor(e){super(),this.config=e;const t="[^\\d]+|\\d"+(this.config.individual_digits?"":"+");this.pattern=new RegExp(t,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class X extends r.Callable{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"TemplateProcessing":return new J(e);case"ByteLevel":return new $(e);case"RobertaProcessing":return new Z(e);case"BertProcessing":return new q(e);case"Sequence":return new ee(e);default:throw new Error(`Unknown PostProcessor type: ${e.type}`)}}post_process(e,...t){throw Error("post_process should be implemented in subclass.")}_call(e,...t){return this.post_process(e,...t)}}class q extends X{constructor(e){super(e),this.cls=e.cls[0],this.sep=e.sep[0]}post_process(e,t=null,{add_special_tokens:n=!0}={}){n&&(e=(0,s.mergeArrays)([this.cls],e,[this.sep]));let r=new Array(e.length).fill(0);if(null!==t){const a=n&&this instanceof Z?[this.sep]:[],i=n?[this.sep]:[];e=(0,s.mergeArrays)(e,a,t,i),r=(0,s.mergeArrays)(r,new Array(t.length+a.length+i.length).fill(1))}return{tokens:e,token_type_ids:r}}}class Z extends q{}class J extends X{constructor(e){super(e),this.single=e.single,this.pair=e.pair}post_process(e,t=null,{add_special_tokens:n=!0}={}){const r=null===t?this.single:this.pair;let a=[],i=[];for(const A of r)"SpecialToken"in A?n&&(a.push(A.SpecialToken.id),i.push(A.SpecialToken.type_id)):"Sequence"in A&&("A"===A.Sequence.id?(a=(0,s.mergeArrays)(a,e),i=(0,s.mergeArrays)(i,new Array(e.length).fill(A.Sequence.type_id))):"B"===A.Sequence.id&&(a=(0,s.mergeArrays)(a,t),i=(0,s.mergeArrays)(i,new Array(t.length).fill(A.Sequence.type_id))));return{tokens:a,token_type_ids:i}}}class $ extends X{post_process(e,t=null){return t&&(e=(0,s.mergeArrays)(e,t)),{tokens:e}}}class ee extends X{constructor(e){super(e),this.processors=e.processors.map((e=>X.fromConfig(e)))}post_process(e,t=null,n={}){let r;for(const s of this.processors)if(s instanceof $){if(e=s.post_process(e).tokens,t){t=s.post_process(t).tokens}}else{const a=s.post_process(e,t,n);e=a.tokens,r=a.token_type_ids}return{tokens:e,token_type_ids:r}}}class te extends r.Callable{constructor(e){super(),this.config=e,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=e.trim_offsets}static fromConfig(e){if(null===e)return null;switch(e.type){case"WordPiece":return new ie(e);case"Metaspace":return new he(e);case"ByteLevel":return new Ae(e);case"Replace":return new ne(e);case"ByteFallback":return new re(e);case"Fuse":return new se(e);case"Strip":return new ae(e);case"Sequence":return new le(e);case"CTC":return new oe(e);case"BPEDecoder":return new ue(e);default:throw new Error(`Unknown Decoder type: ${e.type}`)}}_call(e){return this.decode(e)}decode(e){return this.decode_chain(e).join("")}decode_chain(e){throw Error("`decode_chain` should be implemented in subclass.")}}class ne extends te{decode_chain(e){const t=d(this.config.pattern);return null===t?e:e.map((e=>e.replaceAll(t,this.config.content)))}}class re extends te{constructor(e){super(e),this.text_decoder=new TextDecoder}decode_chain(e){const t=[];let n=[];for(const r of e){let e=null;if(6===r.length&&r.startsWith("<0x")&&r.endsWith(">")){const t=parseInt(r.slice(3,5),16);isNaN(t)||(e=t)}if(null!==e)n.push(e);else{if(n.length>0){const e=this.text_decoder.decode(Uint8Array.from(n));t.push(e),n=[]}t.push(r)}}if(n.length>0){const e=this.text_decoder.decode(Uint8Array.from(n));t.push(e),n=[]}return t}}class se extends te{decode_chain(e){return[e.join("")]}}class ae extends te{constructor(e){super(e),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(e){return e.map((e=>{let t=0;for(let n=0;n<this.start&&e[n]===this.content;++n)t=n+1;let n=e.length;for(let t=0;t<this.stop;++t){const r=e.length-t-1;if(e[r]!==this.content)break;n=r}return e.slice(t,n)}))}}class ie extends te{constructor(e){super(e),this.cleanup=e.cleanup}decode_chain(e){return e.map(((e,t)=>(0!==t&&(e=e.startsWith(this.config.prefix)?e.replace(this.config.prefix,""):" "+e),this.cleanup&&(e=g(e)),e)))}}class Ae extends te{constructor(e){super(e),this.byte_decoder=B,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(e){const t=e.join(""),n=new Uint8Array([...t].map((e=>this.byte_decoder[e])));return this.text_decoder.decode(n)}decode_chain(e){const t=[];let n=[];for(const r of e)void 0!==this.added_tokens.find((e=>e.content===r))?(n.length>0&&(t.push(this.convert_tokens_to_string(n)),n=[]),t.push(r)):n.push(r);return n.length>0&&t.push(this.convert_tokens_to_string(n)),t}}class oe extends te{constructor(e){super(e),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(e){if(0===e.length)return"";const t=[e[0]];for(let n=1;n<e.length;++n)e[n]!==t.at(-1)&&t.push(e[n]);let n=t.filter((e=>e!==this.pad_token)).join("");return this.cleanup&&(n=g(n).replaceAll(this.word_delimiter_token," ").trim()),n}decode_chain(e){return[this.convert_tokens_to_string(e)]}}class le extends te{constructor(e){super(e),this.decoders=e.decoders.map((e=>te.fromConfig(e)))}decode_chain(e){return this.decoders.reduce(((e,t)=>t.decode_chain(e)),e)}}class ue extends te{constructor(e){super(e),this.suffix=this.config.suffix}decode_chain(e){return e.map(((t,n)=>t.replaceAll(this.suffix,n===e.length-1?"":" ")))}}class ce extends te{decode_chain(e){let t="";for(let n=1;n<e.length;n+=2)t+=e[n];return[t]}}class de extends V{constructor(e){super(),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement,this.strRep=e.str_rep||this.replacement,this.prepend_scheme=e.prepend_scheme??"always"}pre_tokenize_text(e,{section_index:t}={}){let n=e.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!n.startsWith(this.replacement)&&("always"===this.prepend_scheme||"first"===this.prepend_scheme&&0===t)&&(n=this.strRep+n),[n]}}class he extends te{constructor(e){super(e),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement}decode_chain(e){const t=[];for(let n=0;n<e.length;++n){let r=e[n].replaceAll(this.replacement," ");this.addPrefixSpace&&0==n&&r.startsWith(" ")&&(r=r.substring(1)),t.push(r)}return t}}class fe extends T{constructor(e){super(e),this.charsmap=e.precompiled_charsmap}normalize(e){if((e=(e=e.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,"")).replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," ")).includes("")){const t=e.split("");e=t.map((e=>e.normalize("NFKC"))).join("")}else e=e.normalize("NFKC");return e}}class ge extends V{constructor(e){super(),this.tokenizers=e.pretokenizers.map((e=>V.fromConfig(e)))}pre_tokenize_text(e,t){return this.tokenizers.reduce(((e,n)=>n.pre_tokenize(e,t)),[e])}}class pe extends V{constructor(e){super()}pre_tokenize_text(e,t){return e.match(/\w+|[^\w\s]+/g)||[]}}class me extends V{constructor(e){super()}pre_tokenize_text(e,t){return function(e){return e.match(/\S+/g)||[]}(e)}}class be extends V{constructor(e){super(),this.config=e,this.pattern=d(this.config.pattern),this.content=this.config.content}pre_tokenize_text(e,t){return null===this.pattern?[e]:[e.replaceAll(this.pattern,this.config.content)]}}const Ce=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function Ie(e,t,n,r){for(const a of Object.keys(e)){const i=t-e[a].length,A=n(a),o=new Array(i).fill(A);e[a]="right"===r?(0,s.mergeArrays)(e[a],o):(0,s.mergeArrays)(o,e[a])}}function we(e,t){for(const n of Object.keys(e))e[n].length=t}class ke extends r.Callable{return_token_type_ids=!1;padding_side="right";constructor(e,t){super(),this._tokenizer_config=t,this.normalizer=T.fromConfig(e.normalizer),this.pre_tokenizer=V.fromConfig(e.pre_tokenizer),this.model=x.fromConfig(e.model,t),this.post_processor=X.fromConfig(e.post_processor),this.decoder=te.fromConfig(e.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const t of e.added_tokens){const e=new k(t);this.added_tokens.push(e),this.model.tokens_to_ids.set(e.content,e.id),this.model.vocab[e.id]=e.content,e.special&&(this.special_tokens.push(e.content),this.all_special_ids.push(e.id))}if(this.additional_special_tokens=t.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_splitter=new o.DictionarySplitter(this.added_tokens.map((e=>e.content))),this.added_tokens_map=new Map(this.added_tokens.map((e=>[e.content,e]))),this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.bos_token=this.getToken("bos_token"),this.bos_token_id=this.model.tokens_to_ids.get(this.bos_token),this.eos_token=this.getToken("eos_token"),this.eos_token_id=this.model.tokens_to_ids.get(this.eos_token),this.model_max_length=t.model_max_length,this.remove_space=t.remove_space,this.clean_up_tokenization_spaces=t.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=t.do_lowercase_and_remove_accent??!1,t.padding_side&&(this.padding_side=t.padding_side),this.legacy=!1,this.chat_template=t.chat_template??null,Array.isArray(this.chat_template)){const e=Object.create(null);for(const{name:t,template:n}of this.chat_template){if("string"!=typeof t||"string"!=typeof n)throw new Error('Chat template must be a list of objects with "name" and "template" properties');e[t]=n}this.chat_template=e}this._compiled_template_cache=new Map}getToken(...e){for(const t of e){const e=this._tokenizer_config[t];if(e){if("object"==typeof e){if("AddedToken"===e.__type)return e.content;throw Error(`Unknown token: ${e}`)}return e}}return null}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:a="main",legacy:i=null}={}){return new this(...await c(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:a,legacy:i}))}_call(e,{text_pair:t=null,add_special_tokens:n=!0,padding:r=!1,truncation:s=null,max_length:a=null,return_tensor:o=!0,return_token_type_ids:l=null}={}){const u=Array.isArray(e);let c;if(u){if(0===e.length)throw Error("text array must be non-empty");if(null!==t){if(!Array.isArray(t))throw Error("text_pair must also be an array");if(e.length!==t.length)throw Error("text and text_pair must have the same length");c=e.map(((e,r)=>this._encode_plus(e,{text_pair:t[r],add_special_tokens:n,return_token_type_ids:l})))}else c=e.map((e=>this._encode_plus(e,{add_special_tokens:n,return_token_type_ids:l})))}else{if(null==e)throw Error("text may not be null or undefined");if(Array.isArray(t))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");c=[this._encode_plus(e,{text_pair:t,add_special_tokens:n,return_token_type_ids:l})]}if(null===a?a=this.model_max_length:null===s&&(!0===r?(console.warn("`max_length` is ignored when `padding: true` and there is no truncation strategy. To pad to max length, use `padding: 'max_length'`."),a=this.model_max_length):!1===r&&(console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation: true` to explicitly truncate examples to max length."),s=!0)),!0===r&&(a=Math.min((0,i.max)(c.map((e=>e.input_ids.length)))[0],a??1/0)),a=Math.min(a,this.model_max_length??1/0),r||s)for(let e=0;e<c.length;++e)c[e].input_ids.length!==a&&(c[e].input_ids.length>a?s&&we(c[e],a):r&&Ie(c[e],a,(e=>"input_ids"===e?this.pad_token_id:0),this.padding_side));const d={};if(o){if((!r||!s)&&c.some((e=>{for(const t of Object.keys(e))if(e[t].length!==c[0][t]?.length)return!0;return!1})))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const e=[c.length,c[0].input_ids.length];for(const t of Object.keys(c[0]))d[t]=new A.Tensor("int64",BigInt64Array.from(c.flatMap((e=>e[t])).map(BigInt)),e)}else{for(const e of Object.keys(c[0]))d[e]=c.map((t=>t[e]));if(!u)for(const e of Object.keys(d))d[e]=d[e][0]}return d}_encode_text(e){if(null===e)return null;const t=this.added_tokens_splitter.split(e);for(let e=0;e<t.length;++e){const n=this.added_tokens_map.get(t[e]);n&&(n.lstrip&&e>0&&(t[e-1]=t[e-1].trimEnd()),n.rstrip&&e<t.length-1&&(t[e+1]=t[e+1].trimStart()))}const n=t.flatMap(((e,t)=>{if(0===e.length)return[];if(this.added_tokens_map.has(e))return[e];if(!0===this.remove_space&&(e=e.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(e=function(e){return p(e.toLowerCase())}(e)),null!==this.normalizer&&(e=this.normalizer(e)),0===e.length)return[];const n=null!==this.pre_tokenizer?this.pre_tokenizer(e,{section_index:t}):[e];return this.model(n)}));return n}_encode_plus(e,{text_pair:t=null,add_special_tokens:n=!0,return_token_type_ids:r=null}={}){const{tokens:s,token_type_ids:a}=this._tokenize_helper(e,{pair:t,add_special_tokens:n}),i=this.model.convert_tokens_to_ids(s),A={input_ids:i,attention_mask:new Array(i.length).fill(1)};return(r??this.return_token_type_ids)&&a&&(A.token_type_ids=a),A}_tokenize_helper(e,{pair:t=null,add_special_tokens:n=!1}={}){const r=this._encode_text(e),a=this._encode_text(t);return this.post_processor?this.post_processor(r,a,{add_special_tokens:n}):{tokens:(0,s.mergeArrays)(r??[],a??[])}}tokenize(e,{pair:t=null,add_special_tokens:n=!1}={}){return this._tokenize_helper(e,{pair:t,add_special_tokens:n}).tokens}encode(e,{text_pair:t=null,add_special_tokens:n=!0,return_token_type_ids:r=null}={}){return this._encode_plus(e,{text_pair:t,add_special_tokens:n,return_token_type_ids:r}).input_ids}batch_decode(e,t={}){return e instanceof A.Tensor&&(e=e.tolist()),e.map((e=>this.decode(e,t)))}decode(e,t={}){if(e instanceof A.Tensor&&(e=f(e)),!Array.isArray(e)||0===e.length||!(0,s.isIntegralNumber)(e[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(e,t)}decode_single(e,{skip_special_tokens:t=!1,clean_up_tokenization_spaces:n=null}){let r=this.model.convert_ids_to_tokens(e);t&&(r=r.filter((e=>!this.special_tokens.includes(e))));let s=this.decoder?this.decoder(r):r.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(s=s.replaceAll(this.decoder.end_of_word_suffix," "),t&&(s=s.trim())),(n??this.clean_up_tokenization_spaces)&&(s=g(s)),s}get_chat_template({chat_template:e=null,tools:t=null}={}){if(this.chat_template&&"object"==typeof this.chat_template){const n=this.chat_template;if(null!==e&&Object.hasOwn(n,e))e=n[e];else if(null===e)if(null!==t&&"tool_use"in n)e=n.tool_use;else{if(!("default"in n))throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(n).sort()}.`);e=n.default}}else if(null===e){if(!this.chat_template)throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");e=this.chat_template}return e}apply_chat_template(e,{tools:t=null,documents:n=null,chat_template:r=null,add_generation_prompt:s=!1,tokenize:a=!0,padding:i=!1,truncation:A=!1,max_length:o=null,return_tensor:u=!0,return_dict:c=!1,tokenizer_kwargs:d={},...h}={}){if("string"!=typeof(r=this.get_chat_template({chat_template:r,tools:t})))throw Error("chat_template must be a string, but got "+typeof r);let f=this._compiled_template_cache.get(r);void 0===f&&(f=new l.Template(r),this._compiled_template_cache.set(r,f));const g=Object.create(null);for(const e of Ce){const t=this.getToken(e);t&&(g[e]=t)}const p=f.render({messages:e,add_generation_prompt:s,tools:t,documents:n,...g,...h});if(a){const e=this._call(p,{add_special_tokens:!1,padding:i,truncation:A,max_length:o,return_tensor:u,...d});return c?e:e.input_ids}return p}}class xe extends ke{return_token_type_ids=!0}class ye extends ke{return_token_type_ids=!0}class ve extends ke{return_token_type_ids=!0}class Ee extends ke{return_token_type_ids=!0}class Be extends ke{return_token_type_ids=!0}class Me extends ke{return_token_type_ids=!0}class De extends ke{return_token_type_ids=!0}class Te extends ke{return_token_type_ids=!0}class Se extends ke{return_token_type_ids=!0}class Ne extends ke{}class Ge extends ke{}class Fe extends ke{return_token_type_ids=!0;constructor(e,t){super(e,t),console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class Pe extends ke{return_token_type_ids=!0}class Qe extends ke{}class ze extends ke{}class Oe extends ke{}class Re extends ke{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))),this.lang_to_token=e=>e}_build_translation_inputs(e,t,n){return et(this,e,t,n)}}class Le extends Re{}class We extends ke{}class _e extends ke{}const Ve="";class He extends ke{padding_side="left";constructor(e,t){super(e,t),this.legacy=t.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new de({replacement:Ve,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(e){if(null===e)return null;if(this.legacy||0===e.length)return super._encode_text(e);let t=super._encode_text(Ve+e.replaceAll(Ve," "));return t.length>1&&t[0]===Ve&&this.special_tokens.includes(t[1])&&(t=t.slice(1)),t}}class Ue extends ke{}class je extends ke{}class Ye extends ke{}class Ke extends ke{}class Xe extends ke{}class qe extends ke{}class Ze extends ke{}class Je extends ke{}class $e extends ke{}function et(e,t,n,r){if(!("language_codes"in e)||!Array.isArray(e.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in e&&e.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in e)||"function"!=typeof e.lang_to_token)throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const s=r.src_lang,a=r.tgt_lang;if(!e.language_codes.includes(a))throw new Error(`Target language code "${a}" is not valid. Must be one of: {${e.language_codes.join(", ")}}`);if(void 0!==s){if(!e.language_codes.includes(s))throw new Error(`Source language code "${s}" is not valid. Must be one of: {${e.language_codes.join(", ")}}`);for(const t of e.post_processor.config.single)if("SpecialToken"in t&&e.languageRegex.test(t.SpecialToken.id)){t.SpecialToken.id=e.lang_to_token(s);break}}return r.forced_bos_token_id=e.model.convert_tokens_to_ids([e.lang_to_token(a)])[0],e._call(t,n)}class tt extends ke{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))),this.lang_to_token=e=>e}_build_translation_inputs(e,t,n){return et(this,e,t,n)}}class nt extends ke{constructor(e,t){super(e,t),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))).map((e=>e.slice(2,-2))),this.lang_to_token=e=>`__${e}__`}_build_translation_inputs(e,t,n){return et(this,e,t,n)}}class rt extends ke{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(e,{return_timestamps:t=!1,return_language:n=!1,time_precision:r=null,force_full_sequences:s=!0}={}){if(null===r)throw Error("Must specify time_precision");let a=null;const A="word"===t;function o(){return{language:a,timestamp:[null,null],text:""}}const l=[];let c=o(),d=0;const h=this.timestamp_begin,f=h+1500;let g=[],p=[],m=!1,b=null;const I=new Set(this.all_special_ids);for(const n of e){const e=n.tokens,s=A?n.token_timestamps:null;let w=null,k=h;if("stride"in n){const[t,s,a]=n.stride;if(d-=s,b=t-a,s&&(k=s/r+h),a)for(let t=e.length-1;t>=0;--t){const n=Number(e[t]);if(n>=h){if(null!==w&&(n-h)*r<b)break;w=n}}}let x=[],y=[];for(let n=0;n<e.length;++n){const b=Number(e[n]);if(I.has(b)){const e=this.decode([b]),n=u.WHISPER_LANGUAGE_MAPPING.get(e.slice(2,-2));if(void 0!==n){if(null!==a&&n!==a&&!t){g.push(x);const e=this.findLongestCommonSequence(g)[0],t=this.decode(e);c.text=t,l.push(c),g=[],x=[],c=o()}a=c.language=n}}else if(b>=h&&b<=f){const e=(b-h)*r+d,t=(0,i.round)(e,2);if(null!==w&&b>=w)m=!0;else if(m||g.length>0&&b<k)m=!1;else if(null===c.timestamp[0])c.timestamp[0]=t;else if(t===c.timestamp[0]);else{c.timestamp[1]=t,g.push(x),A&&p.push(y);const[e,n]=this.findLongestCommonSequence(g,p),r=this.decode(e);c.text=r,A&&(c.words=this.collateWordTimestamps(e,n,a)),l.push(c),g=[],x=[],p=[],y=[],c=o()}}else if(x.push(b),A){let e,t=(0,i.round)(s[n]+d,2);if(n+1<s.length){e=(0,i.round)(s[n+1]+d,2);const a=this.decode([b]);C.test(a)&&(e=(0,i.round)(Math.min(t+r,e),2))}else e=null;y.push([t,e])}}if("stride"in n){const[e,t,r]=n.stride;d+=e-r}x.length>0?(g.push(x),A&&p.push(y)):g.every((e=>0===e.length))&&(c=o(),g=[],x=[],p=[],y=[])}if(g.length>0){if(s&&t)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[e,n]=this.findLongestCommonSequence(g,p),r=this.decode(e);c.text=r,A&&(c.words=this.collateWordTimestamps(e,n,a)),l.push(c)}let w=Object.create(null);const k=l.map((e=>e.text)).join("");if(t||n){for(let e=0;e<l.length;++e){const r=l[e];t||delete r.timestamp,n||delete r.language}if(A){const e=[];for(const t of l)for(const n of t.words)e.push(n);w={chunks:e}}else w={chunks:l}}return[k,w]}findLongestCommonSequence(e,t=null){let n=e[0],r=n.length,s=[];const a=Array.isArray(t)&&t.length>0;let i=a?[]:null,A=a?t[0]:null;for(let o=1;o<e.length;++o){const l=e[o];let u=0,c=[r,r,0,0];const d=l.length;for(let e=1;e<r+d;++e){const s=Math.max(0,r-e),i=Math.min(r,r+d-e),h=n.slice(s,i),f=Math.max(0,e-r),g=Math.min(d,e),p=l.slice(f,g);if(h.length!==p.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let m;m=a?h.filter(((e,n)=>e===p[n]&&A[s+n]<=t[o][f+n])).length:h.filter(((e,t)=>e===p[t])).length;const b=m/e+e/1e4;m>1&&b>u&&(u=b,c=[s,i,f,g])}const[h,f,g,p]=c,m=Math.floor((f+h)/2),b=Math.floor((p+g)/2);s.push(...n.slice(0,m)),n=l.slice(b),r=n.length,a&&(i.push(...A.slice(0,m)),A=t[o].slice(b))}return s.push(...n),a?(i.push(...A),[s,i]):[s,[]]}collateWordTimestamps(e,t,n){const[r,s,a]=this.combineTokensIntoWords(e,n),i=[];for(let e=0;e<r.length;++e){const n=a[e];i.push({text:r[e],timestamp:[t[n.at(0)][0],t[n.at(-1)][1]]})}return i}combineTokensIntoWords(e,t,n="\"'([{-",r="\"'.,!?:)]}"){let s,a,i;return["chinese","japanese","thai","lao","myanmar"].includes(t=t??"english")?[s,a,i]=this.splitTokensOnUnicode(e):[s,a,i]=this.splitTokensOnSpaces(e),this.mergePunctuations(s,a,i,n,r)}decode(e,t){let n;return t?.decode_with_timestamps?(e instanceof A.Tensor&&(e=f(e)),n=this.decodeWithTimestamps(e,t)):n=super.decode(e,t),n}decodeWithTimestamps(e,t){const n=t?.time_precision??.02,r=Array.from(this.all_special_ids).at(-1)+1;let s=[[]];for(let t of e)if(t=Number(t),t>=r){const e=((t-r)*n).toFixed(2);s.push(`<|${e}|>`),s.push([])}else s[s.length-1].push(t);return s=s.map((e=>"string"==typeof e?e:super.decode(e,t))),s.join("")}splitTokensOnUnicode(e){const t=this.decode(e,{decode_with_timestamps:!0}),n=[],r=[],s=[];let a=[],i=[],A=0;for(let o=0;o<e.length;++o){const l=e[o];a.push(l),i.push(o);const u=this.decode(a,{decode_with_timestamps:!0});u.includes("")&&""!==t[A+u.indexOf("")]||(n.push(u),r.push(a),s.push(i),a=[],i=[],A+=u.length)}return[n,r,s]}splitTokensOnSpaces(e){const[t,n,r]=this.splitTokensOnUnicode(e),s=[],a=[],i=[],A=new RegExp(`^[${b}]$`,"gu");for(let e=0;e<t.length;++e){const o=t[e],l=n[e],u=r[e],c=l[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),d=o.startsWith(" "),h=o.trim(),f=A.test(h);if(c||d||f||0===s.length)s.push(o),a.push(l),i.push(u);else{const e=s.length-1;s[e]+=o,a[e].push(...l),i[e].push(...u)}}return[s,a,i]}mergePunctuations(e,t,n,r,a){const i=structuredClone(e),A=structuredClone(t),o=structuredClone(n);let l=i.length-2,u=i.length-1;for(;l>=0;)i[l].startsWith(" ")&&r.includes(i[l].trim())?(i[u]=i[l]+i[u],A[u]=(0,s.mergeArrays)(A[l],A[u]),o[u]=(0,s.mergeArrays)(o[l],o[u]),i[l]="",A[l]=[],o[l]=[]):u=l,--l;for(l=0,u=1;u<i.length;)!i[l].endsWith(" ")&&a.includes(i[u])?(i[l]+=i[u],A[l]=(0,s.mergeArrays)(A[l],A[u]),o[l]=(0,s.mergeArrays)(o[l],o[u]),i[u]="",A[u]=[],o[u]=[]):l=u,++u;return[i.filter((e=>e)),A.filter((e=>e.length>0)),o.filter((e=>e.length>0))]}}class st extends ke{}class at extends ke{}class it extends ke{}class At extends ke{constructor(e,t){super(e,t),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter((e=>this.languageRegex.test(e))),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(e){if(null===e)return null;const[t,...n]=e.trim().split(this.languageRegex);if(0===n.length)return super._encode_text(t);if(2===n.length){const[e,t]=n;return this.supported_language_codes.includes(e)||console.warn(`Unsupported language code "${e}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,s.mergeArrays)([e],super._encode_text(t))}}}class ot extends ke{}class lt extends ke{}class ut extends ke{}class ct extends ke{}class dt extends ke{}class ht extends ke{constructor(e,t){super(e,t),this.decoder=new ce({})}}class ft extends ke{}class gt extends ke{}class pt{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:Qe,DistilBertTokenizer:Ne,CamembertTokenizer:Ge,DebertaTokenizer:Be,DebertaV2Tokenizer:Me,BertTokenizer:xe,HerbertTokenizer:De,ConvBertTokenizer:Te,RoFormerTokenizer:Se,XLMTokenizer:Fe,ElectraTokenizer:Pe,MobileBertTokenizer:ve,SqueezeBertTokenizer:Ee,AlbertTokenizer:ye,GPT2Tokenizer:ze,BartTokenizer:Oe,MBartTokenizer:Re,MBart50Tokenizer:Le,RobertaTokenizer:We,WhisperTokenizer:rt,CodeGenTokenizer:st,CLIPTokenizer:at,SiglipTokenizer:it,MarianTokenizer:At,BloomTokenizer:_e,NllbTokenizer:tt,M2M100Tokenizer:nt,LlamaTokenizer:He,CodeLlamaTokenizer:Ue,XLMRobertaTokenizer:je,MPNetTokenizer:Ye,FalconTokenizer:Ke,GPTNeoXTokenizer:Xe,EsmTokenizer:qe,Wav2Vec2CTCTokenizer:ot,BlenderbotTokenizer:lt,BlenderbotSmallTokenizer:ut,SpeechT5Tokenizer:ct,NougatTokenizer:dt,VitsTokenizer:ht,Qwen2Tokenizer:Ze,GemmaTokenizer:Je,Grok1Tokenizer:$e,CohereTokenizer:ft,MgpstrTokenizer:gt,PreTrainedTokenizer:ke};static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:a="main",legacy:i=null}={}){const[A,o]=await c(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:a,legacy:i}),l=o.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let u=this.TOKENIZER_CLASS_MAPPING[l];return u||(console.warn(`Unknown tokenizer class "${l}", attempting to construct from base class.`),u=ke),new u(A,o)}}},"./src/utils/audio.js":(e,t,n)=>{n.r(t),n.d(t,{RawAudio:()=>k,hamming:()=>d,hanning:()=>c,mel_filter_bank:()=>m,read_audio:()=>l,spectrogram:()=>C,window_function:()=>I});var r=n("./src/utils/hub.js"),s=n("./src/utils/maths.js"),a=n("./src/utils/core.js"),i=n("./src/env.js"),A=n("?7a2c"),o=n("./src/utils/tensor.js");async function l(e,t){if("undefined"==typeof AudioContext)throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const n=await(await(0,r.getFile)(e)).arrayBuffer(),s=new AudioContext({sampleRate:t});void 0===t&&console.warn(`No sampling rate provided, using default of ${s.sampleRate}Hz.`);const a=await s.decodeAudioData(n);let i;if(2===a.numberOfChannels){const e=Math.sqrt(2),t=a.getChannelData(0),n=a.getChannelData(1);i=new Float32Array(t.length);for(let r=0;r<a.length;++r)i[r]=e*(t[r]+n[r])/2}else i=a.getChannelData(0);return i}function u(e,t){if(e<1)return new Float64Array;if(1===e)return new Float64Array([1]);const n=1-t,r=2*Math.PI/(e-1),s=new Float64Array(e);for(let a=0;a<e;++a)s[a]=t-n*Math.cos(a*r);return s}function c(e){return u(e,.5)}function d(e){return u(e,.54)}const h={htk:e=>2595*Math.log10(1+e/700),kaldi:e=>1127*Math.log(1+e/700),slaney:(e,t=1e3,n=15,r=27/Math.log(6.4))=>e>=t?n+Math.log(e/t)*r:3*e/200};function f(e,t="htk"){const n=h[t];if(!n)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return"number"==typeof e?n(e):e.map((e=>n(e)))}const g={htk:e=>700*(10**(e/2595)-1),kaldi:e=>700*(Math.exp(e/1127)-1),slaney:(e,t=1e3,n=15,r=Math.log(6.4)/27)=>e>=n?t*Math.exp(r*(e-n)):200*e/3};function p(e,t,n){const r=(t-e)/(n-1);return Float64Array.from({length:n},((t,n)=>e+r*n))}function m(e,t,n,r,s,a=null,i="htk",A=!1){if(null!==a&&"slaney"!==a)throw new Error('norm must be one of null or "slaney"');if(e<2)throw new Error(`Require num_frequency_bins: ${e} >= 2`);if(n>r)throw new Error(`Require min_frequency: ${n} <= max_frequency: ${r}`);const o=p(f(n,i),f(r,i),t+2);let l,u=function(e,t="htk"){const n=g[t];if(!n)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return"number"==typeof e?n(e):e.map((e=>n(e)))}(o,i);if(A){const t=s/(2*(e-1));l=f(Float64Array.from({length:e},((e,n)=>n*t)),i),u=o}else l=p(0,Math.floor(s/2),e);const c=function(e,t){const n=Float64Array.from({length:t.length-1},((e,n)=>t[n+1]-t[n])),r=Array.from({length:e.length},(()=>new Array(t.length)));for(let n=0;n<e.length;++n){const s=r[n];for(let r=0;r<t.length;++r)s[r]=t[r]-e[n]}const s=t.length-2,a=Array.from({length:s},(()=>new Array(e.length)));for(let t=0;t<e.length;++t){const e=r[t];for(let r=0;r<s;++r){const s=-e[r]/n[r],i=e[r+2]/n[r+1];a[r][t]=Math.max(0,Math.min(s,i))}}return a}(l,u);if(null!==a&&"slaney"===a)for(let n=0;n<t;++n){const t=c[n],r=2/(u[n+2]-u[n]);for(let n=0;n<e;++n)t[n]*=r}return c}function b(e,t,n,r,a){if(n<=0)throw new Error("reference must be greater than zero");if(r<=0)throw new Error("min_value must be greater than zero");n=Math.max(r,n);const i=Math.log10(n);for(let n=0;n<e.length;++n)e[n]=t*Math.log10(Math.max(r,e[n])-i);if(null!==a){if(a<=0)throw new Error("db_range must be greater than zero");const t=(0,s.max)(e)[0]-a;for(let n=0;n<e.length;++n)e[n]=Math.max(e[n],t)}return e}async function C(e,t,n,r,{fft_length:i=null,power:A=1,center:l=!0,pad_mode:u="reflect",onesided:c=!0,preemphasis:d=null,mel_filters:h=null,mel_floor:f=1e-10,log_mel:g=null,reference:p=1,min_value:m=1e-10,db_range:C=null,remove_dc_offset:I=null,min_num_frames:w=null,max_num_frames:k=null,do_pad:x=!0,transpose:y=!1}={}){const v=t.length;if(null===i&&(i=n),n>i)throw Error(`frame_length (${n}) may not be larger than fft_length (${i})`);if(v!==n)throw new Error(`Length of the window (${v}) must equal frame_length (${n})`);if(r<=0)throw new Error("hop_length must be greater than zero");if(null===A&&null!==h)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(l){if("reflect"!==u)throw new Error(`pad_mode="${u}" not implemented yet.`);const t=Math.floor((i-1)/2)+1;e=function(e,t,n){const r=new e.constructor(e.length+t+n),s=e.length-1;for(let n=0;n<e.length;++n)r[t+n]=e[n];for(let n=1;n<=t;++n)r[t-n]=e[(0,a.calculateReflectOffset)(n,s)];for(let i=1;i<=n;++i)r[s+t+i]=e[(0,a.calculateReflectOffset)(s-i,s)];return r}(e,t,t)}let E=Math.floor(1+Math.floor((e.length-n)/r));null!==w&&E<w&&(E=w);const B=c?Math.floor(i/2)+1:i;let M=E,D=E;null!==k&&(k>E?x&&(D=k):D=M=k);const T=new s.FFT(i),S=new Float64Array(i),N=new Float64Array(T.outputBufferSize),G=new Float32Array(B*D);for(let s=0;s<M;++s){const a=s*r,i=Math.min(e.length-a,n);i!==n&&S.fill(0,0,n);for(let t=0;t<i;++t)S[t]=e[a+t];if(I){let e=0;for(let t=0;t<i;++t)e+=S[t];const t=e/i;for(let e=0;e<i;++e)S[e]-=t}if(null!==d){for(let e=i-1;e>=1;--e)S[e]-=d*S[e-1];S[0]*=1-d}for(let e=0;e<t.length;++e)S[e]*=t[e];T.realTransform(N,S);for(let e=0;e<B;++e){const t=e<<1;G[e*D+s]=N[t]**2+N[t+1]**2}}if(null!==A&&2!==A){const e=2/A;for(let t=0;t<G.length;++t)G[t]**=e}const F=h.length;let P=await(0,o.matmul)(new o.Tensor("float32",h.flat(),[F,B]),new o.Tensor("float32",G,[B,D]));y&&(P=P.transpose(1,0));const Q=P.data;for(let e=0;e<Q.length;++e)Q[e]=Math.max(f,Q[e]);if(null!==A&&null!==g){const e=Math.min(Q.length,M*F);switch(g){case"log":for(let t=0;t<e;++t)Q[t]=Math.log(Q[t]);break;case"log10":for(let t=0;t<e;++t)Q[t]=Math.log10(Q[t]);break;case"dB":if(1===A)!function(e,t=1,n=1e-5,r=null){b(e,20,t,n,r)}(Q,p,m,C);else{if(2!==A)throw new Error(`Cannot use log_mel option '${g}' with power ${A}`);!function(e,t=1,n=1e-10,r=null){b(e,10,t,n,r)}(Q,p,m,C)}break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${g}'`)}}return P}function I(e,t,{periodic:n=!0,frame_length:r=null,center:s=!0}={}){const a=n?e+1:e;let i;switch(t){case"boxcar":i=new Float64Array(a).fill(1);break;case"hann":case"hann_window":i=c(a);break;case"hamming":i=d(a);break;case"povey":i=c(a).map((e=>Math.pow(e,.85)));break;default:throw new Error(`Unknown window type ${t}.`)}if(n&&(i=i.subarray(0,e)),null===r)return i;if(e>r)throw new Error(`Length of the window (${e}) may not be larger than frame_length (${r})`);return i}function w(e,t,n){for(let r=0;r<n.length;++r)e.setUint8(t+r,n.charCodeAt(r))}class k{constructor(e,t){this.audio=e,this.sampling_rate=t}toWav(){return function(e,t){let n=44;const r=new ArrayBuffer(n+4*e.length),s=new DataView(r);w(s,0,"RIFF"),s.setUint32(4,36+4*e.length,!0),w(s,8,"WAVE"),w(s,12,"fmt "),s.setUint32(16,16,!0),s.setUint16(20,3,!0),s.setUint16(22,1,!0),s.setUint32(24,t,!0),s.setUint32(28,4*t,!0),s.setUint16(32,4,!0),s.setUint16(34,32,!0),w(s,36,"data"),s.setUint32(40,4*e.length,!0);for(let t=0;t<e.length;++t,n+=4)s.setFloat32(n,e[t],!0);return r}(this.audio,this.sampling_rate)}toBlob(){const e=this.toWav();return new Blob([e],{type:"audio/wav"})}async save(e){let t;if(i.apis.IS_BROWSER_ENV){if(i.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save a file from a Web Worker.");t=a.saveBlob}else{if(!i.apis.IS_FS_AVAILABLE)throw new Error("Unable to save because filesystem is disabled in this environment.");t=async(e,t)=>{let n=await t.arrayBuffer();A.writeFileSync(e,Buffer.from(n))}}await t(e,this.toBlob())}}},"./src/utils/constants.js":(e,t,n)=>{n.r(t),n.d(t,{CHAT_TEMPLATE_NAME:()=>o,CONFIG_NAME:()=>s,FEATURE_EXTRACTOR_NAME:()=>a,GENERATION_CONFIG_NAME:()=>l,GITHUB_ISSUE_URL:()=>r,IMAGE_PROCESSOR_NAME:()=>i,PROCESSOR_NAME:()=>A});const r="https://github.com/huggingface/transformers.js/issues/new/choose",s="config.json",a="preprocessor_config.json",i=a,A="processor_config.json",o="chat_template.json",l="generation_config.json"},"./src/utils/core.js":(e,t,n)=>{function r(e,t){e&&e(t)}function s(e){return Object.fromEntries(Object.entries(e).map((([e,t])=>[t,e])))}function a(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function i(e){return"TypedArray"===e?.prototype?.__proto__?.constructor?.name}function A(e){return Number.isInteger(e)||"bigint"==typeof e}function o(e){return null==e||-1===e}function l(e){const t=[];let n=e;for(;Array.isArray(n);)t.push(n.length),n=n[0];return t}function u(e,t,n=void 0){const r=e[t];if(void 0!==r)return delete e[t],r;if(void 0===n)throw Error(`Key ${t} does not exist in object.`);return n}function c(...e){return Array.prototype.concat.apply([],e)}function d(...e){return e.reduce(((e,t)=>e.flatMap((e=>t.map((t=>[e,t]))))))}function h(e,t){return Math.abs((e+t)%(2*t)-t)}function f(e,t){const n=URL.createObjectURL(t),r=document.createElement("a");r.href=n,r.download=e,r.click(),r.remove(),URL.revokeObjectURL(n)}function g(e,t){return Object.assign({},...t.map((t=>{if(void 0!==e[t])return{[t]:e[t]}})))}function p(e){let t=0;for(const n of e)++t;return t}function m(e,t){let n=0;for(const r of e)r===t&&++n;return n}n.r(t),n.d(t,{calculateDimensions:()=>l,calculateReflectOffset:()=>h,count:()=>m,dispatchCallback:()=>r,escapeRegExp:()=>a,isIntegralNumber:()=>A,isNullishDimension:()=>o,isTypedArray:()=>i,len:()=>p,mergeArrays:()=>c,pick:()=>g,pop:()=>u,product:()=>d,reverseDictionary:()=>s,saveBlob:()=>f})},"./src/utils/data-structures.js":(e,t,n)=>{n.r(t),n.d(t,{CharTrie:()=>s,DictionarySplitter:()=>o,LRUCache:()=>l,PriorityQueue:()=>r,TokenLattice:()=>i});class r{constructor(e=(e,t)=>e>t,t=1/0){this._heap=[],this._comparator=e,this._maxSize=t}get size(){return this._heap.length}isEmpty(){return 0===this.size}peek(){return this._heap[0]}push(...e){return this.extend(e)}extend(e){for(const t of e)if(this.size<this._maxSize)this._heap.push(t),this._siftUp();else{const e=this._smallest();this._comparator(t,this._heap[e])&&(this._heap[e]=t,this._siftUpFrom(e))}return this.size}pop(){const e=this.peek(),t=this.size-1;return t>0&&this._swap(0,t),this._heap.pop(),this._siftDown(),e}replace(e){const t=this.peek();return this._heap[0]=e,this._siftDown(),t}_parent(e){return(e+1>>>1)-1}_left(e){return 1+(e<<1)}_right(e){return e+1<<1}_greater(e,t){return this._comparator(this._heap[e],this._heap[t])}_swap(e,t){const n=this._heap[e];this._heap[e]=this._heap[t],this._heap[t]=n}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(e){for(;e>0&&this._greater(e,this._parent(e));)this._swap(e,this._parent(e)),e=this._parent(e)}_siftDown(){let e=0;for(;this._left(e)<this.size&&this._greater(this._left(e),e)||this._right(e)<this.size&&this._greater(this._right(e),e);){const t=this._right(e)<this.size&&this._greater(this._right(e),this._left(e))?this._right(e):this._left(e);this._swap(e,t),e=t}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class s{constructor(){this.root=a.default()}extend(e){for(const t of e)this.push(t)}push(e){let t=this.root;for(const n of e){let e=t.children.get(n);void 0===e&&(e=a.default(),t.children.set(n,e)),t=e}t.isLeaf=!0}*commonPrefixSearch(e){let t=this.root;if(void 0===t)return;let n="";for(const r of e){if(n+=r,t=t.children.get(r),void 0===t)return;t.isLeaf&&(yield n)}}}class a{constructor(e,t){this.isLeaf=e,this.children=t}static default(){return new a(!1,new Map)}}class i{constructor(e,t,n){this.chars=Array.from(e),this.len=this.chars.length,this.bosTokenId=t,this.eosTokenId=n,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},(()=>[])),this.endNodes=Array.from({length:this.len+1},(()=>[]));const r=new A(this.bosTokenId,0,0,0,0),s=new A(this.eosTokenId,1,this.len,0,0);this.nodes.push(r.clone()),this.nodes.push(s.clone()),this.beginNodes[this.len].push(s),this.endNodes[0].push(r)}insert(e,t,n,r){const s=this.nodes.length,a=new A(r,s,e,t,n);this.beginNodes[e].push(a),this.endNodes[e+t].push(a),this.nodes.push(a)}viterbi(){const e=this.len;let t=0;for(;t<=e;){if(0==this.beginNodes[t].length)return[];for(let e of this.beginNodes[t]){e.prev=null;let n=0,r=null;for(let s of this.endNodes[t]){const t=s.backtraceScore+e.score;(null===r||t>n)&&(r=s.clone(),n=t)}if(null===r)return[];e.prev=r,e.backtraceScore=n}++t}const n=[],r=this.beginNodes[e][0].prev;if(null===r)return[];let s=r.clone();for(;null!==s.prev;){n.push(s.clone());const e=s.clone();s=e.prev.clone()}return n.reverse(),n}piece(e){return this.chars.slice(e.pos,e.pos+e.length).join("")}tokens(){return this.viterbi().map((e=>this.piece(e)))}tokenIds(){return this.viterbi().map((e=>e.tokenId))}}class A{constructor(e,t,n,r,s){this.tokenId=e,this.nodeId=t,this.pos=n,this.length=r,this.score=s,this.prev=null,this.backtraceScore=0}clone(){const e=new A(this.tokenId,this.nodeId,this.pos,this.length,this.score);return e.prev=this.prev,e.backtraceScore=this.backtraceScore,e}}class o{constructor(e){this.trie=this._buildTrie(e)}_buildTrie(e){const t=Object.create(null);for(const n of e){let e=t;for(let t=0;t<n.length;++t)e=e[n[t]]??=Object.create(null);e.end=n}return t}split(e){const t=[],n=e.length;let r=0,s=0;for(;s<n;){let a=this.trie,i=null,A=s;for(;A<n&&(a=a[e[A]]);)a.end&&(i=a.end),++A;i?(s>r&&t.push(e.slice(r,s)),t.push(i),s+=i.length,r=s):++s}return r<n&&t.push(e.slice(r)),t}}class l{constructor(e){this.capacity=e,this.cache=new Map}get(e){if(!this.cache.has(e))return;const t=this.cache.get(e);return this.cache.delete(e),this.cache.set(e,t),t}put(e,t){this.cache.has(e)&&this.cache.delete(e),this.cache.set(e,t),this.cache.size>this.capacity&&this.cache.delete(this.cache.keys().next().value)}clear(){this.cache.clear()}}},"./src/utils/devices.js":(e,t,n)=>{n.r(t),n.d(t,{DEVICE_TYPES:()=>r});const r=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})},"./src/utils/dtypes.js":(e,t,n)=>{n.r(t),n.d(t,{DATA_TYPES:()=>i,DEFAULT_DEVICE_DTYPE_MAPPING:()=>A,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>o,isWebGpuFp16Supported:()=>a});var r=n("./src/env.js"),s=n("./src/utils/devices.js");const a=function(){let e;return async function(){if(void 0===e)if(r.apis.IS_WEBGPU_AVAILABLE)try{const t=await navigator.gpu.requestAdapter();e=t.features.has("shader-f16")}catch(t){e=!1}else e=!1;return e}}(),i=Object.freeze({auto:"auto",fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),A=Object.freeze({[s.DEVICE_TYPES.wasm]:i.q8}),o=Object.freeze({[i.fp32]:"",[i.fp16]:"_fp16",[i.int8]:"_int8",[i.uint8]:"_uint8",[i.q8]:"_quantized",[i.q4]:"_q4",[i.q4f16]:"_q4f16",[i.bnb4]:"_bnb4"})},"./src/utils/generic.js":(e,t,n)=>{n.r(t),n.d(t,{Callable:()=>r});const r=class{constructor(){let e=function(...t){return e._call(...t)};return Object.setPrototypeOf(e,new.target.prototype)}_call(...e){throw Error("Must implement _call method in subclass")}}},"./src/utils/hub.js":(e,t,n)=>{n.r(t),n.d(t,{MAX_EXTERNAL_DATA_CHUNKS:()=>A,getFile:()=>d,getModelFile:()=>g,getModelJSON:()=>p});var r=n("?7a2c"),s=n("?a42a"),a=n("./src/env.js"),i=n("./src/utils/core.js");const A=100,o={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class l{constructor(e){if(this.filePath=e,this.headers=new Headers,this.exists=r.existsSync(e),this.exists){this.status=200,this.statusText="OK";let t=r.statSync(e);this.headers.set("content-length",t.size.toString()),this.updateContentType();const n=r.createReadStream(e);this.body=new ReadableStream({start(e){n.on("data",(t=>e.enqueue(t))),n.on("end",(()=>e.close())),n.on("error",(t=>e.error(t)))},cancel(){n.destroy()}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const e=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",o[e]??"application/octet-stream")}clone(){let e=new l(this.filePath);return e.exists=this.exists,e.status=this.status,e.statusText=this.statusText,e.headers=new Headers(this.headers),e}async arrayBuffer(){return(await r.promises.readFile(this.filePath)).buffer}async blob(){const e=await r.promises.readFile(this.filePath);return new Blob([e],{type:this.headers.get("content-type")})}async text(){return await r.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function u(e,t=null,n=null){let r;try{r=new URL(e)}catch(e){return!1}return!(t&&!t.includes(r.protocol))&&!(n&&!n.includes(r.hostname))}const c=/^(\b[\w\-.]+\b\/)?\b[\w\-.]{1,96}\b$/;async function d(e){if(a.env.useFS&&!u(e,["http:","https:","blob:"]))return new l(e instanceof URL?"file:"===e.protocol?e.pathname:e.toString():e);if("undefined"!=typeof process&&"node"===process?.release?.name){const t=!!process.env?.TESTING_REMOTELY,n=a.env.version,r=new Headers;r.set("User-Agent",`transformers.js/${n}; is_ci/${t};`);if(u(e,["http:","https:"],["huggingface.co","hf.co"])){const e=process.env?.HF_TOKEN??process.env?.HF_ACCESS_TOKEN;e&&r.set("Authorization",`Bearer ${e}`)}return fetch(e,{headers:r})}return fetch(e)}const h={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};class f{constructor(e){this.path=e}async match(e){let t=s.join(this.path,e),n=new l(t);return n.exists?n:void 0}async put(e,t,n=void 0){let a=s.join(this.path,e);try{const e=t.headers.get("Content-Length"),i=parseInt(e??"0");let A=0;await r.promises.mkdir(s.dirname(a),{recursive:!0});const o=r.createWriteStream(a),l=t.body.getReader();for(;;){const{done:e,value:t}=await l.read();if(e)break;await new Promise(((e,n)=>{o.write(t,(t=>{t?n(t):e()}))})),A+=t.length;const r=i?A/i*100:0;n?.({progress:r,loaded:A,total:i})}o.close()}catch(e){try{await r.promises.unlink(a)}catch{}throw e}}}async function g(e,t,n=!0,r={},s=!1){if(!a.env.allowLocalModels){if(r.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!a.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}let A;if((0,i.dispatchCallback)(r.progress_callback,{status:"initiate",name:e,file:t}),!A&&a.env.useCustomCache){if(!a.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!a.env.customCache.match||!a.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");A=a.env.customCache}if(!A&&a.env.useBrowserCache){if("undefined"==typeof caches)throw Error("Browser cache is not available in this environment.");try{A=await caches.open("transformers-cache")}catch(e){console.warn("An error occurred while opening the browser cache:",e)}}if(!A&&a.env.useFSCache){if(!a.apis.IS_FS_AVAILABLE)throw Error("File System Cache is not available in this environment.");A=new f(r.cache_dir??a.env.cacheDir)}const o=r.revision??"main",g=m(e,t),p=(b=e,!(!c.test(b)||b.includes("..")||b.includes("--")||b.endsWith(".git")||b.endsWith(".ipynb")));var b;const C=p?m(a.env.localModelPath,g):g,I=m(a.env.remoteHost,a.env.remotePathTemplate.replaceAll("{model}",e).replaceAll("{revision}",encodeURIComponent(o)),t);let w;const k=A instanceof f?"main"===o?g:m(e,o,t):I;let x,y=!1;A&&(x=await async function(e,...t){for(let n of t)try{let t=await e.match(n);if(t)return t}catch(e){continue}}(A,C,k));const v=void 0!==x;if(void 0===x){if(a.env.allowLocalModels){if(u(g,["http:","https:"])){if(r.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${g}.`);if(!a.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${g}.`)}else try{x=await d(C),w=C}catch(e){console.warn(`Unable to load from local path "${C}": "${e}"`)}}if(void 0===x||404===x.status){if(r.local_files_only||!a.env.allowRemoteModels){if(n)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${C}".`);return null}if(!p)throw Error(`Local file missing at "${C}" and download aborted due to invalid model ID "${e}".`);if(x=await d(I),200!==x.status)return function(e,t,n){if(!n)return null;const r=h[e]??`Error (${e}) occurred while trying to load file`;throw Error(`${r}: "${t}".`)}(x.status,I,n);w=k}y=A&&"undefined"!=typeof Response&&x instanceof Response&&200===x.status}let E;if((0,i.dispatchCallback)(r.progress_callback,{status:"download",name:e,file:t}),!a.apis.IS_NODE_ENV||!s){let n;r.progress_callback?v&&"undefined"!=typeof navigator&&/firefox/i.test(navigator.userAgent)?(n=new Uint8Array(await x.arrayBuffer()),(0,i.dispatchCallback)(r.progress_callback,{status:"progress",name:e,file:t,progress:100,loaded:n.length,total:n.length})):n=await async function(e,t){const n=e.headers.get("Content-Length");null===n&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let r=parseInt(n??"0"),s=new Uint8Array(r),a=0;const i=e.body.getReader();async function A(){const{done:e,value:n}=await i.read();if(e)return;const o=a+n.length;if(o>r){r=o;const e=new Uint8Array(r);e.set(s),s=e}s.set(n,a),a=o;return t({progress:a/r*100,loaded:a,total:r}),A()}return await A(),s}(x,(n=>{(0,i.dispatchCallback)(r.progress_callback,{status:"progress",name:e,file:t,...n})})):n=new Uint8Array(await x.arrayBuffer()),E=n}if(y&&w&&void 0===await A.match(w)&&(E?await A.put(w,new Response(E,{headers:x.headers})).catch((e=>{console.warn(`Unable to add response to browser cache: ${e}.`)})):await A.put(w,x,r.progress_callback)),(0,i.dispatchCallback)(r.progress_callback,{status:"done",name:e,file:t}),E){if(!a.apis.IS_NODE_ENV&&s)throw new Error("Cannot return path in a browser environment.");return E}if(x instanceof l)return x.filePath;const B=await(A?.match(w));if(B instanceof l)return B.filePath;if(B instanceof Response)return new Uint8Array(await B.arrayBuffer());if("string"==typeof B)return B;throw new Error("Unable to get model file path or buffer.")}async function p(e,t,n=!0,r={}){const s=await g(e,t,n,r,!1);if(null===s)return{};const a=new TextDecoder("utf-8").decode(s);return JSON.parse(a)}function m(...e){return(e=e.map(((t,n)=>(n&&(t=t.replace(new RegExp("^/"),"")),n!==e.length-1&&(t=t.replace(new RegExp("/$"),"")),t)))).join("/")}},"./src/utils/image.js":(e,t,n)=>{n.r(t),n.d(t,{RawImage:()=>f,load_image:()=>g});var r=n("./src/utils/core.js"),s=n("./src/utils/hub.js"),a=n("./src/env.js"),i=n("./src/utils/tensor.js"),A=n("?2b25");let o,l,u;const c=a.apis.IS_BROWSER_ENV||a.apis.IS_WEBWORKER_ENV;if(c)o=(e,t)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(e,t)},u=self.createImageBitmap,l=self.ImageData;else{if(!A)throw new Error("Unable to load image processing library.");u=async e=>{const t=(await e.metadata()).channels,{data:n,info:r}=await e.rotate().raw().toBuffer({resolveWithObject:!0}),s=new f(new Uint8ClampedArray(n),r.width,r.height,r.channels);return void 0!==t&&t!==r.channels&&s.convert(t),s}}const d={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},h=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class f{constructor(e,t,n,r){this.data=e,this.width=t,this.height=n,this.channels=r}get size(){return[this.width,this.height]}static async read(e){if(e instanceof f)return e;if("string"==typeof e||e instanceof URL)return await this.fromURL(e);if(e instanceof Blob)return await this.fromBlob(e);if("undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas)return this.fromCanvas(e);throw new Error("Unsupported input type: "+typeof e)}static fromCanvas(e){if(!c)throw new Error("fromCanvas() is only supported in browser environments.");const t=e.getContext("2d").getImageData(0,0,e.width,e.height).data;return new f(t,e.width,e.height,4)}static async fromURL(e){const t=await(0,s.getFile)(e);if(200!==t.status)throw new Error(`Unable to read image from "${e}" (${t.status} ${t.statusText})`);const n=await t.blob();return this.fromBlob(n)}static async fromBlob(e){if(c){const t=await u(e),n=o(t.width,t.height).getContext("2d");return n.drawImage(t,0,0),new this(n.getImageData(0,0,t.width,t.height).data,t.width,t.height,4)}{const t=A(await e.arrayBuffer());return await u(t)}}static fromTensor(e,t="CHW"){if(3!==e.dims.length)throw new Error(`Tensor should have 3 dimensions, but has ${e.dims.length} dimensions.`);if("CHW"===t)e=e.transpose(1,2,0);else if("HWC"!==t)throw new Error(`Unsupported channel format: ${t}`);if(!(e.data instanceof Uint8ClampedArray||e.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${e.type}`);switch(e.dims[2]){case 1:case 2:case 3:case 4:return new f(e.data,e.dims[1],e.dims[0],e.dims[2]);default:throw new Error(`Unsupported number of channels: ${e.dims[2]}`)}}grayscale(){if(1===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let t=0,n=0;t<this.data.length;t+=this.channels){const r=this.data[t],s=this.data[t+1],a=this.data[t+2];e[n++]=Math.round(.2989*r+.587*s+.114*a)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,1)}rgb(){if(3===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let t=0,n=0;t<this.data.length;++t)e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=this.data[t];break;case 4:for(let t=0,n=0;t<this.data.length;t+=4)e[n++]=this.data[t],e[n++]=this.data[t+1],e[n++]=this.data[t+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,3)}rgba(){if(4===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let t=0,n=0;t<this.data.length;++t)e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=255;break;case 3:for(let t=0,n=0;t<this.data.length;t+=3)e[n++]=this.data[t],e[n++]=this.data[t+1],e[n++]=this.data[t+2],e[n++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,4)}putAlpha(e){if(e.width!==this.width||e.height!==this.height)throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${e.width}x${e.height}`);if(1!==e.channels)throw new Error(`Expected mask to have 1 channel, but got ${e.channels}`);const t=this.data,n=e.data,r=this.width*this.height;if(3===this.channels){const e=new Uint8ClampedArray(4*r);for(let s=0,a=0,i=0;s<r;++s)e[i++]=t[a++],e[i++]=t[a++],e[i++]=t[a++],e[i++]=n[s];return this._update(e,this.width,this.height,4)}if(4===this.channels){for(let e=0;e<r;++e)t[4*e+3]=n[e];return this}throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`)}async resize(e,t,{resample:n=2}={}){if(this.width===e&&this.height===t)return this;let s=d[n]??n;const a=(0,r.isNullishDimension)(e),i=(0,r.isNullishDimension)(t);if(a&&i)return this;if(a?e=t/this.height*this.width:i&&(t=e/this.width*this.height),c){const n=this.channels,r=this.toCanvas(),s=o(e,t).getContext("2d");s.drawImage(r,0,0,e,t);return new f(s.getImageData(0,0,e,t).data,e,t,4).convert(n)}{let n=this.toSharp();switch(s){case"box":case"hamming":"box"!==s&&"hamming"!==s||(console.warn(`Resampling method ${s} is not yet supported. Using bilinear instead.`),s="bilinear");case"nearest":case"bilinear":case"bicubic":n=n.affine([e/this.width,0,0,t/this.height],{interpolator:s});break;case"lanczos":n=n.resize({width:e,height:t,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${s} is not supported.`)}return await u(n)}}async pad([e,t,n,r]){if(e=Math.max(e,0),t=Math.max(t,0),n=Math.max(n,0),r=Math.max(r,0),0===e&&0===t&&0===n&&0===r)return this;if(c){const s=this.channels,a=this.toCanvas(),i=this.width+e+t,A=this.height+n+r,l=o(i,A).getContext("2d");l.drawImage(a,0,0,this.width,this.height,e,n,this.width,this.height);return new f(l.getImageData(0,0,i,A).data,i,A,4).convert(s)}{const s=this.toSharp().extend({left:e,right:t,top:n,bottom:r});return await u(s)}}async crop([e,t,n,r]){if(e=Math.max(e,0),t=Math.max(t,0),n=Math.min(n,this.width-1),r=Math.min(r,this.height-1),0===e&&0===t&&n===this.width-1&&r===this.height-1)return this;const s=n-e+1,a=r-t+1;if(c){const n=this.channels,r=this.toCanvas(),i=o(s,a).getContext("2d");i.drawImage(r,e,t,s,a,0,0,s,a);return new f(i.getImageData(0,0,s,a).data,s,a,4).convert(n)}{const n=this.toSharp().extract({left:e,top:t,width:s,height:a});return await u(n)}}async center_crop(e,t){if(this.width===e&&this.height===t)return this;const n=(this.width-e)/2,r=(this.height-t)/2;if(c){const s=this.channels,a=this.toCanvas(),i=o(e,t).getContext("2d");let A=0,l=0,u=0,c=0;n>=0?A=n:u=-n,r>=0?l=r:c=-r,i.drawImage(a,A,l,e,t,u,c,e,t);return new f(i.getImageData(0,0,e,t).data,e,t,4).convert(s)}{let s=this.toSharp();if(n>=0&&r>=0)s=s.extract({left:Math.floor(n),top:Math.floor(r),width:e,height:t});else if(n<=0&&r<=0){const a=Math.floor(-r),i=Math.floor(-n);s=s.extend({top:a,left:i,right:e-this.width-i,bottom:t-this.height-a})}else{let a=[0,0],i=0;r<0?(a[0]=Math.floor(-r),a[1]=t-this.height-a[0]):i=Math.floor(r);let A=[0,0],o=0;n<0?(A[0]=Math.floor(-n),A[1]=e-this.width-A[0]):o=Math.floor(n),s=s.extend({top:a[0],bottom:a[1],left:A[0],right:A[1]}).extract({left:o,top:i,width:e,height:t})}return await u(s)}}async toBlob(e="image/png",t=1){if(!c)throw new Error("toBlob() is only supported in browser environments.");const n=this.toCanvas();return await n.convertToBlob({type:e,quality:t})}toTensor(e="CHW"){let t=new i.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if("HWC"===e);else{if("CHW"!==e)throw new Error(`Unsupported channel format: ${e}`);t=t.permute(2,0,1)}return t}toCanvas(){if(!c)throw new Error("toCanvas() is only supported in browser environments.");const e=this.clone().rgba(),t=o(e.width,e.height),n=new l(e.data,e.width,e.height);return t.getContext("2d").putImageData(n,0,0),t}split(){const{data:e,width:t,height:n,channels:r}=this,s=e.constructor,a=e.length/r,i=Array.from({length:r},(()=>new s(a)));for(let t=0;t<a;++t){const n=r*t;for(let s=0;s<r;++s)i[s][t]=e[n+s]}return i.map((e=>new f(e,t,n,1)))}_update(e,t,n,r=null){return this.data=e,this.width=t,this.height=n,null!==r&&(this.channels=r),this}clone(){return new f(this.data.slice(),this.width,this.height,this.channels)}convert(e){if(this.channels===e)return this;switch(e){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(e){if(!c){if(a.apis.IS_FS_AVAILABLE){const t=this.toSharp();return await t.toFile(e)}throw new Error("Unable to save the image because filesystem is disabled in this environment.")}{if(a.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const t=e.split(".").pop().toLowerCase(),n=h.get(t)??"image/png",s=await this.toBlob(n);(0,r.saveBlob)(e,s)}}toSharp(){if(c)throw new Error("toSharp() is only supported in server-side environments.");return A(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}const g=f.read.bind(f)},"./src/utils/maths.js":(e,t,n)=>{function r(e,[t,n,r],[s,a],i="bilinear",A=!1){const o=a/r,l=s/n,u=new e.constructor(s*a*t),c=n*r,d=s*a;for(let i=0;i<s;++i)for(let s=0;s<a;++s){const A=i*a+s,h=(s+.5)/o-.5,f=(i+.5)/l-.5;let g=Math.floor(h),p=Math.floor(f);const m=Math.min(g+1,r-1),b=Math.min(p+1,n-1);g=Math.max(g,0),p=Math.max(p,0);const C=h-g,I=f-p,w=(1-C)*(1-I),k=C*(1-I),x=(1-C)*I,y=C*I,v=p*r,E=b*r,B=v+g,M=v+m,D=E+g,T=E+m;for(let n=0;n<t;++n){const t=n*c;u[n*d+A]=w*e[t+B]+k*e[t+M]+x*e[t+D]+y*e[t+T]}}return u}function s(e,t,n){const r=new Array(n.length),s=new Array(n.length);for(let e=n.length-1,a=1;e>=0;--e)s[e]=a,r[e]=t[n[e]],a*=r[e];const a=n.map(((e,t)=>s[n.indexOf(t)])),i=new e.constructor(e.length);for(let n=0;n<e.length;++n){let r=0;for(let e=t.length-1,s=n;e>=0;--e)r+=s%t[e]*a[e],s=Math.floor(s/t[e]);i[r]=e[n]}return[i,r]}function a(e){const t=c(e)[0],n=e.map((e=>Math.exp(e-t))),r=n.reduce(((e,t)=>e+t),0),s=n.map((e=>e/r));return s}function i(e){const t=c(e)[0];let n=0;for(let r=0;r<e.length;++r)n+=Math.exp(e[r]-t);const r=Math.log(n),s=e.map((e=>e-t-r));return s}function A(e,t){let n=0;for(let r=0;r<e.length;++r)n+=e[r]*t[r];return n}function o(e,t){return A(e,t)/(l(e)*l(t))}function l(e){return Math.sqrt(e.reduce(((e,t)=>e+t*t),0))}function u(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],n=0;for(let r=1;r<e.length;++r)e[r]<t&&(t=e[r],n=r);return[t,n]}function c(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],n=0;for(let r=1;r<e.length;++r)e[r]>t&&(t=e[r],n=r);return[t,n]}function d(e){return e>0&&!(e&e-1)}n.r(t),n.d(t,{FFT:()=>g,bankers_round:()=>b,cos_sim:()=>o,dot:()=>A,dynamic_time_warping:()=>C,interpolate_data:()=>r,log_softmax:()=>i,magnitude:()=>l,max:()=>c,medianFilter:()=>p,min:()=>u,permute_data:()=>s,round:()=>m,softmax:()=>a});class h{constructor(e){if(this.size=0|e,this.size<=1||!d(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=e<<1,this.table=new Float64Array(2*this.size);for(let e=0;e<this.table.length;e+=2){const t=Math.PI*e/this.size;this.table[e]=Math.cos(t),this.table[e+1]=-Math.sin(t)}let t=0;for(let e=1;this.size>e;e<<=1)++t;this._width=t%2==0?t-1:t,this._bitrev=new Int32Array(1<<this._width);for(let e=0;e<this._bitrev.length;++e){this._bitrev[e]=0;for(let t=0;t<this._width;t+=2){const n=this._width-t-2;this._bitrev[e]|=(e>>>t&3)<<n}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(e,t){const n=t||new Array(e.length>>>1);for(let t=0;t<e.length;t+=2)n[t>>>1]=e[t];return n}toComplexArray(e,t){const n=t||this.createComplexArray();for(let t=0;t<n.length;t+=2)n[t]=e[t>>>1],n[t+1]=0;return n}transform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,1)}realTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._realTransform4(e,t,1)}inverseTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,-1);for(let t=0;t<e.length;++t)e[t]/=this.size}_transform4(e,t,n){const r=this._csize;let s,a,i=1<<this._width,A=r/i<<1;const o=this._bitrev;if(4===A)for(s=0,a=0;s<r;s+=A,++a){const n=o[a];this._singleTransform2(t,e,s,n,i)}else for(s=0,a=0;s<r;s+=A,++a){const r=o[a];this._singleTransform4(t,e,s,r,i,n)}const l=this.table;for(i>>=2;i>=2;i>>=2){A=r/i<<1;const t=A>>>2;for(s=0;s<r;s+=A){const r=s+t-1;for(let a=s,A=0;a<r;a+=2,A+=i){const r=a,s=r+t,i=s+t,o=i+t,u=e[r],c=e[r+1],d=e[s],h=e[s+1],f=e[i],g=e[i+1],p=e[o],m=e[o+1],b=l[A],C=n*l[A+1],I=d*b-h*C,w=d*C+h*b,k=l[2*A],x=n*l[2*A+1],y=f*k-g*x,v=f*x+g*k,E=l[3*A],B=n*l[3*A+1],M=p*E-m*B,D=p*B+m*E,T=u+y,S=c+v,N=u-y,G=c-v,F=I+M,P=w+D,Q=n*(I-M),z=n*(w-D);e[r]=T+F,e[r+1]=S+P,e[s]=N+z,e[s+1]=G-Q,e[i]=T-F,e[i+1]=S-P,e[o]=N-z,e[o+1]=G+Q}}}}_singleTransform2(e,t,n,r,s){const a=e[r],i=e[r+1],A=e[r+s],o=e[r+s+1];t[n]=a+A,t[n+1]=i+o,t[n+2]=a-A,t[n+3]=i-o}_singleTransform4(e,t,n,r,s,a){const i=2*s,A=3*s,o=e[r],l=e[r+1],u=e[r+s],c=e[r+s+1],d=e[r+i],h=e[r+i+1],f=e[r+A],g=e[r+A+1],p=o+d,m=l+h,b=o-d,C=l-h,I=u+f,w=c+g,k=a*(u-f),x=a*(c-g);t[n]=p+I,t[n+1]=m+w,t[n+2]=b+x,t[n+3]=C-k,t[n+4]=p-I,t[n+5]=m-w,t[n+6]=b-x,t[n+7]=C+k}_realTransform4(e,t,n){const r=this._csize;let s,a,i=1<<this._width,A=r/i<<1;const o=this._bitrev;if(4===A)for(s=0,a=0;s<r;s+=A,++a){const n=o[a];this._singleRealTransform2(t,e,s,n>>>1,i>>>1)}else for(s=0,a=0;s<r;s+=A,++a){const r=o[a];this._singleRealTransform4(t,e,s,r>>>1,i>>>1,n)}const l=this.table;for(i>>=2;i>=2;i>>=2){A=r/i<<1;const t=A>>>1,a=t>>>1,o=a>>>1;for(s=0;s<r;s+=A)for(let r=0,A=0;r<=o;r+=2,A+=i){const i=s+r,u=i+a,c=u+a,d=c+a,h=e[i],f=e[i+1],g=e[u],p=e[u+1],m=e[c],b=e[c+1],C=e[d],I=e[d+1],w=h,k=f,x=l[A],y=n*l[A+1],v=g*x-p*y,E=g*y+p*x,B=l[2*A],M=n*l[2*A+1],D=m*B-b*M,T=m*M+b*B,S=l[3*A],N=n*l[3*A+1],G=C*S-I*N,F=C*N+I*S,P=w+D,Q=k+T,z=w-D,O=k-T,R=v+G,L=E+F,W=n*(v-G),_=n*(E-F);if(e[i]=P+R,e[i+1]=Q+L,e[u]=z+_,e[u+1]=O-W,0===r){e[c]=P-R,e[c+1]=Q-L;continue}if(r===o)continue;const V=s+a-r,H=s+t-r;e[V]=z-n*_,e[V+1]=-O-n*W,e[H]=P-n*R,e[H+1]=n*L-Q}}const u=r>>>1;for(let t=2;t<u;t+=2)e[r-t]=e[t],e[r-t+1]=-e[t+1]}_singleRealTransform2(e,t,n,r,s){const a=e[r],i=e[r+s];t[n]=a+i,t[n+1]=0,t[n+2]=a-i,t[n+3]=0}_singleRealTransform4(e,t,n,r,s,a){const i=2*s,A=3*s,o=e[r],l=e[r+s],u=e[r+i],c=e[r+A],d=o+u,h=o-u,f=l+c,g=a*(l-c);t[n]=d+f,t[n+1]=0,t[n+2]=h,t[n+3]=-g,t[n+4]=d-f,t[n+5]=0,t[n+6]=h,t[n+7]=g}}class f{constructor(e){const t=2*(e-1),n=2*(2*e-1),r=2**Math.ceil(Math.log2(n));this.bufferSize=r,this._a=t;const s=new Float64Array(n),a=new Float64Array(r);this._chirpBuffer=new Float64Array(r),this._buffer1=new Float64Array(r),this._buffer2=new Float64Array(r),this._outBuffer1=new Float64Array(r),this._outBuffer2=new Float64Array(r);const i=-2*Math.PI/e,A=Math.cos(i),o=Math.sin(i);for(let t=0;t<n>>1;++t){const n=(t+1-e)**2/2,r=Math.sqrt(A**2+o**2)**n,i=n*Math.atan2(o,A),l=2*t;s[l]=r*Math.cos(i),s[l+1]=r*Math.sin(i),a[l]=s[l],a[l+1]=-s[l+1]}this._slicedChirpBuffer=s.subarray(t,n),this._f=new h(r>>1),this._f.transform(this._chirpBuffer,a)}_transform(e,t,n){const r=this._buffer1,s=this._buffer2,a=this._outBuffer1,i=this._outBuffer2,A=this._chirpBuffer,o=this._slicedChirpBuffer,l=this._a;if(n)for(let e=0;e<o.length;e+=2){const n=e+1,s=t[e>>1];r[e]=s*o[e],r[n]=s*o[n]}else for(let e=0;e<o.length;e+=2){const n=e+1;r[e]=t[e]*o[e]-t[n]*o[n],r[n]=t[e]*o[n]+t[n]*o[e]}this._f.transform(a,r);for(let e=0;e<A.length;e+=2){const t=e+1;s[e]=a[e]*A[e]-a[t]*A[t],s[t]=a[e]*A[t]+a[t]*A[e]}this._f.inverseTransform(i,s);for(let t=0;t<i.length;t+=2){const n=i[t+l],r=i[t+l+1],s=o[t],a=o[t+1];e[t]=n*s-r*a,e[t+1]=n*a+r*s}}transform(e,t){this._transform(e,t,!1)}realTransform(e,t){this._transform(e,t,!0)}}class g{constructor(e){this.fft_length=e,this.isPowerOfTwo=d(e),this.isPowerOfTwo?(this.fft=new h(e),this.outputBufferSize=2*e):(this.fft=new f(e),this.outputBufferSize=this.fft.bufferSize)}realTransform(e,t){this.fft.realTransform(e,t)}transform(e,t){this.fft.transform(e,t)}}function p(e,t){if(t%2==0||t<=0)throw new Error("Window size must be a positive odd number");const n=new e.constructor(e.length),r=new e.constructor(t),s=Math.floor(t/2);for(let t=0;t<e.length;++t){let a=0;for(let n=-s;n<=s;++n){let s=t+n;s<0?s=Math.abs(s):s>=e.length&&(s=2*(e.length-1)-s),r[a++]=e[s]}r.sort(),n[t]=r[s]}return n}function m(e,t){const n=Math.pow(10,t);return Math.round(e*n)/n}function b(e){const t=Math.round(e);return Math.abs(e)%1==.5?t%2==0?t:t-1:t}function C(e){const t=e.length,n=e[0].length,r=[t+1,n+1],s=Array.from({length:r[0]},(()=>Array(r[1]).fill(1/0)));s[0][0]=0;const a=Array.from({length:r[0]},(()=>Array(r[1]).fill(-1)));for(let t=1;t<r[1];++t)for(let n=1;n<r[0];++n){const r=s[n-1][t-1],i=s[n-1][t],A=s[n][t-1];let o,l;r<i&&r<A?(o=r,l=0):i<r&&i<A?(o=i,l=1):(o=A,l=2),s[n][t]=e[n-1][t-1]+o,a[n][t]=l}for(let e=0;e<r[1];++e)a[0][e]=2;for(let e=0;e<r[0];++e)a[e][0]=1;let i=t,A=n,o=[],l=[];for(;i>0||A>0;)switch(o.push(i-1),l.push(A-1),a[i][A]){case 0:--i,--A;break;case 1:--i;break;case 2:--A;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${i}, ${A}]. Please file a bug report.`)}return o.reverse(),l.reverse(),[o,l]}},"./src/utils/tensor.js":(e,t,n)=>{n.r(t),n.d(t,{DataTypeMap:()=>i,Tensor:()=>A,cat:()=>w,full:()=>B,full_like:()=>M,interpolate:()=>l,interpolate_4d:()=>u,layer_norm:()=>m,matmul:()=>c,mean:()=>v,mean_pooling:()=>p,ones:()=>D,ones_like:()=>T,permute:()=>o,quantize_embeddings:()=>F,rand:()=>G,rfft:()=>d,slice:()=>g,stack:()=>k,std_mean:()=>y,topk:()=>h,zeros:()=>S,zeros_like:()=>N});var r=n("./src/utils/maths.js"),s=n("./src/backends/onnx.js"),a=n("./src/ops/registry.js");const i=Object.freeze({float32:Float32Array,float16:"undefined"!=typeof Float16Array?Float16Array:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array,uint4:Uint8Array,int4:Int8Array});class A{get dims(){return this.ort_tensor.dims}set dims(e){this.ort_tensor.dims=e}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}ort_tensor;constructor(...e){return(0,s.isONNXTensor)(e[0])?this.ort_tensor=e[0]:this.ort_tensor=new s.Tensor(e[0],e[1],e[2]),new Proxy(this,{get:(e,t)=>{if("string"==typeof t){let n=Number(t);if(Number.isInteger(n))return e._getitem(n)}return e[t]},set:(e,t,n)=>e[t]=n})}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[e,...t]=this.dims;if(t.length>0){const n=t.reduce(((e,t)=>e*t));for(let r=0;r<e;++r)yield this._subarray(r,n,t)}else yield*this.data}_getitem(e){const[t,...n]=this.dims;if(e=I(e,t),n.length>0){const t=n.reduce(((e,t)=>e*t));return this._subarray(e,t,n)}return new A(this.type,[this.data[e]],n)}indexOf(e){const t=this.data;for(let n=0;n<t.length;++n)if(t[n]==e)return n;return-1}_subarray(e,t,n){const r=e*t,s=(e+1)*t,a="subarray"in this.data?this.data.subarray(r,s):this.data.slice(r,s);return new A(this.type,a,n)}item(){const e=this.data;if(1!==e.length)throw new Error(`a Tensor with ${e.length} elements cannot be converted to Scalar`);return e[0]}tolist(){return function(e,t){const n=e.length,r=t.reduce(((e,t)=>e*t));if(n!==r)throw Error(`cannot reshape array of size ${n} into shape (${t})`);let s=e;for(let e=t.length-1;e>=0;e--)s=s.reduce(((n,r)=>{let s=n[n.length-1];return s.length<t[e]?s.push(r):n.push([r]),n}),[[]]);return s[0]}(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=1/(1+Math.exp(-e[t]));return this}map(e){return this.clone().map_(e)}map_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]=e(t[n],n,t);return this}mul(e){return this.clone().mul_(e)}mul_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]*=e;return this}div(e){return this.clone().div_(e)}div_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]/=e;return this}add(e){return this.clone().add_(e)}add_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]+=e;return this}sub(e){return this.clone().sub_(e)}sub_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]-=e;return this}clone(){return new A(this.type,this.data.slice(),this.dims.slice())}slice(...e){const t=[],n=[];for(let r=0;r<this.dims.length;++r){let s=e[r];if(null==s)n.push([0,this.dims[r]]),t.push(this.dims[r]);else if("number"==typeof s)s=I(s,this.dims[r],r),n.push([s,s+1]);else{if(!Array.isArray(s)||2!==s.length)throw new Error(`Invalid slice: ${s}`);{let[e,a]=s;if(e=null===e?0:I(e,this.dims[r],r,!1),a=null===a?this.dims[r]:I(a,this.dims[r],r,!1),e>a)throw new Error(`Invalid slice: ${s}`);const i=[Math.max(e,0),Math.min(a,this.dims[r])];n.push(i),t.push(i[1]-i[0])}}}const r=n.map((([e,t])=>t-e)),s=r.reduce(((e,t)=>e*t)),a=this.data,i=new a.constructor(s),o=this.stride();for(let e=0;e<s;++e){let t=0;for(let s=r.length-1,a=e;s>=0;--s){const e=r[s];t+=(a%e+n[s][0])*o[s],a=Math.floor(a/e)}i[e]=a[t]}return new A(this.type,i,t)}permute(...e){return o(this,e)}transpose(...e){return this.permute(...e)}sum(e=null,t=!1){return this.norm(1,e,t)}norm(e="fro",t=null,n=!1){if("fro"===e)e=2;else if("string"==typeof e)throw Error(`Unsupported norm: ${e}`);const r=this.data,s=(t,n)=>t+n**e;if(null===t){const t=r.reduce(s,0)**(1/e);return new A(this.type,[t],[])}const[a,i,o]=x(s,this,t,n);if(1!==e)for(let t=0;t<i.length;++t)i[t]=i[t]**(1/e);return new A(a,i,o)}normalize_(e=2,t=1){t=I(t,this.dims.length);const n=this.norm(e,t,!0),r=this.data,s=n.data;for(let e=0;e<r.length;++e){let n=0;for(let r=this.dims.length-1,s=e,a=1;r>=0;--r){const e=this.dims[r];if(r!==t){n+=s%e*a,a*=this.dims[r]}s=Math.floor(s/e)}r[e]/=s[n]}return this}normalize(e=2,t=1){return this.clone().normalize_(e,t)}stride(){return function(e){const t=new Array(e.length);for(let n=e.length-1,r=1;n>=0;--n)t[n]=r,r*=e[n];return t}(this.dims)}squeeze(e=null){return new A(this.type,this.data,b(this.dims,e))}squeeze_(e=null){return this.dims=b(this.dims,e),this}unsqueeze(e=null){return new A(this.type,this.data,C(this.dims,e))}unsqueeze_(e=null){return this.dims=C(this.dims,e),this}flatten_(e=0,t=-1){t=(t+this.dims.length)%this.dims.length;let n=this.dims.slice(0,e),r=this.dims.slice(e,t+1),s=this.dims.slice(t+1);return this.dims=[...n,r.reduce(((e,t)=>e*t),1),...s],this}flatten(e=0,t=-1){return this.clone().flatten_(e,t)}view(...e){let t=-1;for(let n=0;n<e.length;++n)if(-1===e[n]){if(-1!==t)throw new Error("Only one dimension can be inferred");t=n}const n=this.data;if(-1!==t){const r=e.reduce(((e,n,r)=>r!==t?e*n:e),1);e[t]=n.length/r}return new A(this.type,n,e)}neg_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=-e[t];return this}neg(){return this.clone().neg_()}gt(e){const t=new Uint8Array(this.data.length),n=this.data;for(let r=0;r<n.length;++r)t[r]=n[r]>e?1:0;return new A("bool",t,this.dims)}lt(e){const t=new Uint8Array(this.data.length),n=this.data;for(let r=0;r<n.length;++r)t[r]=n[r]<e?1:0;return new A("bool",t,this.dims)}clamp_(e,t){const n=this.data;for(let r=0;r<n.length;++r)n[r]=Math.min(Math.max(n[r],e),t);return this}clamp(e,t){return this.clone().clamp_(e,t)}round_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=Math.round(e[t]);return this}round(){return this.clone().round_()}mean(e=null,t=!1){return v(this,e,t)}min(e=null,t=!1){if(null===e){const e=(0,r.min)(this.data)[0];return new A(this.type,[e],[])}const[n,s,a]=x(((e,t)=>Math.min(e,t)),this,e,t,1/0);return new A(n,s,a)}max(e=null,t=!1){if(null===e){const e=(0,r.max)(this.data)[0];return new A(this.type,[e],[])}const[n,s,a]=x(((e,t)=>Math.max(e,t)),this,e,t,-1/0);return new A(n,s,a)}argmin(e=null,t=!1){if(null!==e)throw new Error("`dim !== null` not yet implemented.");const n=(0,r.min)(this.data)[1];return new A("int64",[BigInt(n)],[])}argmax(e=null,t=!1){if(null!==e)throw new Error("`dim !== null` not yet implemented.");const n=(0,r.max)(this.data)[1];return new A("int64",[BigInt(n)],[])}to(e){if(this.type===e)return this;if(!i.hasOwnProperty(e))throw new Error(`Unsupported type: ${e}`);let t;const n=["int64","uint64"].includes(this.type),r=["int64","uint64"].includes(e);return n&&!r?t=Number:!n&&r&&(t=BigInt),new A(e,i[e].from(this.data,t),this.dims)}}function o(e,t){const[n,s]=(0,r.permute_data)(e.data,e.dims,t);return new A(e.type,n,s)}function l(e,[t,n],s="bilinear",a=!1){const i=e.dims.at(-3)??1,o=e.dims.at(-2),l=e.dims.at(-1);let u=(0,r.interpolate_data)(e.data,[i,o,l],[t,n],s,a);return new A(e.type,u,[i,t,n])}async function u(e,{size:t=null,mode:n="bilinear"}={}){if(4!==e.dims.length)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!t)throw new Error("`interpolate_4d` requires a `size` argument.");let r,s;if(2===t.length)r=[...e.dims.slice(0,2),...t];else if(3===t.length)r=[e.dims[0],...t];else{if(4!==t.length)throw new Error("`size` must be of length 2, 3, or 4.");r=t}if("nearest"===n)s=await a.TensorOpRegistry.nearest_interpolate_4d;else if("bilinear"===n)s=await a.TensorOpRegistry.bilinear_interpolate_4d;else{if("bicubic"!==n)throw new Error(`Unsupported mode: ${n}`);s=await a.TensorOpRegistry.bicubic_interpolate_4d}const i=new A("int64",new BigInt64Array(r.map(BigInt)),[r.length]);return await s({x:e,s:i})}async function c(e,t){const n=await a.TensorOpRegistry.matmul;return await n({a:e,b:t})}async function d(e,t){const n=await a.TensorOpRegistry.rfft;return await n({x:e,a:t})}async function h(e,t){const n=await a.TensorOpRegistry.top_k;return t=null==t?e.dims.at(-1):Math.min(t,e.dims.at(-1)),await n({x:e,k:new A("int64",[BigInt(t)],[1])})}const f=e=>new A("int64",e,[e.length]);async function g(e,t,n,r,s){const i=await a.TensorOpRegistry.slice;return await i({x:e,s:f(t),e:f(n),a:f(r),t:f(s??new Array(r.length).fill(1))})}function p(e,t){const n=e.data,r=t.data,s=[e.dims[0],e.dims[2]],a=new n.constructor(s[0]*s[1]),[i,o,l]=e.dims;let u=0;for(let e=0;e<i;++e){const t=e*l*o;for(let s=0;s<l;++s){let i=0,A=0;const c=e*o,d=t+s;for(let e=0;e<o;++e){const t=Number(r[c+e]);A+=t,i+=n[d+e*l]*t}const h=i/A;a[u++]=h}}return new A(e.type,a,s)}function m(e,t,{eps:n=1e-5}={}){if(2!==e.dims.length)throw new Error("`layer_norm` currently only supports 2D input.");const[r,s]=e.dims;if(1!==t.length&&t[0]!==s)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[a,i]=y(e,1,0,!0),o=a.data,l=i.data,u=e.data,c=new u.constructor(u.length);for(let e=0;e<r;++e){const t=e*s;for(let r=0;r<s;++r){const s=t+r;c[s]=(u[s]-l[e])/(o[e]+n)}}return new A(e.type,c,e.dims)}function b(e,t){return e=e.slice(),null===t?e=e.filter((e=>1!==e)):"number"==typeof t?1===e[t]&&e.splice(t,1):Array.isArray(t)&&(e=e.filter(((e,n)=>1!==e||!t.includes(n)))),e}function C(e,t){return t=I(t,e.length+1),(e=e.slice()).splice(t,0,1),e}function I(e,t,n=null,r=!0){if(e<-t||e>=t){if(r)throw new Error(`IndexError: index ${e} is out of bounds for dimension${null===n?"":" "+n} with size ${t}`);return e<-t?0:t}return e<0&&(e=(e%t+t)%t),e}function w(e,t=0){t=I(t,e[0].dims.length);const n=e[0].dims.slice();n[t]=e.reduce(((e,n)=>e+n.dims[t]),0);const r=n.reduce(((e,t)=>e*t),1),s=new e[0].data.constructor(r),a=e[0].type;if(0===t){let t=0;for(const n of e){const e=n.data;s.set(e,t),t+=e.length}}else{let r=0;for(let a=0;a<e.length;++a){const{data:i,dims:A}=e[a];for(let e=0;e<i.length;++e){let a=0;for(let s=A.length-1,i=e,o=1;s>=0;--s){const e=A[s];let l=i%e;s===t&&(l+=r),a+=l*o,o*=n[s],i=Math.floor(i/e)}s[a]=i[e]}r+=A[t]}}return new A(a,s,n)}function k(e,t=0){return w(e.map((e=>e.unsqueeze(t))),t)}function x(e,t,n=null,r=!1,s=null){const a=t.data,i=t.dims;n=I(n,i.length);const A=i.slice();A[n]=1;const o=new a.constructor(a.length/i[n]);null!==s&&o.fill(s);for(let t=0;t<a.length;++t){let r=0;for(let e=i.length-1,s=t,a=1;e>=0;--e){const t=i[e];if(e!==n){r+=s%t*a,a*=A[e]}s=Math.floor(s/t)}o[r]=e(o[r],a[t],t,r)}return r||A.splice(n,1),[t.type,o,A]}function y(e,t=null,n=1,r=!1){const s=e.data,a=e.dims;if(null===t){const t=s.reduce(((e,t)=>e+t),0),r=t/s.length,a=Math.sqrt(s.reduce(((e,t)=>e+(t-r)**2),0)/(s.length-n)),i=new A(e.type,[r],[]);return[new A(e.type,[a],[]),i]}const i=v(e,t=I(t,a.length),r),o=i.data,[l,u,c]=x(((e,t,n,r)=>e+(t-o[r])**2),e,t,r);for(let e=0;e<u.length;++e)u[e]=Math.sqrt(u[e]/(a[t]-n));return[new A(l,u,c),i]}function v(e,t=null,n=!1){const r=e.dims,s=e.data;if(null===t){const t=s.reduce(((e,t)=>e+t),0);return new A(e.type,[t/s.length],[])}t=I(t,r.length);const[a,i,o]=x(((e,t)=>e+t),e,t,n);if(1!==r[t])for(let e=0;e<i.length;++e)i[e]/=r[t];return new A(a,i,o)}function E(e,t,n,r){const s=e.reduce(((e,t)=>e*t),1);return new A(n,new r(s).fill(t),e)}function B(e,t){let n,r;if("number"==typeof t)n="float32",r=Float32Array;else if("bigint"==typeof t)n="int64",r=BigInt64Array;else{if("boolean"!=typeof t)throw new Error("Unsupported data type: "+typeof t);n="bool",r=Uint8Array}return E(e,t,n,r)}function M(e,t){return B(e.dims,t)}function D(e){return E(e,1n,"int64",BigInt64Array)}function T(e){return D(e.dims)}function S(e){return E(e,0n,"int64",BigInt64Array)}function N(e){return S(e.dims)}function G(e){const t=e.reduce(((e,t)=>e*t),1);return new A("float32",Float32Array.from({length:t},(()=>Math.random())),e)}function F(e,t){if(2!==e.dims.length)throw new Error("The tensor must have 2 dimensions");if(e.dims.at(-1)%8!=0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(t))throw new Error("The precision must be either 'binary' or 'ubinary'");const n="binary"===t,r=n?"int8":"uint8",s=n?Int8Array:Uint8Array,a=e.data,i=new s(a.length/8);for(let e=0;e<a.length;++e){const t=a[e]>0?1:0,r=Math.floor(e/8),s=e%8;i[r]|=t<<7-s,n&&0===s&&(i[r]-=128)}return new A(r,i,[e.dims[0],e.dims[1]/8])}},"./src/utils/video.js":(e,t,n)=>{n.r(t),n.d(t,{RawVideo:()=>i,RawVideoFrame:()=>a,load_video:()=>A});var r=n("./src/utils/image.js"),s=n("./src/env.js");class a{constructor(e,t){this.image=e,this.timestamp=t}}class i{constructor(e,t){e.length>0&&e[0]instanceof r.RawImage&&(e=e.map(((n,r)=>new a(n,(r+1)/(e.length+1)*t)))),this.frames=e,this.duration=t}get width(){return this.frames[0].image.width}get height(){return this.frames[0].image.height}get fps(){return this.frames.length/this.duration}}async function A(e,{num_frames:t=null,fps:n=null}={}){if(!s.apis.IS_BROWSER_ENV)throw new Error("`load_video` is currently only supported in browser environments.");if(null==t&&null==n)throw new Error("Either num_frames or fps must be provided.");const A=[],o=document.createElement("video");if(o.crossOrigin="anonymous",o.muted=!0,"string"==typeof e)o.src=e;else if(e instanceof Blob)o.src=URL.createObjectURL(e);else{if(!(e instanceof HTMLVideoElement))throw new Error("Invalid URL or video element provided.");o.src=e.src}if(await new Promise((e=>o.onloadedmetadata=e)),o.seekable.start(0)===o.seekable.end(0)){const e=await fetch(o.src),t=await e.blob();o.src=URL.createObjectURL(t),await new Promise((e=>o.onloadedmetadata=e))}const l=o.duration;let u,c;null!=t?(u=t,c=1===t?0:l/(t-1)):(c=1/n,u=Math.floor(l/c));let d=[];for(let e=0;e<u;++e)d.push(1===t?l/2:e*c);const h=document.createElement("canvas");h.width=o.videoWidth,h.height=o.videoHeight;const f=h.getContext("2d",{willReadFrequently:!0});for(const e of d){o.currentTime=e,await new Promise((e=>{o.onseeked=e})),f.drawImage(o,0,0,h.width,h.height);const t=f.getImageData(0,0,h.width,h.height),n=new r.RawImage(t.data,h.width,h.height,4),s=new a(n,e);A.push(s)}return o.remove(),new i(A,l)}}},Rc={};function Lc(e){var t=Rc[e];if(void 0!==t)return t.exports;var n=Rc[e]={exports:{}};return Oc[e](n,n.exports,Lc),n.exports}Qc=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,Lc.t=function(e,t){if(1&t&&(e=this(e)),8&t)return e;if("object"==typeof e&&e){if(4&t&&e.__esModule)return e;if(16&t&&"function"==typeof e.then)return e}var n=Object.create(null);Lc.r(n);var r={};Pc=Pc||[null,Qc({}),Qc([]),Qc(Qc)];for(var s=2&t&&e;"object"==typeof s&&!~Pc.indexOf(s);s=Qc(s))Object.getOwnPropertyNames(s).forEach((t=>r[t]=()=>e[t]));return r.default=()=>e,Lc.d(n,r),n},Lc.d=(e,t)=>{for(var n in t)Lc.o(t,n)&&!Lc.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},Lc.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),Lc.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var Wc={};(()=>{Lc.r(Wc),Lc.d(Wc,{ASTFeatureExtractor:()=>c.ASTFeatureExtractor,ASTForAudioClassification:()=>n.ASTForAudioClassification,ASTModel:()=>n.ASTModel,ASTPreTrainedModel:()=>n.ASTPreTrainedModel,AlbertForMaskedLM:()=>n.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>n.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>n.AlbertForSequenceClassification,AlbertModel:()=>n.AlbertModel,AlbertPreTrainedModel:()=>n.AlbertPreTrainedModel,AlbertTokenizer:()=>r.AlbertTokenizer,AudioClassificationPipeline:()=>t.AudioClassificationPipeline,AutoConfig:()=>s.AutoConfig,AutoFeatureExtractor:()=>d.AutoFeatureExtractor,AutoImageProcessor:()=>g.AutoImageProcessor,AutoModel:()=>n.AutoModel,AutoModelForAudioClassification:()=>n.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>n.AutoModelForAudioFrameClassification,AutoModelForAudioTextToText:()=>n.AutoModelForAudioTextToText,AutoModelForCTC:()=>n.AutoModelForCTC,AutoModelForCausalLM:()=>n.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>n.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>n.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>n.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>n.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>n.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>n.AutoModelForImageSegmentation,AutoModelForImageTextToText:()=>n.AutoModelForImageTextToText,AutoModelForImageToImage:()=>n.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>n.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>n.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>n.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>n.AutoModelForObjectDetection,AutoModelForPoseEstimation:()=>n.AutoModelForPoseEstimation,AutoModelForQuestionAnswering:()=>n.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>n.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>n.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>n.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>n.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>n.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>n.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>n.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>n.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>n.AutoModelForVision2Seq,AutoModelForXVector:()=>n.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>n.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>b.AutoProcessor,AutoTokenizer:()=>r.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>t.AutomaticSpeechRecognitionPipeline,BackgroundRemovalPipeline:()=>t.BackgroundRemovalPipeline,BartForConditionalGeneration:()=>n.BartForConditionalGeneration,BartForSequenceClassification:()=>n.BartForSequenceClassification,BartModel:()=>n.BartModel,BartPretrainedModel:()=>n.BartPretrainedModel,BartTokenizer:()=>r.BartTokenizer,BaseModelOutput:()=>n.BaseModelOutput,BaseStreamer:()=>C.BaseStreamer,BeitFeatureExtractor:()=>f.BeitFeatureExtractor,BeitForImageClassification:()=>n.BeitForImageClassification,BeitModel:()=>n.BeitModel,BeitPreTrainedModel:()=>n.BeitPreTrainedModel,BertForMaskedLM:()=>n.BertForMaskedLM,BertForQuestionAnswering:()=>n.BertForQuestionAnswering,BertForSequenceClassification:()=>n.BertForSequenceClassification,BertForTokenClassification:()=>n.BertForTokenClassification,BertModel:()=>n.BertModel,BertPreTrainedModel:()=>n.BertPreTrainedModel,BertTokenizer:()=>r.BertTokenizer,BitImageProcessor:()=>f.BitImageProcessor,BlenderbotForConditionalGeneration:()=>n.BlenderbotForConditionalGeneration,BlenderbotModel:()=>n.BlenderbotModel,BlenderbotPreTrainedModel:()=>n.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>n.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>n.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>n.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>r.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>r.BlenderbotTokenizer,BloomForCausalLM:()=>n.BloomForCausalLM,BloomModel:()=>n.BloomModel,BloomPreTrainedModel:()=>n.BloomPreTrainedModel,BloomTokenizer:()=>r.BloomTokenizer,CLIPFeatureExtractor:()=>f.CLIPFeatureExtractor,CLIPImageProcessor:()=>f.CLIPImageProcessor,CLIPModel:()=>n.CLIPModel,CLIPPreTrainedModel:()=>n.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>n.CLIPSegForImageSegmentation,CLIPSegModel:()=>n.CLIPSegModel,CLIPSegPreTrainedModel:()=>n.CLIPSegPreTrainedModel,CLIPTextModel:()=>n.CLIPTextModel,CLIPTextModelWithProjection:()=>n.CLIPTextModelWithProjection,CLIPTokenizer:()=>r.CLIPTokenizer,CLIPVisionModel:()=>n.CLIPVisionModel,CLIPVisionModelWithProjection:()=>n.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>n.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>n.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>n.CamembertForSequenceClassification,CamembertForTokenClassification:()=>n.CamembertForTokenClassification,CamembertModel:()=>n.CamembertModel,CamembertPreTrainedModel:()=>n.CamembertPreTrainedModel,CamembertTokenizer:()=>r.CamembertTokenizer,CausalLMOutput:()=>n.CausalLMOutput,CausalLMOutputWithPast:()=>n.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>f.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>n.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>n.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>n.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>c.ClapFeatureExtractor,ClapModel:()=>n.ClapModel,ClapPreTrainedModel:()=>n.ClapPreTrainedModel,ClapTextModelWithProjection:()=>n.ClapTextModelWithProjection,ClassifierFreeGuidanceLogitsProcessor:()=>w.ClassifierFreeGuidanceLogitsProcessor,CodeGenForCausalLM:()=>n.CodeGenForCausalLM,CodeGenModel:()=>n.CodeGenModel,CodeGenPreTrainedModel:()=>n.CodeGenPreTrainedModel,CodeGenTokenizer:()=>r.CodeGenTokenizer,CodeLlamaTokenizer:()=>r.CodeLlamaTokenizer,CohereForCausalLM:()=>n.CohereForCausalLM,CohereModel:()=>n.CohereModel,CoherePreTrainedModel:()=>n.CoherePreTrainedModel,CohereTokenizer:()=>r.CohereTokenizer,ConvBertForMaskedLM:()=>n.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>n.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>n.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>n.ConvBertForTokenClassification,ConvBertModel:()=>n.ConvBertModel,ConvBertPreTrainedModel:()=>n.ConvBertPreTrainedModel,ConvBertTokenizer:()=>r.ConvBertTokenizer,ConvNextFeatureExtractor:()=>f.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>n.ConvNextForImageClassification,ConvNextImageProcessor:()=>f.ConvNextImageProcessor,ConvNextModel:()=>n.ConvNextModel,ConvNextPreTrainedModel:()=>n.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>n.ConvNextV2ForImageClassification,ConvNextV2Model:()=>n.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>n.ConvNextV2PreTrainedModel,DFineForObjectDetection:()=>n.DFineForObjectDetection,DFineModel:()=>n.DFineModel,DFinePreTrainedModel:()=>n.DFinePreTrainedModel,DPTFeatureExtractor:()=>f.DPTFeatureExtractor,DPTForDepthEstimation:()=>n.DPTForDepthEstimation,DPTImageProcessor:()=>f.DPTImageProcessor,DPTModel:()=>n.DPTModel,DPTPreTrainedModel:()=>n.DPTPreTrainedModel,DacDecoderModel:()=>n.DacDecoderModel,DacDecoderOutput:()=>n.DacDecoderOutput,DacEncoderModel:()=>n.DacEncoderModel,DacEncoderOutput:()=>n.DacEncoderOutput,DacFeatureExtractor:()=>c.DacFeatureExtractor,DacModel:()=>n.DacModel,DacPreTrainedModel:()=>n.DacPreTrainedModel,DataTypeMap:()=>o.DataTypeMap,DebertaForMaskedLM:()=>n.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>n.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>n.DebertaForSequenceClassification,DebertaForTokenClassification:()=>n.DebertaForTokenClassification,DebertaModel:()=>n.DebertaModel,DebertaPreTrainedModel:()=>n.DebertaPreTrainedModel,DebertaTokenizer:()=>r.DebertaTokenizer,DebertaV2ForMaskedLM:()=>n.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>n.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>n.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>n.DebertaV2ForTokenClassification,DebertaV2Model:()=>n.DebertaV2Model,DebertaV2PreTrainedModel:()=>n.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>r.DebertaV2Tokenizer,DecisionTransformerModel:()=>n.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>n.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>f.DeiTFeatureExtractor,DeiTForImageClassification:()=>n.DeiTForImageClassification,DeiTImageProcessor:()=>f.DeiTImageProcessor,DeiTModel:()=>n.DeiTModel,DeiTPreTrainedModel:()=>n.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>n.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>n.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>t.DepthEstimationPipeline,DepthProForDepthEstimation:()=>n.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>n.DepthProPreTrainedModel,DetrFeatureExtractor:()=>f.DetrFeatureExtractor,DetrForObjectDetection:()=>n.DetrForObjectDetection,DetrForSegmentation:()=>n.DetrForSegmentation,DetrImageProcessor:()=>f.DetrImageProcessor,DetrModel:()=>n.DetrModel,DetrObjectDetectionOutput:()=>n.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>n.DetrPreTrainedModel,DetrSegmentationOutput:()=>n.DetrSegmentationOutput,Dinov2ForImageClassification:()=>n.Dinov2ForImageClassification,Dinov2Model:()=>n.Dinov2Model,Dinov2PreTrainedModel:()=>n.Dinov2PreTrainedModel,Dinov2WithRegistersForImageClassification:()=>n.Dinov2WithRegistersForImageClassification,Dinov2WithRegistersModel:()=>n.Dinov2WithRegistersModel,Dinov2WithRegistersPreTrainedModel:()=>n.Dinov2WithRegistersPreTrainedModel,DistilBertForMaskedLM:()=>n.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>n.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>n.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>n.DistilBertForTokenClassification,DistilBertModel:()=>n.DistilBertModel,DistilBertPreTrainedModel:()=>n.DistilBertPreTrainedModel,DistilBertTokenizer:()=>r.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>t.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>f.DonutFeatureExtractor,DonutImageProcessor:()=>f.DonutImageProcessor,DonutSwinModel:()=>n.DonutSwinModel,DonutSwinPreTrainedModel:()=>n.DonutSwinPreTrainedModel,EfficientNetForImageClassification:()=>n.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>f.EfficientNetImageProcessor,EfficientNetModel:()=>n.EfficientNetModel,EfficientNetPreTrainedModel:()=>n.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>n.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>n.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>n.ElectraForSequenceClassification,ElectraForTokenClassification:()=>n.ElectraForTokenClassification,ElectraModel:()=>n.ElectraModel,ElectraPreTrainedModel:()=>n.ElectraPreTrainedModel,ElectraTokenizer:()=>r.ElectraTokenizer,EncodecFeatureExtractor:()=>c.EncodecFeatureExtractor,EosTokenCriteria:()=>I.EosTokenCriteria,EsmForMaskedLM:()=>n.EsmForMaskedLM,EsmForSequenceClassification:()=>n.EsmForSequenceClassification,EsmForTokenClassification:()=>n.EsmForTokenClassification,EsmModel:()=>n.EsmModel,EsmPreTrainedModel:()=>n.EsmPreTrainedModel,EsmTokenizer:()=>r.EsmTokenizer,ExaoneForCausalLM:()=>n.ExaoneForCausalLM,ExaoneModel:()=>n.ExaoneModel,ExaonePreTrainedModel:()=>n.ExaonePreTrainedModel,FFT:()=>l.FFT,FalconForCausalLM:()=>n.FalconForCausalLM,FalconModel:()=>n.FalconModel,FalconPreTrainedModel:()=>n.FalconPreTrainedModel,FalconTokenizer:()=>r.FalconTokenizer,FastViTForImageClassification:()=>n.FastViTForImageClassification,FastViTModel:()=>n.FastViTModel,FastViTPreTrainedModel:()=>n.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>t.FeatureExtractionPipeline,FeatureExtractor:()=>u.FeatureExtractor,FillMaskPipeline:()=>t.FillMaskPipeline,Florence2ForConditionalGeneration:()=>n.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>n.Florence2PreTrainedModel,Florence2Processor:()=>m.Florence2Processor,ForcedBOSTokenLogitsProcessor:()=>w.ForcedBOSTokenLogitsProcessor,ForcedEOSTokenLogitsProcessor:()=>w.ForcedEOSTokenLogitsProcessor,GLPNFeatureExtractor:()=>f.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>n.GLPNForDepthEstimation,GLPNModel:()=>n.GLPNModel,GLPNPreTrainedModel:()=>n.GLPNPreTrainedModel,GPT2LMHeadModel:()=>n.GPT2LMHeadModel,GPT2Model:()=>n.GPT2Model,GPT2PreTrainedModel:()=>n.GPT2PreTrainedModel,GPT2Tokenizer:()=>r.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>n.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>n.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>n.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>n.GPTJForCausalLM,GPTJModel:()=>n.GPTJModel,GPTJPreTrainedModel:()=>n.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>n.GPTNeoForCausalLM,GPTNeoModel:()=>n.GPTNeoModel,GPTNeoPreTrainedModel:()=>n.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>n.GPTNeoXForCausalLM,GPTNeoXModel:()=>n.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>n.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>r.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>n.Gemma2ForCausalLM,Gemma2Model:()=>n.Gemma2Model,Gemma2PreTrainedModel:()=>n.Gemma2PreTrainedModel,Gemma3ForCausalLM:()=>n.Gemma3ForCausalLM,Gemma3Model:()=>n.Gemma3Model,Gemma3PreTrainedModel:()=>n.Gemma3PreTrainedModel,GemmaForCausalLM:()=>n.GemmaForCausalLM,GemmaModel:()=>n.GemmaModel,GemmaPreTrainedModel:()=>n.GemmaPreTrainedModel,GemmaTokenizer:()=>r.GemmaTokenizer,GlmForCausalLM:()=>n.GlmForCausalLM,GlmModel:()=>n.GlmModel,GlmPreTrainedModel:()=>n.GlmPreTrainedModel,GraniteForCausalLM:()=>n.GraniteForCausalLM,GraniteModel:()=>n.GraniteModel,GranitePreTrainedModel:()=>n.GranitePreTrainedModel,Grok1Tokenizer:()=>r.Grok1Tokenizer,GroundingDinoForObjectDetection:()=>n.GroundingDinoForObjectDetection,GroundingDinoImageProcessor:()=>f.GroundingDinoImageProcessor,GroundingDinoPreTrainedModel:()=>n.GroundingDinoPreTrainedModel,GroundingDinoProcessor:()=>m.GroundingDinoProcessor,GroupViTModel:()=>n.GroupViTModel,GroupViTPreTrainedModel:()=>n.GroupViTPreTrainedModel,HeliumForCausalLM:()=>n.HeliumForCausalLM,HeliumModel:()=>n.HeliumModel,HeliumPreTrainedModel:()=>n.HeliumPreTrainedModel,HerbertTokenizer:()=>r.HerbertTokenizer,HieraForImageClassification:()=>n.HieraForImageClassification,HieraModel:()=>n.HieraModel,HieraPreTrainedModel:()=>n.HieraPreTrainedModel,HubertForCTC:()=>n.HubertForCTC,HubertForSequenceClassification:()=>n.HubertForSequenceClassification,HubertModel:()=>n.HubertModel,HubertPreTrainedModel:()=>n.HubertPreTrainedModel,IJepaForImageClassification:()=>n.IJepaForImageClassification,IJepaModel:()=>n.IJepaModel,IJepaPreTrainedModel:()=>n.IJepaPreTrainedModel,Idefics3ForConditionalGeneration:()=>n.Idefics3ForConditionalGeneration,Idefics3ImageProcessor:()=>f.Idefics3ImageProcessor,Idefics3PreTrainedModel:()=>n.Idefics3PreTrainedModel,Idefics3Processor:()=>m.Idefics3Processor,ImageClassificationPipeline:()=>t.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>t.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>c.ImageFeatureExtractor,ImageMattingOutput:()=>n.ImageMattingOutput,ImageProcessor:()=>h.ImageProcessor,ImageSegmentationPipeline:()=>t.ImageSegmentationPipeline,ImageToImagePipeline:()=>t.ImageToImagePipeline,ImageToTextPipeline:()=>t.ImageToTextPipeline,InterruptableStoppingCriteria:()=>I.InterruptableStoppingCriteria,JAISLMHeadModel:()=>n.JAISLMHeadModel,JAISModel:()=>n.JAISModel,JAISPreTrainedModel:()=>n.JAISPreTrainedModel,JinaCLIPImageProcessor:()=>f.JinaCLIPImageProcessor,JinaCLIPModel:()=>n.JinaCLIPModel,JinaCLIPPreTrainedModel:()=>n.JinaCLIPPreTrainedModel,JinaCLIPProcessor:()=>m.JinaCLIPProcessor,JinaCLIPTextModel:()=>n.JinaCLIPTextModel,JinaCLIPVisionModel:()=>n.JinaCLIPVisionModel,LiteWhisperForConditionalGeneration:()=>n.LiteWhisperForConditionalGeneration,LlamaForCausalLM:()=>n.LlamaForCausalLM,LlamaModel:()=>n.LlamaModel,LlamaPreTrainedModel:()=>n.LlamaPreTrainedModel,LlamaTokenizer:()=>r.LlamaTokenizer,LlavaForConditionalGeneration:()=>n.LlavaForConditionalGeneration,LlavaOnevisionForConditionalGeneration:()=>n.LlavaOnevisionForConditionalGeneration,LlavaOnevisionImageProcessor:()=>f.LlavaOnevisionImageProcessor,LlavaPreTrainedModel:()=>n.LlavaPreTrainedModel,LogitsProcessor:()=>w.LogitsProcessor,LogitsProcessorList:()=>w.LogitsProcessorList,LogitsWarper:()=>w.LogitsWarper,LongT5ForConditionalGeneration:()=>n.LongT5ForConditionalGeneration,LongT5Model:()=>n.LongT5Model,LongT5PreTrainedModel:()=>n.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>n.M2M100ForConditionalGeneration,M2M100Model:()=>n.M2M100Model,M2M100PreTrainedModel:()=>n.M2M100PreTrainedModel,M2M100Tokenizer:()=>r.M2M100Tokenizer,MBart50Tokenizer:()=>r.MBart50Tokenizer,MBartForCausalLM:()=>n.MBartForCausalLM,MBartForConditionalGeneration:()=>n.MBartForConditionalGeneration,MBartForSequenceClassification:()=>n.MBartForSequenceClassification,MBartModel:()=>n.MBartModel,MBartPreTrainedModel:()=>n.MBartPreTrainedModel,MBartTokenizer:()=>r.MBartTokenizer,MPNetForMaskedLM:()=>n.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>n.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>n.MPNetForSequenceClassification,MPNetForTokenClassification:()=>n.MPNetForTokenClassification,MPNetModel:()=>n.MPNetModel,MPNetPreTrainedModel:()=>n.MPNetPreTrainedModel,MPNetTokenizer:()=>r.MPNetTokenizer,MT5ForConditionalGeneration:()=>n.MT5ForConditionalGeneration,MT5Model:()=>n.MT5Model,MT5PreTrainedModel:()=>n.MT5PreTrainedModel,MarianMTModel:()=>n.MarianMTModel,MarianModel:()=>n.MarianModel,MarianPreTrainedModel:()=>n.MarianPreTrainedModel,MarianTokenizer:()=>r.MarianTokenizer,Mask2FormerImageProcessor:()=>f.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>f.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>n.MaskFormerForInstanceSegmentation,MaskFormerImageProcessor:()=>f.MaskFormerImageProcessor,MaskFormerModel:()=>n.MaskFormerModel,MaskFormerPreTrainedModel:()=>n.MaskFormerPreTrainedModel,MaskedLMOutput:()=>n.MaskedLMOutput,MaxLengthCriteria:()=>I.MaxLengthCriteria,Metric3DForDepthEstimation:()=>n.Metric3DForDepthEstimation,Metric3DPreTrainedModel:()=>n.Metric3DPreTrainedModel,Metric3Dv2ForDepthEstimation:()=>n.Metric3Dv2ForDepthEstimation,Metric3Dv2PreTrainedModel:()=>n.Metric3Dv2PreTrainedModel,MgpstrForSceneTextRecognition:()=>n.MgpstrForSceneTextRecognition,MgpstrModelOutput:()=>n.MgpstrModelOutput,MgpstrPreTrainedModel:()=>n.MgpstrPreTrainedModel,MgpstrProcessor:()=>m.MgpstrProcessor,MgpstrTokenizer:()=>r.MgpstrTokenizer,MimiDecoderModel:()=>n.MimiDecoderModel,MimiDecoderOutput:()=>n.MimiDecoderOutput,MimiEncoderModel:()=>n.MimiEncoderModel,MimiEncoderOutput:()=>n.MimiEncoderOutput,MimiModel:()=>n.MimiModel,MimiPreTrainedModel:()=>n.MimiPreTrainedModel,MinLengthLogitsProcessor:()=>w.MinLengthLogitsProcessor,MinNewTokensLengthLogitsProcessor:()=>w.MinNewTokensLengthLogitsProcessor,MistralForCausalLM:()=>n.MistralForCausalLM,MistralModel:()=>n.MistralModel,MistralPreTrainedModel:()=>n.MistralPreTrainedModel,MobileBertForMaskedLM:()=>n.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>n.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>n.MobileBertForSequenceClassification,MobileBertModel:()=>n.MobileBertModel,MobileBertPreTrainedModel:()=>n.MobileBertPreTrainedModel,MobileBertTokenizer:()=>r.MobileBertTokenizer,MobileLLMForCausalLM:()=>n.MobileLLMForCausalLM,MobileLLMModel:()=>n.MobileLLMModel,MobileLLMPreTrainedModel:()=>n.MobileLLMPreTrainedModel,MobileNetV1FeatureExtractor:()=>f.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>n.MobileNetV1ForImageClassification,MobileNetV1ForSemanticSegmentation:()=>n.MobileNetV1ForSemanticSegmentation,MobileNetV1ImageProcessor:()=>f.MobileNetV1ImageProcessor,MobileNetV1Model:()=>n.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>n.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>f.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>n.MobileNetV2ForImageClassification,MobileNetV2ForSemanticSegmentation:()=>n.MobileNetV2ForSemanticSegmentation,MobileNetV2ImageProcessor:()=>f.MobileNetV2ImageProcessor,MobileNetV2Model:()=>n.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>n.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>f.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>n.MobileNetV3ForImageClassification,MobileNetV3ForSemanticSegmentation:()=>n.MobileNetV3ForSemanticSegmentation,MobileNetV3ImageProcessor:()=>f.MobileNetV3ImageProcessor,MobileNetV3Model:()=>n.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>n.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>f.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>n.MobileNetV4ForImageClassification,MobileNetV4ForSemanticSegmentation:()=>n.MobileNetV4ForSemanticSegmentation,MobileNetV4ImageProcessor:()=>f.MobileNetV4ImageProcessor,MobileNetV4Model:()=>n.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>n.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>f.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>n.MobileViTForImageClassification,MobileViTImageProcessor:()=>f.MobileViTImageProcessor,MobileViTModel:()=>n.MobileViTModel,MobileViTPreTrainedModel:()=>n.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>n.MobileViTV2ForImageClassification,MobileViTV2Model:()=>n.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>n.MobileViTV2PreTrainedModel,ModelOutput:()=>n.ModelOutput,ModernBertForMaskedLM:()=>n.ModernBertForMaskedLM,ModernBertForSequenceClassification:()=>n.ModernBertForSequenceClassification,ModernBertForTokenClassification:()=>n.ModernBertForTokenClassification,ModernBertModel:()=>n.ModernBertModel,ModernBertPreTrainedModel:()=>n.ModernBertPreTrainedModel,Moondream1ForConditionalGeneration:()=>n.Moondream1ForConditionalGeneration,MoonshineFeatureExtractor:()=>c.MoonshineFeatureExtractor,MoonshineForConditionalGeneration:()=>n.MoonshineForConditionalGeneration,MoonshineModel:()=>n.MoonshineModel,MoonshinePreTrainedModel:()=>n.MoonshinePreTrainedModel,MoonshineProcessor:()=>m.MoonshineProcessor,MptForCausalLM:()=>n.MptForCausalLM,MptModel:()=>n.MptModel,MptPreTrainedModel:()=>n.MptPreTrainedModel,MultiModalityCausalLM:()=>n.MultiModalityCausalLM,MultiModalityPreTrainedModel:()=>n.MultiModalityPreTrainedModel,MusicgenForCausalLM:()=>n.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>n.MusicgenForConditionalGeneration,MusicgenModel:()=>n.MusicgenModel,MusicgenPreTrainedModel:()=>n.MusicgenPreTrainedModel,NllbTokenizer:()=>r.NllbTokenizer,NoBadWordsLogitsProcessor:()=>w.NoBadWordsLogitsProcessor,NoRepeatNGramLogitsProcessor:()=>w.NoRepeatNGramLogitsProcessor,NomicBertModel:()=>n.NomicBertModel,NomicBertPreTrainedModel:()=>n.NomicBertPreTrainedModel,NougatImageProcessor:()=>f.NougatImageProcessor,NougatTokenizer:()=>r.NougatTokenizer,OPTForCausalLM:()=>n.OPTForCausalLM,OPTModel:()=>n.OPTModel,OPTPreTrainedModel:()=>n.OPTPreTrainedModel,ObjectDetectionPipeline:()=>t.ObjectDetectionPipeline,Olmo2ForCausalLM:()=>n.Olmo2ForCausalLM,Olmo2Model:()=>n.Olmo2Model,Olmo2PreTrainedModel:()=>n.Olmo2PreTrainedModel,OlmoForCausalLM:()=>n.OlmoForCausalLM,OlmoModel:()=>n.OlmoModel,OlmoPreTrainedModel:()=>n.OlmoPreTrainedModel,OpenELMForCausalLM:()=>n.OpenELMForCausalLM,OpenELMModel:()=>n.OpenELMModel,OpenELMPreTrainedModel:()=>n.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>f.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>n.OwlViTForObjectDetection,OwlViTImageProcessor:()=>f.OwlViTImageProcessor,OwlViTModel:()=>n.OwlViTModel,OwlViTPreTrainedModel:()=>n.OwlViTPreTrainedModel,OwlViTProcessor:()=>m.OwlViTProcessor,Owlv2ForObjectDetection:()=>n.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>f.Owlv2ImageProcessor,Owlv2Model:()=>n.Owlv2Model,Owlv2PreTrainedModel:()=>n.Owlv2PreTrainedModel,PaliGemmaForConditionalGeneration:()=>n.PaliGemmaForConditionalGeneration,PaliGemmaPreTrainedModel:()=>n.PaliGemmaPreTrainedModel,PaliGemmaProcessor:()=>m.PaliGemmaProcessor,PatchTSMixerForPrediction:()=>n.PatchTSMixerForPrediction,PatchTSMixerModel:()=>n.PatchTSMixerModel,PatchTSMixerPreTrainedModel:()=>n.PatchTSMixerPreTrainedModel,PatchTSTForPrediction:()=>n.PatchTSTForPrediction,PatchTSTModel:()=>n.PatchTSTModel,PatchTSTPreTrainedModel:()=>n.PatchTSTPreTrainedModel,Phi3ForCausalLM:()=>n.Phi3ForCausalLM,Phi3Model:()=>n.Phi3Model,Phi3PreTrainedModel:()=>n.Phi3PreTrainedModel,Phi3VForCausalLM:()=>n.Phi3VForCausalLM,Phi3VImageProcessor:()=>f.Phi3VImageProcessor,Phi3VPreTrainedModel:()=>n.Phi3VPreTrainedModel,Phi3VProcessor:()=>m.Phi3VProcessor,PhiForCausalLM:()=>n.PhiForCausalLM,PhiModel:()=>n.PhiModel,PhiPreTrainedModel:()=>n.PhiPreTrainedModel,Pipeline:()=>t.Pipeline,PreTrainedModel:()=>n.PreTrainedModel,PreTrainedTokenizer:()=>r.PreTrainedTokenizer,PretrainedConfig:()=>s.PretrainedConfig,PretrainedMixin:()=>n.PretrainedMixin,Processor:()=>p.Processor,PvtForImageClassification:()=>n.PvtForImageClassification,PvtImageProcessor:()=>f.PvtImageProcessor,PvtModel:()=>n.PvtModel,PvtPreTrainedModel:()=>n.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>c.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>n.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>n.PyAnnoteModel,PyAnnotePreTrainedModel:()=>n.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>m.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>n.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>t.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>n.Qwen2ForCausalLM,Qwen2Model:()=>n.Qwen2Model,Qwen2PreTrainedModel:()=>n.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>r.Qwen2Tokenizer,Qwen2VLForConditionalGeneration:()=>n.Qwen2VLForConditionalGeneration,Qwen2VLImageProcessor:()=>f.Qwen2VLImageProcessor,Qwen2VLPreTrainedModel:()=>n.Qwen2VLPreTrainedModel,Qwen2VLProcessor:()=>m.Qwen2VLProcessor,Qwen3ForCausalLM:()=>n.Qwen3ForCausalLM,Qwen3Model:()=>n.Qwen3Model,Qwen3PreTrainedModel:()=>n.Qwen3PreTrainedModel,RFDetrForObjectDetection:()=>n.RFDetrForObjectDetection,RFDetrModel:()=>n.RFDetrModel,RFDetrObjectDetectionOutput:()=>n.RFDetrObjectDetectionOutput,RFDetrPreTrainedModel:()=>n.RFDetrPreTrainedModel,RTDetrForObjectDetection:()=>n.RTDetrForObjectDetection,RTDetrImageProcessor:()=>f.RTDetrImageProcessor,RTDetrModel:()=>n.RTDetrModel,RTDetrObjectDetectionOutput:()=>n.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>n.RTDetrPreTrainedModel,RTDetrV2ForObjectDetection:()=>n.RTDetrV2ForObjectDetection,RTDetrV2Model:()=>n.RTDetrV2Model,RTDetrV2ObjectDetectionOutput:()=>n.RTDetrV2ObjectDetectionOutput,RTDetrV2PreTrainedModel:()=>n.RTDetrV2PreTrainedModel,RawAudio:()=>a.RawAudio,RawImage:()=>i.RawImage,RawVideo:()=>A.RawVideo,RawVideoFrame:()=>A.RawVideoFrame,RepetitionPenaltyLogitsProcessor:()=>w.RepetitionPenaltyLogitsProcessor,ResNetForImageClassification:()=>n.ResNetForImageClassification,ResNetModel:()=>n.ResNetModel,ResNetPreTrainedModel:()=>n.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>n.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>n.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>n.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>n.RoFormerForTokenClassification,RoFormerModel:()=>n.RoFormerModel,RoFormerPreTrainedModel:()=>n.RoFormerPreTrainedModel,RoFormerTokenizer:()=>r.RoFormerTokenizer,RobertaForMaskedLM:()=>n.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>n.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>n.RobertaForSequenceClassification,RobertaForTokenClassification:()=>n.RobertaForTokenClassification,RobertaModel:()=>n.RobertaModel,RobertaPreTrainedModel:()=>n.RobertaPreTrainedModel,RobertaTokenizer:()=>r.RobertaTokenizer,SamImageProcessor:()=>f.SamImageProcessor,SamImageSegmentationOutput:()=>n.SamImageSegmentationOutput,SamModel:()=>n.SamModel,SamPreTrainedModel:()=>n.SamPreTrainedModel,SamProcessor:()=>m.SamProcessor,SapiensForDepthEstimation:()=>n.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>n.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>n.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>n.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>c.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>f.SegformerFeatureExtractor,SegformerForImageClassification:()=>n.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>n.SegformerForSemanticSegmentation,SegformerImageProcessor:()=>f.SegformerImageProcessor,SegformerModel:()=>n.SegformerModel,SegformerPreTrainedModel:()=>n.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>n.Seq2SeqLMOutput,SequenceClassifierOutput:()=>n.SequenceClassifierOutput,SiglipImageProcessor:()=>f.SiglipImageProcessor,SiglipModel:()=>n.SiglipModel,SiglipPreTrainedModel:()=>n.SiglipPreTrainedModel,SiglipTextModel:()=>n.SiglipTextModel,SiglipTokenizer:()=>r.SiglipTokenizer,SiglipVisionModel:()=>n.SiglipVisionModel,SmolVLMForConditionalGeneration:()=>n.SmolVLMForConditionalGeneration,SmolVLMImageProcessor:()=>f.SmolVLMImageProcessor,SmolVLMProcessor:()=>m.SmolVLMProcessor,SnacDecoderModel:()=>n.SnacDecoderModel,SnacEncoderModel:()=>n.SnacEncoderModel,SnacFeatureExtractor:()=>c.SnacFeatureExtractor,SnacModel:()=>n.SnacModel,SnacPreTrainedModel:()=>n.SnacPreTrainedModel,SpeechT5FeatureExtractor:()=>c.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>n.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>n.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>n.SpeechT5HifiGan,SpeechT5Model:()=>n.SpeechT5Model,SpeechT5PreTrainedModel:()=>n.SpeechT5PreTrainedModel,SpeechT5Processor:()=>m.SpeechT5Processor,SpeechT5Tokenizer:()=>r.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>n.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>n.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>n.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>n.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>n.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>r.SqueezeBertTokenizer,StableLmForCausalLM:()=>n.StableLmForCausalLM,StableLmModel:()=>n.StableLmModel,StableLmPreTrainedModel:()=>n.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>n.Starcoder2ForCausalLM,Starcoder2Model:()=>n.Starcoder2Model,Starcoder2PreTrainedModel:()=>n.Starcoder2PreTrainedModel,StoppingCriteria:()=>I.StoppingCriteria,StoppingCriteriaList:()=>I.StoppingCriteriaList,StyleTextToSpeech2Model:()=>n.StyleTextToSpeech2Model,StyleTextToSpeech2PreTrainedModel:()=>n.StyleTextToSpeech2PreTrainedModel,SummarizationPipeline:()=>t.SummarizationPipeline,SuppressTokensAtBeginLogitsProcessor:()=>w.SuppressTokensAtBeginLogitsProcessor,Swin2SRForImageSuperResolution:()=>n.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>f.Swin2SRImageProcessor,Swin2SRModel:()=>n.Swin2SRModel,Swin2SRPreTrainedModel:()=>n.Swin2SRPreTrainedModel,SwinForImageClassification:()=>n.SwinForImageClassification,SwinForSemanticSegmentation:()=>n.SwinForSemanticSegmentation,SwinModel:()=>n.SwinModel,SwinPreTrainedModel:()=>n.SwinPreTrainedModel,T5ForConditionalGeneration:()=>n.T5ForConditionalGeneration,T5Model:()=>n.T5Model,T5PreTrainedModel:()=>n.T5PreTrainedModel,T5Tokenizer:()=>r.T5Tokenizer,TableTransformerForObjectDetection:()=>n.TableTransformerForObjectDetection,TableTransformerModel:()=>n.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>n.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>n.TableTransformerPreTrainedModel,TemperatureLogitsWarper:()=>w.TemperatureLogitsWarper,Tensor:()=>o.Tensor,Text2TextGenerationPipeline:()=>t.Text2TextGenerationPipeline,TextClassificationPipeline:()=>t.TextClassificationPipeline,TextGenerationPipeline:()=>t.TextGenerationPipeline,TextStreamer:()=>C.TextStreamer,TextToAudioPipeline:()=>t.TextToAudioPipeline,TokenClassificationPipeline:()=>t.TokenClassificationPipeline,TokenClassifierOutput:()=>n.TokenClassifierOutput,TokenizerModel:()=>r.TokenizerModel,TopKLogitsWarper:()=>w.TopKLogitsWarper,TopPLogitsWarper:()=>w.TopPLogitsWarper,TrOCRForCausalLM:()=>n.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>n.TrOCRPreTrainedModel,TranslationPipeline:()=>t.TranslationPipeline,UltravoxModel:()=>n.UltravoxModel,UltravoxPreTrainedModel:()=>n.UltravoxPreTrainedModel,UltravoxProcessor:()=>m.UltravoxProcessor,UniSpeechForCTC:()=>n.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>n.UniSpeechForSequenceClassification,UniSpeechModel:()=>n.UniSpeechModel,UniSpeechPreTrainedModel:()=>n.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>n.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>n.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>n.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>n.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>n.UniSpeechSatPreTrainedModel,VLChatProcessor:()=>m.VLChatProcessor,VLMImageProcessor:()=>f.VLMImageProcessor,ViTFeatureExtractor:()=>f.ViTFeatureExtractor,ViTForImageClassification:()=>n.ViTForImageClassification,ViTImageProcessor:()=>f.ViTImageProcessor,ViTMAEModel:()=>n.ViTMAEModel,ViTMAEPreTrainedModel:()=>n.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>n.ViTMSNForImageClassification,ViTMSNModel:()=>n.ViTMSNModel,ViTMSNPreTrainedModel:()=>n.ViTMSNPreTrainedModel,ViTModel:()=>n.ViTModel,ViTPreTrainedModel:()=>n.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>n.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>n.VitMatteForImageMatting,VitMatteImageProcessor:()=>f.VitMatteImageProcessor,VitMattePreTrainedModel:()=>n.VitMattePreTrainedModel,VitPoseForPoseEstimation:()=>n.VitPoseForPoseEstimation,VitPoseImageProcessor:()=>f.VitPoseImageProcessor,VitPosePreTrainedModel:()=>n.VitPosePreTrainedModel,VitsModel:()=>n.VitsModel,VitsModelOutput:()=>n.VitsModelOutput,VitsPreTrainedModel:()=>n.VitsPreTrainedModel,VitsTokenizer:()=>r.VitsTokenizer,Wav2Vec2BertForCTC:()=>n.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>n.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>n.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>n.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>r.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>c.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>n.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>n.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>n.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>n.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>n.Wav2Vec2PreTrainedModel,Wav2Vec2Processor:()=>m.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>m.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>n.WavLMForAudioFrameClassification,WavLMForCTC:()=>n.WavLMForCTC,WavLMForSequenceClassification:()=>n.WavLMForSequenceClassification,WavLMForXVector:()=>n.WavLMForXVector,WavLMModel:()=>n.WavLMModel,WavLMPreTrainedModel:()=>n.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>c.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>n.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>n.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>c.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>n.WhisperForConditionalGeneration,WhisperModel:()=>n.WhisperModel,WhisperPreTrainedModel:()=>n.WhisperPreTrainedModel,WhisperProcessor:()=>m.WhisperProcessor,WhisperTextStreamer:()=>C.WhisperTextStreamer,WhisperTimeStampLogitsProcessor:()=>w.WhisperTimeStampLogitsProcessor,WhisperTokenizer:()=>r.WhisperTokenizer,XLMForQuestionAnswering:()=>n.XLMForQuestionAnswering,XLMForSequenceClassification:()=>n.XLMForSequenceClassification,XLMForTokenClassification:()=>n.XLMForTokenClassification,XLMModel:()=>n.XLMModel,XLMPreTrainedModel:()=>n.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>n.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>n.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>n.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>n.XLMRobertaForTokenClassification,XLMRobertaModel:()=>n.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>n.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>r.XLMRobertaTokenizer,XLMTokenizer:()=>r.XLMTokenizer,XLMWithLMHeadModel:()=>n.XLMWithLMHeadModel,XVectorOutput:()=>n.XVectorOutput,YolosFeatureExtractor:()=>f.YolosFeatureExtractor,YolosForObjectDetection:()=>n.YolosForObjectDetection,YolosImageProcessor:()=>f.YolosImageProcessor,YolosModel:()=>n.YolosModel,YolosObjectDetectionOutput:()=>n.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>n.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>t.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>t.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>t.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>t.ZeroShotObjectDetectionPipeline,bankers_round:()=>l.bankers_round,cat:()=>o.cat,cos_sim:()=>l.cos_sim,dot:()=>l.dot,dynamic_time_warping:()=>l.dynamic_time_warping,env:()=>e.env,full:()=>o.full,full_like:()=>o.full_like,getKeyValueShapes:()=>s.getKeyValueShapes,hamming:()=>a.hamming,hanning:()=>a.hanning,interpolate:()=>o.interpolate,interpolate_4d:()=>o.interpolate_4d,interpolate_data:()=>l.interpolate_data,is_chinese_char:()=>r.is_chinese_char,layer_norm:()=>o.layer_norm,load_image:()=>i.load_image,load_video:()=>A.load_video,log_softmax:()=>l.log_softmax,magnitude:()=>l.magnitude,matmul:()=>o.matmul,max:()=>l.max,mean:()=>o.mean,mean_pooling:()=>o.mean_pooling,medianFilter:()=>l.medianFilter,mel_filter_bank:()=>a.mel_filter_bank,min:()=>l.min,ones:()=>o.ones,ones_like:()=>o.ones_like,permute:()=>o.permute,permute_data:()=>l.permute_data,pipeline:()=>t.pipeline,quantize_embeddings:()=>o.quantize_embeddings,rand:()=>o.rand,read_audio:()=>a.read_audio,rfft:()=>o.rfft,round:()=>l.round,slice:()=>o.slice,softmax:()=>l.softmax,spectrogram:()=>a.spectrogram,stack:()=>o.stack,std_mean:()=>o.std_mean,topk:()=>o.topk,window_function:()=>a.window_function,zeros:()=>o.zeros,zeros_like:()=>o.zeros_like});var e=Lc("./src/env.js"),t=Lc("./src/pipelines.js"),n=Lc("./src/models.js"),r=Lc("./src/tokenizers.js"),s=Lc("./src/configs.js"),a=Lc("./src/utils/audio.js"),i=Lc("./src/utils/image.js"),A=Lc("./src/utils/video.js"),o=Lc("./src/utils/tensor.js"),l=Lc("./src/utils/maths.js"),u=Lc("./src/base/feature_extraction_utils.js"),c=Lc("./src/models/feature_extractors.js"),d=Lc("./src/models/auto/feature_extraction_auto.js"),h=Lc("./src/base/image_processors_utils.js"),f=Lc("./src/models/image_processors.js"),g=Lc("./src/models/auto/image_processing_auto.js"),p=Lc("./src/base/processing_utils.js"),m=Lc("./src/models/processors.js"),b=Lc("./src/models/auto/processing_auto.js"),C=Lc("./src/generation/streamers.js"),I=Lc("./src/generation/stopping_criteria.js"),w=Lc("./src/generation/logits_process.js")})();var _c=Wc.AutoTokenizer,Vc=Wc.RawAudio,Hc=Wc.StyleTextToSpeech2Model,Uc=Wc.Tensor,jc=void 0!==jc?jc:{};jc.expectedDataFileDownloads||(jc.expectedDataFileDownloads=0);var Yc="function"==typeof importScripts,Kc="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,Xc="function"==typeof atob?atob:function(e){var t,n,r,s,a,i,A="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",o="",l=0;e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{t=A.indexOf(e.charAt(l++))<<2|(s=A.indexOf(e.charAt(l++)))>>4,n=(15&s)<<4|(a=A.indexOf(e.charAt(l++)))>>2,r=(3&a)<<6|(i=A.indexOf(e.charAt(l++))),o+=String.fromCharCode(t),64!==a&&(o+=String.fromCharCode(n)),64!==i&&(o+=String.fromCharCode(r))}while(l<e.length);return o};Kc&&(process.argv.length>1&&(Zc=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof Td))throw e})),process.on("unhandledRejection",(function(e){throw e})),jc.inspect=function(){return"[Emscripten Module object]"}),jc.expectedDataFileDownloads++,function(){if(jc.ENVIRONMENT_IS_PTHREAD)return;const e="/usr/share/espeak-ng-data",t=e+"/lang",n=e+"/voices";!function(r){var s=null,a=null;function i(){function i(e,t){if(!e)throw t+(new Error).stack}function A(e,t,n){this.start=e,this.end=t,this.audio=n}jc.FS_createPath("/","usr",!0,!0),jc.FS_createPath("/usr","share",!0,!0),jc.FS_createPath("/usr/share","espeak-ng-data",!0,!0),jc.FS_createPath(e,"lang",!0,!0),jc.FS_createPath(t,"aav",!0,!0),jc.FS_createPath(t,"art",!0,!0),jc.FS_createPath(t,"azc",!0,!0),jc.FS_createPath(t,"bat",!0,!0),jc.FS_createPath(t,"bnt",!0,!0),jc.FS_createPath(t,"ccs",!0,!0),jc.FS_createPath(t,"cel",!0,!0),jc.FS_createPath(t,"cus",!0,!0),jc.FS_createPath(t,"dra",!0,!0),jc.FS_createPath(t,"esx",!0,!0),jc.FS_createPath(t,"gmq",!0,!0),jc.FS_createPath(t,"gmw",!0,!0),jc.FS_createPath(t,"grk",!0,!0),jc.FS_createPath(t,"inc",!0,!0),jc.FS_createPath(t,"ine",!0,!0),jc.FS_createPath(t,"ira",!0,!0),jc.FS_createPath(t,"iro",!0,!0),jc.FS_createPath(t,"itc",!0,!0),jc.FS_createPath(t,"jpx",!0,!0),jc.FS_createPath(t,"map",!0,!0),jc.FS_createPath(t,"miz",!0,!0),jc.FS_createPath(t,"myn",!0,!0),jc.FS_createPath(t,"poz",!0,!0),jc.FS_createPath(t,"roa",!0,!0),jc.FS_createPath(t,"sai",!0,!0),jc.FS_createPath(t,"sem",!0,!0),jc.FS_createPath(t,"sit",!0,!0),jc.FS_createPath(t,"tai",!0,!0),jc.FS_createPath(t,"trk",!0,!0),jc.FS_createPath(t,"urj",!0,!0),jc.FS_createPath(t,"zle",!0,!0),jc.FS_createPath(t,"zls",!0,!0),jc.FS_createPath(t,"zlw",!0,!0),jc.FS_createPath(e,"voices",!0,!0),jc.FS_createPath(n,"!v",!0,!0),jc.FS_createPath(n,"mb",!0,!0),A.prototype={requests:{},open:function(e,t){this.name=t,this.requests[t]=this,jc.addRunDependency("fp "+this.name)},send:function(){},onload:function(){var e=this.byteArray.subarray(this.start,this.end);this.finish(e)},finish:function(e){jc.FS_createDataFile(this.name,null,e,!0,!0,!0),jc.removeRunDependency("fp "+this.name),this.requests[this.name]=null}};for(var o=r.files,l=0;l<o.length;++l)new A(o[l].start,o[l].end,o[l].audio||0).open("GET",o[l].filename);function u(e){i(e,"Loading data file failed."),i(e.constructor.name===ArrayBuffer.name,"bad input to processPackageData");var t=new Uint8Array(e);A.prototype.byteArray=t;for(var n=r.files,s=0;s<n.length;++s)A.prototype.requests[n[s].filename].onload();jc.removeRunDependency("datafile_js/espeakng.worker.data")}jc.addRunDependency("datafile_js/espeakng.worker.data"),a?(u(a),a=null):s=u}(async()=>{const e=function(e){if("boolean"==typeof Kc&&Kc){var t=Buffer.from(e,"base64");return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}try{for(var n=Xc(e),r=new Uint8Array(n.length),s=0;s<n.length;++s)r[s]=n.charCodeAt(s);return r}catch(e){throw console.error(Xc),console.error(e),new Error("Converting base64 string to bytes failed.")}}("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LctW1ziJJ6r8E2fgm8BOcAj6PPYk+UV2sHJvdu2OjS1rm30C8eitlZpb3/vqmd4n7AT/Dkn4k+RuNs1vCvdesaOrcW2DjyN+cltlP777h2feBiugvcS91eecTeHQTTu6GqNtYQfxk9sq2+Du2858Pl4BHSb2UNdX+Ai47paWsCfmZYmfVfnLz8B/g7oI/OeCFgs+KeQ0oVVhHxFeUSXPjvxAVFU0Xc1COSW2Ko7jeV4QBMciOZ1Ol8vtdns+lNfr9fp8Pr8/EAguVigUCofD4UhFNacUrai2trY2FovV1dXV1VfUcFKNjY2NTU1NTc3Nzc0tH6i1tbW1ra29vaOjo3ORurq6urt7enp7e5ctW9Z3Sv39/f3Lly8fGBhYUdXKqlatWrV69eo1a9euXbdu/Z+1YcOGDRs3bty06Zxzzjn33HPPPe+88zZv3rxly9atW88/f9u2Cy644IJPVHThhRdedNFFF1988cWXVHXppZdeun37ZZddfvkVV1x55VVXX331NX/Wtddee+0nP/nJHTt2XHfddddXdMMNN9x444033XTzzZ/61C233HLLp0/q1ltv/cxnPvvZz33uc39X1ec+d/LX2277/Be+8MXbb7/9S1/60pduv/3227/4xS9+sfLXl++44++/8pWvLtLXvvb1r+/cufN/nNTOD/Q//seuXd/4xp2n9I2TuvPOO7/5zbvuuuuuu+++u/LfXd+s6tSUk6pOr/75rZP688SPfK2C3nnnN3adVGXOJ2dTmfyNb+z6yILs3Pn1r3/961/72le/+tWvLNLf//0dd3z5y19apMqqfuELn//8bbfd9neL9LnPffazn/nMZ2699dZbq013yy23fOpTN99004033nDD9R/Vddddt2PHJz957bXXXnPN1VdfffVVV1111ZVXXnHF5Zdfdtn27Zdeeuklp+niiy++6KILL/zEJy64YNu2bed/oK1bt27dsmXL5s2bzzvvvPPOPalzKtpU0cZF2rBhw/r169edprVr165Zs2b1h1pzUqtXr171F6rsoys+ssN+MO2DiScnf/Tbf9bpk1ad3NlXL468trrv/xWt/yv68LioHhmn6dzTVWmhynHzV7RlS/VgOqktJxv05OSt1WPsg6aufvzhF88/f+uHU099suU0bf1rOn+RPoy5SB9dslN/ntzAf7GCJ7f1h1v4Q53a1GtPbt8Pt2h1Ww0s0vLly5f39/dXTkvLli1b1tvb09Pd3dXV2dnZ0fHRs1lHR3t7W1tra+sHp7zm5oplR2NDfX1dLBarXaRotKamJhKJhE8pFAoFgwG/3+fzej0ej/sDuVwup9PhEASB53meOymWrWQaUiRJEAR+SpXLQiUhslLg/+TF5VQ5LdM0jUpCqKZpqqoqSiUFspLbXy6XSqVSsapCoZCvJPhmM5l0OpVKJStKJBKJeCWldX5ubnZ2ZmZmZrqqqampycnJiYnx8bGx0dGRkZHh4eGhoaGhwcETJ04cP37s2LGjFR05qcOHDx86dOjgwffff/+99959990DB/bv37dv3zvvvP323r17975V0Ztvvvnmnj173njj9ddff/2111577dWKXnnllZdffvmll3bvfvHFF/9U0R9P6oUXXnj++ef/8Ic//P73v3/uueee+90p/fa3v/3ts88++8wzzzz99NNPPfXUbyp68sknn/z1r3/96yeeeOKJxx9//PHHKnr00UcffeSRRx5++OFfVfXLD/TQQw899OCDDz7wwAMP/KKqn1f1s5/97Gc/reonH+o/TurHH9H9Ff3oRz/64Sn9+w///S/0w7+uH32g+390/49+dP8pVWZ6MswHUU8uxc+qOrlsJ5fzgaoefPDBByur8Mtf/vJXv/rVww8//PAjjzzySGVtK2v9+OOPV1rh17/+9ZNPPllpm6eeeurpp5955plnn332t7/97e9+97vnnnvu97//wx+ef/75F1744x//+Kc//enFF1/cvXv3Sy+9/PLLr7zy6quvvfb666+/8cYbe/bsefPNt956a+/et99+5519+/bvP3DgwLvvvvfee++/f/DgwUOHDh8+cuTo0WPHjh0/fvzEicHBwaGh4eGRkZHR0bGx8fGJiYnJyamp6enpmZmZ2dm5ubn5+YWFhXg8kUgkk8lUKp1OZzKZbDaby+Xy+XyhUCwWS6VSuVwWRVGSpEoqr6KoajWDV9f1Ss6yWck7tqpV5D6sEld9jmgC94A8uIiKsEe57wtTwXUestcZdTpJsKv6PNt10gt4xX92D4ct4jtD61DcQ/pYlkT/H/bePMiy66wTPNs9d31rvtzXqsrKWlRVKlWVVmRtyJJtYWMbG4wxBAMMBAQz42CWP6aHcEQ3EwMRRAxNdJsOlhnPNI3B2G2DbWxhI8vWvpek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"),t=new Blob([e]).stream().pipeThrough(new DecompressionStream("gzip")),n=[];for await(const e of t)n.push(e);const r=await new Blob(n).arrayBuffer();s?(s(r),s=null):a=r})(),jc.calledRun?i():(jc.preRun||(jc.preRun=[]),jc.preRun.push(i))}({files:[{filename:e+"/en_dict",start:0,end:167064},{filename:e+"/intonations",start:167064,end:169104},{filename:t+"/aav/vi",start:169104,end:169215},{filename:t+"/aav/vi-VN-x-central",start:169215,end:169358},{filename:t+"/aav/vi-VN-x-south",start:169358,end:169500},{filename:t+"/art/eo",start:169500,end:169541},{filename:t+"/art/ia",start:169541,end:169570},{filename:t+"/art/io",start:169570,end:169620},{filename:t+"/art/jbo",start:169620,end:169689},{filename:t+"/art/lfn",start:169689,end:169824},{filename:t+"/art/piqd",start:169824,end:169880},{filename:t+"/art/py",start:169880,end:170020},{filename:t+"/art/qdb",start:170020,end:170077},{filename:t+"/art/qya",start:170077,end:170250},{filename:t+"/art/sjn",start:170250,end:170425},{filename:t+"/azc/nci",start:170425,end:170539},{filename:t+"/bat/lt",start:170539,end:170567},{filename:t+"/bat/ltg",start:170567,end:170879},{filename:t+"/bat/lv",start:170879,end:171108},{filename:t+"/bnt/sw",start:171108,end:171149},{filename:t+"/bnt/tn",start:171149,end:171191},{filename:t+"/ccs/ka",start:171191,end:171315},{filename:t+"/cel/cy",start:171315,end:171352},{filename:t+"/cel/ga",start:171352,end:171418},{filename:t+"/cel/gd",start:171418,end:171469},{filename:t+"/cus/om",start:171469,end:171508},{filename:t+"/dra/kn",start:171508,end:171563},{filename:t+"/dra/ml",start:171563,end:171620},{filename:t+"/dra/ta",start:171620,end:171671},{filename:t+"/dra/te",start:171671,end:171741},{filename:t+"/esx/kl",start:171741,end:171771},{filename:t+"/eu",start:171771,end:171825},{filename:t+"/gmq/da",start:171825,end:171868},{filename:t+"/gmq/is",start:171868,end:171895},{filename:t+"/gmq/nb",start:171895,end:171982},{filename:t+"/gmq/sv",start:171982,end:172007},{filename:t+"/gmw/af",start:172007,end:172130},{filename:t+"/gmw/de",start:172130,end:172172},{filename:t+"/gmw/en",start:172172,end:172312},{filename:t+"/gmw/en-029",start:172312,end:172647},{filename:t+"/gmw/en-GB-scotland",start:172647,end:172942},{filename:t+"/gmw/en-GB-x-gbclan",start:172942,end:173180},{filename:t+"/gmw/en-GB-x-gbcwmd",start:173180,end:173368},{filename:t+"/gmw/en-GB-x-rp",start:173368,end:173617},{filename:t+"/gmw/en-US",start:173617,end:173874},{filename:t+"/gmw/en-US-nyc",start:173874,end:174145},{filename:t+"/gmw/lb",start:174145,end:174176},{filename:t+"/gmw/nl",start:174176,end:174199},{filename:t+"/grk/el",start:174199,end:174222},{filename:t+"/grk/grc",start:174222,end:174321},{filename:t+"/inc/as",start:174321,end:174363},{filename:t+"/inc/bn",start:174363,end:174388},{filename:t+"/inc/bpy",start:174388,end:174427},{filename:t+"/inc/gu",start:174427,end:174469},{filename:t+"/inc/hi",start:174469,end:174492},{filename:t+"/inc/kok",start:174492,end:174518},{filename:t+"/inc/mr",start:174518,end:174559},{filename:t+"/inc/ne",start:174559,end:174596},{filename:t+"/inc/or",start:174596,end:174635},{filename:t+"/inc/pa",start:174635,end:174660},{filename:t+"/inc/sd",start:174660,end:174726},{filename:t+"/inc/si",start:174726,end:174781},{filename:t+"/inc/ur",start:174781,end:174875},{filename:t+"/ine/hy",start:174875,end:174936},{filename:t+"/ine/hyw",start:174936,end:175301},{filename:t+"/ine/sq",start:175301,end:175404},{filename:t+"/ira/fa",start:175404,end:175494},{filename:t+"/ira/fa-Latn",start:175494,end:175763},{filename:t+"/ira/ku",start:175763,end:175803},{filename:t+"/iro/chr",start:175803,end:176372},{filename:t+"/itc/la",start:176372,end:176669},{filename:t+"/jpx/ja",start:176669,end:176721},{filename:t+"/ko",start:176721,end:176772},{filename:t+"/map/haw",start:176772,end:176814},{filename:t+"/miz/mto",start:176814,end:176997},{filename:t+"/myn/quc",start:176997,end:177207},{filename:t+"/poz/id",start:177207,end:177341},{filename:t+"/poz/mi",start:177341,end:177708},{filename:t+"/poz/ms",start:177708,end:178138},{filename:t+"/qu",start:178138,end:178226},{filename:t+"/roa/an",start:178226,end:178253},{filename:t+"/roa/ca",start:178253,end:178278},{filename:t+"/roa/es",start:178278,end:178341},{filename:t+"/roa/es-419",start:178341,end:178508},{filename:t+"/roa/fr",start:178508,end:178587},{filename:t+"/roa/fr-BE",start:178587,end:178671},{filename:t+"/roa/fr-CH",start:178671,end:178757},{filename:t+"/roa/ht",start:178757,end:178897},{filename:t+"/roa/it",start:178897,end:179006},{filename:t+"/roa/pap",start:179006,end:179068},{filename:t+"/roa/pt",start:179068,end:179163},{filename:t+"/roa/pt-BR",start:179163,end:179272},{filename:t+"/roa/ro",start:179272,end:179298},{filename:t+"/sai/gn",start:179298,end:179345},{filename:t+"/sem/am",start:179345,end:179386},{filename:t+"/sem/ar",start:179386,end:179436},{filename:t+"/sem/he",start:179436,end:179476},{filename:t+"/sem/mt",start:179476,end:179517},{filename:t+"/sem/ti",start:179517,end:179610},{filename:t+"/sit/cmn",start:179610,end:180296},{filename:t+"/sit/cmn-Latn-pinyin",start:180296,end:180457},{filename:t+"/sit/hak",start:180457,end:180585},{filename:t+"/sit/my",start:180585,end:180641},{filename:t+"/sit/yue",start:180641,end:180835},{filename:t+"/sit/yue-Latn-jyutping",start:180835,end:181048},{filename:t+"/tai/shn",start:181048,end:181140},{filename:t+"/tai/th",start:181140,end:181177},{filename:t+"/trk/az",start:181177,end:181222},{filename:t+"/trk/ba",start:181222,end:181247},{filename:t+"/trk/cv",start:181247,end:181287},{filename:t+"/trk/kk",start:181287,end:181327},{filename:t+"/trk/ky",start:181327,end:181370},{filename:t+"/trk/nog",start:181370,end:181409},{filename:t+"/trk/tk",start:181409,end:181434},{filename:t+"/trk/tr",start:181434,end:181459},{filename:t+"/trk/tt",start:181459,end:181482},{filename:t+"/trk/ug",start:181482,end:181506},{filename:t+"/trk/uz",start:181506,end:181545},{filename:t+"/urj/et",start:181545,end:181782},{filename:t+"/urj/fi",start:181782,end:182019},{filename:t+"/urj/hu",start:182019,end:182092},{filename:t+"/urj/smj",start:182092,end:182137},{filename:t+"/zle/be",start:182137,end:182189},{filename:t+"/zle/ru",start:182189,end:182246},{filename:t+"/zle/ru-LV",start:182246,end:182526},{filename:t+"/zle/ru-cl",start:182526,end:182617},{filename:t+"/zle/uk",start:182617,end:182714},{filename:t+"/zls/bg",start:182714,end:182825},{filename:t+"/zls/bs",start:182825,end:183055},{filename:t+"/zls/hr",start:183055,end:183317},{filename:t+"/zls/mk",start:183317,end:183345},{filename:t+"/zls/sl",start:183345,end:183388},{filename:t+"/zls/sr",start:183388,end:183638},{filename:t+"/zlw/cs",start:183638,end:183661},{filename:t+"/zlw/pl",start:183661,end:183699},{filename:t+"/zlw/sk",start:183699,end:183723},{filename:e+"/phondata",start:183723,end:734147},{filename:e+"/phonindex",start:734147,end:773403},{filename:e+"/phontab",start:773403,end:829491},{filename:n+"/!v/Alex",start:829491,end:829619},{filename:n+"/!v/Alicia",start:829619,end:830093},{filename:n+"/!v/Andrea",start:830093,end:830450},{filename:n+"/!v/Andy",start:830450,end:830770},{filename:n+"/!v/Annie",start:830770,end:831085},{filename:n+"/!v/AnxiousAndy",start:831085,end:831446},{filename:n+"/!v/Demonic",start:831446,end:835304},{filename:n+"/!v/Denis",start:835304,end:835609},{filename:n+"/!v/Diogo",start:835609,end:835988},{filename:n+"/!v/Gene",start:835988,end:836269},{filename:n+"/!v/Gene2",start:836269,end:836552},{filename:n+"/!v/Henrique",start:836552,end:836933},{filename:n+"/!v/Hugo",start:836933,end:837311},{filename:n+"/!v/Jacky",start:837311,end:837578},{filename:n+"/!v/Lee",start:837578,end:837916},{filename:n+"/!v/Marco",start:837916,end:838383},{filename:n+"/!v/Mario",start:838383,end:838653},{filename:n+"/!v/Michael",start:838653,end:838923},{filename:n+"/!v/Mike",start:838923,end:839035},{filename:n+"/!v/Mr serious",start:839035,end:842228},{filename:n+"/!v/Nguyen",start:842228,end:842508},{filename:n+"/!v/Reed",start:842508,end:842710},{filename:n+"/!v/RicishayMax",start:842710,end:842943},{filename:n+"/!v/RicishayMax2",start:842943,end:843378},{filename:n+"/!v/RicishayMax3",start:843378,end:843813},{filename:n+"/!v/Storm",start:843813,end:844233},{filename:n+"/!v/Tweaky",start:844233,end:847422},{filename:n+"/!v/UniRobot",start:847422,end:847839},{filename:n+"/!v/adam",start:847839,end:847914},{filename:n+"/!v/anika",start:847914,end:848407},{filename:n+"/!v/anikaRobot",start:848407,end:848919},{filename:n+"/!v/announcer",start:848919,end:849219},{filename:n+"/!v/antonio",start:849219,end:849600},{filename:n+"/!v/aunty",start:849600,end:849958},{filename:n+"/!v/belinda",start:849958,end:850298},{filename:n+"/!v/benjamin",start:850298,end:850499},{filename:n+"/!v/boris",start:850499,end:850723},{filename:n+"/!v/caleb",start:850723,end:850780},{filename:n+"/!v/croak",start:850780,end:850873},{filename:n+"/!v/david",start:850873,end:850985},{filename:n+"/!v/ed",start:850985,end:851272},{filename:n+"/!v/edward",start:851272,end:851423},{filename:n+"/!v/edward2",start:851423,end:851575},{filename:n+"/!v/f1",start:851575,end:851899},{filename:n+"/!v/f2",start:851899,end:852256},{filename:n+"/!v/f3",start:852256,end:852631},{filename:n+"/!v/f4",start:852631,end:852981},{filename:n+"/!v/f5",start:852981,end:853413},{filename:n+"/!v/fast",start:853413,end:853562},{filename:n+"/!v/grandma",start:853562,end:853825},{filename:n+"/!v/grandpa",start:853825,end:854081},{filename:n+"/!v/gustave",start:854081,end:854334},{filename:n+"/!v/ian",start:854334,end:857502},{filename:n+"/!v/iven",start:857502,end:857763},{filename:n+"/!v/iven2",start:857763,end:858042},{filename:n+"/!v/iven3",start:858042,end:858304},{filename:n+"/!v/iven4",start:858304,end:858565},{filename:n+"/!v/john",start:858565,end:861751},{filename:n+"/!v/kaukovalta",start:861751,end:862112},{filename:n+"/!v/klatt",start:862112,end:862150},{filename:n+"/!v/klatt2",start:862150,end:862188},{filename:n+"/!v/klatt3",start:862188,end:862227},{filename:n+"/!v/klatt4",start:862227,end:862266},{filename:n+"/!v/klatt5",start:862266,end:862305},{filename:n+"/!v/klatt6",start:862305,end:862344},{filename:n+"/!v/linda",start:862344,end:862694},{filename:n+"/!v/m1",start:862694,end:863029},{filename:n+"/!v/m2",start:863029,end:863293},{filename:n+"/!v/m3",start:863293,end:863593},{filename:n+"/!v/m4",start:863593,end:863883},{filename:n+"/!v/m5",start:863883,end:864145},{filename:n+"/!v/m6",start:864145,end:864333},{filename:n+"/!v/m7",start:864333,end:864587},{filename:n+"/!v/m8",start:864587,end:864871},{filename:n+"/!v/marcelo",start:864871,end:865122},{filename:n+"/!v/max",start:865122,end:865347},{filename:n+"/!v/michel",start:865347,end:865751},{filename:n+"/!v/miguel",start:865751,end:866133},{filename:n+"/!v/mike2",start:866133,end:866321},{filename:n+"/!v/norbert",start:866321,end:869510},{filename:n+"/!v/pablo",start:869510,end:872652},{filename:n+"/!v/paul",start:872652,end:872936},{filename:n+"/!v/pedro",start:872936,end:873288},{filename:n+"/!v/quincy",start:873288,end:873642},{filename:n+"/!v/rob",start:873642,end:873907},{filename:n+"/!v/robert",start:873907,end:874181},{filename:n+"/!v/robosoft",start:874181,end:874632},{filename:n+"/!v/robosoft2",start:874632,end:875086},{filename:n+"/!v/robosoft3",start:875086,end:875541},{filename:n+"/!v/robosoft4",start:875541,end:875988},{filename:n+"/!v/robosoft5",start:875988,end:876433},{filename:n+"/!v/robosoft6",start:876433,end:876720},{filename:n+"/!v/robosoft7",start:876720,end:877130},{filename:n+"/!v/robosoft8",start:877130,end:877373},{filename:n+"/!v/sandro",start:877373,end:877903},{filename:n+"/!v/shelby",start:877903,end:878183},{filename:n+"/!v/steph",start:878183,end:878547},{filename:n+"/!v/steph2",start:878547,end:878914},{filename:n+"/!v/steph3",start:878914,end:879291},{filename:n+"/!v/travis",start:879291,end:879674},{filename:n+"/!v/victor",start:879674,end:879927},{filename:n+"/!v/whisper",start:879927,end:880113},{filename:n+"/!v/whisperf",start:880113,end:880505},{filename:n+"/!v/zac",start:880505,end:880780},{filename:n+"/mb/mb-af1",start:880780,end:880868},{filename:n+"/mb/mb-af1-en",start:880868,end:880951},{filename:n+"/mb/mb-ar1",start:880951,end:881035},{filename:n+"/mb/mb-ar2",start:881035,end:881119},{filename:n+"/mb/mb-br1",start:881119,end:881251},{filename:n+"/mb/mb-br2",start:881251,end:881387},{filename:n+"/mb/mb-br3",start:881387,end:881519},{filename:n+"/mb/mb-br4",start:881519,end:881655},{filename:n+"/mb/mb-ca1",start:881655,end:881760},{filename:n+"/mb/mb-ca2",start:881760,end:881865},{filename:n+"/mb/mb-cn1",start:881865,end:881957},{filename:n+"/mb/mb-cr1",start:881957,end:882068},{filename:n+"/mb/mb-cz1",start:882068,end:882138},{filename:n+"/mb/mb-cz2",start:882138,end:882220},{filename:n+"/mb/mb-de1",start:882220,end:882364},{filename:n+"/mb/mb-de1-en",start:882364,end:882460},{filename:n+"/mb/mb-de2",start:882460,end:882588},{filename:n+"/mb/mb-de2-en",start:882588,end:882668},{filename:n+"/mb/mb-de3",start:882668,end:882767},{filename:n+"/mb/mb-de3-en",start:882767,end:882863},{filename:n+"/mb/mb-de4",start:882863,end:882992},{filename:n+"/mb/mb-de4-en",start:882992,end:883073},{filename:n+"/mb/mb-de5",start:883073,end:883309},{filename:n+"/mb/mb-de5-en",start:883309,end:883399},{filename:n+"/mb/mb-de6",start:883399,end:883521},{filename:n+"/mb/mb-de6-en",start:883521,end:883595},{filename:n+"/mb/mb-de6-grc",start:883595,end:883678},{filename:n+"/mb/mb-de7",start:883678,end:883828},{filename:n+"/mb/mb-de8",start:883828,end:883899},{filename:n+"/mb/mb-ee1",start:883899,end:883996},{filename:n+"/mb/mb-en1",start:883996,end:884127},{filename:n+"/mb/mb-es1",start:884127,end:884241},{filename:n+"/mb/mb-es2",start:884241,end:884349},{filename:n+"/mb/mb-es3",start:884349,end:884453},{filename:n+"/mb/mb-es4",start:884453,end:884541},{filename:n+"/mb/mb-fr1",start:884541,end:884707},{filename:n+"/mb/mb-fr1-en",start:884707,end:884811},{filename:n+"/mb/mb-fr2",start:884811,end:884914},{filename:n+"/mb/mb-fr3",start:884914,end:885014},{filename:n+"/mb/mb-fr4",start:885014,end:885141},{filename:n+"/mb/mb-fr4-en",start:885141,end:885248},{filename:n+"/mb/mb-fr5",start:885248,end:885348},{filename:n+"/mb/mb-fr6",start:885348,end:885448},{filename:n+"/mb/mb-fr7",start:885448,end:885531},{filename:n+"/mb/mb-gr1",start:885531,end:885625},{filename:n+"/mb/mb-gr2",start:885625,end:885719},{filename:n+"/mb/mb-gr2-en",start:885719,end:885807},{filename:n+"/mb/mb-hb1",start:885807,end:885875},{filename:n+"/mb/mb-hb2",start:885875,end:885958},{filename:n+"/mb/mb-hu1",start:885958,end:886060},{filename:n+"/mb/mb-hu1-en",start:886060,end:886157},{filename:n+"/mb/mb-ic1",start:886157,end:886245},{filename:n+"/mb/mb-id1",start:886245,end:886346},{filename:n+"/mb/mb-in1",start:886346,end:886415},{filename:n+"/mb/mb-in2",start:886415,end:886500},{filename:n+"/mb/mb-ir1",start:886500,end:887253},{filename:n+"/mb/mb-it1",start:887253,end:887337},{filename:n+"/mb/mb-it2",start:887337,end:887424},{filename:n+"/mb/mb-it3",start:887424,end:887566},{filename:n+"/mb/mb-it4",start:887566,end:887711},{filename:n+"/mb/mb-jp1",start:887711,end:887782},{filename:n+"/mb/mb-jp2",start:887782,end:887883},{filename:n+"/mb/mb-jp3",start:887883,end:887970},{filename:n+"/mb/mb-la1",start:887970,end:888053},{filename:n+"/mb/mb-lt1",start:888053,end:888140},{filename:n+"/mb/mb-lt2",start:888140,end:888227},{filename:n+"/mb/mb-ma1",start:888227,end:888325},{filename:n+"/mb/mb-mx1",start:888325,end:888445},{filename:n+"/mb/mb-mx2",start:888445,end:888565},{filename:n+"/mb/mb-nl1",start:888565,end:888634},{filename:n+"/mb/mb-nl2",start:888634,end:888730},{filename:n+"/mb/mb-nl2-en",start:888730,end:888821},{filename:n+"/mb/mb-nl3",start:888821,end:888906},{filename:n+"/mb/mb-nz1",start:888906,end:888974},{filename:n+"/mb/mb-pl1",start:888974,end:889073},{filename:n+"/mb/mb-pl1-en",start:889073,end:889155},{filename:n+"/mb/mb-pt1",start:889155,end:889286},{filename:n+"/mb/mb-ro1",start:889286,end:889373},{filename:n+"/mb/mb-ro1-en",start:889373,end:889454},{filename:n+"/mb/mb-sw1",start:889454,end:889552},{filename:n+"/mb/mb-sw1-en",start:889552,end:889645},{filename:n+"/mb/mb-sw2",start:889645,end:889747},{filename:n+"/mb/mb-sw2-en",start:889747,end:889846},{filename:n+"/mb/mb-tl1",start:889846,end:889931},{filename:n+"/mb/mb-tr1",start:889931,end:890016},{filename:n+"/mb/mb-tr2",start:890016,end:890130},{filename:n+"/mb/mb-us1",start:890130,end:890300},{filename:n+"/mb/mb-us2",start:890300,end:890478},{filename:n+"/mb/mb-us3",start:890478,end:890658},{filename:n+"/mb/mb-vz1",start:890658,end:890802}]})}();var qc=Object.assign({},jc),Zc="./this.program",Jc=jc.print||console.log.bind(console),$c=jc.printErr||console.warn.bind(console);Object.assign(jc,qc),qc=null,jc.arguments&&jc.arguments,jc.thisProgram&&(Zc=jc.thisProgram),jc.quit&&jc.quit,jc.wasmBinary&&jc.wasmBinary,jc.noExitRuntime;var ed,td={Memory:function(e){this.buffer=new ArrayBuffer(65536*e.initial)},Module:function(e){},Instance:function(e,t){this.exports=function(e){for(var t,n=new Uint8Array(123),r=25;r>=0;--r)n[48+r]=52+r,n[65+r]=r,n[97+r]=26+r;function s(e,t,r){for(var s,a,i=0,A=t,o=r.length,l=t+(3*o>>2)-("="==r[o-2])-("="==r[o-1]);i<o;i+=4)s=n[r.charCodeAt(i+1)],a=n[r.charCodeAt(i+2)],e[A++]=n[r.charCodeAt(i)]<<2|s>>4,A<l&&(e[A++]=s<<4|a>>2),A<l&&(e[A++]=a<<6|n[r.charCodeAt(i+3)])}n[43]=62,n[47]=63;var a=new ArrayBuffer(16),i=new Int32Array(a),A=new Float32Array(a),o=new Float64Array(a);function l(e){return i[e]}function u(e,t){i[e]=t}function c(){return o[0]}function d(e){o[0]=e}function h(){throw new Error("abort")}function f(e){A[2]=e}return function(e){var n=e.a,r=n.a.buffer,a=new Int8Array(r),i=new Int16Array(r),A=new Int32Array(r),o=new Uint8Array(r),g=new Uint16Array(r),p=new Uint32Array(r),m=new Float64Array(r),b=Math.imul,C=Math.fround,I=Math.abs,w=Math.clz32,k=Math.min,x=Math.floor,y=Math.ceil,v=n.b,E=n.c,B=n.d,M=n.e,D=n.f,T=n.g,S=n.h,N=n.i,G=n.j,F=n.k,P=n.l,Q=n.m,z=n.n,O=n.o,R=n.p,L=n.q,W=n.r,_=n.s,V=n.t,H=n.u,U=294656,j=0,Y=0,K=0;function X(e){var t,n=0,r=0,s=0,h=0,f=0,C=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0,N=0,G=0,F=0,P=0,Q=0,z=0,O=0,R=0,L=0,W=0,_=0,V=0,H=0,j=0,Y=0,K=0,X=0,Z=0,J=0,te=0,ne=0,re=0,oe=0,ue=0,he=0,fe=0,ge=0,pe=0,me=0,be=0,Ce=0,Ie=0,we=0,ke=0,xe=0,ye=0;if(U=t=U-16|0,2!=(0|e))if(e=A[33283],A[e>>2]!=A[e+4>>2]){if(Zr(A[A[32972]+60>>2]),M=A[47192],oe=t+12|0,pe=t+8|0,U=w=U-6832|0,A[w+6816>>2]=0,A[w+6808>>2]=32,A[w+6800>>2]=0,M){A[47351]=0,A[47350]=0,A[47352]=0,a[189076]=0,e=A[33284],A[47353]=(0|e)>0?e:0,A[47355]=A[47354]+1,kt(O=w+5184|0,0,1600),te=w+6800|0,U=f=U-2608|0,A[f+2156>>2]=32,A[f+2148>>2]=0,o[134760]&&(a[190280]=0,a[134760]=0),A[M+8216>>2]=0,A[M+8220>>2]=0,A[M+288>>2]=0,A[w+780>>2]=0,a[189360]=0;e:if(e=A[33691])A[f+2152>>2]=e;else{t:{n:{if(!(n=A[33285])){if(e=A[33283],A[e>>2]==A[e+4>>2]){A[f+2152>>2]=0;break e}if(!(n=A[33285]))break n}A[33285]=0;break t}A[33284]=A[33284]+1,e=A[33283],n=0|Ns[A[e+8>>2]](e)}A[f+2152>>2]=n}Ie=O+2|0,P=32;e:{for(;;){F=P;t:{n:{r:{if(n=A[33691],(s=A[33285])?e=0:(s=A[33285],e=A[33283],e=A[e>>2]==A[e+4>>2]),n|!e|s||!(A[32524]<0)){if(!Er(A[f+2156>>2])){if((s=(0|(e=A[49828]))>0)&(0|(n=e))<(0|(e=A[33284])))break r;if(!((0|(n=A[49845]))<=0|(0|e)<(0|n))){A[49845]=0,a[134760]=1,A[33285]=A[f+2152>>2],r=16384;break e}}P=A[f+2156>>2],A[f+2156>>2]=A[f+2152>>2];s:{a:{i:{A:{o:{if((0|(n=A[32524]))>=0){if(o[n+134736|0])break o;A[32524]=-1}if(n=A[33285])break i;if(e=A[33283],A[e>>2]!=A[e+4>>2])break A;n=32;break s}A[33691]|n||(A[f+2156>>2]=a[134736],n=1),A[32524]=n+1,n=a[n+134736|0];break s}if(!(n=A[33285]))break a}A[33285]=0;break s}A[33284]=A[33284]+1,e=A[33283],n=0|Ns[A[e+8>>2]](e)}A[f+2152>>2]=n,A[33691]=0;s:if(!(k|!A[47203])){a:{if(60!=(0|(e=A[f+2156>>2]))){if(35!=(0|n)&n-97>>>0>25|38!=(0|e))break s;for(s=A[33285],h=0;;){i:{if(A[f+2156>>2]=n,!s){if(e=A[33283],A[e>>2]==A[e+4>>2])break i;n=A[f+2156>>2]}if(!(!((n=!!(0|Er(n)))|35==(0|(e=A[f+2156>>2])))|h>>>0>19)){a[(f+112|0)+h|0]=e,h=h+1|0,(n=A[33285])?(A[33285]=0,s=0):(A[33284]=A[33284]+1,e=A[33283],n=0|Ns[A[e+8>>2]](e),s=A[33285]);continue}}break}a[(f+112|0)+h|0]=0;i:{A:{if(!(n=A[33285])){if(n=0,e=A[33283],A[e>>2]==A[e+4>>2])break i;if(!(n=A[33285]))break A}A[33285]=0;break i}A[33284]=A[33284]+1,e=A[33283],n=0|Ns[A[e+8>>2]](e)}A[f+2152>>2]=n,A[f+100>>2]=A[f+2156>>2],A[f+104>>2]=n,A[f+96>>2]=f+112,En(134736,84252,f+96|0);i:{if(59==A[f+2156>>2]){h=f+2156|0,B=f+2152|0,U=s=U-32|0;A:if(35!=o[0|(n=f+112|0)])e=-1,-1!=(0|(n=Nr(130752,n)))&&(A[h>>2]=n,A[B>>2]||(A[B>>2]=32),e=n);else{if(120==o[0|(e=n+1|0)]){A[s>>2]=h,e=ae(n+2|0,90005,s);break A}A[s+16>>2]=h,e=ae(e,90070,s+16|0)}if(U=s+32|0,(0|e)>0)break i}A[32524]=0,A[f+2156>>2]=38,A[f+2152>>2]=32;break s}if((0|(e=A[f+2156>>2]))>32)break s;if(!(n=A[33692]-20|0)|16==(0|n))break a;break s}if(47!=(0|n)&&!Br(n)&&63!=(0|(e=A[f+2152>>2]))&&33!=(0|e))break s;if((0|(e=A[f+2148>>2]))>780){A[33691]=A[f+2156>>2],a[0|(e=e+189424|0)]=32,a[e+1|0]=0,A[33285]=A[f+2152>>2],r=16384;break e}for(B=A[33285],h=0,n=A[f+2152>>2];A[f+2156>>2]=n,s=0,B||(e=A[33283],s=A[e>>2]==A[e+4>>2],n=A[f+2156>>2]),!(62==(0|n)|s|h>>>0>499);)A[(f+144|0)+(h<<2)>>2]=n,h=h+1|0,(n=A[33285])?(B=0,A[33285]=0):(A[33284]=A[33284]+1,e=A[33283],n=0|Ns[A[e+8>>2]](e),B=A[33285]);A[(s=f+144|0)+(h<<2)>>2]=0,A[f+2152>>2]=32,Q=f+2148|0,F=A[32525],n=0,U=G=U-560|0;i:if(Cr(s,84333,3)&&Cr(s,84477,4)){for(e=(s+(Yr(s)<<2)|0)-4|0,47==(0|(R=A[e>>2]))&&(A[e>>2]=32);;){if(e=A[s+(n<<2)>>2]){if(tr(e))e=n;else if(a[(G+512|0)+n|0]=ar(e<<24>>24),e=39,39!=(0|(n=n+1|0)))continue}else e=n;break}if(a[(G+512|0)+e|0]=0,47!=o[G+512|0]){if(16!=(0|(B=Nr(130480,G+512|0)))&&(n=A[Q>>2],A[Q>>2]=n+1,a[n+189424|0]=32),47==(0|R)&&(n=0,!(502241>>>B&1)))break i}else 16!=(0|(n=Nr(130480,G+512|1)))&&(h=A[Q>>2],A[Q>>2]=h+1,a[h+189424|0]=32),B=n+32|0;h=s+(e<<2)|0,e=A[33708],k=b(e,76)+133076|0,n=262174;A:{o:{l:{u:switch(B-1|0){case 33:c:if(!((0|e)<=1)){for(;;){if(2==A[b(n=e-1|0,76)+133152>>2])break c;if(A[33708]=n,s=e>>>0>2,e=n,!s)break}e=1}n=Be(h,34,e);break i;case 32:c:if(!((0|e)<=1)){for(;;){if(1==A[b(n=e-1|0,76)+133152>>2])break c;if(A[33708]=n,s=e>>>0>2,e=n,!s)break}e=1}n=Be(h,33,e)+524328|0;break i;case 9:(0|(n=A[33709]))<=18&&(A[33709]=n+1),A[(e=134912+(k=n<<6)|0)>>2]=10,A[e+4>>2]=-1,A[e+8>>2]=-1,A[e+52>>2]=-1,A[e+56>>2]=-1,A[e+44>>2]=-1,A[e+48>>2]=-1,A[e+36>>2]=-1,A[e+40>>2]=-1,A[e+28>>2]=-1,A[e+32>>2]=-1,A[e+20>>2]=-1,A[e+24>>2]=-1,A[e+12>>2]=-1,A[e+16>>2]=-1,A[e+60>>2]=-1,e=zt(h,88301),s=zt(h,88390),Xn(e,88479)?Xn(e,88528)||(A[28+(134912+(n<<6)|0)>>2]=mn(s,130224)):A[24+(k+134912|0)>>2]=mn(s,130192),_e(Q,A[33709]);break l;case 2:for((0|(e=A[33709]))<=18&&(A[33709]=e+1),A[(e=134912+(me=e<<6)|0)>>2]=3,A[e+4>>2]=-1,A[e+8>>2]=-1,A[e+52>>2]=-1,A[e+56>>2]=-1,A[e+44>>2]=-1,A[e+48>>2]=-1,A[e+36>>2]=-1,A[e+40>>2]=-1,A[e+28>>2]=-1,A[e+32>>2]=-1,A[e+20>>2]=-1,A[e+24>>2]=-1,A[e+12>>2]=-1,A[e+16>>2]=-1,A[e+60>>2]=-1,j=1;;){if(s=zt(h,A[130448+(Y=j<<2)>>2])){R=0,e=A[Y+131072>>2];c:if(B=A[e>>2])for(;;){for(n=0;k=a[n+B|0],(F=A[(n<<2)+s>>2])&&(n=n+1|0,(0|k)==(0|F)););d:switch(F-34|0){case 0:case 5:if(!k)break c}if(!(B=A[e+((R=R+1|0)<<3)>>2]))break}we=Y+(me+134912|0)|0;c:if((0|(e=A[4+(e+(R<<3)|0)>>2]))>=0)e=(0|b(e,A[4+(Y+134912|0)>>2]))/100|0;else{for(;s=(e=s)+4|0,tr(A[e>>2]););for(be=43==A[e>>2],s=((Ce=45==A[(e=e+(be<<2)|0)>>2])<<2)+e|0,R=G+96|0,U=B=(U=k=U-16|0)-224|0,kt(B+16|0,0,144),e=B+160|4,A[B+24>>2]=e,A[B+60>>2]=e,A[B+92>>2]=-1,A[B+64>>2]=60,A[B+20>>2]=e,A[B+48>>2]=19,n=s;n=(e=n)+4|0,F=(F=A[e>>2])?Fr(124960,F):0;);A[B+100>>2]=e,Un(n=B+16|0,0,0),ee(B,n,1,1),n=A[B+8>>2],ke=A[B+12>>2],F=A[B>>2],xe=A[B+4>>2],R&&(ye=R,R=A[B+136>>2]+(A[B+20>>2]-A[B+60>>2]|0)|0,A[ye>>2]=R?e+(R<<2)|0:s),A[(e=k)+8>>2]=n,A[e+12>>2]=ke,A[e>>2]=F,A[e+4>>2]=xe,U=B+224|0,N=nt(A[e>>2],A[e+4>>2],A[e+8>>2],A[e+12>>2]),U=e+16|0;d:{n=100;h:if((0|(e=s))!=(0|(s=A[G+96>>2]))){n=Ce?-1:be;f:{if(115!=(0|(e=A[s>>2]))){if(37!=(0|e))break f;if(I(N=n?+(0|n)*N+100:N)<2147483648){n=~~N;break h}n=-2147483648;break h}if(116==A[s+4>>2]){d(+(V=N*+(0|n)/12)),e=0|l(1),l(0);g:{if((n=(e=e>>>20&2047)-969|0)>>>0>=63){if(N=V+1,(0|n)<0)break g;if(d(+V),n=0|l(1),s=0|l(0),!(e>>>0<1033)){if(N=0,!s&-1048576==(0|n))break g;if(N=V+1,e>>>0>=2047)break g;if((0|n)>0|(0|n)>=0){m[8+(e=U-16|0)>>3]=3105036184601418e216,N=3105036184601418e216*m[e+8>>3];break g}if(!(n>>>0<3230714880)){m[8+(e=U-16|0)>>3]=12882297539194267e-247,N=12882297539194267e-247*m[e+8>>3];break g}}k=e,e=!(s<<1)&-2129002496==(0|(e=n<<1|s>>>31))|e>>>0<2165964800?k:0}ue=(V=(N=V-((ne=(N=m[14416])+V)-N))*N)*V*(N*m[14421]+m[14420]),V*=N*m[14419]+m[14418],N*=m[14417],d(+ne),l(1),k=0|l(0),N=ue+(V+(N+m[115376+(s=k<<4&2032)>>3])),F=A[(s=s+115384|0)>>2],B=A[s+4>>2],s=(n=F)+(F=0)|0,n=(k<<13)+B|0,n=s>>>0<F>>>0?n+1|0:n,e?(u(0,0|s),u(1,0|n),N=(V=+c())*N+V):-2147483648&k?(u(0,0|s),u(1,n+1071644672|0),(N=(ne=(V=+c())*N)+V)<1&&(A[8+(e=U-16|0)>>2]=0,A[e+12>>2]=1048576,m[e+8>>3]=22250738585072014e-324*m[e+8>>3],N=0==(N=(ue=N+1)+(ne+(V-N)+(N+(1-ue)))+-1)?0:N),N*=22250738585072014e-324):(u(0,0|s),u(1,n+-1048576|0),N=(V=+c())*N+V,N+=N)}if(I(N*=100)<2147483648){n=~~N;break h}n=-2147483648;break h}}if(1!=(0|j))break d;if(n)n=100+(e=I(N=N*+(0|n)*100)<2147483648?~~N:-2147483648)|0;else{if(I(N*=100)<2147483648){n=~~N;break h}n=-2147483648}}e=(0|b(n,A[Y+134848>>2]))/100|0;break c}e=I(N)<2147483648?~~N:-2147483648,n&&(e=A[Y+134848>>2]+b(e,n)|0)}A[we+4>>2]=e}if(5==(0|(j=j+1|0)))break}_e(Q,A[33709]);break l;case 11:(0|(n=A[33709]))<=18&&(A[33709]=n+1),A[(e=134912+(n<<6)|0)>>2]=12,A[e+4>>2]=-1,A[e+8>>2]=-1,A[e+52>>2]=-1,A[e+56>>2]=-1,A[e+44>>2]=-1,A[e+48>>2]=-1,A[e+36>>2]=-1,A[e+40>>2]=-1,A[e+28>>2]=-1,A[e+32>>2]=-1,A[e+20>>2]=-1,A[e+24>>2]=-1,A[e+12>>2]=-1,A[e+16>>2]=-1,A[e+60>>2]=-1,e=(e=zt(h,88658))?mn(e,130400):3,s=134912+(n<<6)|0,1!=A[A[47192]+148>>2]?(A[52+(134912+(n<<6)|0)>>2]=e,e=o[e+102776|0]):(A[20+(134912+(n<<6)|0)>>2]=o[e+102764|0],e=o[e+102770|0]),A[s+12>>2]=e,_e(Q,A[33709]);break l;case 34:case 41:case 43:if(!((0|(e=A[33709]))<=0)){if(h=B-32|0,B=0,s=0,n=0,e>>>0>=4)for(k=-4&e,R=0;j=2|n,Y=1|n,s=(0|h)==A[134912+((F=3|n)<<6)>>2]?F:(0|h)==A[134912+(j<<6)>>2]?j:(0|h)==A[134912+(Y<<6)>>2]?Y:(0|h)==A[134912+(n<<6)>>2]?n:s,n=n+4|0,(0|k)!=(0|(R=R+4|0)););if(k=3&e)for(;s=(0|h)==A[134912+(n<<6)>>2]?n:s,n=n+1|0,(0|k)!=(0|(B=B+1|0)););(0|s)<=0||(A[33709]=s,e=s)}_e(Q,e);break l;case 7:if(e=zt(h,88741),n=zt(h,88860),1!=(0|mn(e,130176)))break l;e=A[Q>>2],A[Q>>2]=e+1,a[e+189424|0]=91,e=A[Q>>2],A[Q>>2]=e+1,a[e+189424|0]=91,e=hn((e=A[Q>>2])+189424|0,n,800-e|0)+A[Q>>2]|0,A[Q>>2]=e+1,a[e+189424|0]=93,e=A[Q>>2],A[Q>>2]=e+1,a[e+189424|0]=93;break l;case 35:36==A[33692]&&(a[A[Q>>2]+189424|0]=0,(s=Nr(131104,n=(e=A[33707])+189424|0))&&(A[Q>>2]=Qn(s,n)+e)),e=A[Q>>2],A[Q>>2]=e+1,a[e+189424|0]=1,e=A[Q>>2],A[Q>>2]=e+1,a[e+189424|0]=89,A[33692]=0;break l;case 8:if(!(e=zt(h,89299)))break l;a[134824]=1,n=A[Q>>2],A[Q>>2]=hn(n+189424|0,e,800-n|0)+A[Q>>2];break l;case 13:a[134824]=1;break l;case 40:case 45:a[134824]=0;break l;case 4:if(!(e=zt(h,89360)))break l;if(hn(G+352|0,e,160),o[G+352|0]&&!mr(199328,G+352|0)){a[134760]=1,a[199328]=0,n=16384;break i}if((0|(e=hr(G+352|0)))<0)break l;A[G+20>>2]=e,A[G+16>>2]=1,En(e=G+352|0,89460,G+16|0),rn(A[Q>>2]+189424|0,e),A[Q>>2]=A[Q>>2]+Hn(e);break l;case 10:(0|(n=A[33709]))<=18&&(A[33709]=n+1),A[(e=134912+(n<<6)|0)>>2]=11,A[e+4>>2]=-1,A[e+8>>2]=-1,A[e+52>>2]=-1,A[e+56>>2]=-1,A[e+44>>2]=-1,A[e+48>>2]=-1,A[e+36>>2]=-1,A[e+40>>2]=-1,A[e+28>>2]=-1,A[e+32>>2]=-1,A[e+20>>2]=-1,A[e+24>>2]=-1,A[e+12>>2]=-1,A[e+16>>2]=-1,A[e+60>>2]=-1;c:if(e=zt(h,89514)){if(hn(G+352|0,e,160),A[34441]){if((0|(e=hr(G+352|0)))<0)break c;if(0|Ns[A[34441]](1,e+A[33282]|0,F))break c;A[G+68>>2]=e,A[G+64>>2]=1,En(G+352|0,89658,G- -64|0)}else{if(!F|47==o[G+352|0]?e=un(G+352|0):(A[G+48>>2]=F,A[G+52>>2]=G+352,En(e=G+96|0,89564,G+48|0),e=un(e)),(0|e)<0)break c;A[G+36>>2]=e,A[G+32>>2]=1,En(G+352|0,89623,G+32|0)}e=G+352|0,rn(A[Q>>2]+189424|0,e),A[Q>>2]=A[Q>>2]+Hn(e),A[4+(134912+(n<<6)|0)>>2]=1}if(_e(Q,A[33709]),47==(0|R)){Yt(11,Q),n=16384;break i}a[134772]=1,n=16384;break i;case 42:Yt(43,Q),a[134772]=0,n=16384;break i;case 12:c:{if(e=zt(h,89714)){if(n=16384,(k=(0|(e=mn(e,130336)))<0?2:e)>>>0<=2&&(e=A[Q>>2],A[G+84>>2]=k,A[G+80>>2]=1,En(e+189424|0,89770,G+80|0),A[Q>>2]=A[Q>>2]+3,n=0),e=A[102784+(k<<2)>>2],!(s=zt(h,89907)))break c;break o}if(n=16384,s=zt(h,89907))break o;e=21;break A}if(k>>>0<3)break l;break A;case 0:(e=zt(h,89965))&&(hn(n=G+352|0,e,160),hr(n)),n=Be(h,1,A[33708])?147456:0;break i;case 1:n=Be(h,2,e)?147456:0;break i;case 5:n=0,6==A[k>>2]&&(n=Be(h,38,e),e=A[33708]),n=524358+(Be(h,6,e)|n)|0;break i;case 6:n=0,6==(0|(s=A[k>>2]))&&(n=Be(h,38,e),s=A[k>>2]),7==(0|s)&&(n=Be(h,39,A[33708])|n),n=524358+(n|Be(h,7,A[33708]))|0;break i;case 37:if(n=524328,6!=A[k>>2])break i;n=Be(h,38,e)+524328|0;break i;case 38:if(n=524358,6!=(-2&A[k>>2]))break i;n=Be(h,39,e)+524358|0;break i;case 14:case 46:break i;case 3:break u;default:break l}e=zt(h,88893),n=zt(h,88992),s=zt(h,89153),h=mn(e,130272),n=mn(n,130320),e=er(s,0),A[G>>2]=1,s=(0|e)<2?193:e- -64|0,n=64==(0|(e=1==(0|n)?19:h))?s:e,A[G+4>>2]=n,En(e=G+352|0,89230,G),rn(A[Q>>2]+189424|0,e),e=A[Q>>2]+Hn(e)|0,A[Q>>2]=e,A[33707]=e,A[33692]=n}n=0;break i}e=er(s,1),s=A[33722],yr(1,A[33713]),(0|(e=(0|(s=(0|b(e,s))/100<<8))/(0|b(A[36429],10))|0))<=199&&(e=(0|s)/(0|b(A[36428],10))|0),n=n||16384}s=e>>>5|0,h=e,n=((e=(0|e)>4095)?s>>>0>=4095?4095:s:h)+(e?8388608|n:n)|0}if(U=G+560|0,n){if(e=A[f+2148>>2]+189424|0,a[0|e]=32,a[e+1|0]=0,!(131072&n)){r=n;break e}rn(189360,134784),r=n;break e}A[f+2156>>2]=32;i:{A:{if(!(n=A[33285])){if(k=0,e=A[33283],A[e>>2]==A[e+4>>2])continue;if(!(n=A[33285]))break A}A[33285]=0;break i}A[33284]=A[33284]+1,e=A[33283],n=0|Ns[A[e+8>>2]](e)}A[f+2152>>2]=n,k=0;continue}A[f+2156>>2]=e+57344}if(o[134824])continue;if(s=A[f+2156>>2],!(10!=(0|(e=A[f+2152>>2]))|-1!=A[47268])){16384==(0|(r=qe(s)))?(e=A[f+2148>>2],i[O+(e<<1)>>1]=A[33284]-A[47353],A[te>>2]=e,r=524328,e=Qn(A[f+2156>>2],e+189424|0)+A[f+2148>>2]|0):e=A[f+2148>>2],a[0|(e=e+189424|0)]=32,a[e+1|0]=0;break e}s:if(1==(0|s)){if(66!=(0|e)){if(86!=(0|e))break s;for(e=A[f+2148>>2],A[f+2148>>2]=e+1,a[e+189424|0]=0;;){a:{i:{A:{if(!(n=A[33285])){if(e=A[33283],A[e>>2]==A[e+4>>2])break a;if(!(n=A[33285]))break A}A[33285]=0;break i}A[33284]=A[33284]+1,e=A[33283],n=0|Ns[A[e+8>>2]](e)}if(A[f+2156>>2]=n,!(tr(n)||(0|(e=A[f+2148>>2]))>=799)){A[f+2148>>2]=e+1,a[e+189424|0]=A[f+2156>>2];continue}}break}a[A[f+2148>>2]+189424|0]=0,r=147456;break e}n=A[f+2148>>2],a[0|(e=n+189424|0)]=32,a[e+1|0]=32,a[e+2|0]=32,a[e+3|0]=0,A[f+2148>>2]=n+3;a:{i:{A:{o:{l:{u:{if(!(n=A[33285])){if(e=A[33283],A[e>>2]==A[e+4>>2])break o;if(!(n=A[33285]))break u}A[33285]=0;break l}A[33284]=A[33284]+1,e=A[33283],n=0|Ns[A[e+8>>2]](e)}if(A[f+2152>>2]=n,s=0,48!=(0|n))break A;break i}n=A[f+2152>>2]}if(A[47208]=0,A[47201]=1,49==(0|n))break a;for(s=A[33285],h=0;;){A:{if(!s){if(e=A[33283],A[e>>2]==A[e+4>>2])break A;n=A[f+2152>>2]}if(!(tr(n)|h>>>0>58)){A[188832+(h<<2)>>2]=A[f+2152>>2],(n=A[33285])?(A[33285]=0,s=0):(A[33284]=A[33284]+1,e=A[33283],n=0|Ns[A[e+8>>2]](e),s=A[33285]),h=h+1|0,A[f+2152>>2]=n,e=A[f+2148>>2],A[f+2148>>2]=e+1,a[e+189424|0]=32;continue}}break}s=2,A[188832+(h<<2)>>2]=0}A[47201]=s}a:{if(!(n=A[33285])){if(e=A[33283],A[e>>2]==A[e+4>>2])continue;if(!(n=A[33285]))break a}A[33285]=0,A[f+2152>>2]=n;continue}A[33284]=A[33284]+1,e=A[33283],A[f+2152>>2]=Ns[A[e+8>>2]](e);continue}X=X+1|0,n=0,e=A[M+340>>2];s:if(h=g[e>>1]){for(;;){if((65535&h)!=(0|s)){if(h=g[e+((n=n+2|0)<<1)>>1])continue;break s}break}a:switch(0|(e=g[e+(n<<1|2)>>1])){case 1:continue;case 0:break s}A[f+2156>>2]=e,s=e}Er(s)?(T=1,n=A[f+2156>>2]):W?(A[33285]=A[f+2152>>2],n=1328,A[f+2156>>2]=1328,A[f+2152>>2]=32,W=0):3851!=(0|(n=A[f+2156>>2]))?(W=0,3405!=(0|n)|8205!=A[f+2152>>2]||(n=3406,A[f+2156>>2]=3406)):(n=32,A[f+2156>>2]=32,W=0);s:if(dr(n)){if(A[M+8216>>2]=A[M+8216>>2]+1,A[33692]|2!=A[47200])break s;if(dr(P))break s;if(A[f+2544>>2]=0,A[f+2548>>2]=0,A[f+2304>>2]=84731,!He(M,f+2304|0,f+2160|0,f+2544|0,0,0))break s;if(Ae(M,e=f+2160|0,f+2544|0,-1,0),St(n=e,e=f+2336|0),A[f+80>>2]=e,En(n=f+2240|0,85451,f+80|0),e=A[f+2148>>2],(0|(n=Hn(n)+e|0))>=800)break s;rn(e+189424|0,f+2240|0),A[f+2148>>2]=n}else Br(A[f+2156>>2])&&(A[M+8220>>2]=A[M+8220>>2]+1);if(n=A[f+2152>>2],e=A[f+2156>>2],A[47204])if((0|k)>0)k=k-1|0;else{if(!(91!=(0|e)|91!=(0|n))){s=0,k=-1;break t}k=93==(0|e)&&93==(0|n)?2:k}if(10==(0|e)){for(s=A[33285],h=0;;){s:{if(!s){if(e=A[33283],A[e>>2]==A[e+4>>2])break s;n=A[f+2152>>2]}if(tr(n)){h=(10==A[f+2152>>2])+h|0,(n=A[33285])?(A[33285]=0,s=0):(A[33284]=A[33284]+1,e=A[33283],n=0|Ns[A[e+8>>2]](e),s=A[33285]),A[f+2152>>2]=n;continue}}break}if((0|h)>0){r&&kt(e=Z+189424|0,32,Ht(f+2336|0,e)),e=A[f+2148>>2]+189424|0,a[0|e]=32,a[e+1|0]=0,A[33285]=A[f+2152>>2],r=A[47203]?524358:b((0|h)>=3?3:h,30)+524328|0;break e}if(e=A[47268]<(0|X),X=0,!e){e=A[f+2148>>2]+189424|0,a[0|e]=32,a[e+1|0]=0,A[33285]=A[f+2152>>2],r=262174;break e}}if(s=0,A[33692]|k)break t;if(e=0,!r)break n;if(tr(A[f+2156>>2])){e=r;break n}if(fn(A[f+2156>>2])&&kr(A[f+2156>>2]))break n;A[33691]=A[f+2156>>2],a[0|(e=Z+189424|0)]=32,a[e+1|0]=0,A[33285]=A[f+2152>>2];break e}W&&(A[f+2148>>2]=Qn(1328,A[f+2148>>2]+189424|0)+A[f+2148>>2]),r&&kt(e=Z+189424|0,32,Ht(f+2336|0,e)),e=A[f+2148>>2]+189424|0,a[0|e]=32,a[e+1|0]=0}r=589864;break e}if(!(46!=(0|(n=A[f+2156>>2]))|46!=A[f+2152>>2])){n:{r:{s:{if(!(n=A[33285])){if(n=A[33283],A[n>>2]==A[n+4>>2])break n;if(!(n=A[33285]))break s}A[33285]=0;break r}A[33284]=A[33284]+1,n=A[33283],n=0|Ns[A[n+8>>2]](n)}if(C=n,46==(0|n))for(A[f+2152>>2]=32,A[f+2156>>2]=8230,C=A[33285];;){r:{s:{if(!C){if(n=A[33283],A[n>>2]==A[n+4>>2]){C=46;break n}if(!(C=A[33285]))break s}A[33285]=0,n=0;break r}A[33284]=A[33284]+1,n=A[33283],C=0|Ns[A[n+8>>2]](n),n=A[33285]}if(46!=(0|C))break n;A[f+2152>>2]=32,A[f+2156>>2]=8230,C=n}}8230!=(0|(n=A[f+2156>>2]))?A[33285]=C:(A[f+2152>>2]=C,n=8230)}if(R=0,16384!=(0|(B=qe(n)))){n:if(536621&B)for(n=A[33285];;){if(!n&&(n=A[33283],A[n>>2]==A[n+4>>2]))break n;if(!(536621&qe(A[f+2152>>2])))break n;(C=A[33285])?(A[33285]=0,n=0):(A[33284]=A[33284]+1,n=A[33283],C=0|Ns[A[n+8>>2]](n),n=A[33285]),A[f+2152>>2]=C}if(1048576&B){A[w+780>>2]=B>>>12&15,W=1,k=0,r=e;continue}(tr(A[f+2152>>2])|32768&B||ss(A[f+2152>>2])||63==(0|(n=A[f+2152>>2]))||(h=0,A[33285]||(n=A[33283],h=A[n>>2]==A[n+4>>2],n=A[f+2152>>2]),h||1==(0|n)))&&(R=1)}if(57404==(0|(n=A[f+2156>>2]))&&(A[f+2156>>2]=60,n=60),A[47201]){r=0;n:if(!(1<<(h=jt(n))&1879048255&&h>>>0<=30)){if(!((h=jt(n))>>>0>27)){if(116672&(k=1<<h))break n;if(134227968&k){r=!(1024&q(n,h));break n}}r=1}if(!(o[134772]|!r)&&(1==A[47201]||Fr(188832,A[f+2156>>2]))){A[M+288>>2]=0,s=A[f+2156>>2],a[f+2336|0]=0,k=A[f+2152>>2],n=0;n:{r:if(!((0|(r=A[34064]))<=0))for(;;){if((0|s)==A[136272+(n<<4)>>2]){if(A[136276+(n<<4)>>2])break n;if(Qe(0,n))break r;break n}if((0|r)==(0|(n=n+1|0)))break}n=-1}n:if((0|n)>=0)A[f>>2]=n,En(f+2336|0,86007,f),A[33285]=k;else if((h=!R)|46!=(0|s)|46==(0|k)||(A[f+2600>>2]=0,A[f+2604>>2]=0,A[f+2540>>2]=86036,!He(M,f+2540|0,f+2544|0,f+2600|0,0,0))?n=We(f+2240|0,M,s,0):(Ae(M,n=f+2544|0,f+2600|0,-1,0),St(r=n,n=f+2160|0),A[f+64>>2]=n,En(n=f+2304|0,85451,f- -64|0)),r=n,h|!A[f+2148>>2]|2&o[M+76|0]){for(n=A[33285],h=1;;){r:{s:{if(!n){if(n=A[33283],A[n>>2]==A[n+4>>2]|60==(0|s)|(0|s)!=(0|k))break r;if(h=h+1|0,k=A[33285])break s;A[33284]=A[33284]+1,n=A[33283],k=0|Ns[A[n+8>>2]](n),n=A[33285];continue}if(60==(0|s)|(0|s)!=(0|k))break r;k=n,h=h+1|0}n=0,A[33285]=0;continue}break}if(A[f+2152>>2]=k,R&&(A[33285]=k),1==(0|h)){A[f+16>>2]=r,En(f+2336|0,86219,f+16|0);break n}if((0|h)<=3){if(a[f+2336|0]=0,(0|(n=A[50786]))<=299&&(A[f+2336>>2]=o[86728]|o[86729]<<8|o[86730]<<16|o[86731]<<24,i[f+2340>>1]=o[86732]|o[86733]<<8),(0|h)>0){for(;A[f+32>>2]=r,En(n=f+2160|0,86219,f+32|0),k=h>>>0>1,Es(f+2336|0,n),h=h-1|0,k;);n=A[50786]}if((0|n)>299)break n;A[f+2160>>2]=o[86857]|o[86858]<<8|o[86859]<<16|o[86860]<<24,n=o[86860]|o[86861]<<8|o[86862]<<16|o[86863]<<24,a[f+2163|0]=n,a[f+2164|0]=n>>>8,a[f+2165|0]=n>>>16,a[f+2166|0]=n>>>24,Es(f+2336|0,f+2160|0);break n}A[f+56>>2]=r,A[f+52>>2]=h,A[f+48>>2]=r,En(f+2336|0,86932,f+48|0)}else A[33691]=s,A[33285]=k,i[f+2336>>1]=32;if(h=Hn(r=f+2336|0),rn((n=A[f+2148>>2])+189424|0,r),A[f+2148>>2]=n+h,R){if(45==(0|s)){r=16384;break e}if(r=qe(s),!(2&o[M+76|0]|(0|n)<=0)){r=266270==(-32769&r)?262148:4096==(28672&r)?266244:262148;break e}if(!(524288&r)){r=4096==(28672&r)?266244:262148;break e}if((0|r)>=0)break e}s=A[f+2156>>2]}}if(s|!(2097152&B)||(n=rn(A[f+2148>>2]+189424|0,We(f+2336|0,M,A[f+2156>>2],1)),o[0|n]?(A[f+2148>>2]=A[f+2148>>2]+Hn(n),B&=-28673,s=A[f+2156>>2]):s=0),k=0,R){n:if(tr(C=A[f+2152>>2]))for(h=A[33285],n=0;;){if(!h&&(r=A[33283],A[r>>2]==A[r+4>>2]))break n;if(!tr(C))break n;n=(10==(0|C))+n|0,(C=A[33285])?(A[33285]=0,h=0):(A[33284]=A[33284]+1,r=A[33283],C=0|Ns[A[r+8>>2]](r),h=A[33285])}else n=0;r=46==(0|(k=A[f+2156>>2]))&&(0|n)<2?4194304|B:B;n:{if(!n){h=1,44!=(0|k)|46!=(0|P)|26741!=A[M+212>>2]|F-48>>>0>=10||C-48>>>0>=10&&!kr(C)||(A[f+2156>>2]=1367,h=0),46!=(0|(B=A[f+2156>>2]))|39!=(0|C)||(k=h,B=A[33283],(0|(G=A[B>>2]))==A[B+4>>2]?h=0:(h=0|Ns[A[B+8>>2]](B),A[B>>2]=G),B=A[f+2156>>2],h=115!=(0|h)&k);r:if(46!=(0|B))h&=T;else{s:if(1&a[M+106|0]){if(!(P-48>>>0<10)){if((k=P-73|0)>>>0>15|!(1<<k&40969))break s;if(!(1<<(k=F-73|0)&40969&&k>>>0<=15||tr(F)))break s}h=P-48>>>0>=10?0:!kr(C)&45!=(0|C)&h}if(kr(C)&&(h=0!=o[M+208|0]&h),T){B=A[f+2156>>2];break r}B=32,A[f+2156>>2]=32,h=0}if(!(!h|46!=(0|B)|!A[47203]|60!=(0|C))){Z=A[f+2148>>2],e=r;break n}if(!h)break n}if(e=A[f+2148>>2]+189424|0,a[0|e]=32,a[e+1|0]=0,A[33285]=C,P-48>>>0<10&&(r=fn(C)?r:-4194305&r),(0|n)<2)break e;r=536621==(0|r)?536656:532520==(0|r)?532555:524358;break e}(A[33285]||(k=0,n=A[33283],A[n>>2]!=A[n+4>>2]))&&(k=0,tr(A[f+2152>>2])&&(A[33285]=C))}r=e}if(1!=A[33712]){if((0|s)!=(0|(n=A[f+2156>>2])))h=A[f+2148>>2],57404==(0|n)&&(n=60,A[f+2156>>2]=60);else{t:{if(ss(s))n=57384;else{if(n=45,45==A[f+2156>>2])break t;n=32}A[f+2156>>2]=n}h=A[f+2148>>2]}A[f+2148>>2]=Qn(n,h+189424|0)+A[f+2148>>2],tr(A[f+2156>>2])||ss(A[f+2156>>2])||(e=A[f+2148>>2],i[O+(e<<1)>>1]=A[33284]-A[47353],(0|e)<=(h+1|0)||kt(Ie+(h<<1)|0,255,e+~h<<1)),n=A[f+2148>>2],A[te>>2]=n;t:{n:{if((0|n)>725){if(!fn(A[f+2156>>2]))break n;n=A[f+2148>>2]}if((0|n)<796)continue;break t}if(n=A[f+2148>>2],!(A[f+2156>>2]-48>>>0>=10)&&(0|n)<796)continue}break}}a[0|(e=n+189424|0)]=32,a[e+1|0]=0,A[33285]=A[f+2152>>2],r=16384}U=f+2608|0,W=r,oe&&(e=A[w+780>>2],A[oe>>2]=e||W>>>12&7),e=(w+5184|0)+(A[w+6800>>2]<<1)|0,i[e+6>>1]=0,i[e+2>>1]=0,i[e+4>>1]=32767,B=b(4095&W,8388608&W?320:10),r=189424;e:{t:{n:if(e=o[189424]){for(;;){if(!!(255&(e=e<<24>>24))&e>>>0<33){if(e=o[0|(r=r+1|0)])continue;break n}break}if(o[0|r])break t}B=(0|(n=B-(e=A[47566])|0))>0?n:0,A[47566]=B+e,W=o[190268]?524288|W:W,A[M+8240>>2]=W;break e}A[47566]=B,e=o[190268],A[M+8240>>2]=W,e&&(_=1,A[47568]=A[47568]+1,(0|(e=A[47569]))<=0||(e=e-1|0,A[47569]=e,e||(a[190280]=0)))}A[49572]=1,A[47572]=655360,A[47573]=0,A[M+8184>>2]=0,A[M+8188>>2]=0,e=0,A[M+288>>2]=0,A[(n=M- -8192|0)>>2]=0,A[n+4>>2]=0,A[M+8200>>2]=0,A[M+8224>>2]=0,A[M+8228>>2]=0,A[(n=M+8232|0)>>2]=0,A[n+4>>2]=0,a[w+786|0]=32,i[w+784>>1]=8192,A[w+6812>>2]=32,i[w+1588>>1]=3,A[w+1584>>2]=0,r=0;e:if(!((0|(n=A[w+6800>>2]))<=0)){for(;;){if(i[(w+5184|0)+(r<<1)>>1]>0)break e;if((0|n)==(0|(r=r+1|0)))break}r=n}if(n=g[(w+5184|0)+(r<<1)>>1],i[w+1592>>1]=n,n)for(;e=!!(65535&~n)+e|0,n=g[(w+5184|0)+((r=r+1|0)<<1)>>1];);for(a[w+1594|0]=e,h=3,O=1,r=0;;){F=A[w+6808>>2],_t(w+6808|0,(Q=(w+784|0)+h|0)-1|0),!o[M+170|0]|A[w+6808>>2]-48>>>0>=10||fn(F)&&(A[w+6808>>2]=97),S?A[w+6812>>2]=S:y&&_t(w+6812|0,y+189423|0),n=y;e:{t:if(r||(n=Ht(w+6816|0,y+189424|0)+y|0,r=A[w+6816>>2])){if(T=Ht(w+6804|0,e=n+189424|0),1==(0|r)){if(s=n-1|0,S=32,P=0,32!=A[w+6812>>2]){n=s,e=32;break t}y=0,r=n;n:{r:switch(o[0|e]-43|0){case 0:r=n+1|0,y=64;break n;case 2:break r;default:break n}r=n+1|0,y=96}if(a[0|(e=r+189424|0)]-48>>>0>=10)C=r+1|0,T=-1;else{for(T=kn(e);r=(e=r)+1|0,a[e+189424|0]-48>>>0<10;);C=r,r=e}if((0|(S=A[47350]))>247)e=0;else if(e=0,!((0|(r=a[r+189424|0]))<0)&&(r=Zt(84868,255&r,14))){n=1+(e=r-84868|0)|0,-1==(0|T)&&(T=A[105536+(n<<2)>>2],y=0);n:{r:switch(e-8|0){case 0:A[49574]=0,A[49573]=T;break n;case 4:break r;default:break n}a[199304]=(0|T)>=3?1:0}e=1,A[47350]=S+1,A[198304+(S<<2)>>2]=(n+y|0)+(T<<8),n=C}S=A[w+6812>>2],kt(s+189424|0,32,n-s|0),re=e+re|0,r=0;break e}S=0,32==(0|r)|36!=A[49573]?(P=0,e=r):(32!=A[w+6812>>2]|32!=A[w+6804>>2]||(A[49573]=20),P=0,e=qr(r,M))}else A[w+6804>>2]=32,P=1,S=0,T=0,e=32;t:if(K){if(K=1,O=8,r=0,93!=(0|e)|93!=A[w+6804>>2])break t;n=n+1|0,e=32,K=0}else if(64!=(240&(r=A[49573])))if(K=0,16&r)r=0;else{n:{r:{s:{a:{if(!(8216!=(0|(C=8242==(0|e)||8217==(0|e)||146==(0|e)||180==(0|e)?39:e))&63!=(0|C)))if(fn(A[w+6808>>2])){if(C=e,fn(A[w+6804>>2])){C=39;break a}}else C=e;i:{if(1367!=(0|C)){if(1328==(0|C)){E|=1024,C=32;break a}if((e=C-44032|0)>>>0>11183)break a;if(s=((r=((k=65535&e)>>>0)/28|0)>>>0)%21|0,e=e-b(r,28)&65535,C-50500>>>0>587)break i;r=e?e+4519|0:0,s=s+4449|0;break r}E|=131072,Z=A[w+6804>>2],e=A[w+6812>>2],C=32;break s}r=50500+(e+b(s,28)|0)|0,s=(k>>>0)/588|4352;break r}if(Z=A[w+6804>>2],e=A[w+6812>>2],!((r=C-12592|0)>>>0>51)){s=4352|o[r+103296|0],r=0;break r}}f=n+189424|0;s:if(!(28268!=(0|(r=A[M+212>>2]))&24934!=(0|r)|39!=(0|C))&&!Br(e)&&(Ht(w+6820|0,f+1|0),Ur(A[w+6820>>2]))){s=601,r=0;a:switch(Z-110|0){case 6:break r;case 0:break a;default:break s}if(24934!=A[M+212>>2])break r;a[0|f]=32;break r}if(A[w+6824>>2]=32,(0|(e=A[49897]))>0)A[49897]=e-1,r=0;else{if(!C){r=0,s=0;break n}s:{a:{i:{A:if((R=A[M+180>>2])&&(k=C,(G=dr(C))&&(k=qr(C,M)),!As(R)))for(;;){A[w+16>>2]=0,A[w+624>>2]=k,e=Ht(w+16|0,R)+R|0;o:if(A[w+624>>2]==A[w+16>>2]){if(o[0|e]){for(s=1,j=0,r=f;Y=Ht(w+16|0,e),X=Ht(w+624|0,r),te=qr(A[w+624>>2],M),A[w+624>>2]=te,r=r+X|0,j=(X=(0|te)==A[w+16>>2])+j|0,s&=X,o[0|(e=e+Y|0)];);if(!s)break o;A[49897]=j}if(!(e=e+1|0))break A;if(8&o[188788]&&(A[w>>2]=R,A[w+4>>2]=e,ts(A[47195],85187,w)),e=Ht(w+6828|0,e)+e|0,o[0|e])break i;r=0;break a}for(;r=e,e=e+1|0,o[0|r];);for(;o[0|(r=(e=r)+1|0)];);if(As(R=e+2|0))break}r=0,s=C;break s}Ht(w+6824|0,e),G&&dr(Z)&&(A[w+6824>>2]=ir(A[w+6824>>2])),r=A[w+6824>>2]}s=A[w+6828>>2],E|=2097152,G&&(s=ir(s))}if(8!=(0|s))break r}s=n;break e}r?A[w+6804>>2]=r:r=0}fn(s)||Ur(s)||Fr(A[M+336>>2],s)||!fn(A[w+6808>>2])|!(!o[M+170|0]|s-48>>>0>=10)&A[w+6804>>2]-48>>>0>=10||(s=32,z=1);n:{r:{s:{a:{i:{if(A[w+6808>>2]-48>>>0<10){if(s-48>>>0<10){e=v;break i}if(1<<(e=s-32|0)&20481&&e>>>0<=14)break a;z=1}else{if(e=0,44!=A[w+6812>>2])break i;if(e=v,44!=(0|s))break i}s=32;break a}if(91==(0|s)){if(2==(0|(C=A[w+6804>>2])))break s;if(s=91,91==(0|C)&&A[47204])break s}v=e}if(fn(s)){a:{i:{A:{if(fn(A[w+6808>>2])){if(!o[M+171|0])break A;if(e=A[w+6808>>2],!((0|s)>12352)&&(0|e)<12353)break A}else e=A[w+6808>>2];if(J=Fr(A[M+336>>2],e)?J:0,32!=(0|(e=A[w+6808>>2]))&&!Fr(A[M+336>>2],e)){e=32,D=ss(A[w+6808>>2])?D:256|D;break i}E=dr(s)?2|E:E,32!=A[w+6808>>2]|a[Q-2|0]-48>>>0>=10|A[w+6812>>2]-48>>>0<10||(a[(w+784|0)+h|0]=32,e=1588+(b(L,12)+w|0)|0,i[e>>1]=g[e>>1]+1,h=h+1|0)}if(e=32,32==(0|s))break a;if(J=J+1|0,(0|(C=A[M+600>>2]))<=0){e=s;break a}if(!((0|s)<=591&(0|(k=A[w+6808>>2]))>=(0|C))){if((0|s)<(0|C)){e=s;break a}if((0|J)<2){e=s;break a}if(!((0|k)<=591)){e=s;break a}}if(!fn(k)){e=s;break a}E|=16384,D|=128}z=1}if(he=he+1|0,dr(e)){if(C=qr(e,M),A[M- -64>>2]){e=fe?C:712,r=fe?r:C,fe=1;break t}if(kr(A[w+6812>>2])){if(32==A[w+6808>>2]){e=C;break t}if(e=32,26465!=A[M+212>>2])break n;for(s=85240,k=(w+784|0)+h|0,T=0;;){if(f=Hn(s),32==o[0|(F=k-f|0)]&&!Sn(F+1|0,s,f=f-1|0)){if((0|(s=a[s+f|0]))==(0|C)){e=C;break t}if(65==(0|s)&&On(M,C)){e=C;break t}}if(s=A[131184+((T=T+1|0)<<2)>>2],11==(0|T))break}break n}if(e=32,32==(0|C))break t;if(!dr(A[w+6812>>2])){e=C;break t}if(!kr(A[w+6804>>2])){e=C;break t}if(Ht(w+16|0,189424+(n+T|0)|0),!(28268!=A[M+212>>2]|2!=(0|J)|106!=(0|C)|73!=A[w+6812>>2])){e=C;break t}if(32==A[w+6808>>2]){e=C;break t}if(!fn(A[w+16>>2])){e=C;break t}D|=256,S=32,z=1;break t}if(!O){O=0;break t}if((0|J)<3){O=0;break t}if(115!=(0|e)){O=0;break t}if(25966!=A[M+212>>2]){O=0;break t}if(32!=A[w+6804>>2]){O=0;break t}if(O|=4,e=32,39!=o[783+(s=h+w|0)|0])break t;a[s+783|0]=32;break t}e=32;a:{i:{A:{o:{l:switch(s-39|0){default:if(95==(0|s))break t;case 1:case 2:case 3:case 4:case 5:if(s-48>>>0>=10)break a;if(o[M+170|0]&&fn(A[w+6808>>2])&&!((C=A[w+6804>>2])-48>>>0<10|C-2406>>>0<10))break a;if(32==(0|(k=A[w+6808>>2])))break i;if(C=A[w+6808>>2],k-48>>>0<10)break A;if((0|(k=C))==(0|(C=A[M+128>>2])))break o;z=1;break t;case 6:if(!Ur(A[w+6812>>2])&&fn(A[w+6804>>2])){if(32!=A[w+6808>>2]){z=1;break t}if(E|=128,(0|L)<=0)break t;s=1572+(b(L,12)+w|0)|0,A[s>>2]=16384|A[s>>2];break t}if(s=A[w+6804>>2],!(32!=A[w+6812>>2]|32!=(0|s))){H=4;break t}if(45==(0|s)){n=n+1|0,H=4;break t}if(e=45,32!=A[w+6808>>2])break t;if(!fn(F))break t;if(fn(A[w+6812>>2]))break t;a[(w+784|0)+h|0]=32,s=1588+(b(L,12)+w|0)|0,i[s>>1]=g[s>>1]+1,h=h+1|0;break t;case 7:if(46==A[w+6808>>2]){z=1;break t}if(e=46,(0|L)<=0)break t;if(s=1572+(b(L,12)+w|0)|0,1&a[s+1|0])break t;if(!fn(A[w+6812>>2]))break t;A[s>>2]=65536|A[s>>2],e=(e=Ur(A[w+6804>>2]))||45==A[w+6804>>2]?32:46;break t;case 0:}l:{if(46!=(0|(C=A[w+6812>>2]))||(s=115,115!=A[w+6804>>2])){if(!Er(C))break l;s=A[w+6804>>2]}if(fn(s))break r}if(1&(s=A[M+88>>2])){if(fn(A[w+6804>>2]))break r;s=A[M+88>>2]}if(2&s&&fn(A[w+6812>>2]))break r;if(!(!Fr(A[M+332>>2],A[w+6812>>2])|32!=(0|F))){n=(32==A[w+6804>>2])+n|0;break r}if(C=115!=(0|(s=A[w+6808>>2]))|ge,ge=0,!(1&C))break t;ge=!!(0|Ur(s)),H=4;break t}if(44==(0|C)&v){z=1;break t}v=1;break a}if(32!=(0|C))break a}fn(F)&&(fn(A[w+6812>>2])||(a[(w+784|0)+h|0]=32,e=1588+(b(L,12)+w|0)|0,i[e>>1]=g[e>>1]+1,h=h+1|0))}e=s;break t}K=1,s=n+1|0,v=e;break e}e=39,ge=0;break t}z=1,S=32}else{if(e-48>>>0<10){r=0,s=(0|(C=A[49574]+1|0))>(15&A[49573]),A[49574]=s?0:C,e=s?32:e,z|=s,K=0;break t}r=0,A[49574]=0,e=(s=A[w+6808>>2]-48>>>0<10)?32:e,z|=s,K=0}if(Ur(e)){if(32==A[w+6808>>2]){E|=262144,s=n;break e}if(s=A[w+6816>>2]-9>>>0<2,k=1&z){T=0;t:if(!((0|x)>(0|(e=n-1|0))))for(;;){if(!(C=i[(w+5184|0)+(e<<1)>>1]))break t;if(T=((0|C)>0)+T|0,!((0|x)<=(0|(e=e-1|0))))break}a[1594+(b(L,12)+w|0)|0]=T}if(D=s?262144|D:D,a[(w+784|0)+h|0]=32,e=h+1|0,!((0|L)>298||(s=(w+1584|0)+b(L,12)|0,(0|(C=g[s+4>>1]))>=(0|e)))){if((0|re)<=0?x=A[s>>2]:(x=198300+(A[47350]<<2)|0,A[x>>2]=128|A[x>>2],re=0,x=64|A[s>>2]),f=A[47352],a[s+6|0]=f,A[s>>2]=x|(he?O:-2&O)|(o[199304]?2048:0)|E,(0|f)>0){for(;E=(x=w+784|0)+e|0,x=x+(e=e-1|0)|0,a[0|E]=o[0|x],(0|e)>(0|C););a[0|x]=32,i[s+4>>1]=C+1,e=h+2|0}C=(w+1584|0)+b(L=L+1|0,12)|0,A[C>>2]=0,i[C+4>>1]=e,h=n;t:if(!((0|(s=A[w+6800>>2]))<=(0|n))){for(;;){if(i[(w+5184|0)+(h<<1)>>1]>0)break t;if((0|s)==(0|(h=h+1|0)))break}h=s}if(T=g[(w+5184|0)+(h<<1)>>1],i[C+8>>1]=T,he=0,s=0,T)for(;s=!!(65535&~T)+s|0,T=g[(w+5184|0)+((h=h+1|0)<<1)>>1];);a[C+10|0]=s,A[47352]=0,O=1,E=D,D=0,fe=0}z=0,r=k?0:r,s=k?y:n}else(0|h)>795?(s=n,n=x,e=h):(e=Qn(e,(w+784|0)+h|0)+h|0,s=n,n=x);A[47352]<(0|H)&&(A[47352]=H),H=0,x=n,h=e}if(P||(y=s,!((0|h)<799)))break}(0|re)<=0|L||(e=198300+(A[47350]<<2)|0,A[e>>2]=128|A[e>>2],A[w+1584>>2]=64|A[w+1584>>2],L=1),e=(w+784|0)+h|0,A[M+8204>>2]=e-1,n=0,a[0|e]=0,a[w+1590|0]=0,a[1590+(b(L,12)+w|0)|0]=8;e:if((0|L)<=0)A[w+1584>>2]=512|A[w+1584>>2],h=A[49572];else{e=L-1|0;t:if(1!=(0|L))for(r=e;;){if(!ss(a[g[1588+(b(r,12)+w|0)>>1]+(w+784|0)|0])){n=r;break t}if(C=(0|r)>1,r=r-1|0,!C)break}if(n=(w+1584|0)+b(n,12)|0,A[n>>2]=16|A[n>>2],4194304&W&&(e=(w+1584|0)+b(e,12)|0,256&(n=A[e>>2])||(A[e>>2]=65536|n)),A[w+1584>>2]=512|A[w+1584>>2],!((0|L)<=0|(0|(h=A[49572]))>990))for(C=3|(e=w+624|0),k=2|e,S=w+754|0,P=!(4194304&W),y=0,x=0;;){A[47354]=A[47354]+1;t:{if((0|(e=A[49827]))<=0||(e=e-1|0,A[49827]=e,e)){if(o[190280])break t}else a[190280]=0;e=g[1588+(b(y,12)+w|0)>>1]+(w+784|0)|0;n:if(!(a[0|e]-48>>>0>=10)&&(n=w+624|0,r=e,1227133512!=A[M+112>>2])){for(;;){r:{if(a[0|r]-48>>>0<10)a[0|n]=o[0|r],n=n+1|0,r=r+1|0;else{if(A[M+124>>2]!=a[0|r]|32!=o[r+1|0])break r;if(h=r+2|0,32==o[r+3|0]|a[0|h]-48>>>0>=10|32==o[r+4|0])break r;y=y+1|0,r=h}if(n>>>0<S>>>0)continue;break n}break}kt(e+(n=n-(v=w+624|0)|0)|0,32,(r=(h=r-e|0)-n|0)>>>0<=h>>>0?r:0),Je(e,v,n)}for(n=0;r=n,n=n+1|0,a[e+r|0]-48>>>0<10;);n:if(r-5>>>0<=27){for(a[w+626|0]=32,i[w+624>>1]=8224,48!=o[0|e]&A[M+132>>2]>=(0|r)||(n=(w+1584|0)+b(y,12)|0,A[n>>2]=524288|A[n>>2]),D=(w+1584|0)+b(y,12)|0,T=0,h=C;n=e,!((e=a[0|e])-48>>>0>=10&(0|e)!=A[M+128>>2])&&(a[0|h]=e,e=h+1|0,v=r,(0|(r=r-1|0))<=0?h=e:A[M+112>>2]>>>r&1?(f=A[D+4>>2],E=(w+16|0)+b(T,12)|0,A[E>>2]=A[D>>2],A[E+4>>2]=f,A[E+8>>2]=A[D+8>>2],T=T+1|0,32!=(0|(E=A[M+124>>2]))&&(a[h+1|0]=E,e=h+2|0),a[0|e]=32,h=e+1|0,8&o[D+2|0]||((H=A[M+112>>2])>>>v-2&1&&(a[e+1|0]=48,a[e+2|0]=48,H=A[M+112>>2],h=e+3|0),H>>>v-3&1&&(a[0|h]=48,h=h+1|0))):h=e,e=n+1|0,h>>>0<S>>>0););if(r=A[D+4>>2],e=(w+16|0)+b(T,12)|0,A[e>>2]=A[D>>2],A[e+4>>2]=r,r=A[D+20>>2],A[e+16>>2]=A[D+16>>2],A[e+20>>2]=r,r=A[D+12>>2],A[e+8>>2]=A[D+8>>2],A[e+12>>2]=r,r=1,(0|T)>0)for(;e=(w+16|0)+b(r,12)|0,A[e>>2]=-262209&A[e>>2],(0|T)>=(0|(r=r+1|0)););if(e=o[n+4|0]|o[n+5|0]<<8|o[n+6|0]<<16|o[n+7|0]<<24,r=o[0|n]|o[n+1|0]<<8|o[n+2|0]<<16|o[n+3|0]<<24,a[0|h]=r,a[h+1|0]=r>>>8,a[h+2|0]=r>>>16,a[h+3|0]=r>>>24,a[h+4|0]=e,a[h+5|0]=e>>>8,a[h+6|0]=e>>>16,a[h+7|0]=e>>>24,e=o[n+12|0]|o[n+13|0]<<8|o[n+14|0]<<16|o[n+15|0]<<24,n=o[n+8|0]|o[n+9|0]<<8|o[n+10|0]<<16|o[n+11|0]<<24,a[h+8|0]=n,a[h+9|0]=n>>>8,a[h+10|0]=n>>>16,a[h+11|0]=n>>>24,a[h+12|0]=e,a[h+13|0]=e>>>8,a[h+14|0]=e>>>16,a[h+15|0]=e>>>24,a[h+16|0]=0,h>>>0<=C>>>0)break n;for(e=o[D+6|0],T=0,r=C;;){for(x=ce(M,r,(w+16|0)+b(T,12)|0,255&e);e=o[0|r],r=r+1|0,32!=(0|e););if(e=0,a[D+6|0]=0,T=T+1|0,!(r>>>0<h>>>0))break}}else{if(A[47352]=0,x=ce(M,e,n=(w+1584|0)+b(y,12)|0,o[n+6|0]),(0|(r=A[47352]))>o[n+18|0]&&(a[n+18|0]=r,A[47352]=0),!(!(4096&x)|32==o[0|e]))for(;kt(w+624|0,0,150),A[w+624>>2]=538976288,A[w+628>>2]=538976288,a[w+632|0]=32,ce(M,Je(k,e,r=Ht(w+16|0,e)),n,0),32!=o[0|(e=e+r|0)];);50331648&x&&(B=(e=P|(~A[33264]+L|0)!=(0|y))?B:10,e|!oe||(A[oe>>2]=4,B=10))}if(128&x&&!((0|(n=A[33264]))<=0)){if(e=0,r=n,h=3&n)for(;v=(w+1584|0)+b(r+y|0,12)|0,A[v>>2]=1048576|A[v>>2],r=r-1|0,(0|h)!=(0|(e=e+1|0)););if(n>>>0>=4)for(;e=(w+1584|0)+b(r+y|0,12)|0,A[e>>2]=1048576|A[e>>2],A[(n=e-12|0)>>2]=1048576|A[n>>2],A[(n=e-24|0)>>2]=1048576|A[n>>2],A[(e=e-36|0)>>2]=1048576|A[e>>2],r=r-4|0;);A[33264]=r}}if(h=A[49572],(0|L)<=(0|(y=y+1|0)))break e;if(!((0|h)<991))break}}if((0|(r=A[47351]))<(0|(C=A[47350]))){for(S=A[47202],P=A[49846],T=A[47352];;){e=(n=A[198304+(r<<2)>>2])>>8;e:{t:switch((31&n)-9|0){case 0:S=e;break e;case 4:P=e;break e;case 3:break t;default:break e}T=n>>>0>=256?e+T|0:0}if(!(!(128&n)&(0|C)>(0|(r=r+1|0))))break}A[47352]=T,A[47351]=r,A[49846]=P,A[47202]=S}A[49572]=h+2,A[(e=190288+(h<<3)|0)>>2]=589824,i[e+4>>1]=s,A[e+8>>2]=589824,i[e+12>>1]=s,n=L&&A[47199]?B:10,A[33285]?e=0:(e=A[33283],e=A[e>>2]==A[e+4>>2]),B=e?n:B,y=_,C=0,L=0,U=k=U-32192|0,A[k+24>>2]=0,A[k+28>>2]=0,A[k+16>>2]=0,A[k+20>>2]=0,A[k+8>>2]=0,A[k+12>>2]=0,A[k>>2]=0,A[k+4>>2]=0,s=A[49572],f=g[190284+(s<<3)>>1];e:{if((0|(r=s-3|0))<0)e=r;else{for(;;){if(C=(0|(n=127&o[3+(e=190288+(r<<3)|0)|0]))<(0|C)?C:n,g[e+4>>1])e=r;else if(e=-1,n=(0|r)>0,r=r-1|0,n)continue;break}if(C>>>0>3)break e}for(;;){if((0|(e=e-1|0))<0)break e;if(64&o[0|(n=190288+(e<<3)|0)]){a[n+3|0]=4;break e}if(!(o[n+3|0]<4))break}}if(e=A[M+292>>2],r=0,(0|s)<=0)C=0;else for(v=-1,C=0;;){n=e,A[M+292>>2]!=(0|e)&&(i[(e=190288+(r<<3)|0)>>1]=32|g[e>>1]),(0|C)>0&&(D=A[4+(x=190288+(r<<3)|0)>>2],A[(h=190288+(e=r-C<<3)|0)>>2]=A[x>>2],A[h+4>>2]=D,-1!=(0|v)&&(i[4+(e+190288|0)>>1]=v),v=-1);e:{if(21==o[2+(190288+(h=r<<3)|0)|0]){if(e=o[7+(x=h+190288|0)|0],2&o[0|x])break e;t:if((0|e)!=(0|n)){if(x=o[10+(h+190288|0)|0]-9|0){if(12==(0|x))break t;break e}if(21!=o[18+(h+190288|0)|0])break e}-1==(0|v)&&(v=(e=g[4+(h+190288|0)>>1])||-1),C=C+1|0}e=n}if((0|s)==(0|(r=r+1|0)))break}if(A[49572]=s-C,Zr(e),(n=A[M+36>>2])&&!((0|(e=(C=A[49572])-1|0))<0))for(S=256&n,E=4&n,P=8&n,D=15&n,z=16&n,_=2&n,n=n>>>8&1,r=0;;){if(h=C,s=r,C=e,21==(0|(e=o[2+(x=190288+(O=e<<3)|0)|0]))){e:{t:{if((0|(r=h-2|0))>=0)for(;;){if(21==o[2+(190288+(e=r<<3)|0)|0])break t;if(e=(0|r)>0,r=r-1|0,!e)break}e=A[M+292>>2];break e}e=o[7+(e+190288|0)|0]}Zr(e),e=o[x+2|0]}if(r=s,(e=A[144464+((255&e)<<2)>>2])&&(r=n,!(32&o[0|x]))){r=o[e+11|0],v=0,_&&(118!=(0|(h=o[0|e]))&82!=(0|h)||(s=z?0:s,v=1));e:{t:{n:{r:switch((h=253&r)-4|0){case 1:break n;case 0:break r;default:break t}if(D&&(r=1,!s))break e;if(2!=(0|(r=s)))break e;if(r=2,!(e=o[e+13|0]))break e;a[x+2|0]=e;break e}if(D&&(r=2,!s))break e;if(1!=(0|(r=s)))break e;if(r=1,!(e=o[e+13|0]))break e;a[x+2|0]=e;break e}r=0,P&&(r=h?s:0)}r=e=v?0:r,g[4+(O+190288|0)>>1]&&(r=e=E?0:e,S&&(r=e||1))}if(!((0|(e=C-1|0))>=0))break}if(Zr(A[M+292>>2]),A[49572]<=0)z=-2,r=0;else{for(r=-1,s=0,x=0,P=0;;){e=x<<3,-1!=(0|r)&&(i[4+(e+190288|0)>>1]=r),21==o[2+(v=e+190288|0)|0]&&Zr(o[7+(e+190288|0)|0]),D=A[49572];e:{if(!(32&o[0|(h=e+190288|0)])){s=(0|(n=D-1|0))>(0|x)?A[144464+(o[10+(e+190288|0)|0]<<2)>>2]:s,!(g[h+12>>1]|(0|n)==(0|x))&&(T=0,o[s+11|0]|!s)||(T=1),C=o[v+2|0];t:if(!((0|(z=A[49848]))<=0))for(n=e+190288|0,r=0;;){if(S=b(r,3),o[S+199408|0]==(255&C)&&!((E=o[2+(S+199408|0)|0])&(1^T)|(4&o[n+3|0]?2&E:0)|(g[n+4>>1]?0:4&E))){if(C=o[1+(S+199408|0)|0],a[v+2|0]=C,!(2&o[A[144464+(C<<2)>>2]+4|0])|o[n+3|0]<2)break t;a[n+3|0]=0;break t}if((0|z)==(0|(r=r+1|0)))break}if(!(255&C)){r=g[4+(e+190288|0)>>1];break e}}r=A[h+4>>2],e=(k+32|0)+(P<<5)|0,n=A[h>>2],A[e>>2]=n,A[e+4>>2]=r,n=A[144464+(n>>>14&1020)>>2],A[e+8>>2]=n,a[e+17|0]=o[n+11|0],P=P+1|0,r=-1}if(!((0|P)<1e3&(0|D)>(0|(x=x+1|0))))break}if(C=0,r=0,!((0|(z=P-2|0))<=0))for(;;){e:if(g[4+((k+32|0)+(C<<5)|0)>>1]){for(n=(0|C)>(0|z)?C:z,r=0,e=C;;){if((0|e)!=(0|n)){if(r=(0|r)>(0|(h=o[3+((s=k+32|0)+(e<<5)|0)|0]))?r:h,!g[4+(s+((e=e+1|0)<<5)|0)>>1])continue}else e=n;break}if((0|e)<=(0|C))break e;if(n=~C+e|0,s=0,h=e-C&7)for(;a[6+((k+32|0)+(C<<5)|0)|0]=r,C=C+1|0,(0|h)!=(0|(s=s+1|0)););if(n>>>0<7)break e;for(;a[6+(n=(k+32|0)+(C<<5)|0)|0]=r,a[n+38|0]=r,a[n+70|0]=r,a[n+102|0]=r,a[n+134|0]=r,a[n+166|0]=r,a[n+198|0]=r,a[n+230|0]=r,(0|(C=C+8|0))!=(0|e););}else e=C+1|0;if(C=e,!((0|z)>(0|e)))break}}for(A[k+40>>2]=A[36125],Zr(A[M+292>>2]),F=(0|r)<4,x=1,S=1,D=0,n=0,r=0,_=0;;){e:{t:{n:{r:{if(n){if(s=(e=k+32|0)+((v=r-1|0)<<5)|0,D=o[2+(e+(r<<5)|0)|0],(0|v)>0){if(e=x-(r=(0|x)>0)|0,v>>>0>=(C=r?x:2)>>>0)for(;h=(r=(k+32|0)+(C<<5)|0)-32|0,x=A[r+12>>2],A[h+8>>2]=A[r+8>>2],A[h+12>>2]=x,x=A[r+4>>2],A[h>>2]=A[r>>2],A[h+4>>2]=x,x=A[r+28>>2],A[h+24>>2]=A[r+24>>2],A[h+28>>2]=x,x=A[r+20>>2],A[h+16>>2]=A[r+16>>2],A[h+20>>2]=x,(0|v)>=(0|(C=C+1|0)););x=e}T=A[144464+(D<<2)>>2],A[s>>2]=0,A[s+4>>2]=0,A[s+24>>2]=0,A[s+28>>2]=0,A[s+16>>2]=0,A[s+20>>2]=0,A[s+8>>2]=0,A[s+12>>2]=0,a[s+2|0]=n,e=A[144464+(n<<2)>>2],A[s+8>>2]=e,D=s}else{if((0|r)>=(0|z)|(0|_)>=997)break r;h=o[2+(s=(C=r<<5)+(k+32|0)|0)|0],e=A[144464+(h<<2)>>2],A[s+8>>2]=e,v=g[s+4>>1],21==(0|h)&&Zr(o[7+(C+(k+32|0)|0)|0]),x=v?r:x,T=A[144464+(o[s+34|0]<<2)>>2],A[s+40>>2]=T,v=r}if(!e){n=0,r=v+1|0;continue}if(le(M,256,s,k+32040|0,k),(0|(r=A[k+32052>>2]))>0&&(C=(k+32|0)+(v<<5)|0,T=A[144464+(r<<2)>>2],A[C+40>>2]=T,a[C+34|0]=r,a[C+49|0]=o[T+11|0]),r=0,n)n=e;else if((0|(C=A[k+32056>>2]))<=0)n=e;else{n=A[144464+(C<<2)>>2],A[s+8>>2]=n,r=o[s+2|0],a[s+2|0]=C,C=g[s>>1];s:if(2!=o[n+11|0])i[s>>1]=65531&C;else{if(i[s>>1]=4|C,2==o[e+11|0])break s;a[s+3|0]=0}le(M,256,s,k+32040|0,k)}if((0|(h=A[k+32048>>2]))<=0)C=n;else{if(C=A[144464+(h<<2)>>2],a[s+2|0]=h,A[s+8>>2]=C,e=o[C+11|0],P=1,1==(0|h)){O=2==(0|e);break t}h=g[s>>1];s:if(2!=(0|e))i[s>>1]=65531&h;else{if(i[s>>1]=4|h,2==o[n+11|0])break s;a[s+3|0]=0}le(M,256,s,k+32040|0,k)}if(O=0,2!=(0|(e=o[C+11|0]))){P=0;break t}if(O=1,P=0,e=2,o[s+3|0]>1){L=0;break t}h=s+3|0,L=L+1|0,n=s;s:{if(8&(E=A[M+12>>2])){for(;;){a:switch(E=n,n=n+32|0,o[E+49|0]){case 0:break t;case 2:break a;default:continue}break}if(o[0|(n=E+35|0)]>1)break t;if(o[s+6|0]<=3&&(a[0|h]=0),o[E+38|0]<4)break s;break t}if(1&L|(0|L)<2)break t;if(2&E)break n;if(F)n=h;else if(n=h,g[s+36>>1])break n}a[0|n]=0;break t}A[36423]=_+2,i[(e=145840+(_<<5)|0)>>1]=0,a[e+2|0]=9,a[e+20|0]=2,A[e+12>>2]=B,i[e+4>>1]=f,a[e+17|0]=0,a[e+18|0]=0,A[e+8>>2]=A[36125],i[e+32>>1]=0,a[e+34|0]=9,a[e+52|0]=0,A[e+44>>2]=0,i[e+36>>1]=0,a[e+49|0]=0,a[e+50|0]=0,A[e+40>>2]=A[36126],Zr(A[M+292>>2]),U=k+32192|0;break e}L=1}if(!(8&(n=g[s+32>>1]))|(0|v)<=0||(h=o[T+11|0])>>>0>15|!(1<<h&457)||(r=o[T+10|0],i[s+32>>1]=8^n),G=g[s+36>>1]){t:if(n=A[M+4>>2]){n:switch(0|e){default:r=512&n?11:r;break;case 0:break t;case 2:}if(2==o[T+11|0]){(h=12&n)&&(r=12!=(0|h)?23:11);n:if(O){r:switch(3&n){case 2:r=10;break n;case 0:break n}r=23}o[s+35|0]<4||(r=256&n?10:r)}}if(!((0|s)==(0|D)|(0|_)<=0)){t:{n:{r:switch(0|(n=7&A[M>>2])){case 0:break t;case 1:break r;default:break n}if(r-12>>>0>4294967293)break t}r=o[n+101916|0]}r=A[47205]>0?24:r}}if(A[s+72>>2]=A[144464+(o[s+66|0]<<2)>>2],n=A[k+32060>>2],n=r||n||r,!P){a[17+(h=145840+(E=_<<5)|0)|0]=e,A[h+8>>2]=C,a[h+16|0]=0,i[h>>1]=g[s>>1],a[h+3|0]=15&o[s+3|0],a[h+6|0]=o[s+6|0],r=o[s+7|0],i[h+4>>1]=0,a[h+7|0]=r,P=o[C+10|0],a[h+2|0]=P;t:if(r=g[s+4>>1]){if(i[h+4>>1]=r,y=1&y?5:1,a[20+(s=E+145840|0)|0]=y,r=S,S=0,!r){y=0;break t}a[s+20|0]=8|y,y=0}else a[20+(E+145840|0)|0]=0;A[12+(r=E+145840|0)>>2]=A[k+32084>>2]<<1,!G|24!=(0|P)||(0|(s=A[47205]))<=0||(A[h+8>>2]=A[36126],A[r+12>>2]=b(s,14)),(1<<e&428?e>>>0<=8:0)|2&o[C+7|0]&&(A[r+12>>2]=128,a[h+16|0]=0),a[21+(e=E+145840|0)|0]=255,a[e+22|0]=255,i[e+18>>1]=5120,_=_+1|0}r=v+1|0;continue}break}i[88922]=1,A[44462]=0,re&&(i[145776+(A[36423]<<5)>>1]=2,e=198304+(A[47350]<<2)|0,A[e>>2]=128,A[(e=e-4|0)>>2]=128|A[e>>2]),a[190268]=W>>>19&1,pe&&(A[pe>>2]=W<<14>>31&189360)}U=w+6832|0,z=A[47192],O=A[t+12>>2],n=0,h=0,x=0,E=0,D=0,H=0,B=0,U=f=U-6e3|0;e:if(!((0|(s=(_=A[36423])-1|0))<=0)){for(;a[2+(f+b(n,6)|0)|0]=0,4&o[145840+(e=n<<5)|0]?(r=f+b(E,6)|0,a[r+1|0]=0,e=e+145840|0,a[r+3|0]=o[e+49|0],e=o[e+3|0],a[0|r]=e,E=E+1|0,H=(e>>>0>3)+H|0):27!=o[A[8+(e+145840|0)>>2]+10|0]|(0|E)<=0||(e=(f+b(E,6)|0)-4|0,a[0|e]=4|o[0|e]),(0|s)!=(0|(n=n+1|0)););if(a[f+b(E,6)|0]=0,E)if(1==A[z+148>>2]){if(!((0|_)<=0)){for(e=-2&_,r=1&_,n=145840;x=2==o[n+17|0]&&o[n+3|0]>3?h:x,x=2==o[n+49|0]&&o[n+35|0]>3?1|h:x,n=n- -64|0,h=h+2|0,(0|e)!=(0|(D=D+2|0)););!r|2!=o[n+17|0]||(x=o[n+3|0]>3?h:x)}if(a[3+(C=145840+(e=x<<5)|0)|0]=7,30313==A[z+212>>2]&&(o[7+(e=e+145840|0)|0]||(a[e+7|0]=Ir(55),_=A[36423])),!((0|_)<=0)){for(D=0,n=145840,e=145840,h=v=A[36125],s=0,S=1;;){if(o[n+17|0]?y=A[36125]:(y=A[36125],v=(r=o[A[n+8>>2]+14|0]>50)?y:v,S|=r),r=o[n+20|0]?y:h,4&o[0|n]){y=o[n+7|0],h=A[144464+(y<<2)>>2];t:{if(6840683==(0|(E=A[z+212>>2]))){if(49!=A[r>>2])break t;if((E=A[h>>2]-49|0)>>>0>5|!(1<<E&41))break t;a[e+7|0]=Ir(50),E=A[z+212>>2]}if(!(6516078!=(0|E)&31336!=(0|E))){E=0,y||(s=Ir(1&(E=s|S)?13621:12593),a[n+7|0]=s,h=A[144464+(s<<2)>>2]),(0|x)!=(0|D)|13621!=(1024|A[h>>2])||(a[C+3|0]=6),3420466==A[v>>2]&&(a[e+7|0]=Ir(3420466==A[h>>2]?13619:12594));n:{if(12597==A[r>>2]){if(12597!=(0|(y=A[h>>2])))break n;a[e+7|0]=Ir(13109)}y=A[h>>2]}s=E,12593==(0|y)&&(13621==(0|(y=A[v>>2]))&&(a[n+7|0]=Ir(12850),y=A[v>>2]),13619==(0|y)&&(a[n+7|0]=Ir(13107),y=A[v>>2]),3420466==(0|y)&&(a[n+7|0]=Ir(13364)),a[n+3|0]=0)}}S=0,v=h,e=n}else h=r;if(n=n+32|0,!((0|(D=D+1|0))<(0|(r=A[36423]))))break}if(h=0,n=145840,!((0|r)<=0))for(;4&o[0|n]&&((e=o[n+7|0])||(a[n+7|0]=17,e=17),e=A[144464+(e<<2)>>2],a[n+21|0]=o[e+12|0],a[n+22|0]=o[e+13|0]),n=n+32|0,(0|r)!=(0|(h=h+1|0)););}}else{if(e=A[z+152>>2],e=z+b(F=(0|e)>7?1:e,6)|0,M=o[0|(F?e+637:z+157)],W=o[0|(F?636+(e+O|0):156+(z+O|0))],a[133068]=4==(0|O),!((0|E)<=0)){for(P=E-1|0,T=O-1>>>0>1,r=0,s=0;;){w=f+b(s,6)|0,B=((e=o[0|w])<<24>>24>3)+B|0;t:if(6==(0|e)){e=s-3|0,n=s;n:{for(;;){if((0|n)<=(0|r)|(0|e)>=(0|n))break n;r:switch(C=f+b(n=n-1|0,6)|0,o[0|C]-4|0){case 2:break n;case 0:break r;default:continue}break}a[0|C]=3}n=s;n:{for(;;){if((0|E)<=(0|(n=n+1|0)))break n;r:switch(o[f+b(n,6)|0]-4|0){case 0:break n;case 2:break r;default:continue}break}a[w+2|0]=2,a[0|w]=5,e=r;break t}if(6==o[0|w]){a[w+2|0]=2,k=0;n:if((0|E)<=(0|(e=s+1|0)))C=s,K=0;else if(K=1,(0|(h=a[f+b(e,6)|0]))>4)C=s;else{for(x=(H-B|0)>1,C=s;;){if(n=e,4==(255&h)&&(e=x+1|0,x=1,!((0|e)<=1))){e=n;break n}if(K=(0|E)>(0|(e=n+1|0)),(0|e)==(0|E))break;if(C=n,(0|(h=a[f+b(e,6)|0]))>4)break n}C=P,e=E}h=-1,y=0,x=0,S=-1,D=0,v=-1;n:{if((0|(n=r))<(0|e)){for(;h=(G=(0|(v=a[f+b(n,6)|0]))>3)&&(0|h)<0?n-r|0:h,k=(D=(0|x)>(0|v))?k:(0|x)<(0|v)?n:y,S=G?n:S,y=D?y:n,G=(0|n)!=(0|C),x=D?x:v,n=n+1|0,G;);if(D=y,v=S,(0|h)>=0)break n}h=e,y=D,S=v}A[33269]=C-y,A[33268]=h,A[33270]=y,A[33271]=k;n:if(o[133068])A[33270]=e,A[33271]=e;else if((0|S)>=0){if((0|e)!=(0|E))break n;a[f+b(S,6)|0]=7}else a[f+b(y,6)|0]=7;de(f,F,r,e,W),!K&!!(0|O)||(W=T?o[z+156|0]:o[z+157|0])}else e=r}else e=r;if((0|e)>=(0|s))r=e;else if(4&o[w+2|0]){for(r=s+1|0,h=-1,S=0,y=0,x=0,n=e,k=-1;h=(D=(0|(C=a[f+b(n,6)|0]))>3)&&(0|h)<0?n-e|0:h,S=(v=(0|C)<(0|x))?S:(0|C)>(0|x)?n:y,k=D?n:k,y=v?y:n,D=(0|n)!=(0|s),x=v?x:C,n=n+1|0,D;);A[33269]=s-y,A[33270]=y,A[33271]=S,A[33268]=(0|h)<0?r:h,o[133068]?(A[33270]=r,A[33271]=r):(0|k)>=0?a[f+b(k,6)|0]=7:a[f+b(y,6)|0]=7,de(f,F,e,r,M)}else r=e;if((0|E)==(0|(s=s+1|0)))break}if(!((0|r)>=(0|E))){for(h=-1,S=0,y=0,x=0,n=r,k=-1;h=(C=(0|(e=a[f+b(n,6)|0]))>3)&&(0|h)<0?n-r|0:h,S=(s=(0|e)<(0|x))?S:(0|e)>(0|x)?n:y,k=C?n:k,y=s?y:n,x=s?x:e,(0|E)!=(0|(n=n+1|0)););A[33270]=y,A[33271]=S,A[33269]=~y+E,A[33268]=(0|h)<0?E:h,o[133068]?(A[33270]=E,A[33271]=E):(0|k)>=0?a[f+b(k,6)|0]=7:a[f+b(y,6)|0]=7,de(f,F,r,E,W)}}if((0|_)<=0)break e;for(n=0,D=0;;){if(v=r=145840+(C=n<<5)|0,e=f+b(D,6)|0,h=o[0|e],a[r+3|0]=h,4&o[0|r]){s=C+145840|0,r=o[e+4|0],a[s+21|0]=r,x=o[e+5|0],a[s+16|0]=0,a[s+22|0]=x;t:{if(1&(y=o[e+2|0]))e=2;else{if(h>>>0<6)break t;e=o[e+1|0]}a[s+16|0]=e}r>>>0<=(255&x)>>>0?(e=x,x=r):(a[s+21|0]=x,a[s+22|0]=r,e=r),(r=o[7+(C+145840|0)|0])&&(e=(255&e)+(255&x)>>>1|0,r=A[144464+(r<<2)>>2],a[s+22|0]=e+o[r+13|0],a[s+21|0]=e+o[r+12|0]),2&y&&(a[v+3|0]=8|h),D=D+1|0}if((0|_)==(0|(n=n+1|0)))break}}}if(U=f+6e3|0,D=A[47192],n=0,T=0,k=0,B=0,U=f=U-160|0,A[36423]>=2)for(O=A[30450],h=1;;){if(h=(e=h)+1|0,E=o[3+(s=145840+(x=e<<5)|0)|0],2&(y=g[s>>1])){for(;2==(31&(C=A[198304+(B<<2)>>2]))&&(Ue(127&C,C>>>8|0),A[36432]=110,A[36433]=100,A[36434]=450,A[36430]=5,y=A[50786],v=A[32972],(0|(r=A[v+84>>2]))>0&&(y=(0|b(r,y))/100|0),S=o[((0|(r=(0|y)>=359?359:y))<=80?80:r)+101856|0],r=(0|(r=(0|y)>=450?450:y))>399?6:(0|r)>379?7:S,A[32526]=(0|b(r,A[v+72>>2]))/256,A[32527]=(0|b(r,A[v+76>>2]))/256,A[32528]=(0|b(r,A[v+80>>2]))/256,r>>>0>7||(v=r-1|0,A[32528]=v,A[32526]=r,A[32527]=v)),B=B+1|0,!(128&C););y=g[s>>1]}v=h<<5,S=e-1|0,r=7&E;e:{t:{n:{r:{s:{a:{i:{A:{o:{l:switch(W=o[17+(x+145840|0)|0],0|(C=4&y?2:W)){case 2:break s;case 3:case 8:break a;case 5:break i;case 6:case 7:break A;case 4:break o;case 0:break l;default:break e}n=0;break e}if(6!=(0|(e=o[17+(145840+(S<<5)|0)|0]))?(r=4==(0|e)?60:A[34063]>0||r>>>0<4?48:60,a[18+(x+145840|0)|0]=r):(r=25,a[18+(x+145840|0)|0]=25),!(16&o[0|D])|!o[20+(x+145840|0)|0]||(a[18+(x+145840|0)|0]=60,r=60),64&o[A[8+(x+145840|0)>>2]+6|0]&&(r=r+30|0,a[18+(x+145840|0)|0]=r),n=0,!(8&y))break e;a[18+(x+145840|0)|0]=o[D+164|0]+r;break e}!(s=o[20+(e=x+145840|0)|0])|1&a[A[e+8>>2]+7|0]&2==o[17+(145840+(S<<5)|0)|0]||(a[18+(x+145840|0)|0]=15),r=o[17+(v+145840|0)|0],8&o[A[8+(x+145840|0)>>2]+4|0]|r|8!=o[17+(145840+(S<<5)|0)|0]||(a[18+(x+145840|0)|0]=25),64&o[A[8+(145840+(e=S<<5)|0)>>2]+5|0]&&(a[18+(x+145840|0)|0]=30),!s|!(16&A[D>>2])||(a[18+(x+145840|0)|0]=30);A:if(o[20+(v+145840|0)|0]|!(32&o[A[8+(x+145840|0)>>2]+4|0])|4!=(0|r))A[12+(x+145840|0)>>2]=256;else{if(s=x+145840|0,2==o[17+(e+145840|0)|0]){A[s+12>>2]=200;break A}A[s+12>>2]=150}if(7!=(0|C))break e;if(T|=2==(0|r),2!=(254&o[17+(e+145840|0)|0]))break e;A[12+(x+145840|0)>>2]=A[12+(e+145840|0)>>2]+255>>>1;break e}6==(254&(r=o[17+(145840+(e=S<<5)|0)|0]))|3==(0|r)|32&A[A[8+(e+145840|0)>>2]+4>>2]&&(a[18+(x+145840|0)|0]=30);i:if(2==(254&(s=o[17+(v+145840|0)|0]))){T=o[20+(v+145840|0)|0]&&2!=(0|s)?T:1,a[18+(s=x+145840|0)|0]=40,E=0;A:{o:switch(0|r){case 0:if((e=A[12+(e+145840|0)>>2])>>>0>39)break A;E=40-e|0;break A;case 2:break A}if(o[20+(x+145840|0)|0])break i;E=20;o:switch(r-3|0){case 1:if(E=0,!(8&o[A[8+(e+145840|0)>>2]+4|0]))break A;break i;case 0:break A;case 5:break o;default:break i}E=12}a[s+18|0]=E}if(!(16&o[0|D])|!o[20+(x+145840|0)|0])break e;if(o[18+(e=x+145840|0)|0]>19)break e;a[e+18|0]=20;break e}s=o[D+296|0],C=r=x+145840|0,A[r+12>>2]=256,a[r+19|0]=s;a:if(o[r+20|0]){y=25;i:switch(o[17+(145840+(S<<5)|0)|0]-2|0){case 0:if(y=12,1&a[A[8+(x+145840|0)>>2]+7|0])break a;break;case 1:break i;default:break a}a[18+(x+145840|0)|0]=y}if(2==(0|(v=o[17+(v+145840|0)|0]))){k=1;break e}if(a[22+(s=x+145840|0)|0]=n,2==(254&o[17+(145840+(r=S<<5)|0)|0]))break r;if(r=n,(0|(C=A[36423]))<=(0|e))break t;for(;;){if(2==o[17+(145840+(r=e<<5)|0)|0]){r=o[22+(r+145840|0)|0],a[s+22|0]=r;break t}if((0|C)==(0|(e=e+1|0)))break}break n}if(z=x+145840|0,P=r^r>>>0<2,r=(_=8&E)?25:o[296+(P+D|0)|0]-k|0,a[z+19|0]=r,(A[36423]-3|0)>(0|e)||(0|(C=255&r))<=(0|(r=A[D+52>>2]))||(a[z+19|0]=r),r=0,E=0,!(y=o[s+52|0]))for(;C=A[s+40>>2],E=2==o[s+49|0]?(~A[C+4>>2]>>>20&1)+E|0:E,r=27==o[C+10|0]?2:r,C=s,s=s+32|0,!(y=o[C+84|0]););C=z+96|0,e=145840+(F=e+2<<5)|0,A[34063]=E,w=o[A[s+40>>2]+10|0],v=v+145840|0,o[17+(F+145840|0)|0]|23!=o[A[v+8>>2]+10|0]?(s=C,C=e,e=v):s=x+145968|0,v=o[A[C+8>>2]+15|0];s:if(E)v=o[A[D+96>>2]+(o[A[e+8>>2]+15|0]+b(v,10)|0)|0],8!=o[e+17|0]|4!=(254&o[C+17|0])||(v=8&o[A[s+8>>2]+4|0]?v-15|0:v);else{if(M=A[D+100>>2],F=o[A[e+8>>2]+15|0],s=o[e+20|0],v=o[M+(F+b(s|o[C+20|0]?1==(0|v):v,10)|0)|0],!s|!(32&o[0|D]))break s;v=o[1+(M+b(F,10)|0)|0]+v>>>1|0}s=y>>>1|0,F=!E,y=(0|(v=(0|b(A[130104+(E?1==(0|E)?4:8:0)>>2],v))/128|0))<=8?8:v;s:if(7!=(0|P))_&&(y=A[D+200>>2]+y|0);else{if(y=(v=A[D+200>>2])+y|0,!_)break s;y=((0|v)/2|0)+y|0}v=s&F|27==(0|w),(s=g[304+(D+(P<<1)|0)>>1])||(s=g[D+316>>1]),y=b(s<<16>>16,y),(E=o[7+(s=x+145840|0)|0])&&(P=o[A[144464+(E<<2)>>2]+14|0])&&(y=(0|b(y,P))/100|0),1==(v|2==(0|r))&&(2097152&(r=A[D+12>>2])||(y=(0|b(262144&r?282:256+((280-(o[A[8+(x+145840|0)>>2]+14|0]<<1)|0)/3|0)&65535,y))/256|0)),P=x+145840|0,r=b(A[32526],A[D+196>>2]),_=2!=(0|W)?256:(0|((0|r)>(0|y)?y:r))/128|0,A[P+12>>2]=_,(r=o[P+16|0])>>>0>=19&&(ns(84371,28,O),a[P+16|0]=0,E=o[s+7|0],r=0),y=r+1|0,(r=255&E)?(Jn(r,f+8|0),r=Jr(A[f+132>>2])):r=A[129280+((255&y)<<2)>>2],v=x+145840|0,1&(k|T)&&(s=145840+(x=S<<5)|0,k=o[0|r],r=o[v+21|0],r=((0|b(k,o[v+22|0]-r|0))/256|0)+r|0,a[s+22|0]=r,n=(r-(n=255==(0|r)?255:n)|0)>16?r-16|0:n,a[s+21|0]=n,s=0,(0|n)<(0|r)&&(a[P+16|0]=y,s=2),A[12+(n=x+145840|0)>>2]=_,a[n+16|0]=s,r=o[z+19|0],a[n+19|0]=3!=o[n+17|0]&&r>>>0>18?18:r),n=2!=(0|W),s=-2&(r=g[e>>1]),i[e>>1]=s;s:{a:{i:switch(o[e+17|0]-3|0){case 5:if(2==o[C+17|0])break s;s=1|r;break a;case 0:break i;default:break s}if(i[e>>1]=1|r,2!=o[C+17|0]&&12146!=A[A[e+8>>2]>>2])break s}i[e>>1]=s}n?(0|(e=n<<4))<=((r=o[v+22|0])-(s=o[v+21|0])|0)||(s=(0|(e=r-e|0))>0?e:0,a[v+21|0]=s):(r=o[v+22|0],s=o[v+21|0]),e=255&s,n=((0|b(o[A[129280+(o[P+16|0]<<2)>>2]+127|0],r-e|0))/256|0)+e|0,k=0,T=0;break e}s=A[12+(r+145840|0)>>2],A[C+12>>2]=s,3==(0|W)&&(s=A[32526],A[C+12>>2]=s),r=n;r:switch(v-5|0){case 0:A[C+12>>2]=(b(s,160)>>>0)/100;break n;case 2:break r;default:break t}A[C+12>>2]=(b(s,120)>>>0)/100}r=n}T=0,a[16+(e=x+145840|0)|0]=0,s=e,r=(e=255&r)-16|0,a[s+21|0]=e>>>0>=r>>>0?r:0}if(!(A[36423]>(0|h)))break}if(U=f+160|0,15&(s=A[47197])|A[36456]){e=0,C=0,U=r=U-80|0;e:if((n=A[33222])||(A[33223]=500,n=ie(500),A[33222]=n,n)){if(!((A[36423]-2|0)<2)){for(e=s>>8,D=128&s?0:e,E=e&s<<24>>31,v=2&s,s=r+32|1,x=1;;){if(st(r,A[8+(h=145840+(S=x<<5)|0)>>2],h,v,r+72|0),e=r+32|0,1==(13&(n=o[h+20|0]))&&(a[r+32|0]=32,e=s),!D|32!=(0|D)&!!(0|n)|x>>>0<2||(Ht(r+76|0,r),A[r+76>>2]-880>>>0>4294967103||(e=Qn(D,e)+e|0)),4&o[0|h]&&((n=o[3+(S+145840|0)|0])>>>0<2||(n=n>>>0>=5?5:n,n=v?n>>>0>3?712:716:a[n+94144|0],A[r+76>>2]=n,e=Qn(n,e)+e|0)),y=0,A[r+72>>2]=0,o[0|(n=r)])for(;n=Ht(r+76|0,n)+n|0,A[r+72>>2]>>>y-1&1|!E|(0|y)<=0||(k=A[r+76>>2])-880>>>0>4294967103||Rr(k)&&(e=Qn(E,e)+e|0),y=y+1|0,e=Qn(A[r+76>>2],e)+e|0,o[0|n];);if(21!=o[A[h+8>>2]+10|0]&&(8&(n=g[h>>1])&&(e=st(e,A[36128],h,v,0),n=g[h>>1]),!(4&n)|2==o[17+(S+145840|0)|0]||(e=st(e,A[36136],h,v,0)),(n=o[7+(S+145840|0)|0])&&(e=st(e,A[144464+(n<<2)>>2],h,v,0))),(e=(h=e-(r+32|0)|0)+C|0)>>>0<p[33223])n=A[33222];else{if(n=e+500|0,A[33223]=n,!(n=Oe(A[33222],n))){A[33223]=0,n=86135;break e}A[33222]=n}if(a[(y=h)+(h=r+32|0)|0]=0,rn(n+C|0,h),C=e,!((0|(x=x+1|0))<(A[36423]-2|0)))break}if(!n){n=86135;break e}}a[e+n|0]=0}else A[33223]=0,n=86135;U=r+80|0,15&o[188788]&&(A[t>>2]=n,ts(A[47195],84367,t)),(e=A[36456])&&Ns[0|e](n)}o[190280]?(A[36423]=0,e=1):($(0),(e=A[t+8>>2])?(U=n=U+-64|0,fs(n,e,60),en(n,1),r=0,(e=se(n,0))&&(r=e,o[202976]&&(r=se(202976,2))),U=n- -64|0,A[44468]=r):r=A[44468],e=1,r&&(n=A[32972],(r=ie(1344))&&(n=Je(r,n,1344),r=216192+(A[50758]<<4)|0,A[r>>2]=11,A[r+8>>2]=n,n=A[50758]+1|0,A[50758]=(0|n)<=169?n:0),A[44468]=0))}else e=0,a[190280]=0;else e=0,A[36423]=0,A[50758]=0,A[50757]=0;return U=t+16|0,e}function q(e,t){var n=0,r=0,s=0,a=0;n=1073741825;e:{t:{n:{r:{s:{a:{i:{A:{o:{l:{u:{c:{d:{h:{f:{g:{p:{m:{b:{C:{I:{w:{k:{x:{y:{v:{E:{B:{M:{D:{T:{S:{N:{G:{F:{P:{Q:{z:{O:{R:{L:{W:{_:{V:{H:{U:{j:{Y:{K:{X:{q:{Z:{J:{$:{ee:{te:{ne:{re:{se:{ae:{ie:{Ae:{oe:{le:{ue:{ce:{de:{he:{fe:{ge:{pe:{me:{be:{Ce:{Ie:{we:{ke:{xe:{ye:{ve:{Ee:{Be:{Me:{De:{Te:{Se:{Ne:{Ge:{Fe:{Pe:{Qe:{ze:{Oe:{Re:{Le:{We:{_e:{Ve:{He:{Ue:{je:{Ye:{Ke:switch(0|t){case 0:t=e-9>>>0<5?1073741825:0,t=(e=133==(0|e))?1073741825:t;break y;case 1:Xe:{qe:{Ze:{Je:{$e:{et:{tt:{nt:{rt:{st:{at:{it:{At:{ot:{if((0|(t=-256&e))<=2047){if(!t)break ot;if(1536==(0|t))break At;if(1792!=(0|t))break Xe;if(n=0,r=1,1807!=(0|e))break Xe;break _}if((0|t)<=69631){if(2048==(0|t))break it;if(8192!=(0|t))break Xe;switch(n=131076,e-8204|0){case 1:break at;case 0:break _;default:break st}}if(69632==(0|t))break rt;if(917504!=(0|t))break Xe;switch(n=8388608,e-917505|0){case 62:break Ze;case 58:break Je;case 57:break $e;case 45:break et;case 43:break tt;case 32:break nt;case 0:break _;default:break qe}}if(n=16,173!=(0|e))break Xe;break _}if(n=0,r=1,e-1536>>>0<6)break _;r=1757==(0|e),t=(e=1564==(0|e))?2:0;break x}if(n=0,r=1,2274!=(0|e))break Xe;break _}return K=64,4}if(n=1073741826,8206==(-2&e))break _;if(e-8234>>>0<5)return K=0,2;if(n=128,e-8289>>>0<4)break _;if(n=2,e-8294>>>0<4)break _;if(n=8388608,e-8298>>>0>=6)break Xe;break _}t=!(e-69821&-17),e=0;break k}K=536870976;break w}K=268435520;break w}K=-2147483584;break w}K=134217792;break w}K=67108928;break w}K=1073741888;break w}if(n=131072,r=64,e-917536>>>0<96)break _}break R;case 2:Xe:{qe:{Ze:{Je:{$e:{et:{tt:{if((0|(t=-256&e))<=130303){if((0|t)<=127743){if((0|t)<=64767){if((0|t)<=11007){if(8192==(0|t))break tt;if(9216!=(0|t))break Xe;if(e-9255>>>0>=25)break et;break O}if(11008==(0|t))break $e;if(11776!=(0|t))break Xe;if(n=-2147483648,e-11845>>>0>=59)break Xe;break _}if((0|t)<=126975){if(64768==(0|t))break Je;if(65280!=(0|t))break Xe;if(n=4194304,e-65520>>>0>=9)break Xe;break _}if(126976==(0|t)|127232==(0|t)|127488==(0|t))break W;break Xe}if((0|t)<=129023){if((0|t)<=128255){if(127744==(0|t)|128e3==(0|t))break W;break Xe}if(128256==(0|t)|128512==(0|t)|128768==(0|t))break W;break Xe}if((0|t)<=129535){if(129024==(0|t)|129280==(0|t))break W;break Xe}if(129536==(0|t)|129792==(0|t)|130048==(0|t))break W;break Xe}if((0|t)<=919039){if((0|t)<=917759){if((0|t)<=130815){if(130304==(0|t))break W;if(130560!=(0|t))break Xe;break W}if(130816==(0|t))break W;if(917504!=(0|t))break Xe;if(917632!=(-128&e))break Ze;break z}if((0|t)<=918271){if(917760==(0|t))break qe;if(n=4194304,918016!=(0|t))break Xe;break _}if(918272==(0|t)|918528==(0|t))break z;if(n=4194304,918784!=(0|t))break Xe;break _}if((0|t)<=920319){if((0|t)<=919551){if(919040==(0|t))break z;if(n=4194304,919296!=(0|t))break Xe;break _}if(919552==(0|t)|919808==(0|t))break z;if(n=4194304,920064!=(0|t))break Xe;break _}if((0|t)<=920831){if(920320==(0|t))break z;if(n=4194304,920576!=(0|t))break Xe;break _}if(920832==(0|t)|921088==(0|t))break z;if(n=4194304,921344!=(0|t))break Xe;break _}if(n=4194304,8293!=(0|e))break Xe;break _}if(n=-2147483648,e-9291>>>0>=21)break Xe;break _}if(11248==(-16&e)|e-11219>>>0<25|11209==(0|e)|e-11194>>>0<3)break O;if(11124==(0|(t=-2&e)))break O;if(n=-2147483648,11158!=(0|t))break Xe;break _}if(n=65536,e-64976>>>0>=32)break Xe;break _}if(917504==(0|e))break z;if(n=4194304,e-917506>>>0>=30)break Xe;break _}if(n=4194304,e>>>0>917999)break _}t=(e=!(65534&~e))>>>16|0,e<<=16;break k;case 6:Xe:{qe:{Ze:{Je:{$e:{et:{tt:{nt:{rt:{st:{at:{it:{if((0|(t=-256&e))<=7679){if((0|t)<=767){if(!t)break it;if(256==(0|t))break at;if(512!=(0|t))break R;if(585!=(0|e))break st;break I}if(768==(0|t))break rt;if(1024==(0|t))break nt;if(7424!=(0|t))break R;if(n=16777216,7574!=(0|e))break R;break _}if((0|t)<=119807){if(7680==(0|t))break tt;if(8448==(0|t))break et;if(65280!=(0|t))break R;if(n=256,e-65345>>>0>=6)break R;break _}if((0|t)<=120319){if(119808==(0|t))break $e;if(120064!=(0|t))break R;if(e>>>0>=120070)break Je;break Q}if(120320==(0|t))break Ze;if(120576!=(0|t))break R;if(e>>>0>=120597)break qe;break Q}if(n=768,e-97>>>0<6)break _;if(n=16777216,e-105>>>0>=2)break R;break _}n=(t=329==(0|e))>>>9|0,t=(e=303==(0|e))?16777216:t<<23;break C}if(616==(0|e))break I;if(n=16777216,669!=(0|e))break R;break _}n=128;rt:switch(e-976|0){case 35:break Xe;case 0:case 1:case 2:case 5:case 32:case 33:break _}if(1012!=(-2&e))break R;break _}r=(e=!(e-1110&-3))>>>8|0,e<<=24;break b}r=(t=7883==(0|e))>>>8|0,t=(e=7725==(0|e))?16777216:t<<24;break x}if(e-8458>>>0<10)break Q;if((t=e-8495|0)>>>0<11)break Ye;break V}if(119842==(0|(t=-2&e)))break P;if(e-119808>>>0<85)break Q;if(e-119894>>>0<2|e-119946>>>0<2)break P;if(119995==(0|e)|e-119896>>>0<69|e-119982>>>0<12)break Q;if(119998==(0|t))break P;if(e-119997>>>0<7)break Q;if(n=16777344,120050==(0|t))break _;if(n=128,e>>>0<=120004)break R;break _}if(120102==(-2&e))break P;if(e-120094>>>0<28)break Q;Je:{if((0|e)<=120257){if(e-120154>>>0<2)break P;if(n=16777344,e-120206>>>0>=2)break Je;break _}if(e-120258>>>0<2)break P;if(n=16777344,e-120310>>>0<2)break _}if(n=128,e>>>0<=120145)break R;break _}if(e-120362>>>0<2|e-120414>>>0<2)break P;if(n=16777344,e-120466>>>0<2)break _;if(e-120540>>>0<31|e>>>0>120571|e>>>0<120486)break Q;if(n=128,e-120514>>>0>=25)break R;break _}if(e-120772>>>0<8|e-120746>>>0<25|e-120714>>>0<31|e-120688>>>0<25)break Q;if(120597!=(0|e)&e>>>0<120629|e-120656>>>0<31)break Q;if(n=128,e-120630>>>0<25)break _;break R}break I;case 7:Xe:{qe:{Ze:{Je:{$e:{et:{tt:{nt:{rt:{st:{at:{it:{At:{ot:{lt:{ut:{ct:{dt:{ht:{ft:{gt:{pt:{if((0|(t=-256&e))<=11263){if((0|t)<=3583){if((0|t)<=1535){if(512==(0|t))break pt;if(768==(0|t))break gt;if(1280!=(0|t))break R;if(n=4096,1369!=(0|e))break R;break _}if(1536==(0|t))break ft;if(1792==(0|t))break ht;if(2304!=(0|t))break R;if(n=4096,2417!=(0|e))break R;break _}if((0|t)<=7167){if(3584==(0|t))break dt;if(6144==(0|t))break ct;if(6656!=(0|t))break R;if(n=8192,6823!=(0|e))break R;break _}if(7168==(0|t))break ut;if(7424==(0|t))break lt;if(8192!=(0|t))break R;if(n=16793600,!(t=e-8305|0))break _;if(14==(0|t))break ot;break At}if((0|t)<=43263){if((0|t)<=40959){if(11264==(0|t))break it;if(11776==(0|t))break at;if(12288!=(0|t))break R;switch(n=8192,e-12293|0){case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:case 16:case 17:case 18:case 19:case 20:case 21:case 22:case 23:case 24:case 25:case 26:case 27:case 28:case 29:case 30:case 31:case 32:case 33:case 34:case 35:case 36:case 37:case 38:case 39:case 40:case 41:case 42:case 43:break rt;case 0:case 44:case 45:case 46:case 47:case 48:break _;default:break st}}if(40960==(0|t))break nt;if(42496==(0|t))break tt;if(42752!=(0|t))break R;if(e-42775>>>0>=9)break et;break F}if((0|t)<=65279){if(43264==(0|t))break $e;if(43520==(0|t))break Je;if(43776!=(0|t))break R;if(n=20480,43868!=(-4&e))break R;break _}if(65280==(0|t))break Ze;if(92928==(0|t))break qe;if(93952!=(0|t))break R;if(n=4096,e-94099>>>0<13)break _;if(n=8192,94176!=(-2&e))break R;break _}if(n=16797696,690==(0|e))break _;if(e-688>>>0<9)return K=0,20480;if(e-697>>>0<7)break F;if(704==(0|(t=-2&e)))return K=0,20480;if(n=4096,e-710>>>0<10)break _;if(n=12288,720==(0|t))break _;if(n=20480,e-736>>>0<5)break _;n=(e=748==(-3&e))>>>20|0,e<<=12;break m}t=890==(0|e)?20480:0,t=(e=884==(0|e))?4096:t;break y}if(n=8192,1600==(0|e))break _;if(n=4096,e-1765>>>0>=2)break R;break _}if(n=4096,2036==(-2&e))break _;if(n=8192,2042!=(0|e))break R;break _}t=(e=!(e-3654&-129))>>>19|0,e<<=13;break k}if(n=8192,6211!=(0|e))break R;break _}if(n=12288,7291==(0|e))break _;if(n=4096,e-7288>>>0>=6)break R;break _}if(n=16797696,7522==(0|e))break _;if(n=20480,e-7468>>>0<63)break _;n=16384;lt:switch(e-7588|0){default:if(7544==(0|e))break _;case 1:case 2:case 3:if(e-7579>>>0>=37)break R;break _;case 0:case 4:}return K=0,16793600}return K=0,16384}if(n=16384,e-8336>>>0>=13)break R;break _}t=(n=11389==(0|e))>>>18|0,n=(e=11388==(0|e))?16793600:n<<14;break p}if(n=-2147479552,11823!=(0|e))break R;break _}if(e-12445>>>0<2)break _;if(12540==(0|e))break Xe}if(e-12541>>>0>=2)break R;break _}if(n=8192,40981!=(0|e))break R;break _}if(42508==(0|e))break g;if(42623==(0|e))break F;if(n=20480,42652!=(-2&e))break R;break _}if(42864==(0|e))return K=0,16384;if(42888==(0|e))break F;if(n=20480,43e3!=(-2&e))break R;break _}n=(t=43494==(0|e))>>>19|0,t=(e=43471==(0|e))?8192:t<<13;break C}if(43632==(0|e))break g;if(43741==(0|e))break g;if(n=8192,e-43763>>>0>=2)break R;break _}if(n=12288,65392==(0|e))break _;if(n=135168,65438!=(-2&e))break R;break _}if(n=8192,92994==(-2&e))break _;break R}return K=0,12288;case 8:n=128;Xe:{qe:{Ze:{Je:{$e:{et:{tt:{nt:{rt:{if((0|(t=-256&e))<=12543){if((0|t)<=5887){if((0|t)<=3583){if(!t)break rt;if(1536!=(0|t))break Z;if(t=8388608,1651!=(0|e))break Z;break K}if(3584==(0|t))break nt;if(4352!=(0|t))break Z;if(n=4194304,e-4447>>>0>=2)break Z;break X}if((0|t)<=8447){if(5888==(0|t))break tt;if(6400!=(0|t))break Z;if((t=e-6581|0)>>>0>=6)break Z;n=A[(t=81432+(t<<3)|0)>>2],r=A[t+4>>2];break X}if(8448==(0|t))break et;if(12288!=(0|t))break Z;if(t=2048,12294!=(0|e))break Z;break K}if((0|t)<=68863){if((0|t)<=63999){if(12544==(0|t))break $e;if(43520!=(0|t))break Z;if((t=e-43701|0)>>>0<8)break qe;break q}if(64e3==(0|t))break Xe;if(65280!=(0|t))break Z;if(t=4194304,65440!=(0|e))break Z;break K}if((0|t)<=100095){if(68864==(0|t))break Je;if(70400!=(0|t))break Z;if(n=8192,70493!=(0|e))break Z;break j}if(100096==(0|t))break Ze;if(126464!=(0|t))break Z;break X}r=(t=!(e-170&-17))>>>18|0,n=t<<14;break X}if(n=33554432,e-3648>>>0<5)break X;if(t=0,a=33554432,3759==(0|e))break K;if(e-3776>>>0>=5)break Z;break X}if(n=8388608,e-6051>>>0>=2)break Z;break X}if(e-8501>>>0>=4)break Z;break X}if(t=4194304,12644!=(0|e))break Z;break K}if(n=4096,68898!=(-2&e))break Z;break X}if(n=2048,e-100333>>>0<5)break X;break Z}if(n=33554432,!(211>>>t&1))break q;break X}if((t=e-64014|0)>>>0>=28)break Z;n=A[(t=81480+(t<<3)|0)>>2],r=A[t+4>>2];break X;case 10:Xe:{qe:{Ze:{Je:{$e:{et:{if((0|(t=-256&e))<=119807){if((0|t)<=8447){if(!t)break et;if(768!=(0|t))break R;switch(n=128,e-976|0){case 0:case 1:case 2:case 36:case 37:break _;default:break R}}if(8448==(0|t))break $e;if(65280!=(0|t))break R;if(n=256,e-65313>>>0>=6)break R;break _}if((0|t)<=120319){if(119808==(0|t))break Je;if(120064!=(0|t))break R;if(e>>>0>=120070)break Ze;break Q}if(120320==(0|t))break qe;if(120576!=(0|t))break R;if(e-120772>>>0>=8)break Xe;break Q}if(n=768,e-65>>>0>=6)break R;break _}n=128;$e:switch(e-8450|0){case 0:case 5:break _}if(e-8458>>>0<10)break Q;if((t=e-8469|0)>>>0<20)break je;if(8508==(-4&e))break _;break J}if(e-119982>>>0<12|e>>>0>120004|e-119977>>>0<4|e-119973>>>0<2)break Q;if(119970==(0|e)|119966==(-2&e)|e-119808>>>0<85)break Q;if(n=128,e-119894>>>0>=71)break R;break _}if(e-120138>>>0<7|e>>>0>120145|120134==(0|e)|e-120128>>>0<5)break Q;if(e-120123>>>0<4|e-120094>>>0<28|120070!=(0|e)&e>>>0<120075|e-120086>>>0<7)break Q;if(n=128,e-120077>>>0>=8)break R;break _}if(e-120540>>>0<31|e>>>0<120486)break Q;if(n=128,e-120488>>>0>=25)break R;break _}if(e-120714>>>0<31|e-120598>>>0<31)break Q;if(n=128,e-120656>>>0<31)break _;break R;case 11:Xe:{qe:{Ze:{Je:{$e:{et:{tt:{nt:{rt:{st:{at:{it:{At:{ot:{lt:{ut:{ct:{if((0|(t=-256&e))<=43263){if((0|t)<=3839){if((0|t)<=3071){if(2304==(0|t))break ct;if(2816!=(0|t))break G;if((0|e)>3005)break lt;if(2878!=(0|e))break ut;return K=0,132096}if(3072==(0|t))break ot;if(3328!=(0|t))break G;switch(n=132096,e-3535|0){case 0:case 16:break _;case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:break G;default:break At}}if((0|t)<=6911){if(3840==(0|t))break it;if(4096!=(0|t))break G;if(n=1024,e-4139>>>0<2)break _;switch(e-4145|0){case 0:case 7:case 10:case 11:case 37:case 38:case 49:case 54:case 55:case 82:case 83:break _;case 86:case 87:case 88:case 89:case 90:case 91:case 94:case 105:case 106:break Xe;default:break at}}if(6912==(0|t))break st;if(7168==(0|t))break rt;if(12288!=(0|t))break G;if(n=135168,12334!=(-2&e))break G;break _}if((0|t)<=70399){if((0|t)<=43775){if(43264==(0|t))break nt;if(43520!=(0|t))break G;return K=0,e-43643&-3?1024:4096}if(43776==(0|t))break tt;if(69888==(0|t))break et;if(70144!=(0|t))break G;if(n=4096,70197!=(0|e))break G;break _}if((0|t)<=70911){if(70400==(0|t))break $e;if(70656!=(0|t))break G;t=70845==(0|e)?132096:1024,t=(e=70832==(0|e))?132096:t;break y}if(70912==(0|t))break Je;if(71168==(0|t))break Ze;if(119040!=(0|t))break G;switch(n=131072,e-119141|0){case 8:break F;case 1:break R;case 0:break _;default:break qe}}t=2519==(0|e)?132096:1024,t=(e=2494==(0|e))?132096:t;break y}if(n=132096,2903!=(0|e))break G;break _}if(3006==(0|e))return K=0,132096;if(n=132096,3031!=(0|e))break G;break _}if((e=e-3266|0)>>>0>20)break G;if(n=132096,!(1<<e&1572865))break G;break _}if(3390==(0|e))break _;if(3415!=(0|e))break G;break _}if(n=4096,3902!=(-2&e))break G;break _}n=(e=4252==(0|e))>>>22|0,e<<=10;break m}n=1024;st:switch(e-6965|0){default:if(6916==(0|e))break _;break;case 0:case 6:break _;case 1:case 2:case 3:case 4:case 5:}if(e-6973>>>0<5)break _;st:switch(e-6979|0){case 1:break F;case 0:break _}if(7042==(0|e)|7073==(0|e)|7078==(-2&e))break _;if(7082==(0|e))break F;if(7143==(0|e)|e-7146>>>0<3)break _;n=(e=7150==(0|e))>>>22|0,e<<=10;break m}t=7415==(0|e)?4096:1024,t=(e=7393==(0|e))?4096:t;break y}t=43456==(0|e)?4096:1024,t=(e=43347==(0|e))?4096:t;break y}if(n=4096,44012!=(0|e))break G;break _}if(n=4096,70080!=(0|e))break G;break _}n=132096;$e:switch(e-70462|0){case 0:case 25:break _;case 15:break $e;default:break G}break F}if(n=132096,71087!=(0|e))break G;break _}if(n=4096,71350!=(0|e))break G;break _}if(n=135168,e-119150>>>0<5)break _;break G}break F;case 12:t=(8419==(0|e))<<6,e=0;break k;case 13:Xe:{qe:{Ze:{Je:{$e:{et:{tt:{nt:{rt:{st:{at:{it:{At:{ot:{lt:{ut:{ct:{dt:{ht:{ft:{gt:{pt:{mt:{bt:{Ct:{It:{wt:{kt:{xt:{yt:{vt:{Et:{Bt:{Mt:{Dt:{Tt:{St:{Nt:{Gt:{Ft:{Pt:{Qt:{zt:{Ot:{Rt:{Lt:{Wt:{_t:{Vt:{Ht:{Ut:{if((0|(t=-256&e))<=43775){if((0|t)<=5887){if((0|t)<=2559){if((0|t)<=1535){if(768==(0|t))break Ut;if(1024==(0|t))break Ht;if(1280!=(0|t))break R;if(e-1425>>>0>=17)break Vt;break F}if((0|t)<=2047){if(1536==(0|t))break _t;if(1792!=(0|t))break R;if(n=1024,1809==(0|e))break _;if(1840!=(-16&e))break Wt;return K=0,5120}if(2048==(0|t))break Lt;if(2304!=(0|t))break R;if(e>>>0>=2307)break Rt;break G}if((0|t)<=3583){if((0|t)<=3071){if(2560==(0|t))break Ot;if(2816!=(0|t))break R;switch(n=1024,e-2876|0){case 0:break F;case 3:break _;case 1:case 2:break Qt;default:break zt}}if(3072==(0|t))break Pt;if(3328!=(0|t))break R;if(3328!=(0|(t=-2&e)))break Ft;break G}if((0|t)<=4095){if(3584==(0|t))break Gt;if(3840!=(0|t))break R;if(3864!=(0|(t=-2&e)))break Nt;break F}if(4096==(0|t))break St;if(4864!=(0|t))break R;if(n=1024,4959!=(0|e))break R;break _}if((0|t)<=8191){if((0|t)<=6655){if(5888==(0|t))break Tt;if(6144==(0|t))break Dt;if(6400!=(0|t))break R;if((t=e-6432|0)>>>0<=18&&(n=1024,1<<t&262535))break _;if(n=4096,e-6457>>>0>=3)break R;break _}if((0|t)<=7167){if(6656==(0|t))break Mt;if(6912!=(0|t))break R;if(n=1024,6912==(-4&e))break _;if(6964!=(0|e))break Bt;break F}if(7168==(0|t))break Et;if(7424!=(0|t))break R;if(n=4096,e-7620>>>0<12)break _;if(n=1024,e-7655>>>0<14)break _;if((e=e-7669|0)>>>0>=11)break R;t=A[(e=82104+(e<<3)|0)>>2];break f}if((0|t)<=42495){if((0|t)<=11519){if(8192==(0|t))break vt;if(11264!=(0|t))break R;if(n=4096,e-11503>>>0>=3)break R;break _}if(11520==(0|t))break yt;if(12288!=(0|t))break R;if(e-12330>>>0>=4)break xt;break F}if((0|t)<=43263){if(42496==(0|t))break kt;if(43008!=(0|t))break R;if(e-43045>>>0>=2)break wt;break G}if(43264==(0|t))break It;if(43520!=(0|t))break R;switch(n=1024,e-43561|0){case 83:case 150:case 152:break F;case 0:case 1:case 2:case 3:case 4:case 5:case 8:case 9:case 12:case 13:case 26:case 35:case 135:case 137:case 138:case 139:case 142:case 143:case 149:break _;default:break Ct}}if((0|t)<=71423){if((0|t)<=69375){if((0|t)<=66047){if(43776==(0|t))break bt;if(64256==(0|t))break mt;if(65024!=(0|t))break R;if(n=536870912,e-65024>>>0<15)break _;if(r=64,65039==(0|e))break _;if(n=4096,r=0,65056!=(-16&e))break R;break _}if((0|t)<=68095){if(66048==(0|t))break pt;if(66304!=(0|t))break R;if(n=1024,e-66422>>>0>=5)break R;break _}if(68096==(0|t))break gt;if(68864!=(0|t))break R;if(n=5120,68900!=(-4&e))break R;break _}if((0|t)<=70399){if((0|t)<=69887){if(69376==(0|t))break ft;if(69632!=(0|t))break R;if(e-69688>>>0>=14)break ht;break G}if(69888==(0|t))break dt;if(70144!=(0|t))break R;if(n=1024,e-70191>>>0<3)break _;switch(e-70196|0){case 2:break F;case 0:case 3:case 10:break _;case 1:case 4:case 5:case 6:case 7:case 8:case 9:break ut;default:break ct}}if((0|t)<=70911){if(70400==(0|t))break lt;if(70656!=(0|t))break R;if(70712!=(-8&e))break ot;break G}if(70912==(0|t))break At;if(71168!=(0|t))break R;if(n=1024,e-71219>>>0<8)break _;switch(e-71229|0){case 2:break F;case 0:case 3:break _;case 1:break at;default:break it}}if((0|t)<=92927){if((0|t)<=72703){if(71424==(0|t))break Le;if(71680==(0|t))break st;if(72192!=(0|t))break R;if(e-72193>>>0>=10)break rt;break G}if((0|t)<=73215){if(72704==(0|t))break nt;if(72960!=(0|t))break R;if((t=e-73009|0)>>>0<19)break Oe;break $}if(73216==(0|t))break tt;if(92672!=(0|t))break R;if(n=4096,e-92912>>>0>=5)break R;break _}if((0|t)<=122879){if((0|t)<=113663){if(92928==(0|t))break et;if(93952!=(0|t))break R;if(n=4096,e-94095>>>0>=4)break R;break _}if(113664==(0|t))break $e;if(119040!=(0|t))break R;switch(n=4096,e-119143|0){case 0:case 1:case 2:case 20:case 21:case 22:case 23:case 24:case 25:case 26:case 27:case 30:case 31:case 32:case 33:case 34:case 35:case 36:case 67:case 68:case 69:case 70:break _;default:break R}}if((0|t)<=125183){if(122880==(0|t))break Je;if(124928!=(0|t))break R;if(n=4096,e-125136>>>0>=7)break R;break _}if(125184==(0|t))break Ze;if(917760!=(0|t))break R;if(n=536870912,e-917760>>>0>=240)break R;break _}if(e-768>>>0<69)break F;if(n=21504,837==(0|e))break _;if(e-838>>>0<9)break F;if(n=4194304,847==(0|e))break _;if(848==(-8&e))break F;if(n=4096,e-861>>>0>=6)break R;break _}if(n=4096,e-1155>>>0>=5)break R;break _}if(n=4096,e-1443>>>0<13)break _;if(n=5120,e-1456>>>0<14)break _;if((e=e-1471|0)>>>0>=9)break R;t=A[(e=81944+(e<<3)|0)>>2];break f}if(e-1552>>>0<11)break G;if(n=5120,e-1611>>>0<8)break _;if(e-1619>>>0<4)break G;_t:switch(e-1623|0){case 1:break F;case 0:break _;case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 25:case 127:case 128:case 129:case 130:case 131:case 132:case 133:break G}if(n=4096,e-1759>>>0<2)break _;if((t=e-1761|0)>>>0<8)break Ue;break ee}if(e-1856>>>0<11)break F;if(n=5120,e-1958>>>0<11)break _;if(n=4096,e-2027>>>0>=9)break R;break _}n=1024;Lt:switch((-2&e)-2070|0){case 2:break F;case 0:break _}if(e-2260>>>0<12|e-2089>>>0<4|e-2075>>>0<9|e-2085>>>0<3)break G;if(e-2275>>>0<7)return K=0,5120;if(n=4096,e-2282>>>0<6)break _;if(n=5120,e-2288>>>0<15)break _;if(n=1024,2303!=(0|e))break R;break _}n=1024;Rt:switch(e-2362|0){case 2:break F;case 0:break _}if(e-2369>>>0<8)break G;n=4096;Rt:switch(e-2381|0){case 0:case 4:case 5:case 6:case 7:case 111:break _;case 8:case 9:case 10:case 21:case 22:case 52:break G}if(e-2497>>>0<4)break G;if(2509==(0|e))break _;if(n=1024,2530!=(-2&e))break R;break _}if(e-2561>>>0<2)break G;n=4096;Ot:switch(e-2620|0){case 0:case 17:case 128:case 145:break _;case 5:case 6:case 11:case 12:case 15:case 16:case 21:case 52:case 53:case 57:case 69:case 70:case 133:case 134:case 135:case 136:case 137:case 139:case 140:case 166:case 167:case 190:case 191:case 192:break G}if(e-2813>>>0>=3)break R;break _}if(2817==(0|e))break G}if(e-2881>>>0<4)break G;n=4096;Qt:switch(e-2893|0){case 0:break _;case 9:break G}if(2914==(-2&e))break G;n=1024;Qt:switch(e-3008|0){default:if(2946!=(0|e))break R;break _;case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:break R;case 0:break _;case 13:}break F}n=1024;Pt:switch(e-3072|0){case 77:case 188:case 205:break F;case 0:case 62:case 63:case 64:case 70:case 71:case 72:case 74:case 75:case 76:case 85:case 86:case 98:case 99:case 129:case 191:case 198:case 204:break _}if(3298!=(-2&e))break R;break _}if(n=4096,e-3387>>>0<2)break _;if(e-3393>>>0<4)break G;if(3405==(0|e))break _;if(3426==(0|t))break G;switch(e-3530|0){case 0:break _;case 8:case 9:case 10:case 12:break G;default:break R}}if((t=e-3633|0)>>>0<10)break He;break te}if((n=e-3893|0)>>>0>4|!(1<<n&21))break ne;break F}n=1024;St:switch(e-4141|0){case 10:case 12:case 13:break F;case 0:case 1:case 2:case 3:case 5:case 6:case 7:case 8:case 9:case 16:case 17:case 43:case 44:case 49:case 50:case 51:case 68:case 69:case 70:case 71:case 85:case 88:case 89:break _}t=(n=4253==(0|e))>>>22|0,n=(e=4237==(0|e))?4096:n<<10;break p}n=1024;Tt:{St:switch(e-5906|0){case 0:case 1:case 32:case 33:break _;case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:case 16:case 17:case 18:case 19:case 20:case 21:case 22:case 23:case 24:case 25:case 26:case 27:case 28:case 29:case 30:case 31:break Tt}switch(e-5970|0){case 0:case 1:case 32:case 33:break _;default:break Tt}}if(n=4194304,6068==(-2&e))break _;if((t=e-6071|0)>>>0<16)break Ve;break re}if(n=536870912,e-6155>>>0<3)break _;if(n=67109888,e-6277>>>0<2)break _;if(n=1024,6313!=(0|e))break R;break _}if(e-6679>>>0<2)break G;n=1024;Mt:switch(e-6683|0){case 0:case 59:case 61:case 62:case 63:case 64:case 65:case 66:case 67:case 71:case 74:case 75:case 76:case 77:case 78:case 79:case 80:case 81:case 88:case 89:break _}if(n=4096,e-6832>>>0<14)break _;if((e=e-6773|0)>>>0>=11)break R;t=A[(e=82016+(e<<3)|0)>>2];break f}if(e-6966>>>0<5)break _;Bt:switch(e-6972|0){case 0:case 6:break _}if(e-7019>>>0<9)break F;switch(e-7040|0){case 43:break F;case 0:case 1:case 34:case 35:case 36:case 37:case 40:case 41:case 44:case 45:case 104:case 105:case 109:case 111:case 112:case 113:break _;default:break R}}if(n=1024,e-7212>>>0<8)break _;n=12288;Et:switch(e-7222|0){case 1:break F;case 0:break _}if(e-7380>>>0<13)break F;n=4096;Et:switch(e-7376|0){case 0:case 1:case 2:case 18:case 19:case 20:case 21:case 22:case 23:case 24:case 29:case 36:break _}if(7416!=(-2&e))break R;break _}if(n=128,e-8400>>>0<13)break _;if((e=e-8417|0)>>>0>=15)break R;t=A[(e=82192+(e<<3)|0)>>2];break f}if(n=1024,11744!=(-32&e))break R;break _}if(n=4096,e-12441>>>0>=2)break R;break _}if(42607==(0|e))break F;if(e-42612>>>0<8)break G;if(42620==(0|(e&=-2)))break F;if(42654==(0|e))break Xe;if(n=4096,42736!=(0|e))break R;break _}n=4096;wt:switch(e-43204|0){case 0:break _;case 1:break G}if(e-43232>>>0>=18)break R;break _}if(e-43302>>>0<5)break G;if(e-43307>>>0<3)break F;if(e-43335>>>0<11|e-43392>>>0<3)break G;if(n=4096,43443==(0|e))break _;if(n=1024,e-43446>>>0<4)break _;r=(t=43493==(0|e))>>>20|0,t=(e=43452==(0|e))?1024:t<<12;break x}if(43756==(-2&e))break _;if(n=4096,43766!=(0|e))break R;break _}n=1024;bt:switch(e-44005|0){case 0:case 3:break _;case 8:break bt;default:break R}break F}if(n=5120,64286!=(0|e))break R;break _}if(n=4096,66272!=(0|e))break R;break _}if(68108==(-4&e))break G;if((t=e-68097|0)>>>0<6)break _e;break se}if(n=4096,e-69446>>>0>=11)break R;break _}if(e-69811>>>0<4)break G;if(n=1024,69633==(0|e))break _;if(n=4096,e-69817>>>0>=2)break R;break _}n=1024;dt:switch(e-69888|0){case 51:case 52:case 115:break F;case 0:case 1:case 2:case 39:case 40:case 41:case 42:case 43:case 45:case 46:case 47:case 48:case 49:case 50:break _}if(70016==(-2&e)|e-70070>>>0<9)break _;if(n=4096,e-70090>>>0>=3)break R;break _}if(70367==(0|e))break _}if(e-70371>>>0<6)break _;if(n=4096,e-70377>>>0>=2)break R;break _}if(70400==(-2&e))break G;n=4096;lt:switch(e-70460|0){case 0:case 42:case 43:case 44:case 45:case 46:case 47:case 48:case 52:case 53:case 54:case 55:case 56:break _;case 4:break lt;default:break R}break G}if(70722==(0|e))break F;if(e-70723>>>0<2)break G;if((t=e-70835|0)>>>0<=13)break qe;break ae}if((t=e-71090|0)>>>0<12)break We;break ie}switch(e-71339|0){case 0:case 2:break _;default:break at}}if(e-71344>>>0<6)break _;if(n=4096,71351!=(0|e))break R;break _}if(n=1024,e-71727>>>0<10)break _;if(n=4096,e-71737>>>0>=2)break R;break _}if(72244==(0|e))break F;if(e-72245>>>0<10)break G;if(n=4096,72263==(0|e))break _;if(e-72273>>>0<11)break G;if(n=1024,e-72330>>>0<13)break _;n=(t=72345==(0|e))>>>20|0,t=(e=72344==(0|e))?8192:t<<12;break C}if((t=e-72752|0)>>>0<16)break Re;break Ae}if(n=1024,e-73459>>>0>=2)break R;break _}if(n=1024,e-92976>>>0>=7)break R;break _}if(n=1024,113822!=(0|e))break R;break _}if(n=1024,e-122888>>>0<17)break _;if((e=e-122880|0)>>>0>=43)break R;t=A[(e=82816+(e<<3)|0)>>2];break f}if(n=12288,e-125252>>>0<3)break _;if(n=1024,125255==(0|e))break _;if(n=4096,e-125256>>>0<3)break _;break R}if(!(1<<t&12479))break ae;break G}break G;case 14:Xe:{if(120576!=(0|(t=-256&e))){if(65280!=(0|t)){if(t)break Xe;if(n=768,r=66,e-48>>>0>=10)break Xe;break _}if(n=256,e-65296>>>0>=10)break Xe;break _}if(n=128,e-120782>>>0<50)break _}break R;case 15:Xe:{if(12288!=(0|(t=-256&e))){if(8448!=(0|t))break Xe;t=(e=8560==(0|(n=-16&e)))>>>18|0,r=e<<14,n=(e=8544==(0|n))?32768:r;break p}if(e-12321>>>0<9)return K=0,2048;if(e-12344>>>0<3)return K=0,2048;if(n=2048,12295==(0|e))break _}break R;case 16:Xe:{qe:{Ze:{if((0|(t=-256&e))<=9215){if(4864==(0|t))break Ze;if(6400!=(0|t))break Xe;if(n=134217728,6618!=(0|e))break Xe;break _}if(9216==(0|t))break qe;if(127232!=(0|t))break Xe;if(n=0,r=-2147483648,127232==(0|e))break _;if(r=268435456,e-127233>>>0>=10)break Xe;break _}if(n=134217728,e-4969>>>0>=9)break Xe;break _}if(n=0,r=-2147483648,e-9352>>>0<20)break _}break R;case 17:r=(e=8256==(0|e))>>>25|0,e<<=7;break b;case 18:Xe:{qe:{Ze:{Je:{if((0|(t=-256&e))<=11775){if((0|t)<=6143){if(n=-2147483624,!t)break _;if(1280!=(0|t))break Xe;if(n=24,1418!=(0|e))break Xe;break _}if(6144==(0|t))break Je;if(8192!=(0|t))break Xe;if(n=-2147483624,8208==(-2&e))break _;e=e-8211>>>0<2,t=-2147483640;break h}if((0|t)<=65023){if(11776==(0|t))break Ze;if(12288!=(0|t))break Xe;t=12336==(0|e),n=(e=12316==(0|e))||t?-2147483640:8,K=e?0:t?130:0;break d}if(65024==(0|t))break qe;if(65280!=(0|t))break Xe;if(n=24,65293!=(0|e))break Xe;break _}if(n=24,6150!=(0|e))break Xe;break _}if(n=-2147483624,11799==(0|e))break _;e=11834==(-2&e),t=-2147483640;break h}if(n=8,r=8388608,e-65073>>>0<2)break _;if(n=152,r=0,65123==(0|e))break _}return K=0,8;case 19:Xe:{qe:{Ze:{Je:{$e:{et:{if((0|(t=-256&e))<=11775){if((0|t)<=8959){if(t)break et;break O}if(8960==(0|t))break $e;if(9984==(0|t))break Je;if(10496!=(0|t))break R;break N}if((0|t)<=64767){if(n=-2147483648,11776==(0|t))break _;if(12288!=(0|t))break R;switch(n=-2147483616,e-12301|0){case 0:case 2:break _;default:break Ze}}if(64768==(0|t))break qe;if(65024==(0|t))break Xe;if(65280!=(0|t))break R;if(n=32,65379==(0|e))break _;break R}if(8192!=(0|t))break R;et:switch(e-8318|0){default:if(n=-2147483648,8262!=(0|e))break R;break _;case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:break R;case 0:case 16:}break Q}n=-2147483520;$e:switch(e-8969|0){case 1:break R;case 0:case 2:break _}if(9002!=(0|e))break R;return K=0,-2139095040}if(n=-2147483520,10182==(0|e))break _;break S}return K=0,12318==(-2&e)?-2147483616:-2147483648}if(n=-2147483648,64830!=(0|e))break R;break _}r=(e=!(e-65090&-3))>>>27|0,e<<=5;break b;case 20:case 21:if(!(e&=-256))break c;if(n=-2147483616,8192==(0|e))break _;break L;case 22:Xe:{qe:{Ze:{Je:{$e:{et:{tt:{nt:{rt:{st:{at:{it:{At:{ot:{lt:{ut:{ct:{dt:{ht:{ft:{gt:{pt:{mt:{bt:{Ct:{It:{wt:{kt:{xt:{yt:{vt:{Et:{Bt:{Mt:{Dt:{Tt:{St:{Nt:{Gt:{Ft:{Pt:{Qt:{zt:{Ot:{Rt:{Lt:{Wt:{_t:{if((0|(t=-256&e))<=43519){if((0|t)<=5887){if((0|t)<=2303){if((0|t)<=1535){if(!t)break _t;if(768==(0|t))break Wt;if(1280!=(0|t))break R;if(n=0,r=538968064,e-1371>>>0<2)break _;switch(r=268435456,e-1373|0){case 0:break _;case 1:break Rt;default:break Lt}}if(1536==(0|t))break zt;if(1792==(0|t))break Qt;if(2048!=(0|t))break R;if((t=e-2103|0)>>>0<8)break Qe;break oe}if((0|t)<=3839){if(2304==(0|t))break Pt;if(3328==(0|t))break Ft;if(3584!=(0|t))break R;if(n=64,3674!=(-2&e))break R;break _}if((0|t)<=4863){if(3840==(0|t))break Gt;if(4096!=(0|t))break R;if(n=268435520,4170==(-2&e))break _;if(n=0,r=16777216,4347!=(0|e))break R;break _}if(4864==(0|t))break Nt;if(5632!=(0|t))break R;switch(n=64,e-5741|0){case 1:break s;case 0:break _;default:break St}}if((0|t)<=11263){if((0|t)<=6655){if(5888==(0|t))break Tt;if(6144==(0|t))break Fe;if(6400!=(0|t))break R;t=6469==(0|e),n=(e=6468==(0|e))||t?268435520:0,K=e?536870912:t?1073741824:0;break d}if((0|t)<=7167){if(6656==(0|t))break Dt;if(6912!=(0|t))break R;if(7002!=(0|(t=-2&e)))break Mt;break T}if(7168==(0|t))break Bt;if(8192!=(0|t))break R;switch(n=-2147483520,e-8214|0){case 1:break O;case 0:break _;case 16:break Et;default:break vt}}if((0|t)<=41983){if(11264==(0|t))break yt;if(11776==(0|t))break xt;if(12288!=(0|t))break R;switch(n=-2147483584,r=272629760,e-12289|0){case 2:break O;case 0:break _;case 1:break wt;default:break kt}}if((0|t)<=43007){if(41984==(0|t))break It;if(42496!=(0|t))break R;switch(n=64,r=268435456,e-42739|0){case 4:break a;case 0:break s;case 3:break n;case 2:break _;case 1:break bt;default:break Ct}}if(43008==(0|t))break mt;if(43264!=(0|t))break R;switch(n=4096,e-43310|0){case 0:break _;case 1:break T;default:break pt}}if((0|t)<=70655){if((0|t)<=67839){if((0|t)<=65279){if(43520==(0|t))break gt;if(43776==(0|t))break ft;if(65024!=(0|t))break R;if(n=0,r=268435456,65040==(0|(a=-2&e)))break _;if((t=e-65042|0)>>>0<8)break Ne;break le}if(65280==(0|t))break ht;if(66304==(0|t))break dt;if(67584!=(0|t))break R;if(n=64,67671!=(0|e))break R;break _}if((0|t)<=69375){if(67840==(0|t))break ct;if(68096==(0|t))break ut;if(68352!=(0|t))break R;switch(n=64,e-68410|0){case 0:case 1:case 2:case 3:case 4:case 5:case 95:case 96:case 97:case 98:break _;default:break R}}if((0|t)<=69887){if(69376==(0|t))break lt;if(69632!=(0|t))break R;if(e-69703>>>0>=2)break ot;break T}if(69888==(0|t))break At;if(70144!=(0|t))break R;if((t=e-70200|0)>>>0<=4)break it;if(70313!=(0|e))break R;break T}if((0|t)<=74751){if((0|t)<=71423){if(70656==(0|t))break at;if(70912==(0|t))break st;if(71168!=(0|t))break R;if(n=268435520,e-71233>>>0>=2)break R;break _}if((0|t)<=72703){if(71424==(0|t))break rt;if(72192!=(0|t))break R;if(e-72258>>>0>=2)break nt;break T}if(72704==(0|t))break tt;if(73216!=(0|t))break R;if(n=268435520,e-73463>>>0>=2)break R;break _}if((0|t)<=93695){if(74752==(0|t))break et;if(92672==(0|t))break Je;if(92928!=(0|t))break R;if(n=268435520,e-92983>>>0<2)break _;t=92996==(0|e)?268435520:0,t=(e=92985==(0|e))?64:t;break y}if((0|t)<=121343){if(93696==(0|t))break $e;if(113664!=(0|t))break R;if(n=268435520,r=-2147483648,113823!=(0|e))break R;break _}if(121344==(0|t))break Se;if(125184!=(0|t))break R;n=(125279==(0|e))<<30,t=0,K=(e=125278==(0|e))?536870912:n;break l}n=-1879048128,r=536870912;_t:{Vt:{Ht:{Ut:{jt:switch(e-33|0){default:switch(e-183|0){case 1:case 2:case 3:case 4:case 5:case 6:case 7:break _t;case 8:break Ht;case 0:break Ut;default:break Vt}case 2:case 9:K=66;break A;case 11:return K=268435456,-2147483584;case 13:return K=-2147483648,-1879048128;case 25:return K=134217728,-2147483584;case 26:return K=67108864,-2147483584;case 1:case 6:break c;case 0:break _;case 3:case 4:case 5:case 7:case 8:case 10:case 12:case 14:case 15:case 16:case 17:case 18:case 19:case 20:case 21:case 22:case 23:case 24:case 27:case 28:case 29:break _t;case 30:}return K=1073741824,-1879048128}return K=0,134230016}K=1078984704;break A}if(161==(0|e))break ue}break O}t=903==(0|e),n=(e=894==(0|e))?64:t?134217792:0,K=e?1073741824:t?67108864:0;break d}if(1417==(0|e))break Ot;if(1475!=(0|e))break R;break D}K=1075838976;break i}K=-2143289344;break r}n=64,r=268435456;zt:switch(e-1548|0){case 15:break n;case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 16:case 17:break R;case 0:break _;case 19:break zt;case 18:break T;default:break Ze}break a}if((t=e-1792|0)>>>0<6)break ze;if(n=64,r=134217728,1798==(-2&e))break _;r=67108864;Qt:{zt:{Ot:switch(e-1800|0){default:switch(e-2040|0){case 1:break Qt;case 0:break zt;default:break R}case 3:break R;case 0:break _;case 1:break Ot;case 2:case 4:break D}K=1073741824;break t}K=268435456;break t}K=536870912;break r}t=2405==(0|e),n=(e=2404==(0|e))||t?268435520:0,K=e?-2143289344:t?16777216:0;break d}if(n=0,r=-2143289344,3572!=(0|e))break R;break _}n=64;Gt:switch(e-3848|0){case 5:K=-2143289344;break t;case 6:K=16777216;break t;case 0:break _}if(e-3854>>>0<5)break _;if(n=0,r=268435456,3860!=(0|e))break R;break _}if((t=e-4961|0)>>>0<4)break Pe;if(n=64,r=134217728,e-4965>>>0<2)break _;t=4968==(0|e),n=(e=4967==(0|e))||t?268435520:0,K=e?1073741824:t?16777216:0;break d}if(e-5867>>>0>=3)break R;break _}if(n=268435520,e-5941>>>0<2)break _;if((e=e-6100|0)>>>0>=7)break R;t=A[(e=83240+(e<<3)|0)>>2];break f}if(n=268435520,6824!=(-4&e))break R;break _}if(n=64,7005==(0|e))break _;if(n=268435520,7006!=(0|t))break R;break _}if(e-7227>>>0<2)break T;if(n=64,e-7229>>>0<3)break _;if(n=268435520,7294==(-2&e))break _;if(n=4096,7379!=(0|e))break R;break _}K=33554432;break A}if(8224==(-8&e))break O;if(e-8242>>>0<3)break _;if(e-8240>>>0<9)break O;if((t=e-8251|0)>>>0<21)break Ge;break ce}if(11513==(0|e)){K=-2147483648;break i}if(n=0,r=1073741824,11514==(-2&e))break _;if(r=-2147483648,11518!=(0|e))break R;break _}n=-1879048128;xt:switch(e-11822|0){case 4:case 6:K=268435456;break A;case 5:K=-2147483648;break A;case 7:K=67108864;break A;case 14:return K=-2147483648,-1879048128;case 19:return K=268435456,-2147483584;case 30:case 32:return K=0,-2147483584;case 0:break _}break O}if(12349==(0|e))break M;if(12539!=(0|e))break R;return K=0,16}return K=-2143289344,-1879048128}t=42239==(0|e),n=(e=42238==(0|e))?64:t?268435520:0,K=e?268435456:t?-2147483648:0;break d}Ct:switch(e-42509|0){case 1:break s;case 0:break _;case 2:break Ct;default:break R}break a}K=134217728;break t}if(e-43126>>>0<2)break T;if(n=268435520,e-43214>>>0>=2)break R;break _}if(43463==(0|e))break D;if(n=268435520,43464!=(-2&e))break R;break _}if(e-43613>>>0<3)break T;if(n=64,43743==(0|e))break _;if(n=268435520,43760!=(-2&e))break R;break _}if(n=268435520,44011!=(0|e))break R;break _}n=268435520,r=541065216;ht:switch(e-65281|0){case 1:case 6:return K=0,32;case 11:K=272629760;break t;case 13:K=-2143289344;break r;case 100:return K=0,16;case 25:K=138412032;break t;case 26:K=71303168;break t;case 30:K=1077936128;break r;case 96:break s;case 59:break Q;case 0:break _;case 99:break ht;default:break R}K=268435456;break t}n=(t=66512==(0|e))>>>26|0,t=(e=66463==(0|e))?64:t<<6;break C}if(n=64,67871!=(0|e))break R;break _}if(n=268435520,68182==(-2&e))break _;if(n=64,e-68336>>>0>=6)break R;break _}if(n=268435520,e-69461>>>0>=5)break R;break _}if(n=64,e-69705>>>0<5)break _;if(n=268435520,e-69822>>>0>=4)break R;break _}if(e-69953>>>0<2)break T;if((t=e-70085|0)>>>0<=26)break qe;break de}if(2!=(0|t))break T;break D}if(n=268435520,e-70731>>>0<2)break _;r=(t=70747==(0|e))>>>26|0,t=(e=70733==(0|e))?64:t<<6,K=e?268435456:r;break l}n=268435520;st:switch((-2&e)-71106|0){case 0:break _;case 2:break Xe}if(n=8192,e-71110>>>0<3)break _;if(n=268435520,e-71113>>>0>=15)break R;break _}if(n=268435520,e-71484>>>0>=3)break R;break _}if(n=268435520,e-72347>>>0<2)break _;if(n=64,e-72353>>>0>=2)break R;break _}if(n=268435520,e-72769>>>0<2)break _;n=(t=72817==(0|e))>>>26|0,t=(e=72771==(0|e))?64:t<<6;break C}if(n=64,r=134217728,e-74865>>>0<2)break _;if(r=0,e-74864>>>0>=5)break R;break _}t=93848==(0|e)?268435520:0,t=(e=93847==(0|e))?64:t;break y}if(n=268435520,92782==(-2&e))break _;if(r=-2147483648,92917!=(0|e))break R;break _}if(1748==(0|e))break s;break R}if(!(1<<t&100663555))break de;break T}break D;case 23:Xe:{qe:{Ze:{Je:{$e:{et:{if((0|(t=-256&e))<=11775){if((0|t)<=8959){if(t)break et;break O}if(8960==(0|t))break $e;if(9984==(0|t))break Je;if(10496!=(0|t))break R;break N}if((0|t)<=64767){if(11776==(0|t))break Ze;if(12288!=(0|t))break R;if((e=e-12300|0)>>>0<=17&&(n=-2147483616,1<<e&131077))break _;break O}if(64768==(0|t))break qe;if(65024==(0|t))break Xe;if(65280!=(0|t))break R;if(n=32,65378==(0|e))break _;break R}if(8192!=(0|t))break R;n=-2147483616;et:switch(e-8218|0){case 1:case 2:case 3:break R;case 0:case 4:break _}et:switch(e-8317|0){default:if(8261!=(0|e))break R;break O;case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:break R;case 0:case 16:}break Q}n=-2147483520;$e:switch(e-8968|0){case 1:break R;case 0:case 2:break _}if(9001!=(0|e))break R;return K=0,-2139095040}if(n=-2147483520,10181==(0|e))break _;break S}return K=0,11842==(0|e)?-2147483616:-2147483648}if(n=-2147483648,64831!=(0|e))break R;break _}n=(e=!(e-65089&-3))>>>27|0,e<<=5;break m;case 24:n=(e=e>>>0<256)>>>1|0,e<<=31;break m;case 25:Xe:{qe:{Ze:{Je:{$e:{et:{tt:{nt:{if((0|(t=-256&e))<=12287){if((0|t)<=767){if(!t)break nt;if(512!=(0|t))break Xe;if(e-751>>>0>=17)break tt;break F}if(768==(0|t))break et;if(7936!=(0|t))break Xe;switch(n=4096,e-8125|0){case 0:case 2:case 3:case 4:case 16:case 17:case 18:case 32:case 33:case 34:case 48:case 49:case 50:case 64:case 65:break _;default:break Xe}}if((0|t)<=43775){if(12288==(0|t))break $e;if(42752!=(0|t))break Xe;if(n=4096,42784!=(-2&e))break Xe;break _}if(43776==(0|t))break Je;if(65280==(0|t))break Ze;if(n=0,r=78,127744!=(0|t))break Xe;break _}nt:switch(e-168|0){default:n=-2147479424;rt:switch(e-94|0){case 0:break _;case 2:break rt;default:break Xe}return K=0,-2147479552;case 0:case 7:break F;case 1:case 2:case 3:case 4:case 5:case 6:case 8:case 9:case 10:case 11:case 13:case 14:case 15:break Xe;case 12:case 16:}break F}if(749==(0|e)|e-741>>>0<7)break F;if(e-706>>>0>=4)break qe;break F}if((e=e-885|0)>>>0>16)break Xe;if(n=4096,!(1<<e&98305))break Xe;break _}if(n=67112960,e-12443>>>0>=2)break Xe;break _}if(n=4096,43867!=(0|e))break Xe;break _}n=4224;Ze:switch(e-65342|0){default:if(65507!=(0|e))break Xe;break;case 0:break _;case 1:break Xe;case 2:}break F}if(n=4096,e-722>>>0<14)break _}break R;case 26:Xe:{qe:{Ze:{Je:{$e:{et:{if((0|(t=-256&e))<=9471){if((0|t)<=8447){if(t)break Xe;break O}if(8448==(0|t))break et;if(8704==(0|t))break $e;if(n=-2147483648,8960!=(0|t))break R;break _}if((0|t)<=10495){if(9472==(0|t))break Je;if(9728==(0|t))break Ze;if(9984==(0|t))break O;break R}if(10496==(0|t))break qe;if(10752==(0|t))break O;if(n=-2147483648,11008!=(0|t))break R;break _}if(8472==(0|e))return K=0,67108864;if(8596==(0|e))break B;if(n=-2147483648,e>>>0<=8591)break R;break _}if(n=-2147483640,8722==(0|e))break _;t=-2147483648,K=(e=e-8942>>>0<4)?33554432:0;break l}if(n=-2147483648,r=130,e-9723>>>0<2)break _;t=-2147483648,K=(e=e-9725>>>0<2)?134:0;break l}if(n=-2147483648,r=128,9839==(0|e))break _;break O}if(n=-2147483648,r=130,10548==(-2&e))break _;t=-2147483648,K=(e=10626==(0|e))?134217728:0;break l}if(8192==(0|t))break he;break R;case 27:Xe:{qe:{Ze:{Je:{$e:{et:{tt:{nt:{rt:{st:{at:{it:{At:{ot:{lt:{ut:{ct:{dt:{ht:{ft:{gt:{pt:{mt:{bt:{if((0|(t=-256&e))<=12287){if((0|t)<=9727){if((0|t)<=8959){if(!t)break bt;if(8448!=(0|t))break R;switch(n=0,r=130,e-8482|0){case 7:break Q;case 0:break _;case 1:case 2:case 3:case 4:case 5:case 6:case 8:case 9:case 10:case 11:break ft;case 12:break pt;default:break mt}}if(8960==(0|t))break ht;if(9216==(0|t))break dt;if(9472!=(0|t))break R;switch(n=-2147483520,(-2&e)-9632|0){case 0:break _;case 10:break B;default:break ct}}if((0|t)<=11007){if(9728==(0|t))break ut;if(9984==(0|t))break lt;if(n=-2147483648,10240!=(0|t))break R;break _}if(11008==(0|t))break ot;if(11776==(0|t))break At;if(12032!=(0|t))break R;if(n=1048576,e>>>0<12246)break _;switch(n=262144,(-2&e)-12272|0){case 0:break _;case 2:break Xe;default:break it}}if((0|t)<=127999){if((0|t)<=127231){if(12288==(0|t))break at;if(12800==(0|t))break st;if(126976!=(0|t))break R;t=127183==(0|e),n=0,K=(e=126980==(0|e))||t?134:128;break d}if(127232==(0|t))break rt;if(127488==(0|t))break nt;if(127744!=(0|t))break R;if(e>>>0>=127777)break tt;break E}if((0|t)<=128767){if(128e3==(0|t))break et;if(128256==(0|t))break $e;if(128512!=(0|t))break R;if((t=e-128581|0)>>>0<11)break we;break fe}if(128768==(0|t))break Je;if(129280==(0|t))break Ze;if(129536!=(0|t))break R;K=128;break i}t=174==(0|e),n=-2147483648,K=(e=169==(0|e))||t?130:0;break d}switch(e-8616|0){case 0:break O;case 1:case 2:break gt;default:break ft}}return K=0,67108864}return K=130,-2147483520}if(n=-2147483520,e-8597>>>0<5)break _;if(e-8604>>>0<18)break N;if((t=e-8624|0)>>>0<8)break Te;break ge}if(e>>>0<8968)break O;if(8986==(0|(t=-2&e)))break o;if(e-8972>>>0<20|e-8994>>>0<6)break O;if(9e3==(0|e))break B;if(e-9003>>>0<81)break O;if(n=-2147483648,r=128,9096==(0|e))break _;if(e-9085>>>0<30)break O;if(n=-2147483520,r=0,9140==(0|t))break _;ht:switch(e-9143|0){case 0:case 25:break _;case 24:break B}if(e-9140>>>0<40)break O;if(9186==(0|e))break _;if((t=e-9193|0)>>>0<4)break o;n=-2147483648,r=134;ht:switch(e-9200|0){case 0:case 3:break _}if(t>>>0<11)break B;if(r=130,e-9208>>>0<3)break _;if(r=0,e>>>0<=9186)break R;break _}if(n=-2147483648,e-9216>>>0<75)break _;if(n=33792,r=130,9410==(0|e))break _;if(r=0,e-9398>>>0<26)break _;if(n=17408,e-9424>>>0>=26)break R;break _}if(e-9646>>>0<8)break N;if(r=130,9654==(0|e))break _;if(9660==(-4&e))break N;ct:switch(e-9664|0){case 0:break _;case 6:case 7:case 10:case 11:case 15:case 16:case 17:case 18:case 19:case 34:case 36:break N}return K=0,e-9703>>>0<6?-2147483520:-2147483648}ut:switch((-16&e)-9728>>>4|0){case 0:if(e>>>0<9733)break B;n=-2147483520,r=128;ct:switch(e-9733|0){case 0:break _;case 9:break ct;case 1:break N;default:break pe}break B;case 2:if((t=e-9760|0)>>>0<11)break Me;if(n=-2147483648,r=130,e>>>0<=9773)break pe;break _;case 3:if(n=-2147483648,r=130,e-9784>>>0>=3)break pe;break _;case 4:n=-2147483520,r=130;ct:switch(e-9792|0){case 0:case 2:break _}if(n=-2147483648,r=134,e>>>0<=9799)break pe;break _;case 5:if(n=-2147483648,r=134,e>>>0<9812)break _;if(r=130,9823!=(0|e))break pe;break _;case 6:if(9734==(0|e))break N;if(9824==(0|e))return K=130,-2147483520;if(n=-2147483520,r=128,e-9825>>>0<2)break _;if((t=e-9827|0)>>>0<6)break Be;break me;case 8:if(n=-2147483648,e>>>0<=9861)break pe;break _;case 10:n=-2147483648,r=130;ct:switch(e-9888|0){case 1:break o;case 0:break _}if(r=134,9898!=(-2&e))break pe;break _;case 11:if(n=-2147483648,r=130,9904==(-2&e))break _;if(r=134,e-9917>>>0>=2)break pe;break _;case 12:if(9924==(-2&e))break o;n=-2147483648,r=130;ct:switch(e-9928|0){case 0:case 7:break _;case 6:break ct;default:break pe}break o;case 14:t=9962==(0|e),n=-2147483648,K=(e=9961==(0|e))?130:t?134:128;break d;case 13:break ye;case 9:break ve;case 15:break ut;case 7:break Ee;case 1:break De;default:break pe}if(9972==(0|e)|e>>>0<9970)break B;if(n=-2147483648,r=134,e>>>0<9974)break _;if(9974!=(0|e)&&(r=130,e>>>0<9977))break _;if((e=e-9977|0)>>>0<5)break xe;break pe}lt:{ut:{ct:{dt:{ht:switch((-16&e)-9984>>>4|0){case 0:if(n=0,r=130,9986==(0|e))break lt;if(r=128,e>>>0<9989)break lt;if(r=134,9989==(0|e))break lt;r=150;ft:switch((-2&e)-9994|0){case 0:break lt;case 2:break ct}if(r=130,e-9992>>>0<6)break lt;t=9999==(0|e),n=0,r=(e=9998==(0|e))?128:t?130:0;break lt;case 1:if(n=0,r=128,e>>>0<10002)break lt;if((e=e-10002|0)>>>0>11)break dt;if(r=130,!(1<<e&2069))break dt;break lt;case 2:t=10024==(0|e),n=0,r=(e=10017==(0|e))?130:t?134:0;break lt;case 4:n=0,r=130;ft:switch(e-10052|0){case 0:case 3:break lt;case 8:case 10:break ft;default:break dt}r=134;break lt;case 5:if(n=0,r=1073741958,e-10067>>>0<2)break lt;r=(e=e-10069&-3)?0:536871046;break lt;case 6:if((t=e-10082|0)>>>0<3)break ut;if(n=0,r=128,e>>>0<=10084)break dt;break lt;case 9:if(n=0,r=134,e-10133>>>0>=3)break dt;break lt;case 10:if(n=0,r=130,10145!=(0|e))break dt;break lt;case 11:t=10175==(0|e),n=0,r=(e=10160==(0|e))||t?134:0;break lt;case 3:break ht;default:break dt}if(n=0,r=130,e-10035>>>0<2)break lt}n=0,r=0;break lt}r=146;break lt}n=A[(e=83992+(t<<3)|0)>>2],r=A[e+4>>2]}return K=r,-2147483648|n}if(n=-2147483648,r=130,e-11013>>>0<3)break _;if(r=134,e-11035>>>0<2)break _;t=11093==(0|e),n=-2147483648,K=(e=11088==(0|e))||t?134:0;break d}if(e-11904>>>0>=26)break qe;return K=0,1048576}if(e-12276>>>0>=8)break R;break _}if((e=e-12306|0)>>>0>14)break R;if(n=-2147483648,!(1<<e&16387))break R;break _}t=0,K=(e=e-12951&-3)?0:130;break l}if(n=0,r=128,127279==(0|e))break _;if(e-127280>>>0<26)return K=0,33792;if(e-127312>>>0<26)return K=0,33792;if((t=e-127344|0)>>>0<=15&&(n=33792,r=130,1<<t&49155))break _;if(n=33792,r=0,t>>>0<26)break _;if(127374==(0|e))break E;if(n=0,r=134,e-127377>>>0<10)break _;if(r=102,e>>>0<=127461)break R;break _}n=0,r=134;nt:{rt:switch(e-127489|0){case 0:case 25:break _;case 1:break M;case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:case 16:case 17:case 18:case 19:case 20:case 21:case 22:case 23:case 24:break nt}switch(e-127535|0){case 0:break _;case 8:break M;default:break nt}}if(127568==(-2&e)|e-127538>>>0<9)break _;if(r=128,e>>>0<=127583)break R;break _}if(127777==(0|e))break M;if(e-127789>>>0<9|e-127799>>>0<70)break E;if(127877==(0|e))break v;if(e-127870>>>0<22)break E;if(e-127780>>>0<112)break M;n=0,r=130;tt:switch(e-127894|0){case 44:case 45:case 46:case 49:break v;case 0:case 1:case 3:case 4:case 5:break _}if(e-127904>>>0<42)break E;if(r=150,127946==(0|e))break _;if(r=146,e-127947>>>0<2)break _;if(e-127951>>>0<5)break E;if(r=134,e-127968>>>0<17)break _;if(r=130,e-127902>>>0<83)break _;if((t=e-127987|0)>>>0<5)break ke;break be}n=0,r=130;et:switch(e-128063|0){case 0:case 2:break _}if(128124==(0|e)|(-5&e)-128129>>>0<3|128110==(0|e)|e-128112>>>0<9)break v;if(128066==(-2&e)|e-128102>>>0<4|e-128070>>>0<11)break v;et:switch(e-128253|0){case 1:K=128;break i;case 0:break M}if(r=150,128170==(0|e))break _;break E}if(e>>>0<128318)break E;if(n=0,e>>>0<128326)break _;if(e-128329>>>0<2)break M;if(e-128331>>>0<4|e-128336>>>0<24)break E;if(e-128367>>>0<2)break M;if(128372==(-2&e)){K=146;break i}if(e-128371>>>0<7)break M;if(r=150,!(t=e-128378|0))break _;if(13==(0|t)|e-128394>>>0<4)break M;if(r=146,128400==(0|e))break _;if(r=150,e-128405>>>0<2)break _;r=134;$e:switch(e-128420|0){case 0:break _;case 1:case 4:case 13:case 14:case 24:case 30:case 31:case 32:case 45:case 46:case 47:case 56:case 57:case 58:case 61:case 63:case 68:case 75:case 79:case 86:break M}e=e>>>0>128506,t=0;break u}if(n=0,r=128,e-128981>>>0>=4)break R;break _}if(e>>>0<129292)break R;if(e-129328>>>0<10)break v;n=0,r=150;Ze:switch(e-129304|0){case 35:break R;case 0:case 1:case 2:case 3:case 4:case 6:case 7:case 14:break _}if(e-129341>>>0<2)break v;if(r=0,129350==(0|e))break _;if(r=198,129456==(-4&e))break _;if((t=e-129461|0)>>>0<5)break Ie;break Ce}if(n=1048576,e-11931>>>0<89)break _;break R}return K=0,524288;case 29:return K=16777216,1073741825;case 28:break _;case 30:break Ke;default:break R}return K=0,32==(0|e)?1073741825:1}if(!(1079>>>t&1))break V;t=A[(e=81344+(t<<3)|0)>>2];break f}if(557553>>>t&1)break Q;if(8508!=(-4&e))break J;break _}if(!(207>>>t&1))break ee;break G}if(n=1024,!(1017>>>t&1))break te;break _}if(n=1024,!(32895>>>t&1))break re;break _}if(n=1024,!(55>>>t&1))break se;break _}if(n=1024,!(3087>>>t&1))break ie;break _}if((e=e-71453|0)>>>0>=15)break R;t=A[(e=82312+(e<<3)|0)>>2];break f}if(!(49023>>>t&1))break Ae;t=A[(e=82432+(t<<3)|0)>>2];break f}if(!(514623>>>t&1))break $;t=A[(e=82664+(t<<3)|0)>>2];break f}t=A[(e=83160+(t<<3)|0)>>2];break f}if(n=268435520,!(197>>>t&1))break oe;break _}t=A[(e=83208+(t<<3)|0)>>2];break f}if((e=e-6145|0)>>>0>=10)break R;t=A[(e=83296+(e<<3)|0)>>2];break f}if(!(1077711>>>t&1))break ce;t=A[(e=83376+(t<<3)|0)>>2];break f}if(!(159>>>t&1))break le;t=A[(e=83544+(t<<3)|0)>>2];break f}if((e=e-121479|0)>>>0>=4)break R;t=A[(e=83608+(e<<3)|0)>>2];break f}if(!(195>>>t&1))break ge;break N}if((e=e-9745|0)>>>0>=13)break pe;t=A[(e=83640+(e<<3)|0)>>2];break f}if(1101>>>t&1)break B;if(n=-2147483648,r=130,e>>>0<=9773)break pe;break _}if(!(45>>>t&1))break me;t=A[(e=83744+(t<<3)|0)>>2];break f}if((e=e-9851|0)>>>0>=5)break pe;t=A[(e=83792+(e<<3)|0)>>2];break f}if((e=e-9874|0)>>>0>=11)break pe;t=A[(e=83832+(e<<3)|0)>>2];break f}if((e=e-9937|0)>>>0>=4)break pe;t=A[(e=83920+(e<<3)|0)>>2];break f}t=A[(e=83952+(e<<3)|0)>>2];break f}if(!(23>>>t&1))break be;t=A[(e=84016+(t<<3)|0)>>2];break f}if(n=0,r=150,!(1991>>>t&1))break fe;break _}if(r=150,27>>>t&1)break _}t=0,K=(e=e-129489>>>0<13)?150:134;break l}e=e-127992>>>0<3,t=0;break u}if(e-9837>>>0<2)break _}K=128;break A}if(e-8623>>>0<13)break O;if(e-8636>>>0<18)break N;if((t=e-8656|0)>>>0<22&&(r=0,3157995>>>t&1))break _;if(n=-2147483648,r=0,e-8661>>>0<31)break _;break R}if(e>>>0<128592)break E;if(n=0,r=0,e>>>0<128640)break _;if(!((t=e-128675|0)>>>0>29|!(1<<t&537788417)))break v;if(e>>>0<128710)break E;if(r=150,128716==(0|e))break _;if(e-128715>>>0<5)break M;if(e-128720>>>0<3)break E;if(!((t=e-128736|0)>>>0>=10|!(575>>>t&1)))break M;if(r=134,e-128747>>>0<2)break _;r=130;fe:switch(e-128752|0){case 0:case 3:break _}e=e-128756>>>0<6,t=0;break u}n=-2147483648;he:switch(e-8260|0){case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:break R;case 0:case 14:break _}if(16!=(0|(e=e-8315|0))&&e)break R;return K=0,8}if(n=268435520,r=1073741824,69955!=(0|e))break R;break _}if(e-8266>>>0<8)break O;if(n=-2147483640,8275==(0|e))break _;if(n=-2147483648,e-8277>>>0>=10)break R;break _}K=542113792;break A}if(n=-2147483648,r=0,e-65093>>>0<2)break _;if(n=64,r=268435456,65104==(0|a))break _;n=268435520,r=-2147483648;le:switch(e-65106|0){case 3:K=134217728;break t;case 5:K=536870912;break r;case 4:break a;case 2:break n;case 0:break _;case 15:case 22:break le;default:break R}break Q}if(2142==(0|e))break D;if(n=64,e-2096>>>0<15)break _;break R}if(n=1024,e-72850>>>0<22)break _;if((e=e-72874|0)>>>0>=13)break R;t=A[(e=82560+(e<<3)|0)>>2];break f}if(n=4096,e-71103>>>0<2)break _;if(n=1024,71132!=(-2&e))break R;break _}if(70726==(0|e))break F;if(n=4096,70850!=(-2&e))break R;break _}if(n=4096,e-68325>>>0>=2)break R;break _}if(6109==(0|e))break F;if(n=4096,e-6089>>>0>=11)break R;break _}ne:switch(e-3959|0){case 0:case 2:return K=0,8389632}if(3968==(0|t)|e-3953>>>0<14)break G;if(!((t=e-3970|0)>>>0>=6|!(55>>>t&1)))break F;if(e-3981>>>0<11)break G;if(n=1024,e-3993>>>0<36)break _;if(n=4096,4038!=(0|e))break R;break _}if(e-3655>>>0<6)break F;if(!((t=e-3761|0)>>>0>11|!(1<<t&3577)))break G;n=1024;te:switch(e-3661|0){case 1:break F;case 0:break _}if(n=4096,e-3784>>>0<5)break _;if(n=1024,3789!=(0|e))break R;break _}if(e-1770>>>0<3)break _;if(n=1024,1773!=(0|e))break R;break _}if(73028==(-2&e))break F;n=1024;$:switch(e-73104|0){default:if(73031!=(0|e))break R;break _;case 2:case 3:case 4:case 6:break R;case 0:case 1:case 5:break _;case 7:}break F}if((e=e-8492|0)>>>0>=30)break R;t=A[(e=81704+(e<<3)|0)>>2];break f}n=0;break X}r=(t=43712==(-3&e))>>>20|0,n=t<<12}if(131072==(0|(s=-65536&e)))break Y;if(65536==(0|s))break j;if(t=n,a=r,s)break U}if(e-13312>>>0<6582)break e;if(e-19968>>>0<20976)break e;if(s=2048,e-63744>>>0<366)return K=a,2048|t;if(n=t,r=a,e-64112>>>0>=106)break U;break H}if(s=2099200,e-183984>>>0<7473|e-178208>>>0<5762|e-177984>>>0<222|e-131072>>>0<42711)break H;if(e-173824>>>0<4149)break H;if(s=2048,e-194560>>>0<542)break H;break U}if(s=2048,e-110960>>>0<396|e-94208>>>0<6125|e-100352>>>0<755)break H}s=0}return K=r,n|s}if(8508==(-4&e))break Q;if(n=128,!(e-8517>>>0<3)&&(n=16777344,8520!=(-2&e)))break R}K=r;break d}t=(e=e>>>0>131069)?65536:0,K=e?0:128;break l}if(11776==(0|e))break O}K=0;break i}K=0;break A}return K=0,4194304}return K=0,128}return K=0,16777344}return K=0,4096}return K=0,1024}return K=0,-2147483520}return K=0,e-10214>>>0<10?-2147483520:-2147483648}K=0;break r}K=0;break t}K=130;break i}K=130;break A}K=134;break i}return K=150,0}K=0;break l}K=e?0:r;break l}return K=t,e}return 131072}return K=0,16777216}K=e?0:n;break l}return K=r,e}return K=n,e}K=e?0:t;break d}return K=0,8192}K=A[e+4>>2];break l}K=e?8388608:0;break l}return n}return K=0,-2147483616}K=e?134:128}return t}K=134}return-2147483648}return 0}K=1073741824;break r}K=-2147483648}return 268435520}K=67108864}return 64}return K=a,2099200|t}function Z(e){var t,n=0,r=0,s=0,l=0,u=0;(t=ie(8244))&&(A[t+328>>2]=2,a[132848]=0,A[t+684>>2]=0,A[t+688>>2]=0,A[t+320>>2]=0,A[t+324>>2]=0,a[t+268|0]=0,a[t+228|0]=0,A[t+8216>>2]=0,A[t+8220>>2]=0,A[t+224>>2]=104944,A[t+216>>2]=383,A[t+220>>2]=96,kt(t+344|0,0,292),A[t+8196>>2]=0,A[(n=t+8188|0)>>2]=0,A[n+4>>2]=0,A[t+8180>>2]=0,A[t+8184>>2]=0,a[t+460|0]=22,a[t+461|0]=129,a[t+466|0]=38,a[t+462|0]=38,a[t+463|0]=36,a[t+464|0]=22,a[t+465|0]=224,a[t+456|0]=22,a[t+457|0]=22,a[t+458|0]=44,a[t+459|0]=22,a[t+454|0]=46,a[t+455|0]=129,a[t+446|0]=22,a[t+447|0]=38,a[t+448|0]=28,a[t+449|0]=193,a[t+450|0]=38,a[t+451|0]=22,a[t+452|0]=46,a[t+453|0]=46,a[t+441|0]=129,a[t+442|0]=38,a[t+443|0]=22,a[t+444|0]=38,a[t+445|0]=193,A[t+332>>2]=104912,A[t+336>>2]=104916,A[t+340>>2]=105232,a[t+296|0]=18,a[t+297|0]=18,i[t+304>>1]=182,i[t+306>>1]=140,a[t+298|0]=20,i[t+308>>1]=220,i[t+310>>1]=220,i[t+312>>1]=220,a[t+299|0]=20,a[t+300|0]=20,i[t+314>>1]=240,a[t+301|0]=22,i[t+316>>1]=260,i[t+318>>1]=280,a[t+302|0]=22,a[t+303|0]=20,n=kt(t,0,212),A[n+200>>2]=20,A[n+192>>2]=25966,A[n+196>>2]=500,A[n+80>>2]=95,A[n+16>>2]=1,A[n+20>>2]=3,A[n+8>>2]=2,A[n+52>>2]=19,a[n+168|0]=3,A[n+92>>2]=2,A[n+72>>2]=4,A[n+40>>2]=115,A[n+44>>2]=95,A[n+140>>2]=105244,Tr(n,201),A[n+120>>2]=2,A[n+124>>2]=44,A[n+164>>2]=100,A[n+128>>2]=46,A[n+132>>2]=14,A[n+112>>2]=1227133512,A[n+116>>2]=49,A[n+104>>2]=1,r=A[26313],A[n+636>>2]=A[26312],A[n+640>>2]=r,r=A[26315],A[n+644>>2]=A[26314],A[n+648>>2]=r,r=A[26317],A[n+652>>2]=A[26316],A[n+656>>2]=r,r=A[26319],A[n+660>>2]=A[26318],A[n+664>>2]=r,r=A[26321],A[n+668>>2]=A[26320],A[n+672>>2]=r,r=A[26323],A[n+676>>2]=A[26322],A[n+680>>2]=r,r=o[104928]|o[104929]<<8,a[n+160|0]=r,a[n+161|0]=r>>>8,r=o[104924]|o[104925]<<8|o[104926]<<16|o[104927]<<24,a[n+156|0]=r,a[n+157|0]=r>>>8,a[n+158|0]=r>>>16,a[n+159|0]=r>>>24),s=rn(t+228|0,e),n=0;e:{t:if(r=o[0|e]){for(;n=(r<<24>>24)+(n<<8)|0,r=o[0|(e=e+1|0)];);n:{r:{s:{a:{i:{A:{o:{l:{u:{c:{d:{h:{f:{g:{p:{m:{b:{C:{I:{w:{k:{x:{y:{v:{E:{B:{M:{D:{T:{S:{N:{G:{F:{P:{Q:{z:{O:{R:{L:{W:{_:{V:{H:{U:{j:{Y:{K:{X:{q:{Z:{J:{$:{ee:{te:{ne:{re:{se:{ae:{ie:{Ae:{oe:{le:{ue:{ce:{de:{he:{fe:{ge:{pe:{me:{if((0|n)<=28008){if((0|n)<=26464){if((0|n)<=25696){be:switch(n-24934|0){case 20:break l;case 1:case 2:case 3:case 4:case 5:case 6:case 9:case 10:case 11:case 14:case 15:case 16:case 17:case 18:case 19:break t;case 8:break $;case 12:break oe;case 7:break le;case 0:break ue;case 13:break me}be:switch(n-25189|0){case 1:case 3:case 4:case 5:case 6:case 7:case 8:case 10:case 11:case 12:case 13:break t;case 14:break V;case 2:break ie;case 0:break Ae;case 9:break me}switch(n-25441|0){case 18:break m;case 0:break $;case 24:break se;default:break t}}be:switch(n-25964|0){case 1:case 4:case 5:case 6:break t;case 8:break q;case 9:break J;case 7:break $;case 3:break ee;case 2:break te;case 0:break ge}be:switch(n-26209|0){case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 9:case 10:case 11:case 12:case 13:case 14:case 15:case 16:break t;case 17:break K;case 8:break X;case 0:break Z}switch(n-25697|0){case 4:break ne;case 0:break re;default:break t}}if((0|n)<=27488){be:switch(n-26729|0){case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 10:case 13:case 14:case 15:break t;case 16:break L;case 12:break W;case 11:break _;case 9:break V;case 0:break H}be:switch(n-26977|0){case 1:case 2:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 15:case 16:case 17:break t;case 19:break Q;case 18:break z;case 3:break O;case 14:break R;case 0:break $}switch(n-26465|0){case 20:break H;case 13:break U;case 0:case 3:break j;default:break t}}be:switch(n-27489|0){case 13:break u;case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 12:case 15:case 16:case 17:case 18:case 19:case 21:case 22:case 23:break t;case 24:break D;case 20:break T;case 14:break S;case 11:break N;case 10:break G;case 0:break F}switch(n-27745|0){case 19:break B;case 0:break M;case 21:break he;default:break t}}if((0|n)<=29792){if((0|n)<=28768){be:switch(n-28009|0){case 3:break u;case 11:break v;case 2:break E;case 1:case 4:case 5:case 6:case 7:case 8:case 12:case 13:case 14:case 15:break t;case 10:break O;case 9:break H;case 0:case 16:break ce}be:switch(n-28258|0){case 0:break x;case 10:break y;case 1:case 2:case 4:case 5:case 6:case 7:case 8:case 9:break t;case 3:break H}switch(n-28525|0){case 0:break k;case 5:break H;default:break t}}if((0|n)<=29539){be:switch(n-28769|0){case 19:break I;case 11:break w;case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 12:case 13:case 14:case 15:case 16:case 17:case 18:case 20:case 21:case 22:case 23:break t;case 0:break H;case 24:break ce}be:switch(n-29295|0){case 6:break b;case 0:break C;case 1:case 2:case 3:case 4:case 5:break t}if(29045==(0|n))break ce;break t}switch(n-29540|0){case 19:break c;case 18:break d;case 13:break h;case 8:break g;case 5:break p;case 7:break m;case 14:break V;case 0:break i;default:break t}}if((0|n)>6514801)break pe;if((0|n)<=30058)switch(n-29793|0){case 19:break o;case 17:break l;case 0:case 4:break u;case 13:break c;case 7:break ce;default:break t}if((0|n)<=30312)switch(n-30059|0){case 0:break A;case 15:break ce;case 7:break i;default:break t}if(30313==(0|n))break a;if(31336==(0|n))break s;if(6451321!=(0|n))break t}if(A[t+296>>2]=303174162,A[t+300>>2]=370545684,A[t+600>>2]=2432,A[t+8>>2]=0,A[t+12>>2]=65540,A[t+100>>2]=A[t+96>>2],e=A[25889],A[t+304>>2]=A[25888],A[t+308>>2]=e,e=A[25891],A[t+312>>2]=A[25890],A[t+316>>2]=e,Ge(t),a[t+345|0]=2|o[t+345|0],a[t+406|0]=16|o[t+406|0],a[t+407|0]=16|o[t+407|0],a[t+408|0]=16|o[t+408|0],a[t+409|0]=16|o[t+409|0],a[t+410|0]=16|o[t+410|0],a[t+411|0]=16|o[t+411|0],a[t+412|0]=16|o[t+412|0],a[t+413|0]=16|o[t+413|0],a[t+414|0]=16|o[t+414|0],a[t+415|0]=16|o[t+415|0],a[t+416|0]=16|o[t+416|0],a[t+417|0]=16|o[t+417|0],a[t+418|0]=16|o[t+418|0],a[t+419|0]=16|o[t+419|0],a[t+420|0]=16|o[t+420|0],a[t+456|0]=4|o[t+456|0],a[t+457|0]=4|o[t+457|0],A[t+112>>2]=613567144,A[t+104>>2]=16,6451321!=(0|n))break e;A[t+104>>2]=1,A[t+108>>2]=512,n=6451321;break e}if((0|n)>7364975)break de;if((0|n)>6840682)break fe;if(6514802==(0|n))break ae;if(6516078==(0|n))break s;if(6779491!=(0|n))break t}if(A[t+600>>2]=896,A[t+328>>2]=8,A[t+296>>2]=336858127,A[t+300>>2]=353768980,A[t+332>>2]=103632,e=A[25905],A[t+304>>2]=A[25904],A[t+308>>2]=e,e=A[25907],A[t+312>>2]=A[25906],A[t+316>>2]=e,kt(t+344|0,0,256),a[t+388|0]=129,a[t+389|0]=129,a[t+390|0]=129,a[t+391|0]=129,a[t+420|0]=129,a[t+421|0]=129,a[t+422|0]=129,a[t+423|0]=129,a[t+360|0]=129,a[t+392|0]=129,a[t+393|0]=129,a[t+417|0]=129,a[t+418|0]=129,a[t+419|0]=129,a[t+420|0]=129,a[t+408|0]=6,a[t+409|0]=4,a[t+410|0]=6,a[t+411|0]=6,a[t+412|0]=6,a[t+413|0]=193,a[t+414|0]=6,a[t+415|0]=6,a[t+406|0]=6,a[t+407|0]=129,a[t+398|0]=4,a[t+399|0]=193,a[t+400|0]=6,a[t+401|0]=193,a[t+402|0]=6,a[t+403|0]=4,a[t+404|0]=4,a[t+405|0]=4,a[t+394|0]=4,a[t+395|0]=4,a[t+396|0]=4,a[t+397|0]=193,A[t+44>>2]=130,A[t+8>>2]=2,A[t+12>>2]=6,A[t+16>>2]=0,A[t+20>>2]=2,A[t+104>>2]=264,A[t+108>>2]=6146,a[t+391|0]=193,a[t+389|0]=193,a[t+390|0]=193,a[t+421|0]=193,A[t+100>>2]=A[t+96>>2],a[t+416|0]=4|o[t+416|0],6779491!=(0|n))break e;A[t+40>>2]=1,n=6779491;break e}if(6840683==(0|n))break Y;if(6972015==(0|n))break P;if(7107687!=(0|n))break t}A[t+296>>2]=134875662,A[t+300>>2]=252968960,A[t+328>>2]=5,a[t+169|0]=1,A[t+132>>2]=33,A[t+104>>2]=99336,A[t+8>>2]=0,A[t+12>>2]=262182,e=A[26069],A[t+304>>2]=A[26068],A[t+308>>2]=e,e=A[26071],A[t+312>>2]=A[26070],A[t+316>>2]=e;break e}if((0|n)<=7564649){if(7364976==(0|n))break $;if(7435619==(0|n))break ce;if(7563374!=(0|n))break t;A[t+148>>2]=1,A[t+112>>2]=24,A[t+104>>2]=1,A[t+100>>2]=A[t+96>>2],n=7563374;break e}if(7564650==(0|n))break f;if(7959909==(0|n))break s;if(1885958500!=(0|n))break t}A[t+104>>2]=0;break e}A[t+4>>2]=48,A[t+8>>2]=0,A[t+144>>2]=1,A[t+104>>2]=16779472,A[t+32>>2]=1,A[t+24>>2]=1,e=A[25881],A[t+304>>2]=A[25880],A[t+308>>2]=e,e=A[25883],A[t+312>>2]=A[25882],A[t+316>>2]=e,a[t+465|0]=64&o[t+465|0]|129,n=24934;break e}A[t+600>>2]=4608,A[t+296>>2]=303173650,A[t+300>>2]=303174162,A[t+8>>2]=0,A[t+12>>2]=36,A[t+104>>2]=1024,A[t+100>>2]=A[t+96>>2],A[t+40>>2]=1,e=A[25865],A[t+304>>2]=A[25864],A[t+308>>2]=e,e=A[25867],A[t+312>>2]=A[25866],A[t+316>>2]=e,n=24941;break e}for(A[t+600>>2]=1536,A[t+224>>2]=0,A[t+216>>2]=1631,A[t+220>>2]=1536,A[t+104>>2]=2884720,A[t+328>>2]=7,A[t+40>>2]=1,U=n=U-16|0,A[n+12>>2]=-1,e=89684;s=Ht(n+12|0,e),(0|(r=A[n+12>>2]))>=33&&(a[0|(l=(t+r|0)-1192|0)]=1|o[0|l]),e=e+s|0,r;);for(A[n+12>>2]=-1,e=89743;s=Ht(n+12|0,e),(0|(r=A[n+12>>2]))>=33&&(a[0|(l=(t+r|0)-1192|0)]=2|o[0|l]),e=e+s|0,r;);for(A[n+12>>2]=-1,e=89795;s=Ht(n+12|0,e),(0|(r=A[n+12>>2]))>=33&&(a[0|(l=(t+r|0)-1192|0)]=4|o[0|l]),e=e+s|0,r;);for(A[n+12>>2]=-1,e=89941;s=Ht(n+12|0,e),(0|(r=A[n+12>>2]))>=33&&(a[0|(l=(t+r|0)-1192|0)]=16|o[0|l]),e=e+s|0,r;);for(A[n+12>>2]=-1,e=90045;s=Ht(n+12|0,e),(0|(r=A[n+12>>2]))>=33&&(a[0|(l=(t+r|0)-1192|0)]=32|o[0|l]),e=e+s|0,r;);for(A[n+12>>2]=-1,e=90045;s=Ht(n+12|0,e),(0|(r=A[n+12>>2]))>=33&&(a[0|(l=(t+r|0)-1192|0)]=8|o[0|l]),e=e+s|0,r;);for(A[n+12>>2]=-1,e=90045;s=Ht(n+12|0,e),(0|(r=A[n+12>>2]))>=33&&(a[0|(l=(t+r|0)-1192|0)]=64|o[0|l]),e=e+s|0,r;);U=n+16|0,n=24946;break e}A[t+600>>2]=1056,A[t+12>>2]=34,A[t+216>>2]=1118,A[t+220>>2]=1072,kt(t+344|0,0,256),a[t+406|0]=4,a[t+366|0]=4,a[t+367|0]=4,a[t+369|0]=4,a[t+370|0]=4,a[t+371|0]=4,a[t+372|0]=4,a[t+361|0]=4,a[t+362|0]=4,a[t+363|0]=4,a[t+364|0]=4,a[t+373|0]=4,a[t+380|0]=4,a[t+381|0]=4,a[t+382|0]=4,a[t+383|0]=4,a[t+375|0]=4,a[t+376|0]=4,a[t+377|0]=4,a[t+378|0]=4,a[t+384|0]=4,a[t+360|0]=129,A[t+328>>2]=6,A[t+296>>2]=134744588,A[t+300>>2]=286261248,A[t+40>>2]=1,A[t+8>>2]=0,A[t+104>>2]=1032,A[t+108>>2]=66,e=A[25885],A[t+304>>2]=A[25884],A[t+308>>2]=e,e=A[25887],A[t+312>>2]=A[25886],A[t+316>>2]=e,n=25189;break e}Ve(t),A[t+328>>2]=6,A[t+56>>2]=2,A[t+36>>2]=263,A[t+40>>2]=1074,A[t+124>>2]=32,A[t+104>>2]=184554728,A[t+8>>2]=2,a[t+386|0]=64&o[t+386|0]|129,n=25191;break e}A[t+12>>2]=262182,A[t+40>>2]=1,n=6514802;break e}A[t+328>>2]=14,A[t+296>>2]=303173393,A[t+300>>2]=336986112,A[t+104>>2]=1024,A[t+16>>2]=0,A[t+20>>2]=2,A[t+8>>2]=2,A[t+12>>2]=22,A[t+44>>2]=120,e=A[25893],A[t+304>>2]=A[25892],A[t+308>>2]=e,e=A[25895],A[t+312>>2]=A[25894],A[t+316>>2]=e,a[t+463|0]=64&o[t+463|0]|129,a[t+465|0]=64&o[t+465|0]|129,n=25465;break e}A[t+8>>2]=0,A[t+104>>2]=184618072,A[t+32>>2]=1,e=A[26101],A[t+304>>2]=A[26100],A[t+308>>2]=e,e=A[26103],A[t+312>>2]=A[26102],A[t+316>>2]=e,a[t+465|0]=64&o[t+465|0]|129,n=25697;break e}A[t+296>>2]=336860180,A[t+300>>2]=336991764,A[t+8>>2]=0,A[t+104>>2]=16846872,A[t>>2]=8,A[t+4>>2]=48,A[t+80>>2]=87,A[t+32>>2]=1,A[t+36>>2]=256,A[t+40>>2]=2,e=A[25897],A[t+304>>2]=A[25896],A[t+308>>2]=e,e=A[25899],A[t+312>>2]=A[25898],A[t+316>>2]=e,a[t+465|0]=64&o[t+465|0]|129,n=25701;break e}A[t+132>>2]=33,A[t+104>>2]=16779328,A[t+8>>2]=0,A[t+12>>2]=8,A[t+204>>2]=101,A[t+60>>2]=2,A[t+40>>2]=2,e=A[25901],A[t+304>>2]=A[25900],A[t+308>>2]=e,e=A[25903],A[t+312>>2]=A[25902],A[t+316>>2]=e,a[t+441|0]=64|o[t+441|0],a[t+445|0]=64|o[t+445|0],a[t+449|0]=64|o[t+449|0],a[t+455|0]=64|o[t+455|0],a[t+461|0]=64|o[t+461|0],a[t+465|0]=64|o[t+465|0],n=25966;break e}A[t+328>>2]=4,A[t+296>>2]=336858640,A[t+300>>2]=353768980,A[t+104>>2]=16782344,A[t+20>>2]=2,A[t+12>>2]=22,A[t+4>>2]=2,A[t+8>>2]=2,A[t+332>>2]=103640,e=A[25997],A[t+304>>2]=A[25996],A[t+308>>2]=e,e=A[25999],A[t+312>>2]=A[25998],A[t+316>>2]=e,n=25967;break e}A[t+296>>2]=269422096,A[t+300>>2]=370545684,A[t+104>>2]=86017320,A[t+108>>2]=6144,A[t+16>>2]=0,A[t+20>>2]=2,A[t+8>>2]=2,A[t+12>>2]=534,A[t+100>>2]=A[t+96>>2],A[t+44>>2]=120,e=A[25913],A[t+304>>2]=A[25912],A[t+308>>2]=e,e=A[25915],A[t+312>>2]=A[25914],A[t+316>>2]=e;$:{ee:{if((0|n)<=26976){if(24942==(0|n))break ee;if(25441!=(0|n))break $;A[t+12>>2]=566,A[t+336>>2]=103664,n=25441;break e}if(26977!=(0|n)){if(7364976!=(0|n))break $;A[t+8>>2]=3,A[t+12>>2]=310,n=7364976;break e}A[t+104>>2]=85984264,n=26977;break e}A[t+104>>2]=153093416,A[t+108>>2]=2048,A[t+140>>2]=103676,n=24942;break e}A[t+40>>2]=2;break e}A[t+296>>2]=303173648,A[t+300>>2]=303174162,A[t+104>>2]=3147080,A[t+12>>2]=65792,A[t+84>>2]=1,e=A[25921],A[t+304>>2]=A[25920],A[t+308>>2]=e,e=A[25923],A[t+312>>2]=A[25922],A[t+316>>2]=e,n=25973;break e}A[t+600>>2]=1536,A[t+216>>2]=1740,A[t+220>>2]=1568,A[t+104>>2]=96,A[t+224>>2]=103696,A[t+340>>2]=103872,A[t+40>>2]=1,n=26209;break e}A[t+328>>2]=5}A[t+104>>2]=86024,A[t+164>>2]=130,a[t+465|0]=64&o[t+465|0]|129;break e}A[t+296>>2]=303173650,A[t+300>>2]=303174162,A[t+8>>2]=3,A[t+12>>2]=36,A[t+144>>2]=2,A[t+104>>2]=118658312,A[t+28>>2]=1,A[t+100>>2]=A[t+96>>2],e=A[25865],A[t+304>>2]=A[25864],A[t+308>>2]=e,e=A[25867],A[t+312>>2]=A[25866],A[t+316>>2]=e,a[t+465|0]=64&o[t+465|0]|129,n=26226;break e}i[t+170>>1]=257,A[t+148>>2]=1,A[t+12>>2]=2,n=6840683;break e}A[t+144>>2]=2,A[t+104>>2]=2098176,A[t+8>>2]=0,A[t+12>>2]=32,A[t+40>>2]=3,A[t+28>>2]=1;break e}A[t+8>>2]=3,A[t+100>>2]=A[t+96>>2],n=26478;break e}A[t+328>>2]=18,A[t+296>>2]=320081425,A[t+300>>2]=353768980,A[t+600>>2]=2304,A[t+112>>2]=84648,A[t+104>>2]=16,A[t+8>>2]=6,A[t+12>>2]=65540,A[t+100>>2]=A[t+96>>2],e=A[25973],A[t+304>>2]=A[25972],A[t+308>>2]=e,e=A[25975],A[t+312>>2]=A[25974],A[t+316>>2]=e;H:{U:{j:{if((0|n)<=28529){if(26485==(0|n))break j;if(28261!=(0|n))break H;e=A[25861],A[t+304>>2]=A[25860],A[t+308>>2]=e,e=A[25863],A[t+312>>2]=A[25862],A[t+316>>2]=e,A[t+296>>2]=320017171,A[t+300>>2]=320017171,A[t+132>>2]=22,A[t+112>>2]=-1431655768,A[t+108>>2]=32768|A[t+108>>2],Ge(t);break e}if(28530==(0|n))break U;if(28769!=(0|n))break H;A[t+600>>2]=2560,Ge(t);break e}e=A[25861],A[t+304>>2]=A[25860],A[t+308>>2]=e,e=A[25863],A[t+312>>2]=A[25862],A[t+316>>2]=e,A[t+600>>2]=2688,A[t+296>>2]=320017171,A[t+300>>2]=320017171,A[t+8>>2]=2,Ge(t);break e}A[t+600>>2]=2816}Ge(t);break e}a[0|s]=104,a[s+1|0]=98,a[s+2|0]=115,a[s+3|0]=0,29554!=(0|n)?(e=A[26093],A[t+304>>2]=A[26092],A[t+308>>2]=e,e=A[26095],A[t+312>>2]=A[26094],A[t+316>>2]=e):(e=A[25977],A[t+304>>2]=A[25976],A[t+308>>2]=e,e=A[25979],A[t+312>>2]=A[25978],A[t+316>>2]=e),A[t+328>>2]=3,A[t+296>>2]=336859409,A[t+300>>2]=353768980,i[t+168>>1]=261,A[t+8>>2]=0,A[t+12>>2]=16,A[t+144>>2]=1,A[t+184>>2]=1056,A[t+104>>2]=33572172,A[t+108>>2]=330,A[t+36>>2]=3,a[t+465|0]=64&o[t+465|0]|129,a[t+458|0]=64&o[t+458|0]|129;break e}A[t+104>>2]=17990912,A[t+8>>2]=3,A[t+12>>2]=36,n=26740;break e}A[t+328>>2]=3,A[t+296>>2]=320016657,A[t+300>>2]=353768980,A[t+124>>2]=32,A[t+128>>2]=44,A[t+104>>2]=186758144,A[t+12>>2]=1081398,A[t+16>>2]=2,A[t+4>>2]=32,A[t+8>>2]=0,A[t+116>>2]=899,A[t+120>>2]=1,a[t+169|0]=1,A[t+76>>2]=2,e=A[25981],A[t+304>>2]=A[25980],A[t+308>>2]=e,e=A[25983],A[t+312>>2]=A[25982],A[t+316>>2]=e,a[t+465|0]=64&o[t+465|0]|129,Tr(t,3),n=26741;break e}for(A[t+600>>2]=1328,A[t+8>>2]=3,e=A[25985],A[t+304>>2]=A[25984],A[t+308>>2]=e,e=A[25987],A[t+312>>2]=A[25986],A[t+316>>2]=e,s=kt(t+344|0,0,256),a[t+429|0]=129,a[t+416|0]=129,a[t+403|0]=129,a[t+399|0]=129,a[t+400|0]=129,a[t+397|0]=129,a[t+393|0]=129,r=103952,l=50,u=50;a[0|(e=s+u|0)]=2|o[0|e],e=s+o[r+1|0]|0,a[0|e]=2|o[0|e],e=s+o[r+2|0]|0,a[0|e]=2|o[0|e],u=o[0|(r=r+3|0)],e=103952,103982!=(0|r););for(r=t+344|0;a[0|(s=r+l|0)]=4|o[0|s],s=r+o[e+1|0]|0,a[0|s]=4|o[0|s],s=r+o[e+2|0]|0,a[0|s]=4|o[0|s],l=o[0|(e=e+3|0)],103982!=(0|e););a[t+168|0]=6,A[t+104>>2]=5128,a[t+413|0]=4|o[t+413|0];break e}A[t+328>>2]=4,A[t+296>>2]=336858640,A[t+300>>2]=353768980,A[t+104>>2]=16782440,A[t+20>>2]=2,A[t+12>>2]=22,A[t+4>>2]=2,A[t+8>>2]=2,A[t+332>>2]=104e3,e=A[25997],A[t+304>>2]=A[25996],A[t+308>>2]=e,e=A[25999],A[t+312>>2]=A[25998],A[t+316>>2]=e,n=26991;break e}A[t+296>>2]=303174160,A[t+300>>2]=353768980,A[t+104>>2]=16781320,A[t+144>>2]=2,A[t+8>>2]=2,A[t+12>>2]=22,e=A[26005],A[t+304>>2]=A[26004],A[t+308>>2]=e,e=A[26007],A[t+312>>2]=A[26006],A[t+316>>2]=e;break e}for(A[t+8>>2]=0,A[t+12>>2]=16,A[t+56>>2]=2,A[t+28>>2]=17,e=A[26009],A[t+304>>2]=A[26008],A[t+308>>2]=e,e=A[26011],A[t+312>>2]=A[26010],A[t+316>>2]=e,e=0,r=t+344|0;a[0|(s=e+r|0)]=231&o[0|s],a[0|(s=r+(1|e)|0)]=231&o[0|s],a[0|(s=r+(2|e)|0)]=231&o[0|s],a[0|(s=r+(3|e)|0)]=231&o[0|s],256!=(0|(e=e+4|0)););A[t+104>>2]=2280,A[t+108>>2]=2,A[t+608>>2]=104048,a[t+451|0]=16|o[t+451|0],a[t+456|0]=16|o[t+456|0],a[t+459|0]=16|o[t+459|0],a[t+460|0]=16|o[t+460|0],a[t+450|0]=8|o[t+450|0],a[t+462|0]=8|o[t+462|0],a[t+458|0]=8|o[t+458|0],a[t+465|0]=64&o[t+465|0]|129;break e}A[t+296>>2]=269618961,A[t+300>>2]=370546196,A[t+12>>2]=131110,A[t+144>>2]=2,A[t+104>>2]=184559112,A[t+108>>2]=8192,A[t+16>>2]=0,A[t+20>>2]=2,A[t+4>>2]=1,A[t+8>>2]=2,A[t+100>>2]=A[t+96>>2],A[t+140>>2]=103676,A[t+68>>2]=2,A[t+56>>2]=1,A[t+44>>2]=130,A[t+28>>2]=2,e=A[26025],A[t+304>>2]=A[26024],A[t+308>>2]=e,e=A[26027],A[t+312>>2]=A[26026],A[t+316>>2]=e,a[t+465|0]=64&o[t+465|0]|129,n=26996;break e}A[t+4>>2]=524,A[t+8>>2]=2,A[t+196>>2]=368,A[t+104>>2]=0,A[t+336>>2]=104128,A[t- -64>>2]=1,e=A[26029],A[t+304>>2]=A[26028],A[t+308>>2]=e,e=A[26031],A[t+312>>2]=A[26030],A[t+316>>2]=e,a[t+465|0]=64&o[t+465|0]|129,n=6972015;break e}for(A[t+296>>2]=303174162,A[t+300>>2]=370545684,e=A[25873],A[t+304>>2]=A[25872],A[t+308>>2]=e,e=A[25875],A[t+312>>2]=A[25874],A[t+316>>2]=e,s=kt(t+344|0,0,256),a[t+431|0]=1,a[t+429|0]=1,a[t+411|0]=1,a[t+405|0]=1,a[t+400|0]=1,a[t+396|0]=1,a[t+392|0]=1,e=104160,r=49;a[0|(r=r+s|0)]=4|o[0|r],r=s+o[e+1|0]|0,a[0|r]=4|o[0|r],r=s+o[e+2|0]|0,a[0|r]=4|o[0|r],r=o[0|(e=e+3|0)],104193!=(0|e););A[t+600>>2]=4256,A[t+8>>2]=0,A[t+12>>2]=16,a[t+168|0]=7,A[t+132>>2]=32,a[t+392|0]=128|o[t+392|0],a[t+396|0]=128|o[t+396|0],a[t+400|0]=128|o[t+400|0],a[t+405|0]=128|o[t+405|0],a[t+411|0]=128|o[t+411|0],a[t+429|0]=128|o[t+429|0],a[t+431|0]=128|o[t+431|0],A[t+188>>2]=1056,A[t+192>>2]=29301,A[t+104>>2]=19964960;break e}for(A[t+600>>2]=1056,s=kt(t+344|0,0,256),a[t+393|0]=1,a[t+365|0]=1,a[t+360|0]=1,a[t+545|0]=1,a[t+529|0]=1,a[t+391|0]=1,a[t+389|0]=1,a[t+390|0]=1,a[t+387|0]=1,a[t+379|0]=1,a[t+374|0]=1,a[t+368|0]=1,a[t+489|0]=1,a[t+487|0]=1,a[t+398|0]=1,e=104224,r=17;a[0|(r=r+s|0)]=4|o[0|r],r=s+o[e+1|0]|0,a[0|r]=4|o[0|r],r=s+o[e+2|0]|0,a[0|r]=4|o[0|r],r=o[0|(e=e+3|0)],104251!=(0|e););a[t+360|0]=128|o[t+360|0],a[t+365|0]=128|o[t+365|0],a[t+393|0]=128|o[t+393|0],a[t+368|0]=128|o[t+368|0],a[t+374|0]=128|o[t+374|0],a[t+379|0]=128|o[t+379|0],a[t+387|0]=128|o[t+387|0],a[t+389|0]=128|o[t+389|0],a[t+390|0]=128|o[t+390|0],a[t+391|0]=128|o[t+391|0],a[t+529|0]=128|o[t+529|0],a[t+545|0]=128|o[t+545|0],a[t+489|0]=128|o[t+489|0],a[t+487|0]=128|o[t+487|0],a[t+398|0]=128|o[t+398|0],e=A[26055],A[t+312>>2]=A[26054],A[t+316>>2]=e,e=A[26053],A[t+304>>2]=A[26052],A[t+308>>2]=e,A[t+296>>2]=353636370,A[t+300>>2]=336925972,A[t+200>>2]=0,A[t+8>>2]=7,A[t+12>>2]=2097184,a[t+168|0]=2,A[t+104>>2]=50176,A[t+84>>2]=1,Tr(t,3);break e}A[t+296>>2]=320017171,A[t+300>>2]=320017171,A[t+104>>2]=184618072,A[t+8>>2]=12,A[t+12>>2]=32,e=A[25861],A[t+304>>2]=A[25860],A[t+308>>2]=e,e=A[25863],A[t+312>>2]=A[25862],A[t+316>>2]=e,n=27500;break e}A[t+184>>2]=42752,A[t+600>>2]=4352,kt(t+344|0,0,256),a[t+456|0]=1,a[t+457|0]=1,a[t+458|0]=1,a[t+459|0]=1,a[t+449|0]=1,a[t+450|0]=1,a[t+451|0]=1,a[t+452|0]=1,a[t+453|0]=1,a[t+454|0]=1,a[t+455|0]=1,a[t+456|0]=1,a[t+441|0]=1,a[t+442|0]=1,a[t+443|0]=1,a[t+444|0]=1,a[t+445|0]=1,a[t+446|0]=1,a[t+447|0]=1,a[t+448|0]=1,a[t+460|0]=65,a[t+461|0]=65,a[t+532|0]=32,a[t+527|0]=32,a[t+519|0]=32,a[t+515|0]=32,a[t+349|0]=32,a[t+350|0]=32,a[t+346|0]=32,A[t+132>>2]=20,A[t+112>>2]=286331152,A[t+104>>2]=1024,A[t+108>>2]=16384,A[t+40>>2]=1,A[t+8>>2]=8,a[t+458|0]=65,a[t+453|0]=65,a[t+447|0]=65,a[t+448|0]=65,a[t+443|0]=65,a[t+444|0]=65,n=27503;break e}A[t+328>>2]=10,A[t+296>>2]=336859666,A[t+300>>2]=353768980,a[t+168|0]=2,A[t+104>>2]=263264,A[t+8>>2]=7,e=A[26065],A[t+304>>2]=A[26064],A[t+308>>2]=e,e=A[26067],A[t+312>>2]=A[26066],A[t+316>>2]=e,n=27509;break e}A[t+104>>2]=1,n=27513;break e}A[t+116>>2]=5e3,A[t+104>>2]=16777216,A[t+24>>2]=1,A[t+16>>2]=0,A[t+20>>2]=2,A[t+8>>2]=2,A[t+12>>2]=32,A[t+328>>2]=5,n=27745;break e}A[t+116>>2]=5e3,A[t+104>>2]=99336,A[t+108>>2]=256,A[t+24>>2]=1,A[t+16>>2]=0,A[t+20>>2]=2,A[t+8>>2]=2,A[t+12>>2]=32,A[t+328>>2]=5,n=27764;break e}A[t+328>>2]=6,A[t+296>>2]=336859409,A[t+300>>2]=353768980,A[t+600>>2]=1056,A[t+104>>2]=2114600,A[t+108>>2]=138,A[t+8>>2]=4,A[t+632>>2]=104288,A[t+604>>2]=104288,e=A[26093],A[t+304>>2]=A[26092],A[t+308>>2]=e,e=A[26095],A[t+312>>2]=A[26094],A[t+316>>2]=e,n=28011;break e}A[t+328>>2]=4,A[t+104>>2]=1,A[t+8>>2]=2,A[t+36>>2]=256,n=28020;break e}A[t+4>>2]=48,A[t+8>>2]=0,A[t+12>>2]=128,A[t+104>>2]=2169880,A[t+32>>2]=1,A[t+36>>2]=256,A[t+24>>2]=1,A[t+136>>2]=85767,e=A[26097],A[t+304>>2]=A[26096],A[t+308>>2]=e,e=A[26099],A[t+312>>2]=A[26098],A[t+316>>2]=e,a[t+465|0]=64&o[t+465|0]|129,n=28268;break e}A[t+8>>2]=0,A[t+104>>2]=71752,e=A[26101],A[t+304>>2]=A[26100],A[t+308>>2]=e,e=A[26103],A[t+312>>2]=A[26102],A[t+316>>2]=e,a[t+465|0]=64&o[t+465|0]|129,n=28258;break e}A[t+296>>2]=336858898,A[t+300>>2]=370546196,A[t+104>>2]=1088,A[t+108>>2]=512,A[t+8>>2]=2,A[t+12>>2]=524310,e=A[26105],A[t+304>>2]=A[26104],A[t+308>>2]=e,e=A[26107],A[t+312>>2]=A[26106],A[t+316>>2]=e,n=28525;break e}A[t+328>>2]=3,A[t+296>>2]=320015633,A[t+300>>2]=353768980,a[t+168|0]=7,A[t+8>>2]=2,A[t+12>>2]=6,A[t+104>>2]=20488,A[t+108>>2]=192,A[t+36>>2]=9,A[t+60>>2]=260,e=A[26109],A[t+304>>2]=A[26108],A[t+308>>2]=e,e=A[26111],A[t+312>>2]=A[26110],A[t+316>>2]=e,a[t+465|0]=64&o[t+465|0]|129,n=28780;break e}for(A[t+296>>2]=353569552,A[t+300>>2]=353768980,A[t+116>>2]=5e3,A[t+104>>2]=33570920,A[t+108>>2]=14336,A[t+8>>2]=3,A[t+12>>2]=139286,A[t+100>>2]=A[t+96>>2],e=A[26113],A[t+304>>2]=A[26112],A[t+308>>2]=e,e=A[26115],A[t+312>>2]=A[26114],A[t+316>>2]=e,a[t+465|0]=64&o[t+465|0]|129,e=0,r=t+344|0;a[0|(s=e+r|0)]=253&o[0|s],a[0|(s=r+(1|e)|0)]=253&o[0|s],a[0|(s=r+(2|e)|0)]=253&o[0|s],a[0|(s=r+(3|e)|0)]=253&o[0|s],256!=(0|(e=e+4|0)););a[t+442|0]=2|o[t+442|0],a[t+443|0]=2|o[t+443|0],a[t+444|0]=2|o[t+444|0],a[t+446|0]=2|o[t+446|0],a[t+447|0]=2|o[t+447|0],a[t+450|0]=2|o[t+450|0],a[t+451|0]=2|o[t+451|0],a[t+453|0]=2|o[t+453|0],a[t+454|0]=2|o[t+454|0],a[t+456|0]=2|o[t+456|0],a[t+457|0]=2|o[t+457|0],a[t+459|0]=2|o[t+459|0],a[t+460|0]=2|o[t+460|0],a[t+462|0]=2|o[t+462|0],a[t+464|0]=2|o[t+464|0],a[t+466|0]=2|o[t+466|0],A[t+144>>2]=2,A[t+68>>2]=2;break e}A[t+296>>2]=303172879,A[t+300>>2]=353768980,A[t+328>>2]=3,A[t+8>>2]=3,A[t+12>>2]=262,A[t+104>>2]=16805928,A[t+108>>2]=30,e=A[26117],A[t+304>>2]=A[26116],A[t+308>>2]=e,e=A[26119],A[t+312>>2]=A[26118],A[t+316>>2]=e,n=29295;break e}on(t),n=29301;break e}for(A[t+328>>2]=3,A[t+296>>2]=336859153,A[t+300>>2]=353768980,i[t+168>>1]=261,A[t+8>>2]=0,A[t+12>>2]=22,A[t+124>>2]=0,A[t+128>>2]=44,A[t+104>>2]=16794624,A[t+108>>2]=128,A[t+36>>2]=3,A[t+60>>2]=4,e=A[25869],A[t+304>>2]=A[25868],A[t+308>>2]=e,e=A[25871],A[t+312>>2]=A[25870],A[t+316>>2]=e,25459==(0|n)&&(A[t+108>>2]=136),a[t+465|0]=64&o[t+465|0]|129,a[t+458|0]=64&o[t+458|0]|129,e=0,r=t+344|0;a[0|(s=e+r|0)]=223&o[0|s],a[0|(s=r+(1|e)|0)]=223&o[0|s],a[0|(s=r+(2|e)|0)]=223&o[0|s],a[0|(s=r+(3|e)|0)]=223&o[0|s],256!=(0|(e=e+4|0)););a[t+442|0]=32|o[t+442|0],a[t+444|0]=32|o[t+444|0],a[t+447|0]=32|o[t+447|0],a[t+450|0]=32|o[t+450|0],a[t+452|0]=32|o[t+452|0],a[t+453|0]=32|o[t+453|0],a[t+454|0]=32|o[t+454|0],a[t+458|0]=32|o[t+458|0],a[t+462|0]=32|o[t+462|0],a[t+463|0]=32|o[t+463|0],a[t+466|0]=32|o[t+466|0],a[t+441|0]=32|o[t+441|0],a[t+445|0]=32|o[t+445|0],a[t+449|0]=32|o[t+449|0],a[t+455|0]=32|o[t+455|0],a[t+461|0]=32|o[t+461|0],a[t+465|0]=32|o[t+465|0];break e}for(A[t+296>>2]=303174162,A[t+300>>2]=370545684,A[t+600>>2]=3456,a[t+169|0]=1,A[t+8>>2]=0,A[t+12>>2]=22,A[t+100>>2]=A[t+96>>2],e=A[25873],A[t+304>>2]=A[25872],A[t+308>>2]=e,e=A[25875],A[t+312>>2]=A[25874],A[t+316>>2]=e,kt(t+344|0,0,256),a[t+365|0]=1,a[t+366|0]=1,a[t+357|0]=1,a[t+358|0]=1,a[t+359|0]=1,a[t+360|0]=1,a[t+361|0]=1,a[t+362|0]=1,a[t+363|0]=1,a[t+364|0]=1,a[t+349|0]=1,a[t+350|0]=1,a[t+351|0]=1,a[t+352|0]=1,a[t+353|0]=1,a[t+354|0]=1,a[t+355|0]=1,a[t+356|0]=1,e=74,r=74;a[344+(s=t+r|0)|0]=1|o[s+344|0],a[s+345|0]=1|o[s+345|0],a[s+346|0]=1|o[s+346|0],116!=(0|(r=r+3|0)););for(;a[344+(r=e+t|0)|0]=2|o[r+344|0],a[r+345|0]=2|o[r+345|0],a[r+346|0]=2|o[r+346|0],116!=(0|(e=e+3|0)););for(r=26;a[344+(e=t+r|0)|0]=4|o[e+344|0],a[e+345|0]=4|o[e+345|0],a[e+346|0]=4|o[e+346|0],a[e+347|0]=4|o[e+347|0],a[e+348|0]=4|o[e+348|0],71!=(0|(r=r+5|0)););A[t+112>>2]=84648,A[t+104>>2]=270589952,A[t+108>>2]=65536,A[t+40>>2]=1,A[t+204>>2]=A[t+600>>2]+74;break e}A[t+8>>2]=2,A[t+12>>2]=32,A[t+328>>2]=3,A[t+124>>2]=32,A[t+104>>2]=16864280,A[t+108>>2]=256,A[t+68>>2]=2,A[t+36>>2]=259,A[t+40>>2]=118,A[t+28>>2]=1,a[t+458|0]=128|o[t+458|0],n=29548;break e}A[t+296>>2]=370544658,A[t+300>>2]=370546196,A[t+164>>2]=130,A[t+8>>2]=0,A[t+12>>2]=86,A[t+104>>2]=87064,a[t+169|0]=1,A[t+152>>2]=3,e=A[26121],A[t+304>>2]=A[26120],A[t+308>>2]=e,e=A[26123],A[t+312>>2]=A[26122],A[t+316>>2]=e,a[t+465|0]=64&o[t+465|0]|129,n=7564650;break e}A[t+296>>2]=269487120,A[t+300>>2]=320148500,A[t+8>>2]=3,A[t+12>>2]=278,A[t+144>>2]=2,A[t+104>>2]=32872,e=A[26125],A[t+304>>2]=A[26124],A[t+308>>2]=e,e=A[26127],A[t+312>>2]=A[26126],A[t+316>>2]=e,a[t+465|0]=64&o[t+465|0]|129,n=29553;break e}A[t+296>>2]=336859152,A[t+300>>2]=353768980,A[t+8>>2]=0,A[t+144>>2]=1,A[t+104>>2]=6408,e=A[26129],A[t+304>>2]=A[26128],A[t+308>>2]=e,e=A[26131],A[t+312>>2]=A[26130],A[t+316>>2]=e,a[t+465|0]=64&o[t+465|0]|129,n=29558;break e}A[t+296>>2]=320015376,A[t+300>>2]=353768980,a[t+168|0]=4,A[t+12>>2]=22,A[t+4>>2]=1,A[t+8>>2]=2,A[t+104>>2]=1248,A[t+100>>2]=A[t+96>>2],e=A[26133],A[t+304>>2]=A[26132],A[t+308>>2]=e,e=A[26135],A[t+312>>2]=A[26134],A[t+316>>2]=e;break e}A[t+296>>2]=303174162,A[t+300>>2]=370545684,a[t+169|0]=1,A[t+8>>2]=0,A[t+12>>2]=22,A[t+112>>2]=5288,A[t+100>>2]=A[t+96>>2],e=A[25877],A[t+304>>2]=A[25876],A[t+308>>2]=e,e=A[25879],A[t+312>>2]=A[25878],A[t+316>>2]=e;u:switch(n-29793|0){default:if(27502!=(0|n)){if(28012!=(0|n))break n;e=A[26137],A[t+304>>2]=A[26136],A[t+308>>2]=e,e=A[26139],A[t+312>>2]=A[26138],A[t+316>>2]=e,A[t+600>>2]=3328,A[t+296>>2]=320017171,A[t+300>>2]=320017171,A[t+104>>2]=2098176,A[t+108>>2]=131072,A[t+8>>2]=13;break n}A[t+104>>2]=1,A[t+600>>2]=3200;break n;case 4:break u;case 1:case 2:case 3:break n;case 0:break r}A[t+104>>2]=1,A[t+108>>2]=524288,A[t+600>>2]=3072;break n}A[t+328>>2]=10,A[t+296>>2]=353636370,A[t+300>>2]=336925972,a[t+173|0]=1,A[t+8>>2]=7,A[t+12>>2]=32,a[t+168|0]=2,A[t+84>>2]=1,e=A[26141],A[t+304>>2]=A[26140],A[t+308>>2]=e,A[t+104>>2]=24954==(0|n)?2118920:2114824,e=A[26143],A[t+312>>2]=A[26142],A[t+316>>2]=e;break e}Ve(t),A[t+296>>2]=303173650,A[t+300>>2]=303174162,A[t+104>>2]=2131208,A[t+8>>2]=3,A[t+12>>2]=32,e=A[25865],A[t+304>>2]=A[25864],A[t+308>>2]=e,e=A[25867],A[t+312>>2]=A[25866],A[t+316>>2]=e,n=29812;break e}on(t),n=30059;break e}A[t+112>>2]=21160,A[t+104>>2]=16,A[t+600>>2]=1536,A[t+40>>2]=1;break e}A[t+296>>2]=269488144,A[t+300>>2]=370546198,A[t+8>>2]=0,A[t>>2]=33,A[t+148>>2]=1,A[t+104>>2]=12615688,A[t+16>>2]=2,A[t+100>>2]=A[t+96>>2],A[t+632>>2]=104592,A[t+604>>2]=104592,e=A[26145],A[t+304>>2]=A[26144],A[t+308>>2]=e,e=A[26147],A[t+312>>2]=A[26146],A[t+316>>2]=e,n=30313;break e}if(A[t+296>>2]=370544662,A[t+300>>2]=370546198,A[t+8>>2]=3,A[t+12>>2]=2,A[t+148>>2]=1,A[t+184>>2]=12544,i[t+170>>1]=257,A[t+176>>2]=1,a[t+172|0]=1,A[t>>2]=33,A[t+4>>2]=0,A[t+100>>2]=A[t+96>>2],e=A[26225],A[t+304>>2]=A[26224],A[t+308>>2]=e,e=A[26227],A[t+312>>2]=A[26226],A[t+316>>2]=e,7959909!=(0|n))break e;A[t+112>>2]=24,A[t+104>>2]=1,A[t+108>>2]=1048576,n=7959909;break e}e=A[25873],A[t+304>>2]=A[25872],A[t+308>>2]=e,e=A[25875],A[t+312>>2]=A[25874],A[t+316>>2]=e,A[t+600>>2]=2944,A[t+104>>2]=2097152,A[t+108>>2]=262144,A[t+48>>2]=1}Ge(t),a[t+422|0]=2|o[t+422|0];break e}A[t+40>>2]=1}return A[t+212>>2]=n,8&(e=A[t+104>>2])&&(A[t+124>>2]=46,A[t+128>>2]=44),4&e&&(A[t+124>>2]=0),t}function J(e){var t=0,n=0,r=0,s=0,l=0,u=0,c=0,d=0,h=0,f=0,C=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0,N=0,G=0,F=0;e:{n=A[32538],A[47354]=0,A[47568]=0,A[49828]=0,A[47569]=0,a[199328]=0,A[49827]=0,A[49845]=0,a[190280]=0,a[190268]=1,A[47202]=0,A[49573]=0,A[49846]=0,a[199304]=0,a[199388]=0,A[33691]=0,A[33285]=0,A[33708]=1,A[33709]=1,A[33288]=0,t=A[33730],A[33712]=A[33729],A[33713]=t,t=A[33732],A[33714]=A[33731],A[33715]=t,t=A[33734],A[33716]=A[33733],A[33717]=t,t=A[33736],A[33718]=A[33735],A[33719]=t,t=A[33738],A[33720]=A[33737],A[33721]=t,t=A[33740],A[33722]=A[33739],A[33723]=t,t=A[33742],A[33724]=A[33741],A[33725]=t,A[33726]=A[33743],a[134784]=0,a[134824]=0,a[134772]=0,a[134760]=0,A[33284]=-1,A[33692]=0,A[32525]=0,A[47201]=A[33717],A[47200]=A[33718],es(),A[34438]=0,A[34437]=0,t=A[33730],A[34048]=A[33729],A[34049]=t,t=A[33732],A[34050]=A[33731],A[34051]=t,t=A[33734],A[34052]=A[33733],A[34053]=t,t=A[33736],A[34054]=A[33735],A[34055]=t,t=A[33738],A[34056]=A[33737],A[34057]=t,t=A[33740],A[34058]=A[33739],A[34059]=t,t=A[33742],A[34060]=A[33741],A[34061]=t,A[34062]=A[33743];t:{n:{if(1&n){if(A[A[32539]>>2]=0,A[47569]|A[49845]|A[49827])break n;break t}if(A[A[32539]>>2]=0,!(A[49845]|A[49827]||A[47569]))break t}a[190280]=1}A[49828]=0,t=268436735;t:if(!(!A[34391]|!A[34388])&&(A[47204]=0,A[47203]=0,A[47199]=0,A[34439]=0,(A[47192]||!(t=Kt(86228)))&&((t=A[33283])||((t=ie(16))&&(A[t>>2]=0,A[t+4>>2]=0,A[t+8>>2]=0,A[t+12>>2]=0),A[33283]=t),l=268439807,(n=A[A[47192]+328>>2])>>>0>20|!A[129104+(n<<3)>>2]?t=l:(e?(l=4,s=Hn(e)+1|0):(l=2,s=0),A[t+8>>2]=l,A[t>>2]=e,A[t+12>>2]=A[129108+(n<<3)>>2],A[t+4>>2]=e?e+s|0:0,t=0),!t))){X(0);n:{for(;;){A[34436]=0,e=A[34391],A[51290]=e,A[54046]=e+A[34390],A[50767]<=102399&&(A[50767]=102400);r:if(!((u=A[51290])>>>0>=p[54046]))for(;;){if((((0|(e=(s=A[50757])-(c=A[50758])|0))<=0?e+170|0:e)-171|0)>=-1){if((0|(e=A[54731]))<=0)break r;l=0,A[50763]=0,A[50762]=0,A[50765]=2147483647,e=o[218920]?A[54732]:e;s:{for(;;){if(n=e-1|0,A[54732]=n,(0|e)<=0)break s;if(A[51290]=u+1,t=(e=A[51293])+1|0,A[51293]=(0|t)<=5499?t:0,t=(e=b(A[50755],i[205184+(e<<1)>>1]))>>8,a[0|u]=t,s=A[51290],A[51290]=s+1,a[0|s]=e>>>16,(s=A[50756])?(e=n,(n=A[s+4>>2])&&(Ns[0|n](t<<16>>16),e=A[54732])):e=n,s=(n=A[51292])+1|0,A[51292]=s,i[205184+(n<<1)>>1]=t,(0|s)>=5500&&(A[51292]=0),u=A[51290],!(p[54046]>=u+2>>>0))break}l=1}a[218920]=l;break r}e=A[4+(n=216192+(s<<4)|0)>>2];s:{a:{i:{A:{o:{l:{u:{c:{d:{h:{f:{g:{p:{m:{b:{C:switch((255&(t=A[n>>2]))-1|0){case 9:break i;case 7:break A;case 10:break o;case 11:break l;case 13:break u;case 0:break c;case 1:break d;case 2:break h;case 3:break f;case 6:break g;case 5:break p;case 4:break m;case 15:break b;case 8:break C;default:break a}if(!A[50759])break a;t=A[n+12>>2],n=A[n+8>>2],A[50768]=0,u=n||99232,A[50766]=u,A[50769]=e?2097152/(0|e)|0:0,e=A[50971],s=(0|b(e,A[50788]))/50|0,n=b(s-e|0,-18),e=((0|(e=A[50785]))>=101?101:e)-A[50790]|0,t=(l=n+((0|b(A[50970],o[((0|e)>0?e:0)+105680|0]))/128|0)|0)+((0|b(s,(0|(e=t>>16))<(0|(n=65535&t))?e:n))/2|0)|0,A[50770]=t,e=(l+((0|b(s,(0|e)>(0|n)?e:n))/2|0)|0)-t|0,A[50771]=e,n=o[0|u],A[33072]=A[50976],A[50767]=t+(b(e,n)>>8);break a}Ns[A[A[50756]>>2]](e,A[n+8>>2]),Ee(e);break a}if(o[218920]||(A[54731]=A[54731]-e),A[50781]=100,A[50773]=0,At(),A[50763]=0,A[50762]=0,A[50765]=2147483647,!e)break a;for(e=o[218920]?A[54732]:e;;){if(n=e-1|0,A[54732]=n,(0|e)<=0)break a;if(e=A[51290],A[51290]=e+1,s=(t=A[51293])+1|0,A[51293]=(0|s)<=5499?s:0,s=e,t=(e=b(A[50755],i[205184+(t<<1)>>1]))>>8,a[0|s]=t,s=A[51290],A[51290]=s+1,a[0|s]=e>>>16,(s=A[50756])?(e=n,(n=A[s+4>>2])&&(Ns[0|n](t<<16>>16),e=A[54732])):e=n,s=(n=A[51292])+1|0,A[51292]=s,i[205184+(n<<1)>>1]=t,(0|s)>=5500&&(A[51292]=0),s=1,!(p[54046]>=A[51290]+2>>>0))break}break s}for(A[50773]=0,A[54731]=A[54729],At(),t=A[n+12>>2],s=A[n+8>>2],o[218920]?e=A[54733]:A[54734]=0,c=t>>8,l=255&t,A[50762]=0,A[50763]=0;;){if(n=e-1|0,A[54733]=n,(0|e)<=0)break a;if(t=(e=A[54734])+1|0,l?u=b(l,a[e+s|0]):(u=o[e+s|0]|a[t+s|0]<<8,t=e+2|0),A[54734]=t,d=(e=A[51293])+1|0,A[51293]=d,t=(0|(e=(0|(e=((0|b(c,b(A[33037],b(A[33038],u))>>10))/32|0)+(b(A[50755],i[205184+(e<<1)>>1])>>8)|0))<=-32768?-32768:e))>=32767?32767:e,(0|d)>=5500&&(A[51293]=0),a[A[51290]]=t,a[A[51290]+1|0]=t>>>8,(u=A[50756])?(e=n,(n=A[u+12>>2])&&(Ns[0|n](t<<16>>16),e=A[54733])):e=n,n=A[51290],A[51290]=n+2,d=(u=A[51292])+1|0,A[51292]=d,i[205184+(u<<1)>>1]=(0|b(t,3))/4,(0|d)>=5500&&(A[51292]=0),!(p[54046]>=n+4>>>0))break}s=1;break s}t=A[n+12>>2],s=e>>>16|0,A[50777]=s,e&=65535,A[50773]=e,l=255&t,A[50774]=l,A[50775]=t>>8,l||(A[50777]=s<<1,A[50773]=e<<1),A[50778]=0,A[50776]=0,A[50772]=A[n+8>>2];break a}A[50773]=0}if(A[54731]=A[54729],t=A[50759],o[218920]){if(!t)break a}else{if(!t)break a;for(l=A[n+12>>2],u=A[n+8>>2],n=e>>16,A[55912]=255&n,a[218960]=1,A[55908]=0,67108864&e&&(A[55908]=3,A[55909]=A[110496+(n>>>6&12)>>2]),134217728&e&&(A[55908]=4,A[55909]=A[110512+(n>>>6&12)>>2]),e&=65504;;){if((0|c)!=(0|(s=(0|(n=s+1|0))<=169?n:0)))if(3!=(0|(n=A[216192+(s<<4)>>2]))){if(n-5>>>0>1)continue}else a[218960]=0;break}for(A[55913]=A[50762],e=(e=e+32&131008)||64,A[50763]=e+A[50763],A[55684]=b(i[101997],7800)+(g[102024]<<8)<<8,A[55704]=b(i[101998],9e3)+(g[102025]<<8)<<8,k=A[50980],r=+(0|e),C=+(e>>>2|0),e=0;7!=(0|e)&&(s=i[218+(d=(n=e<<1)+t|0)>>1]<<8,c=b(e,80)+222176|0,d=i[d+164>>1],w=s+b(d,i[2+(n+u|0)>>1])<<8,A[c>>2]=w,f=+(0|w),m[c+16>>3]=f,m[c+48>>3]=16*(+(s+b(d,i[2+(n+l|0)>>1])<<8)-f)/C),s=(n=b(e,80))+222176|0,d=i[182+(w=t+(e<<1)|0)>>1],y=b(d,o[18+(c=e+u|0)|0])<<6,A[s+4>>2]=y,f=+(0|y),m[s+24>>3]=f,x=s,s=e+l|0,m[x+56>>3]=64*(+(b(d,o[s+18|0])<<6)-f)/r,(0|e)>(0|k)|e>>>0>5||(d=n+222176|0,y=i[w+200>>1],w=b(y,o[c+26|0])<<10,A[d+8>>2]=w,f=+(0|w),m[d+32>>3]=f,x=d- -64|0,d=y<<10,m[x>>3]=64*(+(0|b(d,o[s+26|0]))-f)/r,e>>>0<=2?(n=n+222176|0,c=b(d,o[c+32|0]),A[n+12>>2]=c,f=+(0|c),m[n+40>>3]=f,m[n+72>>3]=64*(+(0|b(d,o[s+32|0]))-f)/r):A[n+222188>>2]=w),8!=(0|(e=e+1|0)););}for(;;){if(e=A[50762],!o[218960]&(0|e)==A[50763])break a;h:{f:{if(63&e){if(7&e)break h;g:if(!((0|(n=A[54736]))<=0||(0|(t=A[54735]))<=0))for(s=A[50826],e=1;;){if(A[(u=(l=e<<2)+s|0)>>2]=A[u>>2]+A[l+203312>>2],e>>>0>28|(0|e)>=(0|n))break g;if(l=(0|e)<(0|t),e=e+1|0,!l)break}if((0|(e=A[33073]))>255)break h;A[33073]=e+1;break h}if(e)if(A[50759]){if(n=A[50768]+A[50769]|0,A[50768]=n,n=(t=A[50766])?b(o[t+((0|(n>>=8))>=127?127:n)|0],A[50771])>>8:0,A[55911]=A[55911]+A[55915],t=(0|(t=A[55914]))<=23551?t:0,A[55914]=t+A[50761],t=(n+A[50770]|0)+b(A[33072],o[110528+(t>>6)|0]-128|0)|0,A[50767]=t,!(s=A[51291])&(0|(n=s?s<<12:t))>102399||(t=(0|n)<=102400?102400:n,A[50767]=t),(0|e)!=A[55913]){if(e=0,!((0|(c=A[50980]))<0)){for(;u=b(e,80),r=m[48+(n=u+222176|0)>>3]+m[n+16>>3],m[n+16>>3]=r,C=m[n+56>>3]+m[n+24>>3],m[n+24>>3]=C,f=m[n- -64>>3]+m[n+32>>3],m[n+32>>3]=f,s=I(r)<2147483648?~~r:-2147483648,A[n>>2]=s,s=I(f)<2147483648?~~f:-2147483648,A[n+8>>2]=s,l=I(C)<2147483648?~~C:-2147483648,A[n+4>>2]=(0|l)>0?l:0,(0|e)>2||(r=m[72+(n=u+222176|0)>>3]+m[n+40>>3],m[n+40>>3]=r,s=I(r)<2147483648?~~r:-2147483648),A[u+222188>>2]=s,(0|c)>=(0|(e=e+1|0)););if((0|e)>=8)break f}for(;7!=(0|e)&&(n=b(e,80)+222176|0,r=m[n+48>>3]+m[n+16>>3],m[n+16>>3]=r,s=I(r)<2147483648?~~r:-2147483648,A[n>>2]=s),n=b(e,80)+222176|0,r=m[n+56>>3]+m[n+24>>3],m[n+24>>3]=r,s=I(r)<2147483648?~~r:-2147483648,A[n+4>>2]=(0|s)>0?s:0,8!=(0|(e=e+1|0)););}}else t=A[50767];else A[50826]=218976,A[54742]=0,A[54736]=Le(A[50767]<<4,218976,0),t=A[50767],A[54737]=890/(t>>12),A[54739]=(0|b(A[50781],b(A[50779],t>>8)))/8e4}if(A[55906]=t>>11,A[54735]=A[54736],A[55904]=b(A[50760],t>>7),A[55905]=A[50754]/(t>>12),n=1^(e=A[54742]),A[54742]=n,A[50826]=b(e,1600)+218976,A[54736]=Le(t<<4,b(n,1600)+218976|0,1),!(!(t=A[50759])|!A[51022]))for(C=m[25430],f=m[25429],e=1;A[272+(n=t+(e<<2)|0)>>2]&&(s=A[n+308>>2],n=b(e,40)+203456|0,h=sn(C*+i[2+(b(e,80)+222176|0)>>1]),h*=r=$e(f*+(0|s)),h+=h,m[n+8>>3]=h,r*=-r,m[n+16>>3]=r,m[n>>3]=1-h-r),9!=(0|(e=e+1|0)););}if(l=A[50762]+1|0,A[50762]=l,u=(e=A[50765])+A[55904]|0,A[50765]=u,(0|u)<0&(0|e)>0){if(d=A[55905],t=A[50800]+((0|d)/-2|0)|0,A[55907]=t,(0|(w=A[50763]))<(0|l))break a;if(k=A[54738]+1|0,A[54738]=k,c=A[50767],!((0|(e=(n=A[50980])+1|0))>8)&&(s=c<<3,1&n&&(A[203264+(e<<2)>>2]=(1+(A[b(e,80)+222176>>2]/(0|s)|0)|0)/2,e=n+2|0),7!=(0|n)))for(;n=203264+(e<<2)|0,y=b(e,80)+222176|0,A[n>>2]=(1+(A[y>>2]/(0|s)|0)|0)/2,A[n+4>>2]=(1+(A[y+80>>2]/(0|s)|0)|0)/2,9!=(0|(e=e+2|0)););e=(0|b(A[50781],b(A[50779],c>>8)))/8e4|0,A[54739]=e;h:if(!((0|(n=A[55908]))<=0)){f:switch(n-3|0){case 0:if((w-l|0)>=d<<1)break h;A[55908]=2,e=(0|b(A[55909],e))/256|0,A[54739]=e;break h;case 1:A[55908]=2,e=(0|b(A[55909],e))/256|0,A[54739]=e;break h}A[55908]=n-1}(n=A[55910])&&(s=e,e=A[55911]>>8,e=(0|b(s,o[n+((0|e)>=127?127:e)|0]))/128|0,A[54739]=e),(0|(n=A[A[32972]+92>>2]))>7||(n=15&(s=o[A[55912]+(106336+(n<<3)|0)|0]),(s=s>>>4|0)&&(15!=(0|s)?(0|k)%(0|s)|0||(A[54739]=(0|b(e,n))/16):(A[55912]=0,A[54739]=(0|b(e,n))/16)))}else t=A[55907];if(l=t+1|0,A[55907]=l,n=u>>>16|0,s=0,!((0|l)<0|(0|l)>=A[50799])){if(!((0|(e=(t=A[50980])+1|0))>8)){if(c=1&(u=8-t|0),7!=(0|t))for(d=-2&u,t=0;s=b(A[203216+(w=4+(u=e<<2)|0)>>2],i[106400+(b(n,A[w+203264>>2])>>>4&4094)>>1])+(b(A[u+203216>>2],i[106400+(b(n,A[u+203264>>2])>>>4&4094)>>1])+s|0)|0,e=e+2|0,(0|d)!=(0|(t=t+2|0)););c&&(s=b(A[203216+(e<<=2)>>2],i[106400+(b(n,A[e+203264>>2])>>>4&4094)>>1])+s|0)}s=b(o[l+132160|0],(0|s)/A[55906]|0)}if(e=1,(0|(l=A[54737]))<=0)t=n;else for(u=A[50826],t=n;s=b(A[u+(e<<2)>>2],i[106400+((65504&t)>>>4|0)>>1])+s|0,t=t+n|0,(0|l)>=(0|(e=e+1|0)););if((0|(l=A[54735]))>=(0|e))for(u=A[50826];s=s-b(A[u+(e<<2)>>2],i[106400+((65504&t)>>>4|0)>>1])|0,t=t+n|0,(0|l)>=(0|(e=e+1|0)););if(l=64==(0|(e=A[54728]))?s:b(e,s>>6),A[51022]){if(A[50759])for(n=sr(A[33209],0,1103515245,0),e=K,e=cs(n=n+12345|0,e=n>>>0<12345?e+1|0:e),A[33209]=e,C=+((16383&e)- -8192|0),t=A[50759],u=0,e=1;(s=A[272+(t+(e<<2)|0)>>2])&&(c=A[b(e,80)+222180>>2],n=b(e,40)+203456|0,r=m[n+32>>3],f=m[n+24>>3],m[n+32>>3]=f,r=r*m[n+16>>3]+(m[n>>3]*C+f*m[n+8>>3]),m[n+24>>3]=r,n=I(r)<2147483648?~~r:-2147483648,u=b(n,b(s,c>>14))+u|0),9!=(0|(e=e+1|0)););else u=0;l=l+u|0}t=0,(0|(e=A[50776]))>=A[50773]||(n=A[50778],t=A[50772],(u=A[50774])?(s=e+1|0,A[50776]=s,e=b(u,a[t+(e+n|0)|0])):(u=o[0|(t=t+(e+n|0)|0)],t=a[t+1|0],s=e+2|0,A[50776]=s,e=u|t<<8),t=(0|b(b(e,A[50780])>>10,A[50775]))/32|0,(0|(e=A[50777]))>(n+s|0)||(A[50778]=n+((0|b(e,3))/-4|0))),n=(e=A[51293])+1|0,A[51293]=n,e=((b(A[54739],l>>8)>>13)+t|0)+(b(A[50755],i[205184+(e<<1)>>1])>>8)|0,(0|n)>=5500&&(A[51293]=0),n=A[33073];h:{f:{if((0|(t=b(n,e)))>=8388608){if((0|n)>=(0|(u=8388608/(0|e)|0)))break f;break h}if((0|t)>-8388353)break h;if((0|n)<(0|(u=-8388608/(0|e)|0)))break h}n=u-1|0,A[33073]=n,t=b(e,n)}if(e=A[51290],A[51290]=e+1,n=e,e=t>>8,a[0|n]=e,n=A[51290],A[51290]=n+1,a[0|n]=t>>>16,(n=A[50756])&&(n=A[n+8>>2])&&Ns[0|n](e<<16>>16),t=(n=A[51292])+1|0,A[51292]=t,i[205184+(n<<1)>>1]=e,(0|t)>=5500&&(A[51292]=0),!(p[54046]>=A[51290]+2>>>0))break}s=1;break s}A[50773]=0}A[54731]=A[54729],s=1,c=65535&e,t=o[218920],u=A[n+8>>2],l=A[n+12>>2],r=0,f=0,U=n=U+-64|0,d=A[50759];c:if(6!=(0|(e=A[d+132>>2]))){if(!t){for(e-1>>>0<=4&&(A[55921]=e,A[55964]=A[110896+(e<<2)>>2]),e=A[d+88>>2],A[54741]=1,A[55922]=(0|e)/32,t=A[50758],e=A[50757];;){d:if((0|t)!=(0|(e=(0|(e=e+1|0))<=169?e:0)))if(1!=(0|(w=A[216192+(e<<4)>>2]))){if(w-5>>>0>1)continue}else{if(A[54741]=0,e=A[8+(216192+(e<<4)|0)>>2],!(g[l+4>>1]!=g[e+4>>1]|g[e+6>>1]!=g[l+6>>1]|g[e+8>>1]!=g[l+8>>1]|g[e+10>>1]!=g[l+10>>1])&&g[e+12>>1]==g[l+12>>1])break d;A[54741]=2}break}for((g[u+4>>1]!=g[113564]|g[u+6>>1]!=g[113565]|g[u+8>>1]!=g[113566]|g[u+10>>1]!=g[113567]||g[u+12>>1]!=g[113568])&&(Mr(),A[55974]=0,A[55975]=0,A[55972]=0,A[55973]=0,A[55988]=0,A[55989]=0,A[55990]=0,A[55991]=0,A[56004]=0,A[56005]=0,A[56006]=0,A[56007]=0,A[56020]=0,A[56021]=0,A[56022]=0,A[56023]=0,A[56036]=0,A[56037]=0,A[56038]=0,A[56039]=0,A[56052]=0,A[56053]=0,A[56054]=0,A[56055]=0,A[56068]=0,A[56069]=0,A[56070]=0,A[56071]=0,A[56086]=0,A[56087]=0,A[56084]=0,A[56085]=0,A[56102]=0,A[56103]=0,A[56100]=0,A[56101]=0,A[56118]=0,A[56119]=0,A[56116]=0,A[56117]=0,A[56134]=0,A[56135]=0,A[56132]=0,A[56133]=0,A[56150]=0,A[56151]=0,A[56148]=0,A[56149]=0,A[56166]=0,A[56167]=0,A[56164]=0,A[56165]=0,A[56182]=0,A[56183]=0,A[56180]=0,A[56181]=0,A[56198]=0,A[56199]=0,A[56196]=0,A[56197]=0,A[56214]=0,A[56215]=0,A[56212]=0,A[56213]=0,A[56230]=0,A[56231]=0,A[56228]=0,A[56229]=0),e=g[l+4>>1]|g[l+6>>1]<<16,t=g[l>>1]|g[l+2>>1]<<16,i[113562]=t,i[113563]=t>>>16,i[113564]=e,i[113565]=e>>>16,e=g[l+60>>1]|g[l+62>>1]<<16,t=g[l+56>>1]|g[l+58>>1]<<16,i[113590]=t,i[113591]=t>>>16,i[113592]=e,i[113593]=e>>>16,e=g[l+52>>1]|g[l+54>>1]<<16,t=g[l+48>>1]|g[l+50>>1]<<16,i[113586]=t,i[113587]=t>>>16,i[113588]=e,i[113589]=e>>>16,e=g[l+44>>1]|g[l+46>>1]<<16,t=g[l+40>>1]|g[l+42>>1]<<16,i[113582]=t,i[113583]=t>>>16,i[113584]=e,i[113585]=e>>>16,e=g[l+36>>1]|g[l+38>>1]<<16,t=g[l+32>>1]|g[l+34>>1]<<16,i[113578]=t,i[113579]=t>>>16,i[113580]=e,i[113581]=e>>>16,e=g[l+28>>1]|g[l+30>>1]<<16,t=g[l+24>>1]|g[l+26>>1]<<16,i[113574]=t,i[113575]=t>>>16,i[113576]=e,i[113577]=e>>>16,e=g[l+20>>1]|g[l+22>>1]<<16,t=g[l+16>>1]|g[l+18>>1]<<16,i[113570]=t,i[113571]=t>>>16,i[113572]=e,i[113573]=e>>>16,e=g[l+12>>1]|g[l+14>>1]<<16,t=g[l+8>>1]|g[l+10>>1]<<16,i[113566]=t,i[113567]=t>>>16,i[113568]=e,i[113569]=e>>>16,C=+(0|c),(x=1&i[u>>1])?(e=o[u+39|0],A[56680]=e,m[28364]=e>>>0,m[28354]=+(o[l+39|0]-e<<6)/C,e=o[u+40|0],m[28366]=e>>>0,m[28356]=+(o[l+40|0]-e<<6)/C,e=o[u+41|0],A[56682]=e,m[28368]=e>>>0,m[28358]=+(o[l+41|0]-e<<6)/C,t=o[u+42|0],A[56684]=t,m[28370]=t>>>0,e=o[u+43|0],r=+(o[l+43|0]-e<<6)/C,f=+(o[l+42|0]-t<<6)/C,h=+(e>>>0)):(A[56728]=0,A[56729]=0,e=0,A[56680]=0,A[56708]=0,A[56709]=0,A[56732]=0,A[56733]=0,A[56712]=0,A[56713]=0,A[56682]=0,A[56736]=0,A[56737]=0,A[56716]=0,A[56717]=0,A[56684]=0,A[56740]=0,A[56741]=0,h=0),A[56688]=e,m[28360]=f,m[28372]=h,m[28362]=r,A[56692]=0,A[56748]=0,A[56749]=0,A[56694]=0,A[56752]=0,A[56753]=0,A[56696]=0,A[56756]=0,A[56757]=0,A[56700]=0,A[56760]=0,A[56761]=0,A[56704]=0,A[56764]=0,A[56765]=0,A[50764]=c,e=1;k=i[164+(w=(c=e<<1)+d|0)>>1],t=(D=b(e,80))+222896|0,f=+i[w+218>>1],r=.00390625*+(0|b(k,i[2+(u+c|0)>>1]))+f,m[t+16>>3]=r,y=I(r)<2147483648?~~r:-2147483648,A[t>>2]=y,m[t+48>>3]=64*(.00390625*+(0|b(k,i[2+(l+c|0)>>1]))+f-r)/C,e>>>0<=3&&(t=D+222896|0,r=.00390625*+i[w+200>>1]*+(o[35+(e+u|0)|0]<<1),m[t+24>>3]=r,c=I(r)<2147483648?~~r:-2147483648,A[t+4>>2]=c,m[t+56>>3]=64*(+(o[35+(e+l|0)|0]<<1)-r)/C),6!=(0|(e=e+1|0)););if(r=+((e=o[u+40|0])<<1),m[27864]=r,t=A[56618],e||(r=+(0|t),m[27864]=r),e=I(r)<2147483648?~~r:-2147483648,A[55724]=e,c=o[l+40|0],A[55730]=0,A[55731]=1079394304,A[55738]=0,A[55739]=0,A[55725]=89,e=1,m[27868]=64*(+(0|(c?c<<1:t))-r)/C,x)for(;t=b(e,80)+222896|0,d=o[56+(c=e+u|0)|0]<<2,A[t+12>>2]=d,r=+(0|d),m[t+40>>3]=r,d=e+l|0,m[t+72>>3]=64*(+(o[d+56|0]<<2)-r)/C,c=o[c+49|0],A[t+8>>2]=c,r=+(c>>>0),m[t+32>>3]=r,m[t- -64>>3]=64*(+o[d+49|0]-r)/C,7!=(0|(e=e+1|0)););A[56606]=0}for(;;){if((0|(y=A[50764]))>(0|(l=A[56606]))){for(e=A[50767],A[56609]=A[55724],A[56619]=A[55725],A[56610]=A[55744],A[56611]=A[55764],A[56612]=A[55784],A[56613]=A[55804],x=b(e,10),A[56607]=(0|x)/4096,A[56620]=A[55745],A[56621]=A[55765],A[56622]=A[55785],A[56614]=A[55824],A[56630]=A[55746],A[56631]=A[55766],A[56632]=A[55786],A[56633]=A[55806],A[56634]=A[55826],A[56635]=A[55846],D=A[56680],A[56608]=D,u=A[56694],A[56656]=u,c=A[56696],A[56653]=c,d=A[56700],A[56655]=d,w=A[56684],A[56649]=w,A[56651]=A[56704],A[56654]=A[56688],A[56652]=A[56682],A[56650]=A[56692],e=0;t=b(e,80)+222896|0,r=m[t+48>>3]+m[t+16>>3],m[t+16>>3]=r,C=m[t+56>>3]+m[t+24>>3],m[t+24>>3]=C,f=m[t+72>>3]+m[t+40>>3],m[t+40>>3]=f,h=m[t- -64>>3]+m[t+32>>3],m[t+32>>3]=h,k=I(r)<2147483648?~~r:-2147483648,A[t>>2]=k,k=I(C)<2147483648?~~C:-2147483648,A[t+4>>2]=k,k=I(f)<2147483648?~~f:-2147483648,A[t+12>>2]=k,k=I(h)<2147483648?~~h:-2147483648,A[t+8>>2]=k,9!=(0|(e=e+1|0)););for(r=m[28354]+m[28364],m[28364]=r,m[28366]=m[28356]+m[28366],C=m[28358]+m[28368],m[28368]=C,f=m[28360]+m[28370],m[28370]=f,h=m[28362]+m[28372],m[28372]=h,e=I(r)<2147483648?~~r:-2147483648,A[56680]=e,e=I(C)<2147483648?~~C:-2147483648,A[56682]=e,e=I(f)<2147483648?~~f:-2147483648,A[56684]=e,e=I(h)<2147483648?~~h:-2147483648,A[56688]=e,r=m[28374]+0,m[28374]=r,e=I(r)<2147483648?~~r:-2147483648,A[56692]=e,r=m[28376]+0,m[28376]=r,e=I(r)<2147483648?~~r:-2147483648,A[56694]=e,r=m[28378]+0,m[28378]=r,e=I(r)<2147483648?~~r:-2147483648,A[56696]=e,r=m[28380]+0,m[28380]=r,e=I(r)<2147483648?~~r:-2147483648,A[56700]=e,r=m[28382]+0,m[28382]=r,e=I(r)<2147483648?~~r:-2147483648,A[56704]=e,A[56659]=A[55724],A[56669]=A[55725],A[56660]=A[55744],A[56670]=A[55745],A[56661]=A[55764],A[56671]=A[55765],A[56662]=A[55784],A[56672]=A[55785],A[56663]=A[55804],A[56664]=A[55824],A[56665]=A[55844],e=A[50768]+A[50769]|0,A[50768]=e,e>>=8,A[50767]=A[50770]+(b(A[50771],o[A[50766]+((0|e)>=127?127:e)|0])>>8),e=y-l|0,A[55923]=(0|e)>=64?64:e,A[55961]=(0|x)/40960,e=D-7|0,A[56658]=(0|e)>0?e:0,m[27974]=w>>>0<=87?.001*+i[111136+(w<<1)>>1]*.05:0,m[27975]=c>>>0<=87?.001*+i[111136+(c<<1)>>1]*.25:0,m[27973]=u>>>0<=87?.001*+i[111136+(u<<1)>>1]:0,m[27971]=d>>>0<=87?.001*+i[111136+(d<<1)>>1]*.05:0,r=(e=A[56629])>>>0<=87?.001*+i[111136+(e<<1)>>1]*.6:0,m[n>>3]=r,r=(e=A[56630])>>>0<=87?.001*+i[111136+(e<<1)>>1]*.4:0,m[n+8>>3]=r,r=(e=A[56631])>>>0<=87?.001*+i[111136+(e<<1)>>1]*.15:0,m[n+16>>3]=r,r=(e=A[56632])>>>0<=87?.001*+i[111136+(e<<1)>>1]*.06:0,m[n+24>>3]=r,r=(e=A[56633])>>>0<=87?.001*+i[111136+(e<<1)>>1]*.04:0,m[n+32>>3]=r,r=(e=A[56634])>>>0<=87?.001*+i[111136+(e<<1)>>1]*.022:0,m[n+40>>3]=r,r=(e=A[56635])>>>0<=87?.001*+i[111136+(e<<1)>>1]*.03:0,m[n+48>>3]=r,r=(e=(0|(e=A[56657]-3|0))<=0?57:e)>>>0<=87?.001*+i[111136+(e<<1)>>1]:0,m[27977]=r/+A[55964],C=m[27968],f=m[27967],e=1;t=223664+(l=e<<6)|0,h=(r=$e(f*+A[48+(c=226428+(u=e<<2)|0)>>2]))*-r,m[t+216>>3]=h,r*=sn(C*+A[c+8>>2]),r+=r,m[t+208>>3]=r,B=1-r-h,m[t+200>>3]=B,e>>>0<=5&&(c=A[208+(u=u+226428|0)>>2],t=l+223664|0,E=(v=$e(f*+A[u+248>>2]))*sn(C*+(0|c)),E+=E,m[t+1488>>3]=E,v*=-v,m[t+1496>>3]=v,M=1-E-v,m[t+1480>>3]=M,m[t+256>>3]=.015625*(v-h),m[t+248>>3]=.015625*(E-r),m[t+240>>3]=.015625*(M-B)),10!=(0|(e=e+1|0)););for(v=(r=$e(f*+A[56619]))*-r,m[27985]=v,E=(r*=sn(C*+(0-A[56609]|0)))+r,m[27984]=E,r=1-E-v,m[27983]=r,0!=r&&(r=1/r,m[27983]=r,v*=h=-r,m[27985]=v,E*=h,m[27984]=E),B=(h=$e(f*+A[56669]))*-h,m[28145]=B,M=(h*=sn(C*+(0-A[56659]|0)))+h,m[28144]=M,h=1-M-B,m[28143]=h,0!=h&&(h=1/h,m[28143]=h,B*=N=-h,m[28145]=B,M*=N,m[28144]=M),m[27990]=.015625*(B-v),m[27989]=.015625*(M-E),m[27988]=.015625*(h-r),e=0;u=A[8+(l=226428+(e<<2)|0)>>2],t=223664+(e<<6)|0,h=(r=$e(f*+A[l+128>>2]))*sn(C*+(0|u)),h+=h,m[t+848>>3]=h,r*=-r,m[t+856>>3]=r,m[t+840>>3]=m[n+(e<<3)>>3]*(1-h-r),7!=(0|(e=e+1|0)););if(f=(r=$e(f*+(A[55918]/2|0)))*-r,m[28137]=f,r*=sn(0*C),r+=r,m[28136]=r,m[28135]=1-r-f,e=1,1!=(0|ge()))continue;break c}break}e=1,A[54741]>0&&(A[54741]=0,A[55963]=64,A[56606]=l+-64,A[55923]=64,1==(0|ge()))||(e=0)}else{if(U=w=U-752|0,!t){kt(e=w+376|0,0,376),Xe(d,u,e),Xe(d,l,e=kt(w,0,376)),t=A[50768]+b(A[50769],c>>>6|0)|0,A[50768]=t,t>>=8,t=A[50770]+(b(A[50771],o[A[50766]+((0|t)>=127?127:t)|0])>>8)|0,A[50767]=t,m[e+368>>3]=(0|t)/4096|0,A[50773]&&(m[e+736>>3]=m[e+736>>3]/5,m[e+360>>3]=m[e+360>>3]/5),t=A[A[56797]+4>>2],Ns[A[A[t>>2]>>2]](t,e+376|0,110,110,-1,0),l=c-110|0,d=A[50758],t=A[50757];d:{for(;;){if((0|d)!=(0|(t=(t+1|0)%170|0))&&!((k=A[216192+(t<<4)>>2])-5>>>0<2)){if(u=1,1!=(0|k))continue;break d}break}l=c-220|0,u=0}(0|l)>0&&(t=A[A[56797]+4>>2],Ns[A[A[t>>2]>>2]](t,e,l,l||1,-1,0)),u||(A[e+352>>2]=0,A[e+356>>2]=0,m[e>>3]=m[e+368>>3],t=A[A[56797]+4>>2],Ns[A[A[t>>2]>>2]](t,e,55,55,-1,0),A[e+360>>2]=0,A[e+364>>2]=0,t=A[A[56797]+4>>2],Ns[A[A[t>>2]>>2]](t,e,55,55,-1,0))}e=A[A[56797]+8>>2],t=A[51290],c=0|Ns[A[A[e>>2]>>2]](e,A[54046]-t>>>1|0,t),d=A[51290];d:if(c&&!((0|(t=A[50776]))>=(0|(D=A[50773]))))for(T=A[50777],G=(0|b(T,3))/-4|0,r=.0009765625*+A[50780],k=A[50772],l=A[50778],F=A[50775],y=A[50774],e=0;;){if(x=o[k+(u=t+l|0)|0],y?x=b(y,x<<24>>24):(t=t+1|0,A[50776]=t,x|=a[k+(u=t+l|0)|0]<<8),x=I(C=r*+(0|x))<2147483648?~~C:-2147483648,i[(S=d+(e<<1)|0)>>1]=g[S>>1]+((0|b(x,F))/40|0),(0|u)>=(0|T)&&(l=l+G|0,A[50778]=l),t=t+1|0,A[50776]=t,(0|t)>=(0|D))break d;if(!(c>>>0>(e=e+1|0)>>>0))break}e=d+(c<<1)|0,A[51290]=e,U=w+752|0,e=p[54046]<=e>>>0}if(U=n- -64|0,e)break s;break a}A[50781]=e||100;break a}Ue(e,A[n+8>>2]);break a}e=A[n+8>>2],A[50759]=Je(203816,e,1344),A[50801]=A[e+108>>2]?105792:106064,e=(0|b(A[e+120>>2],26))/100|0,A[33038]=e,(0|(s=A[50754]))<=11e3&&(a[203300]=1,A[33038]=e<<1),A[54728]=A[50982],e=A[50979],t=A[50978],kt(205184,0,11e3),A[51293]=0,e=(t=(u=(0|(l=A[50789]))>0)?130:(0|t)>=5499?5499:t)?u?l:(0|e)>=100?100:e:0,A[50755]=e,t=(0|b(t,s))/1e3|0,A[51292]=t,A[54729]=(0|e)>20?t<<1:e?t:0,A[33037]=(0|b(500-e|0,(0|b(o[A[50797]+105596|0],(0|b(A[50787],55))/100|0))/16|0))/500,e=256,(0|(t=(0|(t=A[50785]))>=101?101:t))>=51&&(e=256+(((b(t,25)-1250&65535)>>>0)/50|0)|0),i[101990]=(0|b(i[102026],e))/256,i[101991]=(0|b(i[102027],e))/256,i[101992]=(0|b(i[102028],e))/256,i[101993]=(0|b(i[102029],e))/256,i[101994]=(0|b(i[102030],e))/256,i[101995]=(0|b(i[102031],e))/256,e=A[50790],i[101999]=(0|b(i[102035],b(e,-6)+256|0))/256,i[102e3]=(0|b(i[102036],b(e,-3)+256|0))/256,Rt(8,0,A[50986],0,A[51290]),Ee(A[n+8>>2]);break a}if(!A[50759])break a;t=A[n+12>>2],n=A[n+8>>2],A[55911]=0,A[55915]=e?2097152/(0|e)|0:0,A[55910]=n,e=(0|b(t,A[33037]))/16|0,A[50779]=e,A[50780]=(0|b(b(e,A[50985]),15))/100;break a}Rt(t>>8,e,A[n+8>>2],A[n+12>>2],u)}s=0,e=A[50757]+1|0,A[50757]=(0|e)<=169?e:0}if(a[218920]=s,!((u=A[51290])>>>0<p[54046]))break}l=A[34391],n=(A[51290]-l|0)/2|0,A[34439]=n+A[34439],t=A[34436],e=A[34388]+b(t,36)|0,A[e+4>>2]=0,A[e>>2]=0,A[e+24>>2]=A[34438];r:if(2&(e=A[32538])){if(u=A[34388],2==(-2&e)&&(!(n=t?u:0)|8!=A[n>>2]||(0|(n=A[n+28>>2]))!=A[34389]&&(A[34389]=n)),s=1,(0|t)<2)break r;for(;;){n=t?u+b(s,36)|0:0;s:{a:switch(0|e){case 2:case 3:if(!n|8!=A[n>>2])break s;if((0|(n=A[n+28>>2]))==A[34389])break s;A[34389]=n;break s;case 0:break a;default:break s}(e=A[34440])?(Ns[0|e](l,0,n),t=A[34436],e=A[32538]):e=0}if(!((0|(s=s+1|0))<(0|t)))break}}else if((e=A[34440])&&0|Ns[0|e](l,n,A[34388]))break n;if(!$(1)&&!(170-((0|(e=A[50757]-A[50758]|0))<=0?e+170|0:e)|0||(e=A[34388],A[e>>2]=0,A[e+4>>2]=A[34437],A[e+24>>2]=A[34438],X(1))))break}if(t=0,2&o[130152])break t;if(!(e=A[34440]))break t;if(!(0|Ns[0|e](0,0,A[34388])))break t}X(2),t=268439295}if((0|t)<=268437502){if(!t|268436479==(0|t)|268437247!=(0|t))break e;return}}}function $(e){var t,n=0,r=0,s=0,l=0,u=0,c=0,d=0,h=0,f=0,p=0,m=0,b=0,C=0,I=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0;U=t=U-720|0,n=A[47198],e||(A[36443]=0,A[36442]=1,A[36444]=0,A[36440]=0,A[36441]=0,e=A[50758],A[36454]=e,A[36427]=-1,A[36424]=-1,A[36446]=0,A[36447]=0,A[36439]=-1,A[36426]=0,A[36455]=e,A[36448]=0,A[36449]=0,A[36450]=0,A[36451]=0,A[36452]=0,A[36453]=0,he(),A[36427]=-1,e=216192+(A[50758]<<4)|0,A[e>>2]=5,A[e+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,A[36426]=0,A[36438]&&(A[36438]=0,e=216192+(A[50758]<<4)|0,A[e>>2]=14,A[e+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0));e:{t:if(!((0|(e=A[36442]))>997|A[36423]<=(0|e)))for(C=n>>>1&1,I=t+48|4,w=t+348|0,k=t+652|0,x=A[32322],p=A[32320],y=t+60|0,v=t+648|0,E=t+56|0,B=t+620|0,m=t- -64|0;;){if(r=145840+(e<<5)|0,!(e=A[50756])|!A[e>>2]||(A[t+12>>2]=0,st(e=t+16|0,A[r+8>>2],r,0,t+12|0),n=$r(e),s=o[r+17|0],e=216192+(A[50758]<<4)|0,A[e>>2]=16,A[e+8>>2]=s,A[e+4>>2]=n,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0),e=1,(0|(s=(0|(n=A[50757]-A[50758]|0))<=0?n+170|0:n))<=(0|((n=o[r+17|0])?2==(0|n)?25:15:10)))break e;if(h=A[36442],2&o[0|r])for(f=2047&g[r+4>>1];;){if(s=A[36443],c=127&(n=A[198304+(s<<2)>>2])){e=n>>>8|0,A[36443]=s+1;n:{r:{s:switch((31&n)-2|0){case 0:Ue(96&n|8,e),Ke(2);break n;case 5:if((0|e)>=A[34064])break n;if(!A[4+(c=136272+(s=e<<4)|0)>>2])break n;Dt(10,0),e=216192+(A[50758]<<4)|0,A[e>>2]=6,c=A[c+4>>2],A[e+8>>2]=A[8+(s+136272|0)>>2]+44,A[e+12>>2]=5376,A[e+4>>2]=c;break r;case 8:if((0|((0|(s=A[50757]-A[50758]|0))<=0?s+170:s))<6)break n;c=A[47353],s=216192+(A[50758]<<4)|0,A[s>>2]=778,A[s+8>>2]=e,A[s+4>>2]=c+f&16777215;break r;case 9:if((0|((0|(s=A[50757]-A[50758]|0))<=0?s+170:s))<6)break n;c=A[33284],s=216192+(A[50758]<<4)|0,A[s>>2]=1034,A[s+8>>2]=e,A[s+4>>2]=c+1&16777215;break r}Dt(10,0),s=216192+(A[50758]<<4)|0,A[s>>2]=12,A[s+8>>2]=e,A[s+4>>2]=c}e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0}if(!(128&n))continue}break}(e=o[r+20|0])&&(1&a[A[47192]+48|0]&2==o[r+17|0]|1&a[A[r+8>>2]+7|0]||(A[36426]=0),n=A[47353]+(2047&g[r+4>>1])|0,A[36445]=n,4&e&&((0|((0|(e=A[50757]-A[50758]|0))<=0?e+170:e))<6||(s=A[47568],e=216192+(A[50758]<<4)|0,A[e>>2]=522,A[e+8>>2]=s,A[e+4>>2]=16777215&n,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0)),1&a[r+20|0]&&(n=g[r+4>>1],s=A[36444],A[36444]=s+1,(0|((0|(e=A[50757]-A[50758]|0))<=0?e+170:e))<6||(f=A[36445],c=A[47355],e=216192+(A[50758]<<4)|0,A[e>>2]=266,A[e+8>>2]=s+c,A[e+4>>2]=16777215&f|(63488&n)<<13,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0))),(0|(e=A[36441]))>0&&(n=216192+(A[36425]<<4)|0,A[n+4>>2]||(A[n+4>>2]=e),A[36441]=0),e=h+1<<5,n=h-1<<5,!(s=o[r+18|0])|2&o[A[r+8>>2]+7|0]||Dt(s,1),c=e+145840|0,l=n+145840|0,f=1;n:{r:{if(A[47198]&&(d=A[r+8>>2],15!=o[d+10|0])){s:if(2==o[r+17|0])switch(o[l+17|0]-3|0){case 0:case 5:break r;default:break s}f=0,st(t+704|0,d,r,C,0),(0|((0|(e=A[50757]-A[50758]|0))<=0?e+170:e))<6||(n=A[36445],e=216192+(A[50758]<<4)|0,A[e>>2]=1802,A[e+4>>2]=16777215&n,n=A[t+708>>2],A[e+8>>2]=A[t+704>>2],A[e+12>>2]=n,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0)}s:switch(o[r+17|0]){case 0:Dt(A[r+12>>2],0),a[r+23|0]=o[A[r+8>>2]+14|0];break n;case 4:n=A[r+8>>2],2==(0|(e=o[c+17|0]))|!o[c+20|0]&3==(0|e)||(i[r>>1]=8192|g[r>>1]),2&o[n+7|0]&&(A[t+88>>2]=0,A[t+92>>2]=0,A[t+80>>2]=0,A[t+84>>2]=0,A[t+72>>2]=0,A[t+76>>2]=0,A[m>>2]=0,A[m+4>>2]=0,A[t+56>>2]=0,A[t+60>>2]=0,A[t+48>>2]=0,A[t+52>>2]=0,le(0,1,r,t+552|0,145784),A[t+56>>2]=A[t+620>>2],A[m>>2]=A[t+640>>2],A[36424]<0&&(s=o[c+19|0],e=A[50758],A[36425]=e,A[36441]=0,A[12+(e=216192+(e<<4)|0)>>2]=s,A[e+8>>2]=0,A[e>>2]=8,A[e+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,f=o[c+22|0],s=o[c+21|0],c=A[129280+(o[r+16|0]<<2)>>2],(0|(e=A[36424]))<0|(0|(d=A[36440]))<=0||A[4+(e=216192+(e<<4)|0)>>2]||(A[e+4>>2]=d),e=A[50758],A[36424]=e,A[36440]=0,A[(e=216192+(e<<4)|0)>>2]=9,A[e+4>>2]=0,f|=s<<16,s=255==(0|s),A[e+12>>2]=s?3604556:f,A[e+8>>2]=s?p:c,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0),te(n,0,t+48|0,r,0)),le(0,0,r,t+552|0,145784),A[t+552>>2]=4|A[t+552>>2],(0|(e=A[36440]))<=0||(0|(n=A[36424]))<0||(A[4+(n=216192+(n<<4)|0)>>2]||(A[n+4>>2]=e),A[36440]=0),A[36426]=0,A[36439]=-1,A[36455]=A[50758],he(),A[36427]=-1,A[36422]=0,(e=A[t+624>>2])&&(s=e,e=A[t+644>>2],Ze(s,2,A[t+596>>2]<<1,A[t+552>>2],0,e?(e<<5)/100|0:32)),A[36426]=0;break n;case 6:le(0,0,r,t+552|0,145784),8&o[0|r]&&(e=A[r+12>>2],(0|(n=A[36440]))<=0||(0|(s=A[36424]))<0||(A[4+(s=216192+(s<<4)|0)>>2]||(A[s+4>>2]=n),A[36440]=0),A[36426]=0,A[36439]=-1,A[36455]=A[50758],he(),A[36427]=-1,A[36422]=0,(n=A[t+624>>2])&&(s=e,e=A[t+644>>2],Ze(n,2,A[t+596>>2]<<1,A[t+552>>2],s,e?(e<<5)/100|0:32))),e=A[r+12>>2],(0|(n=A[36440]))<=0||(0|(s=A[36424]))<0||(A[4+(s=216192+(s<<4)|0)>>2]||(A[s+4>>2]=n),A[36440]=0),A[36426]=0,A[36439]=-1,A[36455]=A[50758],he(),A[36427]=-1,A[36422]=0,(n=A[t+624>>2])&&(s=e,e=A[t+644>>2],Ze(n,2,A[t+596>>2]<<1,A[t+552>>2],s,e?(e<<5)/100|0:32)),A[36426]=0;break n;case 5:s=A[r+8>>2],A[I+40>>2]=0,A[(e=I)+32>>2]=0,A[e+36>>2]=0,A[e+24>>2]=0,A[e+28>>2]=0,A[e+16>>2]=0,A[e+20>>2]=0,A[e+8>>2]=0,A[e+12>>2]=0,A[e>>2]=0,A[e+4>>2]=0,A[t+48>>2]=4;a:{i:{A:{o:switch(o[c+17|0]-2|0){case 0:n=o[r+19|0],e=A[50758],A[36425]=e,A[36441]=0,A[12+(e=216192+(e<<4)|0)>>2]=n,A[e+8>>2]=0,A[e>>2]=8,A[e+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,n=o[r+22|0],d=o[r+21|0],f=A[129280+(o[r+16|0]<<2)>>2],(0|(e=A[36424]))<0|(0|(u=A[36440]))<=0||A[4+(e=216192+(e<<4)|0)>>2]||(A[e+4>>2]=u),e=(u=!(255&~d))?p:f,f=1;break i;case 1:break o;default:break A}if(!o[c+20|0]){n=o[c+19|0],e=A[50758],A[36425]=e,A[36441]=0,A[12+(e=216192+(e<<4)|0)>>2]=n,A[e+8>>2]=0,A[e>>2]=8,A[e+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,n=o[c+22|0],d=o[c+21|0],f=A[129280+(o[c+16|0]<<2)>>2],(0|(e=A[36424]))<0|(0|(u=A[36440]))<=0||A[4+(e=216192+(e<<4)|0)>>2]||(A[e+4>>2]=u),e=(u=!(255&~d))?p:f,f=1;break i}}if(f=0,A[36424]>=0)break a;n=o[c+19|0],e=A[50758],A[36425]=e,A[36441]=0,A[12+(e=216192+(e<<4)|0)>>2]=n,A[e+8>>2]=0,A[e>>2]=8,A[e+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,n=o[r+22|0],d=o[r+21|0],f=A[129280+(o[r+16|0]<<2)>>2],(0|(e=A[36424]))<0|(0|(u=A[36440]))<=0||A[4+(e=216192+(e<<4)|0)>>2]||(A[e+4>>2]=u),e=(u=!(255&~d))?p:f,f=0}b=A[50758],A[36424]=b,A[36440]=0,A[(b=216192+(b<<4)|0)>>2]=9,A[b+4>>2]=0,A[b+12>>2]=u?3604556:255&n|(255&d)<<16,A[b+8>>2]=e,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0}a:if(!(2&o[s+7|0])&2!=o[l+17|0])8&o[0|r]&&Dt(50,0);else{if(le(0,1,r,t+552|0,145784),A[t+56>>2]=A[t+620>>2],A[t+64>>2]=A[t+640>>2],te(s,0,t+48|0,r,0),!(8&o[0|r]))break a;Dt(25,1),te(s,0,t+48|0,r,0)}a:if(f){if(A[36455]!=A[36454])break a;A[36455]=A[50758]}else i[r>>1]=8192|g[r>>1];if(le(0,0,r,t+552|0,145784),A[t+56>>2]=A[t+620>>2],A[t+64>>2]=A[t+640>>2],A[t+76>>2]=A[t+636>>2],A[t+80>>2]=A[t+656>>2],te(s,0,t+48|0,r,0),o[r+20|0]|o[84+(145840+(h<<5)|0)|0])break n;if(7==(0|(e=o[c+17|0]))&&(Dt(20,0),e=o[c+17|0]),6!=(255&e))break n;Dt(12,0);break n;case 7:a:{i:{A:{o:{l:switch((e=o[c+17|0])-2|0){case 1:break o;case 0:break l;default:break A}n=o[r+19|0],e=A[50758],A[36425]=e,A[36441]=0,A[12+(e=216192+(e<<4)|0)>>2]=n,A[e+8>>2]=0,A[e>>2]=8,A[e+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,f=o[r+22|0],e=o[r+21|0],s=A[129280+(o[r+16|0]<<2)>>2],(0|(n=A[36424]))<0|(0|(d=A[36440]))<=0||A[4+(n=216192+(n<<4)|0)>>2]||(A[n+4>>2]=d),n=(d=!(255&~e))?p:s;break i}n=o[c+19|0],e=A[50758],A[36425]=e,A[36441]=0,A[12+(e=216192+(e<<4)|0)>>2]=n,A[e+8>>2]=0,A[e>>2]=8,A[e+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,f=o[c+22|0],e=o[c+21|0],s=A[129280+(o[c+16|0]<<2)>>2],(0|(n=A[36424]))<0|(0|(d=A[36440]))<=0||A[4+(n=216192+(n<<4)|0)>>2]||(A[n+4>>2]=d),n=(d=!(255&~e))?p:s;break i}if(A[36424]>=0)break a;n=o[r+19|0],e=A[50758],A[36425]=e,A[36441]=0,A[12+(e=216192+(e<<4)|0)>>2]=n,A[e+8>>2]=0,A[e>>2]=8,A[e+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,f=o[r+22|0],e=o[r+21|0],s=A[129280+(o[r+16|0]<<2)>>2],(0|(n=A[36424]))<0|(0|(d=A[36440]))<=0||A[4+(n=216192+(n<<4)|0)>>2]||(A[n+4>>2]=d),n=(d=!(255&~e))?p:s}s=A[50758],A[36424]=s,A[36440]=0,A[(s=216192+(s<<4)|0)>>2]=9,A[s+4>>2]=0,A[s+12>>2]=d?3604556:(255&e)<<16|f,A[s+8>>2]=n,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,e=o[c+17|0]}a:{i:{A:switch((255&e)-2|0){case 1:if(o[c+20|0])break i;break;case 0:break A;default:break i}if(A[36455]!=A[36454])break a;A[36455]=A[50758];break a}i[r>>1]=8192|g[r>>1]}le(0,0,r,t+552|0,145784),A[t+56>>2]=0,A[t+60>>2]=0,A[m>>2]=0,A[m+4>>2]=0,A[t+80>>2]=0,A[t+84>>2]=0,A[t+72>>2]=0,A[t+76>>2]=0,A[t+88>>2]=0,A[t+56>>2]=A[t+620>>2],A[m>>2]=A[t+640>>2],A[t+80>>2]=A[t+656>>2],A[t+48>>2]=0,A[t+52>>2]=0,A[t+76>>2]=A[t+636>>2],A[t+92>>2]=A[t+596>>2]<<1,8&o[0|r]&&te(A[r+8>>2],0,t+48|0,r,0),te(A[r+8>>2],0,t+48|0,r,0);break n;case 8:if(A[t+88>>2]=0,A[t+92>>2]=0,A[t+80>>2]=0,A[t+84>>2]=0,A[t+72>>2]=0,A[t+76>>2]=0,A[m>>2]=0,A[m+4>>2]=0,A[t+56>>2]=0,A[t+60>>2]=0,A[t+48>>2]=0,A[t+52>>2]=0,1&a[0|r]||(n=o[r+19|0],e=A[50758],A[36425]=e,A[36441]=0,A[12+(e=216192+(e<<4)|0)>>2]=n,A[e+8>>2]=0,A[e>>2]=8,A[e+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,s=o[r+22|0],n=o[r+21|0],f=A[129280+(o[r+16|0]<<2)>>2],(0|(e=A[36424]))<0|(0|(d=A[36440]))<=0||A[4+(e=216192+(e<<4)|0)>>2]||(A[e+4>>2]=d),e=A[50758],A[36424]=e,A[36440]=0,A[(e=216192+(e<<4)|0)>>2]=9,A[e+4>>2]=0,s|=n<<16,n=255==(0|n),A[e+12>>2]=n?3604556:s,A[e+8>>2]=n?p:f,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0),8==o[l+17|0]&&(A[36426]=0),le(0,0,r,t+552|0,145784),A[t+56>>2]=A[t+620>>2],A[t+64>>2]=A[t+640>>2],A[t+92>>2]=A[t+596>>2]<<1,2==o[c+17|0]){A[36455]==A[36454]&&(A[36455]=A[50758]),te(A[r+8>>2],0,t+48|0,r,0);break n}if(!(!(1&a[0|r])|2!=o[l+17|0])){te(A[r+8>>2],0,t+48|0,r,0);break n}A[36426]=0,te(A[r+8>>2],0,t+48|0,r,0),A[36426]=0;break n;case 3:A[t+88>>2]=0,A[t+92>>2]=0,A[t+80>>2]=0,A[t+84>>2]=0,A[t+72>>2]=0,A[t+76>>2]=0,A[m>>2]=0,A[m+4>>2]=0,A[t+56>>2]=0,A[t+60>>2]=0,A[t+48>>2]=0,A[t+52>>2]=0,s=A[A[r+8>>2]+4>>2],1&a[0|r]||(n=o[r+19|0],e=A[50758],A[36425]=e,A[36441]=0,A[12+(e=216192+(e<<4)|0)>>2]=n,A[e+8>>2]=0,A[e>>2]=8,A[e+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,f=o[r+22|0],n=o[r+21|0],d=A[129280+(o[r+16|0]<<2)>>2],(0|(e=A[36424]))<0|(0|(u=A[36440]))<=0||A[4+(e=216192+(e<<4)|0)>>2]||(A[e+4>>2]=u),e=A[50758],A[36424]=e,A[36440]=0,A[(e=216192+(e<<4)|0)>>2]=9,A[e+4>>2]=0,f|=n<<16,n=255==(0|n),A[e+12>>2]=n?3604556:f,A[e+8>>2]=n?p:d,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0),8==o[l+17|0]&&(A[36426]=0),2!=o[c+17|0]|A[36455]!=A[36454]||(A[36455]=A[50758]),le(0,0,r,t+552|0,145784),(0|(e=A[t+584>>2]-o[r+18|0]|0))>0&&Dt(e,1),A[t+56>>2]=A[t+620>>2],A[t+64>>2]=A[t+640>>2],A[t+76>>2]=A[t+636>>2],A[t+80>>2]=A[t+656>>2],A[t+92>>2]=A[t+596>>2]<<1,te(A[r+8>>2],0,t+48|0,r,s<<24>>31&5);break n;case 2:break s;default:break n}d=A[r+8>>2]}h=o[r+3|0],A[t+88>>2]=0,A[t+92>>2]=0,A[t+80>>2]=0,A[t+84>>2]=0,A[t+72>>2]=0,A[t+76>>2]=0,A[m>>2]=0,A[m+4>>2]=0,A[t+56>>2]=0,A[t+60>>2]=0,A[t+48>>2]=0,A[t+52>>2]=0,le(0,0,r,t+552|0,145784),e=A[t+628>>2],A[t+56>>2]=e,A[t+92>>2]=A[t+596>>2]<<1;r:{if(!e||(u=0,s=v,n=y,2&o[t+552|0])){if(o[l+17|0]?(u=0,le(0,0,l,t+400|0,0),e=A[t+476>>2],A[t+56>>2]=e,!e|!(2&o[t+400|0])||(A[t+72>>2]=A[t+496>>2],u=1),n=A[t+512>>2],A[t+84>>2]=A[t+508>>2],A[t+88>>2]=n):u=0,e)break r;A[t+48>>2]=1,A[t+52>>2]=1,s=B,n=E}A[n>>2]=A[s>>2]}A[t+64>>2]=A[t+640>>2],n=o[r+16|0],e=0,(s=o[r+7|0])?(Jn(s,t+96|0),n=Jr(A[t+220>>2]),(0|(s=A[t+224>>2]))<=0||(e=Jr(s))):n=A[129280+(n<<2)>>2],A[36455]==A[36454]&&(A[36455]=A[50758]),s=(s=15&h)>>>0<2?1:s>>>0>6?3:2;r:{s:switch(o[l+17|0]-3|0){case 2:case 4:u=o[r+19|0],l=A[50758],A[36425]=l,A[36441]=0,A[12+(l=216192+(l<<4)|0)>>2]=u,A[l+8>>2]=e,A[l>>2]=8,A[l+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,u=o[r+22|0],l=o[r+21|0],(0|(e=A[36440]))<=0||(0|(h=A[36424]))<0||A[4+(h=216192+(h<<4)|0)>>2]||(A[h+4>>2]=e),e=A[50758],A[36424]=e,A[36440]=0,A[(e=216192+(e<<4)|0)>>2]=9,A[e+4>>2]=0,u|=l<<16,l=255==(0|l),A[e+12>>2]=l?3604556:u,A[e+8>>2]=l?p:n,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,te(d,1,t+48|0,r,s);break r;case 0:case 5:u=o[r+19|0],l=A[50758],A[36425]=l,A[36441]=0,A[12+(l=216192+(l<<4)|0)>>2]=u,A[l+8>>2]=e,A[l>>2]=8,A[l+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,te(d,1,t+48|0,r,s),u=o[r+22|0],l=o[r+21|0],(0|(e=A[36440]))<=0||(0|(h=A[36424]))<0||A[4+(h=216192+(h<<4)|0)>>2]||(A[h+4>>2]=e),e=A[50758],A[36424]=e,A[36440]=0,A[(e=216192+(e<<4)|0)>>2]=9,A[e+4>>2]=0,u|=l<<16,l=255==(0|l),A[e+12>>2]=l?3604556:u,A[e+8>>2]=l?p:n,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0;break r}u?(u=o[r+22|0],(0|(l=A[36440]))<=0||(0|(h=A[36424]))<0||A[4+(h=216192+(h<<4)|0)>>2]||(A[h+4>>2]=l),l=A[50758],A[36424]=l,A[36440]=0,A[(l=216192+(l<<4)|0)>>2]=9,A[l+4>>2]=0,A[l+12>>2]=(u|u<<16)-983040,A[l+8>>2]=x,l=A[50758]+1|0,A[50758]=(0|l)<=169?l:0,u=o[r+19|0],l=A[50758],A[36425]=l,A[36441]=0,A[(l=216192+(l<<4)|0)>>2]=8,A[l+4>>2]=0,A[l+12>>2]=u-1,A[l+8>>2]=e,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,te(d,1,t+48|0,r,s),l=o[r+21|0],u=o[r+22|0],(0|(e=A[36440]))<=0||(0|(h=A[36424]))<0||A[4+(h=216192+(h<<4)|0)>>2]||(A[h+4>>2]=e),e=A[50758],A[36424]=e,A[36440]=0,A[(e=216192+(e<<4)|0)>>2]=9,A[e+4>>2]=0,u|=l<<16,l=255==(0|l),A[e+12>>2]=l?3604556:u,A[e+8>>2]=l?p:n,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0):(1&a[0|r]||(u=o[r+19|0],l=A[50758],A[36425]=l,A[36441]=0,A[12+(l=216192+(l<<4)|0)>>2]=u,A[l+8>>2]=e,A[l>>2]=8,A[l+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,u=o[r+22|0],l=o[r+21|0],(0|(e=A[36440]))<=0||(0|(h=A[36424]))<0||A[4+(h=216192+(h<<4)|0)>>2]||(A[h+4>>2]=e),e=A[50758],A[36424]=e,A[36440]=0,A[(e=216192+(e<<4)|0)>>2]=9,A[e+4>>2]=0,u|=l<<16,l=255==(0|l),A[e+12>>2]=l?3604556:u,A[e+8>>2]=l?p:n,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0),te(d,1,t+48|0,r,s))}!A[47198]|1^f||(st(t+704|0,A[r+8>>2],r,C,0),(0|((0|(e=A[50757]-A[50758]|0))<=0?e+170:e))<6||(n=A[36445],e=216192+(A[50758]<<4)|0,A[e>>2]=1802,A[e+4>>2]=16777215&n,n=A[t+708>>2],A[e+8>>2]=A[t+704>>2],A[e+12>>2]=n,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0)),A[t+56>>2]=A[t+620>>2],A[t+84>>2]=0,A[t+88>>2]=0,A[t+64>>2]=A[t+640>>2],n=A[t+632>>2],A[t+68>>2]=n,e=k;r:{if(!n){if(!o[c+17|0])break r;if(A[t+72>>2]=0,le(0,0,c,t+248|0,0),A[t+52>>2]=1,e=A[t+368>>2],A[t+84>>2]=A[t+364>>2],A[t+88>>2]=e,n=A[t+328>>2],A[t+68>>2]=n,e=w,!n)break r}A[t+72>>2]=A[e>>2]}te(d,2,t+48|0,r,s)}if(e=A[36442]+1|0,A[36442]=e,(0|e)>997)break t;if(!(A[36423]>(0|e)))break}(0|(e=A[36440]))<=0||(0|(n=A[36424]))<0||(A[4+(n=216192+(n<<4)|0)>>2]||(A[n+4>>2]=e),A[36440]=0),A[36426]=0,A[36439]=-1,A[36455]=A[50758],he(),A[36427]=-1,e=0,A[36423]<=0||(n=A[47568],s=A[33284],(0|((0|(e=A[50757]-A[50758]|0))<=0?e+170:e))>=6&&(e=216192+(A[50758]<<4)|0,A[e>>2]=1290,A[e+8>>2]=n,A[e+4>>2]=16777215&s,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0),A[36423]=0,e=0)}return U=t+720|0,e}function ee(e,t,n,r){var s,i=0,u=0,c=0,d=0,h=0,g=0,m=0,I=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0,N=0,G=0,F=0,P=0,Q=0,z=0,O=0;U=s=U-48|0;e:{if(n>>>0<=2){for(F=A[124732+(n<<=2)>>2],P=A[n+124720>>2];(0|(n=A[t+4>>2]))==A[t+104>>2]?n=pt(t):(A[t+4>>2]=n+1,n=o[0|n]),32==(0|n)|n-9>>>0<5;);k=1;t:{n:switch(n-43|0){case 0:case 2:break n;default:break t}k=45==(0|n)?-1:1,(0|(n=A[t+4>>2]))==A[t+104>>2]?n=pt(t):(A[t+4>>2]=n+1,n=o[0|n])}t:{n:{for(;;){if(a[c+84056|0]==(32|n)){if(c>>>0>6||((0|(n=A[t+4>>2]))==A[t+104>>2]?n=pt(t):(A[t+4>>2]=n+1,n=o[0|n])),8!=(0|(c=c+1|0)))continue;break n}break}if(3!=(0|c)){if(8==(0|c))break n;if(!r|c>>>0<4)break t;if(8==(0|c))break n}if((0|(n=A[t+116>>2]))>0|(0|n)>=0&&(A[t+4>>2]=A[t+4>>2]-1),!(!r|c>>>0<4))for(n=(0|n)<0;n||(A[t+4>>2]=A[t+4>>2]-1),(c=c-1|0)>>>0>3;);}U=m=U-16|0,f(C(C(0|k)*C(1/0))),(t=2147483647&(d=l(2)))-8388608>>>0<=2130706431?(n=t,n<<=25,r=1065353216+(t=t>>>7|0)|0):(n=d<<25,r=d>>>7|2147418112,t>>>0>=2139095040||(n=0,r=0,t&&(Ut(m,n=t,0,0,0,(t=w(t))+81|0),g=A[m>>2],h=A[m+4>>2],n=A[m+8>>2],r=65536^A[m+12>>2]|16265-t<<16))),A[s>>2]=g,A[s+4>>2]=h,A[s+8>>2]=n,A[s+12>>2]=-2147483648&d|r,U=m+16|0,g=A[s+8>>2],h=A[s+12>>2],d=A[s>>2],I=A[s+4>>2];break e}t:{n:{r:if(!c){for(c=0;;){if(a[c+84473|0]!=(32|n))break r;if(c>>>0>1||((0|(n=A[t+4>>2]))==A[t+104>>2]?n=pt(t):(A[t+4>>2]=n+1,n=o[0|n])),3==(0|(c=c+1|0)))break}break n}r:switch(0|c){case 0:if(48==(0|n)){if((0|(c=A[t+4>>2]))==A[t+104>>2]?c=pt(t):(A[t+4>>2]=c+1,c=o[0|c]),88==(-33&c)){U=u=U-432|0,(0|(n=A[t+4>>2]))==A[t+104>>2]?c=pt(t):(A[t+4>>2]=n+1,c=o[0|n]);s:{a:{for(;;){if(48!=(0|c)){if(46!=(0|c))break s;if((0|(n=A[t+4>>2]))!=A[t+104>>2]){A[t+4>>2]=n+1,c=o[0|n];break a}break}(0|(n=A[t+4>>2]))!=A[t+104>>2]?(G=1,A[t+4>>2]=n+1,c=o[0|n]):(G=1,c=pt(t))}c=pt(t)}if(v=1,48==(0|c)){for(;E=(n=E)-1|0,B=B-!n|0,(0|(n=A[t+4>>2]))==A[t+104>>2]?c=pt(t):(A[t+4>>2]=n+1,c=o[0|n]),48==(0|c););G=1}}for(I=1073676288;;){s:{n=32|c;a:{if(!((Q=c-48|0)>>>0<10)){if(46!=(0|c)&n-97>>>0>=6)break s;if(46==(0|c)){if(v)break s;v=1,E=g,B=h;break a}}n=(0|c)>57?n-87|0:Q,(0|h)<=0&g>>>0<=7|(0|h)<0?i=n+(i<<4)|0:!h&g>>>0<=28?(Nn(u+48|0,n),me(u+32|0,S,N,d,I,0,0,0,1073414144),S=A[u+32>>2],N=A[u+36>>2],d=A[u+40>>2],I=A[u+44>>2],me(u+16|0,A[u+48>>2],A[u+52>>2],A[u+56>>2],A[u+60>>2],S,N,d,I),ve(u,A[u+16>>2],A[u+20>>2],A[u+24>>2],A[u+28>>2],m,y,D,T),D=A[u+8>>2],T=A[u+12>>2],m=A[u>>2],y=A[u+4>>2]):x|!n||(me(u+80|0,S,N,d,I,0,0,0,1073610752),ve(u- -64|0,A[u+80>>2],A[u+84>>2],A[u+88>>2],A[u+92>>2],m,y,D,T),D=A[u+72>>2],T=A[u+76>>2],x=1,m=A[u+64>>2],y=A[u+68>>2]),h=(g=g+1|0)?h:h+1|0,G=1}(0|(n=A[t+4>>2]))!=A[t+104>>2]?(A[t+4>>2]=n+1,c=o[0|n]):c=pt(t);continue}break}s:if(G){if((0|h)<=0&g>>>0<=7|(0|h)<0)for(d=g,I=h;i<<=4,8!=(0|(d=d+1|0))|(I=d?I:I+1|0););a:{i:{A:{if(80==(-33&c)){if(d=Ye(t,r),I=n=K,d|-2147483648!=(0|n))break a;if(r){if((0|(n=A[t+116>>2]))>0|(0|n)>=0)break A;break i}m=0,y=0,Un(t,0,0),n=0,t=0;break s}if(d=0,I=0,A[t+116>>2]<0)break a}A[t+4>>2]=A[t+4>>2]-1}d=0,I=0}if(i)if(n=d+((t=v?E:g)<<2)|0,t=(h=(v?B:h)<<2|t>>>30)+I|0,(g=n-32|0)>>>0>0-F>>>0&(0|(t=h=(n>>>0<d>>>0?t+1|0:t)-(n>>>0<32)|0))>=0|(0|t)>0)A[56798]=68,Nn(u+160|0,k),me(u+144|0,A[u+160>>2],A[u+164>>2],A[u+168>>2],A[u+172>>2],-1,-1,-1,2147418111),me(u+128|0,A[u+144>>2],A[u+148>>2],A[u+152>>2],A[u+156>>2],-1,-1,-1,2147418111),m=A[u+128>>2],y=A[u+132>>2],n=A[u+140>>2],t=A[u+136>>2];else if((0|h)>=(0|(n=(t=F-226|0)>>31))&t>>>0<=g>>>0|(0|n)<(0|h)){if((0|i)>=0)for(;ve(u+416|0,m,y,D,T,0,0,0,-1073807360),ve(u+400|0,m,y,D,T,(t=n=(0|(t=$t(m,y,D,T,1073610752)))>=0)?A[u+416>>2]:m,t?A[u+420>>2]:y,t?A[u+424>>2]:D,t?A[u+428>>2]:T),g=(t=g)-1|0,h=h-!t|0,D=A[u+408>>2],T=A[u+412>>2],m=A[u+400>>2],y=A[u+404>>2],(0|(i=n|i<<1))>=0;);t=h-((F>>31)+(g>>>0<F>>>0)|0)|0,(0|(n=(n=32+(g-F|0)|0)>>>0<P>>>0&(0|(t=n>>>0<32?t+1|0:t))<=0|(0|t)<0?(0|n)>0?n:0:P))>=113?(Nn(u+384|0,k),E=A[u+392>>2],B=A[u+396>>2],S=A[u+384>>2],N=A[u+388>>2],d=0,t=0):(Gt(u+352|0,bn(1,144-n|0)),Nn(u+336|0,k),S=A[u+336>>2],N=A[u+340>>2],E=A[u+344>>2],B=A[u+348>>2],Lr(u+368|0,A[u+352>>2],A[u+356>>2],A[u+360>>2],A[u+364>>2],S,N,E,B),M=A[u+376>>2],z=A[u+380>>2],d=A[u+372>>2],t=A[u+368>>2]),Ln(u+320|0,(r=!(1&i)&!!(0|Tt(m,y,D,T,0,0,0,0))&(0|n)<32)+i|0),me(u+304|0,S,N,E,B,A[u+320>>2],A[u+324>>2],A[u+328>>2],A[u+332>>2]),n=t,ve(u+272|0,A[u+304>>2],A[u+308>>2],A[u+312>>2],A[u+316>>2],t,d,M,z),me(u+288|0,S,N,E,B,(t=r)?0:m,t?0:y,t?0:D,t?0:T),ve(u+256|0,A[u+288>>2],A[u+292>>2],A[u+296>>2],A[u+300>>2],A[u+272>>2],A[u+276>>2],A[u+280>>2],A[u+284>>2]),pr(u+240|0,A[u+256>>2],A[u+260>>2],A[u+264>>2],A[u+268>>2],n,d,M,z),Tt(t=A[u+240>>2],r=A[u+244>>2],n=A[u+248>>2],d=A[u+252>>2],0,0,0,0)||(A[56798]=68),Ct(u+224|0,t,r,n,d,g),m=A[u+224>>2],y=A[u+228>>2],n=A[u+236>>2],t=A[u+232>>2]}else A[56798]=68,Nn(u+208|0,k),me(u+192|0,A[u+208>>2],A[u+212>>2],A[u+216>>2],A[u+220>>2],0,0,0,65536),me(u+176|0,A[u+192>>2],A[u+196>>2],A[u+200>>2],A[u+204>>2],0,0,0,65536),m=A[u+176>>2],y=A[u+180>>2],n=A[u+188>>2],t=A[u+184>>2];else Gt(u+112|0,0*+(0|k)),m=A[u+112>>2],y=A[u+116>>2],n=A[u+124>>2],t=A[u+120>>2]}else{a:{i:{if((0|(n=A[t+116>>2]))>0|(0|n)>=0){if(n=A[t+4>>2],A[t+4>>2]=n-1,!r)break i;if(A[t+4>>2]=n-2,!v)break a;A[t+4>>2]=n-3;break a}if(r)break a}Un(t,0,0)}Gt(u+96|0,0*+(0|k)),m=A[u+96>>2],y=A[u+100>>2],n=A[u+108>>2],t=A[u+104>>2]}A[s+16>>2]=m,A[s+20>>2]=y,A[s+24>>2]=t,A[s+28>>2]=n,U=u+432|0,g=A[s+24>>2],h=A[s+28>>2],d=A[s+16>>2],I=A[s+20>>2];break e}A[t+116>>2]<0||(A[t+4>>2]=A[t+4>>2]-1)}c=t,M=k,u=r,t=0,k=0,U=i=U-8976|0,z=(Q=0-F|0)-P|0;s:{a:{for(;;){if(48!=(0|n)){if(46!=(0|n))break s;if((0|(n=A[c+4>>2]))!=A[c+104>>2]){A[c+4>>2]=n+1,n=o[0|n];break a}break}(0|(t=A[c+4>>2]))!=A[c+104>>2]?(A[c+4>>2]=t+1,n=o[0|t]):n=pt(c),t=1}n=pt(c)}if(x=1,48==(0|n)){for(;g=(t=g)-1|0,h=h-!t|0,(0|(t=A[c+4>>2]))==A[c+104>>2]?n=pt(c):(A[c+4>>2]=t+1,n=o[0|t]),48==(0|n););t=1}}A[i+784>>2]=0;s:{a:{i:{A:{o:{if((r=46==(0|n))|(m=n-48|0)>>>0<=9)for(;;){l:{if(1&r){if(!x){g=d,h=I,x=1;break l}r=!t;break o}I=(d=d+1|0)?I:I+1|0,(0|k)<=2044?(G=48==(0|n)?G:d,t=(i+784|0)+(k<<2)|0,v&&(m=(b(A[t>>2],10)+n|0)-48|0),A[t>>2]=m,t=1,v=(n=9==(0|(r=v+1|0)))?0:r,k=n+k|0):48!=(0|n)&&(A[i+8960>>2]=1|A[i+8960>>2],G=18396)}if((0|(n=A[c+4>>2]))==A[c+104>>2]?n=pt(c):(A[c+4>>2]=n+1,n=o[0|n]),!((r=46==(0|n))|(m=n-48|0)>>>0<10))break}if(g=x?g:d,h=x?h:I,!(!t|69!=(-33&n))){if(m=Ye(c,u),y=t=K,!(m|-2147483648!=(0|t))){if(!u)break i;m=0,y=0,A[c+116>>2]<0||(A[c+4>>2]=A[c+4>>2]-1)}h=h+y|0,h=(g=g+m|0)>>>0<m>>>0?h+1|0:h;break a}if(r=!t,(0|n)<0)break A}A[c+116>>2]<0||(A[c+4>>2]=A[c+4>>2]-1)}if(!r)break a;A[56798]=28}d=0,I=0,Un(c,0,0),n=0,t=0;break s}if(t=A[i+784>>2])if(d>>>0>9&(0|I)>=0|(0|I)>0|(0|d)!=(0|g)|(0|h)!=(0|I)|(t>>>P|0?(0|P)<=30:0))if(g>>>0>Q>>>1>>>0&(0|h)>=0|(0|h)>0)A[56798]=68,Nn(i+96|0,M),me(i+80|0,A[i+96>>2],A[i+100>>2],A[i+104>>2],A[i+108>>2],-1,-1,-1,2147418111),me(i- -64|0,A[i+80>>2],A[i+84>>2],A[i+88>>2],A[i+92>>2],-1,-1,-1,2147418111),d=A[i+64>>2],I=A[i+68>>2],n=A[i+76>>2],t=A[i+72>>2];else if((n=g>>>0<(t=F-226|0)>>>0)&(0|h)<=(0|(t>>=31))|(0|t)>(0|h))A[56798]=68,Nn(i+144|0,M),me(i+128|0,A[i+144>>2],A[i+148>>2],A[i+152>>2],A[i+156>>2],0,0,0,65536),me(i+112|0,A[i+128>>2],A[i+132>>2],A[i+136>>2],A[i+140>>2],0,0,0,65536),d=A[i+112>>2],I=A[i+116>>2],n=A[i+124>>2],t=A[i+120>>2];else{if(v){if((0|v)<=8){for(c=A[(t=(i+784|0)+(k<<2)|0)>>2];c=b(c,10),9!=(0|(v=v+1|0)););A[t>>2]=c}k=k+1|0}if(x=g,!((0|G)>(0|g)|(0|G)>=9|(0|g)>17)){if(9==(0|x)){Nn(i+192|0,M),Ln(i+176|0,A[i+784>>2]),me(i+160|0,A[i+192>>2],A[i+196>>2],A[i+200>>2],A[i+204>>2],A[i+176>>2],A[i+180>>2],A[i+184>>2],A[i+188>>2]),d=A[i+160>>2],I=A[i+164>>2],n=A[i+172>>2],t=A[i+168>>2];break s}if((0|x)<=8){Nn(i+272|0,M),Ln(i+256|0,A[i+784>>2]),me(i+240|0,A[i+272>>2],A[i+276>>2],A[i+280>>2],A[i+284>>2],A[i+256>>2],A[i+260>>2],A[i+264>>2],A[i+268>>2]),Nn(i+224|0,A[124720+(0-x<<2)>>2]),oe(i+208|0,A[i+240>>2],A[i+244>>2],A[i+248>>2],A[i+252>>2],A[i+224>>2],A[i+228>>2],A[i+232>>2],A[i+236>>2]),d=A[i+208>>2],I=A[i+212>>2],n=A[i+220>>2],t=A[i+216>>2];break s}if(t=27+(b(x,-3)+P|0)|0,!((n=A[i+784>>2])>>>t|0&&(0|t)<=30)){Nn(i+352|0,M),Ln(i+336|0,n),me(i+320|0,A[i+352>>2],A[i+356>>2],A[i+360>>2],A[i+364>>2],A[i+336>>2],A[i+340>>2],A[i+344>>2],A[i+348>>2]),Nn(i+304|0,A[124648+(x<<2)>>2]),me(i+288|0,A[i+320>>2],A[i+324>>2],A[i+328>>2],A[i+332>>2],A[i+304>>2],A[i+308>>2],A[i+312>>2],A[i+316>>2]),d=A[i+288>>2],I=A[i+292>>2],n=A[i+300>>2],t=A[i+296>>2];break s}}for(;!A[(i+784|0)+((k=(n=k)-1|0)<<2)>>2];);if(v=0,t=(0|x)%9|0){if(r=0,t=(0|x)<0?t+9|0:t,n){for(h=1e9/(0|(g=A[124720+(0-t<<2)>>2]))|0,m=0,c=0;d=(d=m)+(k=((I=A[(m=(i+784|0)+(c<<2)|0)>>2])>>>0)/(g>>>0)|0)|0,A[m>>2]=d,r=(d=!d&(0|r)==(0|c))?r+1&2047:r,x=d?x-9|0:x,m=b(h,I-b(g,k)|0),(0|(c=c+1|0))!=(0|n););m&&(A[(i+784|0)+(n<<2)>>2]=m,n=n+1|0)}else n=0;x=9+(x-t|0)|0}else r=0;for(;;){c=(i+784|0)+(r<<2)|0;a:{for(;;){if((36!=(0|x)|p[c>>2]>=10384593)&(0|x)>=36)break a;for(k=n+2047|0,m=0,t=n;n=t,g=m,m=(t=A[(k=(i+784|0)+((d=2047&k)<<2)|0)>>2])<<29,t=I=t>>>3|0,!(h=(g=g+m|0)>>>0<m>>>0?t+1|0:t)&g>>>0<1000000001?m=0:g=(t=g)-sr(m=ys(t,h,1e9),K,1e9,0)|0,A[k>>2]=g,t=(0|d)!=(n-1&2047)||(0|r)==(0|d)||g?n:d,k=d-1|0,(0|r)!=(0|d););if(v=v-29|0,m)break}(0|(r=r-1&2047))==(0|t)&&(c=n=(g=i+784|0)+((t+2046&2047)<<2)|0,h=A[n>>2],n=t-1&2047,A[c>>2]=h|A[g+(n<<2)>>2]),x=x+9|0,A[(i+784|0)+(r<<2)>>2]=m;continue}break}a:{i:for(;;){for(g=n+1&2047,m=(i+784|0)+((n-1&2047)<<2)|0;;){d=(0|x)>45?9:1;A:{for(;;){t=r,c=0;o:{for(;;){if((0|(r=t+c&2047))!=(0|n)&&!((r=A[(i+784|0)+(r<<2)>>2])>>>0<(h=A[124672+(c<<2)>>2])>>>0)){if(r>>>0>h>>>0)break o;if(4!=(0|(c=c+1|0)))continue}break}if(36==(0|x)){for(g=0,h=0,c=0,d=0,I=0;(0|(r=t+c&2047))==(0|n)&&(A[780+(i+((n=n+1&2047)<<2)|0)>>2]=0),Ln(i+768|0,A[(i+784|0)+(r<<2)>>2]),me(i+752|0,g,h,d,I,0,0,1342177280,1075633366),ve(i+736|0,A[i+752>>2],A[i+756>>2],A[i+760>>2],A[i+764>>2],A[i+768>>2],A[i+772>>2],A[i+776>>2],A[i+780>>2]),d=A[i+744>>2],I=A[i+748>>2],g=A[i+736>>2],h=A[i+740>>2],4!=(0|(c=c+1|0)););if(Nn(i+720|0,M),me(i+704|0,g,h,d,I,A[i+720>>2],A[i+724>>2],A[i+728>>2],A[i+732>>2]),d=A[i+712>>2],I=A[i+716>>2],g=0,h=0,m=A[i+704>>2],y=A[i+708>>2],(0|(r=(k=(0|(c=(u=v+113|0)-F|0))<(0|P))?(0|c)>0?c:0:P))<=112)break A;break a}}if(v=d+v|0,r=n,(0|t)!=(0|n))break}for(I=1e9>>>d|0,k=~(-1<<d),c=0,r=t;h=(h=c)+((u=A[(c=(i+784|0)+(t<<2)|0)>>2])>>>d|0)|0,A[c>>2]=h,r=(h=!h&(0|t)==(0|r))?r+1&2047:r,x=h?x-9|0:x,c=b(I,u&k),(0|n)!=(0|(t=t+1&2047)););if(!c)continue;if((0|r)!=(0|g)){A[(i+784|0)+(n<<2)>>2]=c,n=g;continue i}A[m>>2]=1|A[m>>2];continue}break}break}Gt(i+656|0,bn(1,225-r|0)),Lr(i+688|0,A[i+656>>2],A[i+660>>2],A[i+664>>2],A[i+668>>2],m,y,d,I),S=A[i+696>>2],N=A[i+700>>2],D=A[i+688>>2],T=A[i+692>>2],Gt(i+640|0,bn(1,113-r|0)),Fe(i+672|0,m,y,d,I,A[i+640>>2],A[i+644>>2],A[i+648>>2],A[i+652>>2]),pr(i+624|0,m,y,d,I,g=A[i+672>>2],h=A[i+676>>2],E=A[i+680>>2],B=A[i+684>>2]),ve(i+608|0,D,T,S,N,A[i+624>>2],A[i+628>>2],A[i+632>>2],A[i+636>>2]),d=A[i+616>>2],I=A[i+620>>2],m=A[i+608>>2],y=A[i+612>>2]}if((0|(x=t+4&2047))!=(0|n)){a:if((x=A[(i+784|0)+(x<<2)>>2])>>>0<=499999999){if(!x&(t+5&2047)==(0|n))break a;Gt(i+496|0,.25*+(0|M)),ve(i+480|0,g,h,E,B,A[i+496>>2],A[i+500>>2],A[i+504>>2],A[i+508>>2]),E=A[i+488>>2],B=A[i+492>>2],g=A[i+480>>2],h=A[i+484>>2]}else 5e8==(0|x)?(O=+(0|M),(t+5&2047)!=(0|n)?(Gt(i+560|0,.75*O),ve(i+544|0,g,h,E,B,A[i+560>>2],A[i+564>>2],A[i+568>>2],A[i+572>>2]),E=A[i+552>>2],B=A[i+556>>2],g=A[i+544>>2],h=A[i+548>>2]):(Gt(i+528|0,.5*O),ve(i+512|0,g,h,E,B,A[i+528>>2],A[i+532>>2],A[i+536>>2],A[i+540>>2]),E=A[i+520>>2],B=A[i+524>>2],g=A[i+512>>2],h=A[i+516>>2])):(Gt(i+592|0,.75*+(0|M)),ve(i+576|0,g,h,E,B,A[i+592>>2],A[i+596>>2],A[i+600>>2],A[i+604>>2]),E=A[i+584>>2],B=A[i+588>>2],g=A[i+576>>2],h=A[i+580>>2]);(0|r)>111||(Fe(i+464|0,g,h,E,B,0,0,0,1073676288),Tt(A[i+464>>2],A[i+468>>2],A[i+472>>2],A[i+476>>2],0,0,0,0)||(ve(i+448|0,g,h,E,B,0,0,0,1073676288),E=A[i+456>>2],B=A[i+460>>2],g=A[i+448>>2],h=A[i+452>>2]))}ve(i+432|0,m,y,d,I,g,h,E,B),pr(i+416|0,A[i+432>>2],A[i+436>>2],A[i+440>>2],A[i+444>>2],D,T,S,N),d=A[i+424>>2],I=A[i+428>>2],m=A[i+416>>2],y=A[i+420>>2],(z-2|0)>=(2147483647&u)||(A[i+408>>2]=d,A[i+412>>2]=2147483647&I,A[i+400>>2]=m,A[i+404>>2]=y,me(i+384|0,m,y,d,I,0,0,0,1073610752),d=(t=(0|(t=$t(A[i+400>>2],A[i+404>>2],A[i+408>>2],A[i+412>>2],1081081856)))>=0)?A[i+392>>2]:d,I=t?A[i+396>>2]:I,m=t?A[i+384>>2]:m,y=t?A[i+388>>2]:y,v=t+v|0,!(!!(0|Tt(g,h,E,B,0,0,0,0))&(t?k&(0|r)!=(0|c):k))&(v+110|0)<=(0|z)||(A[56798]=68)),Ct(i+368|0,m,y,d,I,v),d=A[i+368>>2],I=A[i+372>>2],n=A[i+380>>2],t=A[i+376>>2]}else Nn(i+48|0,M),Ln(i+32|0,t),me(i+16|0,A[i+48>>2],A[i+52>>2],A[i+56>>2],A[i+60>>2],A[i+32>>2],A[i+36>>2],A[i+40>>2],A[i+44>>2]),d=A[i+16>>2],I=A[i+20>>2],n=A[i+28>>2],t=A[i+24>>2];else Gt(i,0*+(0|M)),d=A[i>>2],I=A[i+4>>2],n=A[i+12>>2],t=A[i+8>>2]}A[s+40>>2]=t,A[s+44>>2]=n,A[s+32>>2]=d,A[s+36>>2]=I,U=i+8976|0,g=A[s+40>>2],h=A[s+44>>2],d=A[s+32>>2],I=A[s+36>>2];break e;case 3:break n}(0|(n=A[t+116>>2]))>0|(0|n)>=0&&(A[t+4>>2]=A[t+4>>2]-1);break t}if((0|(n=A[t+4>>2]))==A[t+104>>2]?n=pt(t):(A[t+4>>2]=n+1,n=o[0|n]),40!=(0|n)){if(h=2147450880,A[t+116>>2]<0)break e;A[t+4>>2]=A[t+4>>2]-1;break e}for(c=1;(0|(n=A[t+4>>2]))==A[t+104>>2]?n=pt(t):(A[t+4>>2]=n+1,n=o[0|n]),n-48>>>0<10|n-65>>>0<26|95==(0|n)||!(n-97>>>0>=26);)c=c+1|0;if(h=2147450880,41==(0|n))break e;(0|(n=A[t+116>>2]))>0|(0|n)>=0&&(A[t+4>>2]=A[t+4>>2]-1);n:{if(r){if(c)break n;break e}break t}for(;c=c-1|0,(0|n)>0|(0|n)>=0&&(A[t+4>>2]=A[t+4>>2]-1),c;);break e}A[56798]=28,Un(t,0,0)}h=0}A[e>>2]=d,A[e+4>>2]=I,A[e+8>>2]=g,A[e+12>>2]=h,U=s+48|0}function te(e,t,n,r,s){var l,u=0,c=0,d=0,h=0,f=0,p=0,m=0,C=0,I=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0,N=0;if(U=l=U-112|0,A[n+8>>2]){S=A[50754]/70|0,w=(p=A[r+12>>2])||256;e:if(2!=(0|t)){if(1==(0|t)){t:if(3!=o[e+11|0])switch(o[r-15|0]-3|0){case 0:case 5:break t;default:break e}w=(0|(p=A[A[47192]+44>>2]))<(0|w)?w:p}}else{if((0|(p=A[A[47192]+80>>2]))<=0|!(8&o[0|r]|p>>>0<=o[e+14|0]|32&o[e+6|0]))break e;S<<=1}if(A[36436]=0,y=e,N=t,f=r,U=I=U-16|0,e=A[34460]+A[n+8>>2]|0,t=(t=o[e+2|0])>>>0>=24?24:t,A[I+12>>2]=t,c=A[n+12>>2]+A[n+24>>2]|0,A[36422]=c,t){for(p=e+4|0,u=1&i[e+4>>1];e=145488+(h<<3)|0,r=p+(u?h<<6:b(h,44))|0,A[e+4>>2]=r,C=g[r>>1],i[e+2>>1]=C,i[e>>1]=o[r+16|0],d=2&C?h:d,(0|(h=h+1|0))!=(0|t););p=145488,(0|d)<=0||(1!=(0|N)?(t=t-d|0,A[I+12>>2]=t,p=145488+(d<<3)|0):(t=d+1|0,A[I+12>>2]=t,p=145488))}else t=0,p=145488;if(!(!A[n+4>>2]|A[n+20>>2]|2!=o[y+11|0])){if(u=A[n+36>>2],r=A[n+40>>2],e=0,(0|(t=A[I+12>>2]))>=2){d=u>>>12|0,C=r>>>26&7,v=r>>>18&248,k=b(x=63&r,50),B=63&(M=u>>>6|0),h=u<<1&126,D=b(r>>>16&31,50)-750|0,T=b(r>>>11&31,50)-750|0,E=b(r>>>6&31,50)-750|0;e:{t:if(1!=(0|N)){if(!(d|x))break e;if(8&d?(t=A[4+(p+((c=t-1|0)<<3)|0)>>2],i[t>>1]<0?e=t:(e=(0|(e=A[44469]+1|0))<=169?e:0,A[44469]=e,c=g[t+20>>1]|g[t+22>>1]<<16,e=177888+(e<<6)|0,u=g[t+16>>1]|g[t+18>>1]<<16,i[e+16>>1]=u,i[e+18>>1]=u>>>16,i[e+20>>1]=c,i[e+22>>1]=c>>>16,c=g[t+4>>1]|g[t+6>>1]<<16,u=g[t>>1]|g[t+2>>1]<<16,i[e>>1]=u,i[e+2>>1]=u>>>16,i[e+4>>1]=c,i[e+6>>1]=c>>>16,c=g[t+12>>1]|g[t+14>>1]<<16,u=g[t+8>>1]|g[t+10>>1]<<16,i[e+8>>1]=u,i[e+10>>1]=u>>>16,i[e+12>>1]=c,i[e+14>>1]=c>>>16,c=g[t+28>>1]|g[t+30>>1]<<16,u=g[t+24>>1]|g[t+26>>1]<<16,i[e+24>>1]=u,i[e+26>>1]=u>>>16,i[e+28>>1]=c,i[e+30>>1]=c>>>16,c=g[t+36>>1]|g[t+38>>1]<<16,u=g[t+32>>1]|g[t+34>>1]<<16,i[e+32>>1]=u,i[e+34>>1]=u>>>16,i[e+36>>1]=c,i[e+38>>1]=c>>>16,c=g[t+44>>1]|g[t+46>>1]<<16,u=g[t+40>>1]|g[t+42>>1]<<16,i[e+40>>1]=u,i[e+42>>1]=u>>>16,i[e+44>>1]=c,i[e+46>>1]=c>>>16,c=g[t+52>>1]|g[t+54>>1]<<16,u=g[t+48>>1]|g[t+50>>1]<<16,i[e+48>>1]=u,i[e+50>>1]=u>>>16,i[e+52>>1]=c,i[e+54>>1]=c>>>16,c=g[t+60>>1]|g[t+62>>1]<<16,t=g[t+56>>1]|g[t+58>>1]<<16,i[e+56>>1]=t,i[e+58>>1]=t>>>16,i[e+60>>1]=c,i[e+62>>1]=c>>>16,a[e+16|0]=0,i[e>>1]=32768|g[e>>1],c=A[I+12>>2]-1|0),A[4+(p+(c<<3)|0)>>2]=e,t=1792,(0|(c=i[e+4>>1]))<300||(t=1536,c>>>0<400||(t=c>>>0<500?1280:1024)),A[36436]=t,u=35):(A[I+12>>2]=t+1,i[(e=(c=p+(t<<3)|0)-8|0)>>1]=h,t=A[e+4>>2],e=(0|(e=A[44469]+1|0))<=169?e:0,A[44469]=e,(e=177888+(M=e<<6)|0)&&(u=g[t+4>>1]|g[t+6>>1]<<16,m=g[t>>1]|g[t+2>>1]<<16,i[e>>1]=m,i[e+2>>1]=m>>>16,i[e+4>>1]=u,i[e+6>>1]=u>>>16,u=g[t+60>>1]|g[t+62>>1]<<16,m=g[t+56>>1]|g[t+58>>1]<<16,i[e+56>>1]=m,i[e+58>>1]=m>>>16,i[e+60>>1]=u,i[e+62>>1]=u>>>16,u=g[t+52>>1]|g[t+54>>1]<<16,m=g[t+48>>1]|g[t+50>>1]<<16,i[e+48>>1]=m,i[e+50>>1]=m>>>16,i[e+52>>1]=u,i[e+54>>1]=u>>>16,u=g[t+44>>1]|g[t+46>>1]<<16,m=g[t+40>>1]|g[t+42>>1]<<16,i[e+40>>1]=m,i[e+42>>1]=m>>>16,i[e+44>>1]=u,i[e+46>>1]=u>>>16,u=g[t+36>>1]|g[t+38>>1]<<16,m=g[t+32>>1]|g[t+34>>1]<<16,i[e+32>>1]=m,i[e+34>>1]=m>>>16,i[e+36>>1]=u,i[e+38>>1]=u>>>16,u=g[t+28>>1]|g[t+30>>1]<<16,m=g[t+24>>1]|g[t+26>>1]<<16,i[e+24>>1]=m,i[e+26>>1]=m>>>16,i[e+28>>1]=u,i[e+30>>1]=u>>>16,u=g[t+20>>1]|g[t+22>>1]<<16,m=g[t+16>>1]|g[t+18>>1]<<16,i[e+16>>1]=m,i[e+18>>1]=m>>>16,i[e+20>>1]=u,i[e+22>>1]=u>>>16,u=g[t+12>>1]|g[t+14>>1]<<16,t=g[t+8>>1]|g[t+10>>1]<<16,i[e+8>>1]=t,i[e+10>>1]=t>>>16,i[e+12>>1]=u,i[e+14>>1]=u>>>16,a[M+177904|0]=0,i[e>>1]=32768|g[e>>1]),i[c>>1]=0,A[c+4>>2]=e,h>>>0>=37&&(A[36422]=(h+A[36422]|0)-36),u=B<<1,x&&ft(e,k,E,T,C,D,v,d)),A[A[32972]+132>>2]||(t=o[e+17|0])&&(t=i[102896+(((0|(t=(u<<6>>>0)/(t>>>0)|0))>=199?199:t)<<1)>>1],a[e+18|0]=(0|b(t,o[e+18|0]))/512,a[e+19|0]=(0|b(t,o[e+19|0]))/512,a[e+20|0]=(0|b(t,o[e+20|0]))/512,a[e+21|0]=(0|b(t,o[e+21|0]))/512,a[e+22|0]=(0|b(t,o[e+22|0]))/512,a[e+23|0]=(0|b(t,o[e+23|0]))/512,a[e+24|0]=(0|b(t,o[e+24|0]))/512,a[e+25|0]=(0|b(t,o[e+25|0]))/512),r-536870912>>>0<=1073741823){if(C=A[44469],(0|(c=A[I+12>>2]))>0)for(e=b(r>>>29|0,10)+102854|0,v=i[e+4>>1],x=i[e+2>>1],k=i[e>>1],D=i[e+6>>1],T=i[e+8>>1],u=0;t=A[4+(E=p+(u<<3)|0)>>2],i[t>>1]<0?e=t:(e=177888+(B=(C=(0|(e=C+1|0))<=169?e:0)<<6)|0)?(r=g[t+4>>1]|g[t+6>>1]<<16,c=g[t>>1]|g[t+2>>1]<<16,i[e>>1]=c,i[e+2>>1]=c>>>16,i[e+4>>1]=r,i[e+6>>1]=r>>>16,r=g[t+60>>1]|g[t+62>>1]<<16,c=g[t+56>>1]|g[t+58>>1]<<16,i[e+56>>1]=c,i[e+58>>1]=c>>>16,i[e+60>>1]=r,i[e+62>>1]=r>>>16,r=g[t+52>>1]|g[t+54>>1]<<16,c=g[t+48>>1]|g[t+50>>1]<<16,i[e+48>>1]=c,i[e+50>>1]=c>>>16,i[e+52>>1]=r,i[e+54>>1]=r>>>16,r=g[t+44>>1]|g[t+46>>1]<<16,c=g[t+40>>1]|g[t+42>>1]<<16,i[e+40>>1]=c,i[e+42>>1]=c>>>16,i[e+44>>1]=r,i[e+46>>1]=r>>>16,r=g[t+36>>1]|g[t+38>>1]<<16,c=g[t+32>>1]|g[t+34>>1]<<16,i[e+32>>1]=c,i[e+34>>1]=c>>>16,i[e+36>>1]=r,i[e+38>>1]=r>>>16,r=g[t+28>>1]|g[t+30>>1]<<16,c=g[t+24>>1]|g[t+26>>1]<<16,i[e+24>>1]=c,i[e+26>>1]=c>>>16,i[e+28>>1]=r,i[e+30>>1]=r>>>16,r=g[t+20>>1]|g[t+22>>1]<<16,c=g[t+16>>1]|g[t+18>>1]<<16,i[e+16>>1]=c,i[e+18>>1]=c>>>16,i[e+20>>1]=r,i[e+22>>1]=r>>>16,r=g[t+12>>1]|g[t+14>>1]<<16,t=g[t+8>>1]|g[t+10>>1]<<16,i[e+8>>1]=t,i[e+10>>1]=t>>>16,i[e+12>>1]=r,i[e+14>>1]=r>>>16,a[B+177904|0]=0,i[e>>1]=32768|g[e>>1],c=A[I+12>>2]):e=0,A[E+4>>2]=e,i[e+8>>1]=(0|b(v,i[e+8>>1]))/256,i[e+6>>1]=(0|b(x,i[e+6>>1]))/256,i[e+4>>1]=(0|b(k,i[e+4>>1]))/256,i[e+12>>1]=(0|b(T,i[e+12>>1]))/256,i[e+10>>1]=(0|b(D,i[e+10>>1]))/256,(0|c)>(0|(u=u+1|0)););A[44469]=C}if(!e)break e}else{t=A[p+4>>2],(0|(c=i[t>>1]))<0?e=t:(r=(0|(r=A[44469]+1|0))<=169?r:0,A[44469]=r,(r=177888+(c=r<<6)|0)&&(e=g[t+4>>1]|g[t+6>>1]<<16,m=g[t>>1]|g[t+2>>1]<<16,i[r>>1]=m,i[r+2>>1]=m>>>16,i[r+4>>1]=e,i[r+6>>1]=e>>>16,e=g[t+60>>1]|g[t+62>>1]<<16,m=g[t+56>>1]|g[t+58>>1]<<16,i[r+56>>1]=m,i[r+58>>1]=m>>>16,i[r+60>>1]=e,i[r+62>>1]=e>>>16,e=g[t+52>>1]|g[t+54>>1]<<16,m=g[t+48>>1]|g[t+50>>1]<<16,i[r+48>>1]=m,i[r+50>>1]=m>>>16,i[r+52>>1]=e,i[r+54>>1]=e>>>16,e=g[t+44>>1]|g[t+46>>1]<<16,m=g[t+40>>1]|g[t+42>>1]<<16,i[r+40>>1]=m,i[r+42>>1]=m>>>16,i[r+44>>1]=e,i[r+46>>1]=e>>>16,e=g[t+36>>1]|g[t+38>>1]<<16,m=g[t+32>>1]|g[t+34>>1]<<16,i[r+32>>1]=m,i[r+34>>1]=m>>>16,i[r+36>>1]=e,i[r+38>>1]=e>>>16,e=g[t+28>>1]|g[t+30>>1]<<16,m=g[t+24>>1]|g[t+26>>1]<<16,i[r+24>>1]=m,i[r+26>>1]=m>>>16,i[r+28>>1]=e,i[r+30>>1]=e>>>16,e=g[t+20>>1]|g[t+22>>1]<<16,m=g[t+16>>1]|g[t+18>>1]<<16,i[r+16>>1]=m,i[r+18>>1]=m>>>16,i[r+20>>1]=e,i[r+22>>1]=e>>>16,e=g[t+12>>1]|g[t+14>>1]<<16,t=g[t+8>>1]|g[t+10>>1]<<16,i[r+8>>1]=t,i[r+10>>1]=t>>>16,i[r+12>>1]=e,i[r+14>>1]=e>>>16,a[c+177904|0]=0,c=-32768|g[r>>1],i[r>>1]=c,e=r)),A[p+4>>2]=e,i[p>>1]=h||50,i[p+2>>1]=16384|g[p+2>>1],i[e>>1]=16384|c,c=A[p+12>>2],t=o[c+17|0],r=A[32972],A[r+132>>2]&&(a[e+39|0]=o[c+39|0]-4);n:if(x){if(2048&u){t=(b(t,31&M)>>>0)/30|0,A[r+132>>2]||(r=o[e+17|0])&&(t=i[102896+(((0|(t=(t<<6>>>0)/(r>>>0)|0))>=199?199:t)<<1)>>1],a[e+18|0]=(0|b(t,o[e+18|0]))/512,a[e+19|0]=(0|b(t,o[e+19|0]))/512,a[e+20|0]=(0|b(t,o[e+20|0]))/512,a[e+21|0]=(0|b(t,o[e+21|0]))/512,a[e+22|0]=(0|b(t,o[e+22|0]))/512,a[e+23|0]=(0|b(t,o[e+23|0]))/512,a[e+24|0]=(0|b(t,o[e+24|0]))/512,a[e+25|0]=(0|b(t,o[e+25|0]))/512),ft(e,k,E,T,C,D,v,d);break n}if(ft(e,k,E,T,C,D,v,d),A[A[32972]+132>>2])break n;if(!(t=o[e+17|0]))break n;t=i[102896+(((0|(t=(B<<7>>>0)/(t>>>0)|0))>=199?199:t)<<1)>>1],a[e+18|0]=(0|b(t,o[e+18|0]))/512,a[e+19|0]=(0|b(t,o[e+19|0]))/512,a[e+20|0]=(0|b(t,o[e+20|0]))/512,a[e+21|0]=(0|b(t,o[e+21|0]))/512,a[e+22|0]=(0|b(t,o[e+22|0]))/512,a[e+23|0]=(0|b(t,o[e+23|0]))/512,a[e+24|0]=(0|b(t,o[e+24|0]))/512,a[e+25|0]=(0|b(t,o[e+25|0]))/512}else if(r=A[r+132>>2],8&d){if(r)break n;if(!(r=o[e+17|0]))break n;t=((16320&b(t,48))>>>0)/(r>>>0)|0,t=i[102896+((t>>>0>=199?199:t)<<1)>>1],a[e+18|0]=(0|b(t,o[e+18|0]))/512,a[e+19|0]=(0|b(t,o[e+19|0]))/512,a[e+20|0]=(0|b(t,o[e+20|0]))/512,a[e+21|0]=(0|b(t,o[e+21|0]))/512,a[e+22|0]=(0|b(t,o[e+22|0]))/512,a[e+23|0]=(0|b(t,o[e+23|0]))/512,a[e+24|0]=(0|b(t,o[e+24|0]))/512,a[e+25|0]=(0|b(t,o[e+25|0]))/512}else r||(t=o[e+17|0])&&(t=i[102896+(((t=1792/(t>>>0)|0)>>>0>=199?199:t)<<1)>>1],a[e+18|0]=(0|b(t,o[e+18|0]))/512,a[e+19|0]=(0|b(t,o[e+19|0]))/512,a[e+20|0]=(0|b(t,o[e+20|0]))/512,a[e+21|0]=(0|b(t,o[e+21|0]))/512,a[e+22|0]=(0|b(t,o[e+22|0]))/512,a[e+23|0]=(0|b(t,o[e+23|0]))/512,a[e+24|0]=(0|b(t,o[e+24|0]))/512,a[e+25|0]=(0|b(t,o[e+25|0]))/512);if(!(8&d))break t;t=2816,(0|(r=i[e+4>>1]))<300||(t=2560,r>>>0<400||(t=r>>>0<500?2304:2048)),A[36436]=t}4&d&&(i[e>>1]=32|g[e>>1]),2&d&&(i[e>>1]=16|g[e>>1])}64&d&&Dt(20,0),e=h&d<<27>>31}else e=0;c=e+A[36422]|0,A[36422]=c,t=A[I+12>>2]}if((0|(r=t-1|0))<=0)u=0;else{if(e=0,h=0,u=0,t-2>>>0>=3)for(v=-4&r,C=0;u=(((i[(d=h<<3)+p>>1]+u|0)+i[p+(8|d)>>1]|0)+i[p+(16|d)>>1]|0)+i[p+(24|d)>>1]|0,h=h+4|0,(0|v)!=(0|(C=C+4|0)););if(d=3&r)for(;u=i[p+(h<<3)>>1]+u|0,h=h+1|0,(0|d)!=(0|(e=e+1|0)););}if(e=t,(d=A[n+20>>2])&&(e=r,h=d+A[34460]|0,(C=o[h+2|0])&&(x=g[h+4>>1],i[p+(r<<3)>>1]=o[h+20|0],d=1,e=t,1!=(0|C)))){if(v=h+4|0,x&=1,D=1&(h=C-1|0),2!=(0|C))for(T=-2&h,C=0;E=v+(d<<6)|0,B=v+b(d,44)|0,M=o[(k=x?E:B)+16|0],A[4+(h=p+(e<<3)|0)>>2]=k,i[h>>1]=M,i[h+2>>1]=g[k>>1],E=o[16+(k=x?E- -64|0:B+44|0)|0],A[h+12>>2]=k,i[h+8>>1]=E,i[h+10>>1]=g[k>>1],d=d+2|0,e=e+2|0,(0|T)!=(0|(C=C+2|0)););D&&(d=v+(x?d<<6:b(d,44))|0,C=o[d+16|0],A[4+(h=p+(e<<3)|0)>>2]=d,i[h>>1]=C,i[h+2>>1]=g[d>>1],e=e+1|0)}e:if(!((0|u)<=0)){t:{n:switch(N-1|0){case 1:if(d=(0|(d=(A[n+44>>2]+c|0)-45|0))<=10?10:d,8&o[0|f]&&(d=d+(o[A[36128]+14|0]<<1)|0),(0|r)<=0)break e;if(f=(d<<8)/(0|u)|0,h=0,2!=(0|t))for(t=-2&r,d=0;i[(u=(c=h<<3)+p|0)>>1]=(0|b(f,i[u>>1]))/256,i[(c=p+(8|c)|0)>>1]=(0|b(f,i[c>>1]))/256,h=h+2|0,(0|t)!=(0|(d=d+2|0)););if(!(1&r))break e;i[(t=p+(h<<3)|0)>>1]=(0|b(f,i[t>>1]))/256;break e;case 0:if(1!=A[n>>2])break t;if((0|(d=A[n+44>>2]))>129)break t;i[p>>1]=(0|b(d,i[p>>1]))/130;break t}(0|(d=A[n+44>>2]))<=0||(c=(d-u|0)+c|0,A[36422]=c)}if(!(!c|(0|r)<=0)){if(f=(u+c<<8)/(0|u)|0,h=0,2!=(0|t))for(t=-2&r,d=0;i[(u=(c=h<<3)+p|0)>>1]=(0|b(f,i[u>>1]))/256,i[(c=p+(8|c)|0)>>1]=(0|b(f,i[c>>1]))/256,h=h+2|0,(0|t)!=(0|(d=d+2|0)););1&r&&(i[(t=p+(h<<3)|0)>>1]=(0|b(f,i[t>>1]))/256)}}if(A[l+108>>2]=e,U=I+16|0,p){if((0|(e=A[n+16>>2]))!=A[36438]&&(A[36438]=e,t=216192+(A[50758]<<4)|0,A[t>>2]=14,A[t+4>>2]=e,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0),h=(e=A[A[32972]+132>>2])?1:3,t=A[p+4>>2],A[n+28>>2]|!o[145748]||(a[145748]=0,h=e?2:4),(r=A[36426])&&(!((2&(e=g[r>>1]))>>>1|o[r+16|0]<2)|16&e||(c=216192+(A[36439]<<4)|0,A[c+12>>2]=t,8&e&&(e=(0|(e=A[44469]+1|0))<=169?e:0,A[44469]=e,(e=177888+(d=e<<6)|0)&&(f=g[t+4>>1]|g[t+6>>1]<<16,u=g[t>>1]|g[t+2>>1]<<16,i[e>>1]=u,i[e+2>>1]=u>>>16,i[e+4>>1]=f,i[e+6>>1]=f>>>16,f=g[t+60>>1]|g[t+62>>1]<<16,u=g[t+56>>1]|g[t+58>>1]<<16,i[e+56>>1]=u,i[e+58>>1]=u>>>16,i[e+60>>1]=f,i[e+62>>1]=f>>>16,f=g[t+52>>1]|g[t+54>>1]<<16,u=g[t+48>>1]|g[t+50>>1]<<16,i[e+48>>1]=u,i[e+50>>1]=u>>>16,i[e+52>>1]=f,i[e+54>>1]=f>>>16,f=g[t+44>>1]|g[t+46>>1]<<16,u=g[t+40>>1]|g[t+42>>1]<<16,i[e+40>>1]=u,i[e+42>>1]=u>>>16,i[e+44>>1]=f,i[e+46>>1]=f>>>16,f=g[t+36>>1]|g[t+38>>1]<<16,u=g[t+32>>1]|g[t+34>>1]<<16,i[e+32>>1]=u,i[e+34>>1]=u>>>16,i[e+36>>1]=f,i[e+38>>1]=f>>>16,f=g[t+28>>1]|g[t+30>>1]<<16,u=g[t+24>>1]|g[t+26>>1]<<16,i[e+24>>1]=u,i[e+26>>1]=u>>>16,i[e+28>>1]=f,i[e+30>>1]=f>>>16,f=g[t+20>>1]|g[t+22>>1]<<16,u=g[t+16>>1]|g[t+18>>1]<<16,i[e+16>>1]=u,i[e+18>>1]=u>>>16,i[e+20>>1]=f,i[e+22>>1]=f>>>16,f=g[t+12>>1]|g[t+14>>1]<<16,u=g[t+8>>1]|g[t+10>>1]<<16,i[e+8>>1]=u,i[e+10>>1]=u>>>16,i[e+12>>1]=f,i[e+14>>1]=f>>>16,a[d+177904|0]=0,i[e>>1]=32768|g[e>>1]),i[8+(d=d+177888|0)>>1]=g[r+8>>1],a[d+21|0]=o[r+21|0],i[d+10>>1]=g[r+10>>1],a[d+22|0]=o[r+22|0],i[d+12>>1]=g[r+12>>1],a[d+23|0]=o[r+23|0],i[d+14>>1]=g[r+14>>1],a[d+24|0]=o[r+24|0],a[d+25|0]=o[r+25|0],A[c+12>>2]=e))),2!=(0|N)|2!=o[y+11|0]||(he(),A[36427]=A[50758]),!((0|(y=A[l+108>>2]))<2)){for(e=A[36433],f=(b(256-e|0,w)+(e<<8)|0)/256|0,e=A[36432],c=(b(256-e|0,w)+(e<<8)|0)/256|0,u=A[50754],e=0,r=1;d=g[2+(I=(p+(r<<3)|0)-8|0)>>1],d=(0|b((0|b(u,i[I>>1]))/1e3|0,4&d?c:16384&d?f:w))/256|0,A[(r<<2)+l>>2]=d,e=e+d|0,(0|y)!=(0|(r=r+1|0)););if(!((0|e)<=0|(0|e)>=(0|S)|(0|y)<2)){if(r=1,f=1&(d=y-1|0),2!=(0|y))for(c=-2&d,w=0;A[(d=(r<<2)+l|0)>>2]=(0|b(A[d>>2],S))/(0|e),A[d+4>>2]=(0|b(A[d+4>>2],S))/(0|e),r=r+2|0,(0|c)!=(0|(w=w+2|0)););f&&(A[(r=(r<<2)+l|0)>>2]=(0|b(A[r>>2],S))/(0|e))}if(w=0,!((0|y)<2))for(y=N+256|0,r=1;e=A[4+(p+(r<<3)|0)>>2],!(d=A[n+28>>2])|128&o[0|t]||(A[36422]=0,Ze(d,y,0,u=A[n>>2],0,f=(f=A[n+32>>2])?(f<<5)/100|0:32),a[145748]=1,A[n+28>>2]=0),(0|s)<0||(s=64&o[0|t]?6:s,(A[l+108>>2]-1|0)==(0|r)&&(s=(d=s)|(3840&(s=A[36436])?s:0))),d=A[(r<<2)+l>>2],A[36440]=d+A[36440],A[36441]=d+A[36441],d?(f=A[50758],A[36439]=f,(0|s)>=0&&(A[(f=216192+(f<<4)|0)>>2]=h,A[f+12>>2]=e,A[f+8>>2]=t,A[f+4>>2]=d+(s<<16),t=A[50758]+1|0,A[50758]=(0|t)<=169?t:0),A[36426]=e,w=d+w|0):A[36426]=0,t=e,(0|(r=r+1|0))<A[l+108>>2];);}!A[36438]|1==(0|N)||(A[36438]=0,e=216192+(A[50758]<<4)|0,A[e>>2]=14,A[e+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0)}}U=l+112|0}function ne(e,t,n,r){var s,i=0,l=0,u=0,c=0,d=0,h=0,f=0,p=0,m=0,C=0,I=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0;U=s=U-1856|0,A[s+164>>2]=0,n?p=A[n>>2]:kt(n=s- -64|0,0,96),A[33264]=0,A[s+1824>>2]=0,A[s+1828>>2]=0,A[s+1832>>2]=0,A[s+1836>>2]=0,a[s+1616|0]=0,a[s+992|0]=0,a[s+1200|0]=0,a[s+784|0]=0;e:if(A[e+688>>2]){for(A[s+1840>>2]=t,32==o[0|(i=t)]&&(i=t+1|0,A[s+1840>>2]=i),m=s+416|1,B=s+1844|1,D=s+1848|1,T=s+1852|1,A[s+1820>>2]=i,Ht(s+168|0,i),i=A[s+1820>>2];32!=(32|o[0|i]);)i=Ht(s+164|0,i)+A[s+1820>>2]|0,A[s+1820>>2]=i,w=w+1|0;Je(s+256|0,t,M=(0|(u=i-t|0))>=159?159:u),!(v=4194304&p)|1!=(0|w)?(x=(36==(0|(i=A[47202])))<<2,1==(0|w)|36!=(0|i)||(i=A[s+1840>>2]-1|0,A[s+1840>>2]=i,a[0|i]=95,x=0,l=!!(0|He(e,s+1840|0,s+1616|0,s+1832|0,0,n)),i=A[47202])):(l=1,Ht(s+172|0,i+1|0),fn(A[s+172>>2])&&(0|at(A[s+164>>2]))==(0|at(A[s+172>>2]))&&(l=0),x=36==(0|(i=A[47202]))?4:l,l=0);t:{n:{r:{s:{a:if(16&i)C=15&i,x=0;else{if(k=1,l||(k=!!(0|He(e,s+1840|0,s+1616|0,s+1832|0,2,n))),50331648&(i=A[s+1832>>2])&&(u=A[s+1820>>2],46==o[u+1|0]&&(a[u+1|0]=32,i=A[s+1832>>2])),536870912&i){if(!r)break e;rn(r,A[s+1840>>2]);break e}if(8192&i|!(128&i)|k)r=A[33264];else if(i=A[s+1840>>2],A[s+1820>>2]=i,!((0|(r=A[33264]))<=0))for(l=0;32==o[0|i]&&(a[0|i]=45,l=l+1|0,i=A[s+1820>>2],r=A[33264]),i=i+1|0,A[s+1820>>2]=i,(0|r)>(0|l););i:if(!(r|1!=(0|w))&&(u=Ht(s+576|0,f=A[s+1840>>2]),32==o[u+f|0])){l=s+1408|0,r=f;A:{o:{l:{for(;;){u:if(fn(A[s+576>>2])){c:{if(46==o[1+(c=r+u|0)|0]){C=0;d:switch(o[(i=u+2|0)+r|0]-32|0){case 0:break c;case 7:break d;default:break u}if(C=1,u=i,115==o[c+3|0])break c;break u}if(C=1,(0|h)<=0)break l}if(!((0|u)<=0)){if(I=3&u,d=0,u>>>0<4)i=0;else for(y=-4&u,i=0,c=0;a[0|l]=o[r+i|0],a[l+1|0]=o[(1|i)+r|0],a[l+2|0]=o[(2|i)+r|0],a[l+3|0]=o[(3|i)+r|0],i=i+4|0,l=l+4|0,(0|y)!=(0|(c=c+4|0)););if(I)for(;a[0|l]=o[r+i|0],i=i+1|0,l=l+1|0,(0|I)!=(0|(d=d+1|0)););}if(h=h+1|0,C)r=r+u|0;else if(u=Ht(s+576|0,r=3+(r+u|0)|0),32==o[r+u|0])continue}break}if(!((0|h)<2)){(u=(u=l-(i=s+1408|0)|0)+(i=Je(f,i,u))|0)>>>0<r>>>0&&kt(u,32,(s+1408|0)+r-(i+l)|0),A[33264]=(h<<1)-2,A[s+1836>>2]=0;break o}}if(!h)break i;if(A[s+1832>>2]=0,A[s+1836>>2]=0,!A[33264])break A}A[s+1832>>2]=128}x=1}if(21==o[s+1616|0]){rn(189088,s+1616|0),i=0;break e}if(S=o[s+1833|0],l=1,!k){if(A[s+168>>2]-48>>>0<10){if(Mn(e,84174,189088),i=0,21==o[189088])break e;if(!(!(128&o[e+109|0])|32&o[n+2|0])){a[189088]=21,a[189089]=0;break e}l=!!(0|ue(e,A[s+1840>>2],s+1616|0,s+1832|0,n,0))}else l=0;if(!(l|2==(3&p))&&(16777216&(r=A[e+104>>2])||(l=0,!(!(33554432&r)|!(1&p))))&&(16&p||(l=0,!(1&a[n+13|0])))){y=A[s+1840>>2],i=0,h=0,c=0,U=I=U-224|0,a[0|(d=s+1616|0)]=0,A[I+216>>2]=0,A[I+220>>2]=0;i:if(!(a[y-2|0]-48>>>0<10|(1&a[0|n]?0:2&o[e+107|0])||(r=o[0|(u=y+1|0)],(!(2561&g[e+106>>1])|!(1&a[n+2|0]))&32==(0|r)))){if(32!=(0|(h=o[0|y]))){for(C=32767,r=0;;){if(!(i=Zt(101868,h<<24>>24,8))){h=0;break i}if(f=0,(0|(i=A[(i<<2)-305584>>2]))==(0|r)&&!((0|(f=c+1|0))<=2)){h=0;break i}A:{o:{l:{u:{if(!((0|r)<2)){if(10==(0|r)|100==(0|r))break u;if(!((0|r)>(0|i))){h=0;break i}}if(!r)break o;if((0|r)<(0|i))break l;break o}if((0|r)>=(0|i))break o}if(h=0,(0|E)%10|(0|b(r,10))<(0|i))break i;i=i-r|0,C=r;break A}if((0|i)>=(0|C)){h=0;break i}E=r+E|0}if(h=o[0|u],u=l=u+1|0,r=i,c=f,32==(0|h))break}r=o[0|l]}else l=u;if((r<<24>>24)-48>>>0<10)h=0;else if((0|(r=i+E|0))<A[e+120>>2])h=0;else if((0|r)>A[e+116>>2])h=0;else if(Mn(e,85600,I+176|0),i=d,4&o[e+107|0]||(i=rn(d,i=I+176|0)+Hn(i)|0),A[I+4>>2]=A[e+140>>2],A[I>>2]=r,En(I+16|0,85839,I),h=0,46!=o[0|l]){Et(e,y,l,n,1)&&(A[n>>2]=32768|A[n>>2]),u=0;A:if(8&o[e+107|0]){if(c=A[n>>2],26741==A[e+212>>2]){if(32768&c)break A;if(!(16384&c))break i;u=1,c=0;o:{l:switch(o[0|l]-97|0){case 0:case 4:break l;default:break o}l:{u:{c:{d:switch((C=o[l+1|0])-116|0){case 6:break o;case 1:case 2:case 3:case 4:case 5:break u;case 0:break d;default:break c}if(116!=o[l+2|0])break l;break o}if(32==(0|C))break o}if(!((0|r)%1e3|0)&&108==(0|C))break o}c=1}if(c)break A;break i}A[n>>2]=32768|c}A[(r=e+8232|0)>>2]=0,A[r+4>>2]=0,ue(e,I+16|2,i,I+216|0,n,u),h=1,4&o[e+107|0]&&Es(d,I+176|0)}}U=I+224|0,h?(A[s+1832>>2]=8192|A[s+1832>>2],l=1):l=0}}if(C=k?x:32&S?1:x,x=0,!(!(1&p)|(0|w)<2)&&Br(A[s+168>>2])){i:{if(1&a[188785]){if(!(!(r=8192&(i=A[s+1832>>2]))|l))break i;x=r>>>2^2048;break a}if(l)break s;i=A[s+1832>>2]}if(!(128&i|w>>>0>3)&&!((0|(i=A[e+8220>>2]))<4)&&(r=1,(0|i)>=A[e+8216>>2]))break t}}if(d=0,(0|C)<=0)break r;r=C;break t}if((0|(r=C))>0)break t;d=0,f=0,c=0,h=0;break n}if(l)f=0,c=0,h=0;else{r=A[s+1840>>2],A[s+1820>>2]=r,i=999,h=0,f=0,m=0;r:{s:{a:{for(;;){i:{A:{o:{if(i-1>>>0>=2){if((0|w)<2)break o;if(Ht(s+1408|0,r),(0|(i=A[s+1408>>2]))<577&A[e+600>>2]>0)break o;if(i=at(i),(A[i+4>>2]!=A[e+600>>2]?i:0)|1==A[e+40>>2])break o;i=o[0|r],A[s+1408>>2]=i<<24>>24;l:switch(i-32|0){default:if(!i)break o;break;case 0:case 7:break o;case 1:case 2:case 3:case 4:case 5:case 6:}d=Ht(s+1408|0,r),k=9;l:{u:{c:{d:if(-33&(i=A[s+1408>>2])){for(l=0,c=0;;){h:{f:{if(39==(0|i)){if((0|f)>0|(0|l)>1)break d;if(c=l?c:39,3!=A[e+40>>2])break f;break h}c=l?c:i}l=l+1|0}if(!On(e,i)){if(39!=(0|(i=A[s+1408>>2]))&&!Br(i))break o;if(d=Ht(s+1408|0,r+d|0)+d|0,-33&(i=A[s+1408>>2]))continue;break d}break}if((0|l)<=2)break c;k=l}else c=0;if(2!=(0|(i=A[e+40>>2])))break u;U=i=U-208|0,a[0|i]=0,l=o[0|(u=r-1|0)],a[0|u]=32,r=be(e,r,i,200,0,-2147483648,0),a[0|u]=l,U=i+208|0,r=!r|(32768&r)>>>15;break l}i=A[e+40>>2],k=l}r=(a[e+168|0]+1|0)<(k-((0|i)==(0|c))|0)}if(!r)break o;r=A[s+1820>>2]}if(39!=o[0|r])break A;h=67108864,x=0}if(d=0,Mt(e,s+992|0,0,f),r=A[s+1820>>2],32!=(0|(i=o[0|r])))break i;f=0,c=0;break n}if(x=0,r=we(e,r,s+992|0,1&(m|=(0|f)>0))+A[s+1820>>2]|0,A[s+1820>>2]=r,21==o[s+992|0])break a;for(f=f+1|0,l=0;l=(i=l)+1|0,32!=o[r+i|0];);h=67108864;continue}break}if(!o[s+992|0]|39==(0|i)||(a[r-1|0]=32,r=A[s+1820>>2]),u=be(e,r,s+1616|0,200,s+784|0,p,s+1832|0),21==(0|(r=o[s+1616|0]))){rn(189088,s+1616|0),i=0;break e}if(!(r|o[s+784|0])&&(Ht(s+1408|0,A[s+1820>>2]),1==(0|w)&&(fn(A[s+1408>>2])||rr(A[s+1408>>2])))){Pn(e,A[s+1820>>2],s+1616|0,C)&&rn(189088,s+1616|0),i=0;break e}A[s+172>>2]=a[A[s+1820>>2]-1|0];i:if(1024&u)for(y=s+176|1,C=0,i=1,m=0,f=0;;){if((k=131072&u)|!(1&i)||(a[s+1408|0]=0,!(r=be(e,A[s+1820>>2],s+1408|0,200,s+576|0,805306368|p,s+1832|0)))){2048&u&&(A[e+8184>>2]=1),a[A[s+1820>>2]-1|0]=A[s+172>>2];A:{o:{l:{u:if(k){if(a[s+176|0]=0,i=A[s+1820>>2],r=1,c=63&u){if(I=1&u,f=c-1|0,l=0,1!=(0|c))for(E=c-I|0,c=0;d=i,A[s+1820>>2]=i+1,a[0|(v=(s+176|0)+r|0)]=(0|l)!=(0|f)?o[0|i]:0,i=i+2|0,A[s+1820>>2]=i,a[v+1|0]=(0|f)!=(1|l)?o[d+1|0]:0,l=l+2|0,r=r+2|0,(0|E)!=(0|(c=c+2|0)););I&&(c=i+1|0,A[s+1820>>2]=c,a[(s+176|0)+r|0]=(0|l)!=(0|f)?o[0|i]:0,r=r+1|0,i=c)}a[(s+176|0)+r|0]=0}else{if(i=A[s+1820>>2],!(c=15&u))break l;if(r=0,l=c,d=3&u)for(;i=i+1|0,A[s+1820>>2]=i,128==(192&o[0|i])||(l=l-1|0,(0|d)!=(0|(r=r+1|0))););if(c>>>0<4)break u;for(;;)if(i=i+1|0,A[s+1820>>2]=i,128!=(192&o[0|i])){for(;i=i+1|0,A[s+1820>>2]=i,128==(192&o[0|i]););for(;i=i+1|0,A[s+1820>>2]=i,128==(192&o[0|i]););for(;i=i+1|0,A[s+1820>>2]=i,128==(192&o[0|i]););if(r=(0|l)>4,l=l-4|0,!r)break}}if(r=i-1|0,A[s+172>>2]=a[0|r],a[0|r]=32,r=p|=8388608,!k)break o;if(fs(s+576|0,s+784|0,12),A[s+1852>>2]=y,r=rn(s+1200|0,i=s+1616|0),He(e,s+1852|0,i,s+1832|0,0,n)&&rn(r,s+1616|0),!(32&o[s+1833|0]))break A;a[0|r]=0,Pn(e,A[s+1852>>2],r,1);break A}r=i-1|0,A[s+172>>2]=a[0|r],a[0|r]=32,r=8388608|p}p=r,Es(s+1200|0,s+784|0)}if(a[s+784|0]=0,c=1,r=He(e,s+1820|0,s+1616|0,s+1824|0,1024,n),A[s+1832>>2]||(i=A[s+1828>>2],A[s+1832>>2]=A[s+1824>>2],A[s+1836>>2]=i,c=m),r){d=0,f=u;break r}if(d=be(e,A[s+1820>>2],s+1616|0,200,s+784|0,8404992&p,s+1832|0),i=1,f=u,m=c,21==o[s+1616|0]){a[A[s+1820>>2]-1|0]=A[s+172>>2],rn(189088,s+1616|0),i=0;break e}}else i=s+416|0,ye(e,A[s+1820>>2],r,i),d=be(e,A[s+1820>>2],s+1616|0,200,s+784|0,268435456|p,s+1832|0),Je(A[s+1820>>2],i,Hn(i)),1024&d||(rn(s+1616|0,s+1408|0),i=rn(s+784|0,s+576|0),8&o[188788]&&(St(c=i,i=s+576|0),u=A[47195],A[s+48>>2]=i,ts(u,85205,s+48|0)),d=r),i=0;if(r=(l=1024&d)>>>10|0,C>>>0>48)break i;if(C=C+1|0,u=d,!l)break}else d=u,f=0,m=0,r=0;if(r|!d)break s;for(u=rn(s+1408|0,s+1616|0),l=ye(e,A[s+1820>>2],d,s+416|0),c=m,i=d;;){i:{if(a[s+1616|0]=0,o[s+1200|0]){if(a[A[s+1820>>2]-1|0]=A[s+172>>2],r=He(e,s+1840|0,s+1616|0,s+1824|0,l,n),a[A[s+1820>>2]-1|0]=32,21==o[s+1616|0]){e=s+416|0,Je(A[s+1820>>2],e,Hn(e)),rn(189088,s+1616|0),i=0;break e}if(A[s+1832>>2]||(m=A[s+1828>>2],A[s+1832>>2]=A[s+1824>>2],A[s+1836>>2]=m),r){a[s+1200|0]=0;break i}c=A[s+1824>>2]?1:c}if(r=He(e,s+1820|0,s+1616|0,s+1824|0,l,n),21==o[s+1616|0]){e=s+416|0,Je(A[s+1820>>2],e,Hn(e)),rn(189088,s+1616|0),i=0;break e}if(A[s+1832>>2]||(m=A[s+1828>>2],A[s+1832>>2]=A[s+1824>>2],A[s+1836>>2]=m),!r)if(16384&i)rn(s+1616|0,u);else{p|=l<<11&8192|i<<9&134217728;A:if(524288&i){if(m=rn(s+576|0,r=s+784|0),i=be(e,A[s+1820>>2],s+1616|0,200,r,p,s+1832|0),Es(r,m),r=0,!i){i=0;break A}if(1024&i)break A;r=1,l=ye(e,A[s+1820>>2],i,0)}else i=0,be(e,A[s+1820>>2],s+1616|0,200,0,p,s+1832|0),r=0;if(21==o[s+1616|0]){rn(189088,s+1616|0),e=s+416|0,Je(A[s+1820>>2],e,Hn(e)),a[A[s+1820>>2]-1|0]=A[s+172>>2],i=0;break e}if(r)continue}}break}65536&d||(an(e,s+1616|0,200,s+784|0),a[s+784|0]=0),r=s+416|0,Je(A[s+1820>>2],r,Hn(r));break r}rn(189088,e=s+992|0),i=!Sn(1|e,84744,3)<<12;break e}d=0,c=m}a[A[s+1820>>2]-1|0]=A[s+172>>2]}}if(r=A[s+164>>2],A[s+1852>>2]=8026656,A[s+1848>>2]=8022304,A[s+1844>>2]=7566112,4&p){n:{if(i=255&r){if(102==(0|i))break n;if(B=D,is(r<<24>>24))break n}B=T}be(e,B,189088,200,0,0,0)}for(r=0,i=s+1200|0,m=o[s+784|0];;){n:{r:{s:switch(0|(u=o[0|i])){case 0:break n;case 6:case 7:break s;default:break r}r=u}i=i+1|0;continue}break}n:if(r|c){if(A[e+32>>2]|65536&f){for(l=0,Ae(e,s+1616|0,s+1832|0,3,0),i=s+1200|0;;){r:switch(o[0|i]){case 6:l&&(a[0|i]=5),l=1;default:i=i+1|0;continue;case 0:}break}A[s+24>>2]=s+1616,A[s+20>>2]=s+1200,A[s+16>>2]=s+992,Cn(189088,200,85233,s+16|0),a[189287]=0,Ae(e,189088,s+1832|0,-1,0);break n}A[s+8>>2]=s+1616,A[s+4>>2]=s+1200,A[s>>2]=s+992,Cn(189088,200,85233,s),a[189287]=0,Ae(e,189088,s+1832|0,-1,0)}else Ae(e,r=s+1616|0,s+1832|0,-1,!!(0|m)<<1),A[s+40>>2]=r,A[s+36>>2]=s+1200,A[s+32>>2]=s+992,Cn(189088,200,85233,s+32|0),a[189287]=0;o[s+784|0]&&(r=Hn(189088),a[983+(s-r|0)|0]=0,rn(r+189088|0,s+784|0)),16&(r=p|x)&&(A[s+1832>>2]=-268435457&A[s+1832>>2]);n:if(!(128&r)|!(16&o[e+14|0]))if(3072&r){if(ct(e,6),!(2048&r))break n;A[s+1832>>2]=268435456|A[s+1832>>2]}else 16&o[b(A[33264],12)+n|0]&&(1536&(n=A[s+1832>>2])?ct(e,4):2048&n&&ct(e,3));else ct(e,3);8192&d&&(A[e+8192>>2]=2,A[e+8184>>2]=2);n:{if(8&(n=A[s+1836>>2]))A[e+8184>>2]=0,A[e+8188>>2]=3,r=e+8196|0;else if(1&n)A[e+8192>>2]=0,A[e+8184>>2]=2,r=e+8196|0;else if(2&n)A[e+8192>>2]=2,A[e+8184>>2]=0,A[e+8188>>2]=0,r=e+8196|0;else{if(!(4&n))break n;A[e+8184>>2]=0,A[e+8192>>2]=0,A[e+8196>>2]=2,r=e+8188|0}A[r>>2]=0}!o[A[s+1820>>2]]|256&n||((0|(n=A[e+8184>>2]))>0&&(A[e+8184>>2]=n-1),(0|(n=A[e+8192>>2]))>0&&(A[e+8192>>2]=n-1),(0|(n=A[e+8196>>2]))>0&&(A[e+8196>>2]=n-1),(0|(n=A[e+8188>>2]))<=0||(A[e+8188>>2]=n-1)),1!=(0|w)|25966!=A[e+212>>2]||!Br(A[s+168>>2])|105==A[s+168>>2]||(A[s+1832>>2]=16777216|A[s+1832>>2]);n:if(2&o[e+68|0]&&98304&(r=A[s+1832>>2])&&!((0|(n=Hn(189088)-1|0))<=0))for(i=0;;){if(e=i+1|0,6==o[i+189088|0]){n=a[0|(e=e+189088|0)];r:{if(65536&r){if((0|Ir(69))==(0|n)?(w=Ir(101),a[0|e]=w):w=o[0|e],l=111,(0|Ir(79))==w<<24>>24)break r;break n}if((0|Ir(101))==(0|n)?(w=Ir(69),a[0|e]=w):w=o[0|e],l=79,(0|Ir(111))!=w<<24>>24)break n}a[0|e]=Ir(l);break n}if((0|n)==(0|(i=e)))break}e=A[s+1832>>2],Je(t,s+256|0,M),i=e|h;break e}if(i=0,a[s+1616|0]=0,Pn(e,A[s+1840>>2],s+1616|0,r)){if(u=rn(189088,s+1616|0),!v){if(r=A[s+164>>2],A[s+1408>>2]=8026656,A[s+576>>2]=8022304,A[s+416>>2]=7566112,4&p){t=s+576|1,n=s+1408|1;t:{if(i=255&r){if(102==(0|i))break t;if(m=t,is(r<<24>>24))break t}m=n}be(e,m,u,200,0,0,0)}i=128&A[s+1832>>2]}}else i=((0|w)>1)<<12}else a[189088]=0;return U=s+1856|0,i}function re(e,t,n,r,s,i,l,u){var c,d,h=0,f=0,g=0,p=0,m=0,C=0,I=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0,N=0,G=0,F=0,P=0,Q=0,z=0,O=0,R=0,L=0,W=0,_=0,V=0,H=0,j=0,Y=0,K=0,X=0,q=0,Z=0,J=0,$=0,ee=0,te=0;U=c=U-384|0,d=A[t>>2];e:{t:{n:{r:{if(s){if(7!=o[0|s])break r;A[t>>2]=(r||1)+d;break n}A[i>>2]=0,A[t>>2]=d+1;break e}F=86135,_=268435456&l,V=134217728&l,H=8388608&l,j=16384&l,Y=8192&l,z=n-1|0,O=r-n|0,K=2&l,X=128&l,q=l>>>31|0,Z=-2147483648&l,R=c+96|1;r:for(;;)for(A[c+268>>2]=0,I=(g=A[t>>2])+r|0,M=-2,E=-6,n=s,D=Z,S=0,P=0,B=1,h=0,T=0,G=0;;){p=g,w=h;s:{a:{i:{A:{o:{l:{u:{c:{d:{h:{f:{g:{p:{m:{b:{C:{for(;x=n,n=n+1|0,!((f=o[0|x])>>>0>9);){m=n;I:switch(0|f){case 0:if(!(n=L)){L=0,n=86135;break b}for(;;){f=1;w:{k:switch(0|(h=o[0|n])){case 0:case 3:break C;case 5:break k;default:break w}f=2}n=(n+f|0)+((9==(0|h))<<1)|0}case 1:if(G=1,!q)continue;break o;case 2:G=2;continue;case 4:L=n;continue;case 5:n=x+2|0,h=A[e+320>>2];w:{if((g=o[x+1|0])>>>0>=32){if(!(h>>>g-32&1))break w;break o}if(!(h>>>g&1))break o}B=B+1|0;continue;case 9:n=x+3|0;continue;case 8:G=1,P=1,D=0;break;case 3:break m}}m=0,h=w,g=p;I:switch(0|G){case 0:w:{k:{if((0|(h=o[0|I]))!=(0|f)){if(69!=(0|h))break o;if(101==(0|f))break k;break o}if(m=0,128==(192&f))break w}m=21}I=I+1|0,S=S+1|0;break s;case 1:break p;case 2:break I;default:break h}if(A[c+264>>2]=A[c+268>>2],!o[I-1|0])break o;E=(0|(h=E+6|0))>=19?19:h,v=I+1|0,y=Ht(c+268|0,I),k=o[0|I],m=20,h=w;I:{w:switch(f-11|0){case 6:n=x+2|0,h=A[c+268>>2],g=a[x+1|0];k:if(f=A[604+(((g=((0|g)<65?191:-65)+g|0)<<2)+e|0)>>2])h=!!(0|Fr(f,h));else{if((0|g)>7)break o;x:{if((0|(f=A[e+600>>2]))>0){if((h=h-f|0)-1>>>0<255)break x;break o}if((f=h-192|0)>>>0<=413){h=o[344+(o[f+94240|0]+e|0)|0]&1<<g;break k}if(h>>>0>255)break o}h=o[344+(e+h|0)|0]&1<<g}if(!h)break o;I=I+y|0,m=(2==(0|g)?19:20)-E|0;break s;case 7:if(n=x+2|0,h=a[x+1|0],!(h=A[4788+((((0|h)<65?191:-65)+h<<2)+e|0)>>2]))break o;k:for(;;){if(7==(0|(m=o[0|h])))break o;if(126==(0|m)){m=20-E|0;break s}x:if(k){if(C=I,f=h,(0|m)==(0|k))for(;;){if((0|(m=o[0|(f=f+1|0)]))!=(0|(h=o[0|(C=C+1|0)])))break x;if(!h)break}}else f=h,C=I;if(m)for(;;)if(g=o[0|f],f=h=f+1|0,!g)continue k;break}if((0|(h=C-I|0))<0)break o;I=h+I|0,m=20-E|0;break s;case 14:f=A[c+268>>2];k:{x:if(h=A[e+604>>2])h=!!(0|Fr(h,f));else{y:{if((0|(h=A[e+600>>2]))>0){if((C=f-h|0)-1>>>0<255)break y;break k}if((h=f-192|0)>>>0<=413){h=1&a[344+(o[h+94240|0]+e|0)|0];break x}if(C=f,f>>>0>255)break a}h=1&a[344+(e+C|0)|0]}if(h)break o;f=A[c+268>>2]}if(!V)break a;if(32==(0|f))break o;break a;case 4:if((h=A[c+268>>2])-48>>>0<10|h-2406>>>0<10)break a;if(!o[e+170|0])break o;m=20-E|0;break s;case 5:if(Rr(A[c+268>>2]))break o;break i;case 0:if(A[c+268>>2]==A[c+264>>2])break i;break o;case 17:n=x+2|0,h=32768,m=0;k:{x:switch((f=o[x+1|0])-1|0){case 0:break h;case 1:break x;default:break k}if(m=1,h=w,!H)break h;break o}if(16==(0|(h=240&f))){if(m=23,h=w,u>>>(15&f)&16384)break h;break o}if(3!=(0|f)&32!=(0|h))break s;if(Je(h=c+96|0,z,g=1+(A[t>>2]+(S+O|0)|0)|0),a[0|(h=h+g|0)]=32,a[h+1|0]=0,A[33265]=0,A[33266]=0,A[c+16>>2]=R,He(e,c+16|0,c+272|0,133060,0,0),m=23,!(3!=(0|f)|(0|(C=A[33265]))>=0|16384&A[33266]))break s;if(h=w,g=p,C>>>(15&f)&16384)break h;break o;case 34:k:{if(h=k-32|0){if(13==(0|h))break k;break o}if(!j)break o}C=22-E|0;break A;case 10:if(h=1,21==o[0|n])break I;break l;case 18:if(32!=(0|(C=A[c+268>>2])))for(f=I+y|0;;){k:{x:if(h=A[e+632>>2])h=!!(0|Fr(h,C));else{y:{if((0|(h=A[e+600>>2]))>0){if((C=C-h|0)-1>>>0<255)break y;break k}if((h=C-192|0)>>>0<=413){h=128&o[344+(o[h+94240|0]+e|0)|0];break x}if(C>>>0>255)break k}h=128&o[344+(e+C|0)|0]}if(h)break o}if(f=Ht(c+268|0,f)+f|0,32==(0|(C=A[c+268>>2])))break}C=19-E|0;break A;case 49:break u;case 2:break c;case 3:break d;case 1:break h;case 13:break f;case 12:break w;default:break g}Ht(c+272|0,n),y=-1;w:if((0|(h=A[c+272>>2]))!=(0|(f=A[c+268>>2])))if(-33&f)for(;;){k=I,y=-1;k:if(18==(0|h)&&(h=a[x+2|0],m=A[4788+((((0|h)<65?191:-65)+h<<2)+e|0)>>2])){for(;;){if(7==(0|(g=o[0|m])))break k;if(126==(0|g)){y=0;break k}x:if((0|(I=o[0|k]))==(0|g)){if(h=k,f=m,I)for(;;){if((0|(g=o[0|(f=f+1|0)]))!=(0|(m=o[0|(h=h+1|0)])))break x;if(!m)break}}else f=m,h=k;if(!g){h=h-k|0;break}for(;h=o[0|f],f=m=f+1|0,h;);}y=h}if(g=Ht(c+268|0,k),(0|(h=A[c+272>>2]))==(0|(f=A[c+268>>2]))|!(-33&f))break w;if(I=g+k|0,-1!=(0|y))break}else k=I;else k=I;I=(0|h)==(0|f)||(0|y)>=0?k:v,m=0;break s}for(;h=h+1|0,21==o[0|(n=n+1|0)];);break l}n=n+1|0}m=x}if(!(32!=o[p-1|0]&P|D||((0|(f=P?B+4|0:B))>=(0|Q)&&(J=T,$=w,Q=f,ee=S,F=n),!(8&A[47197])|_|(0|f)<=0))){for(St(n,x=c+272|0),v=A[47195],g=c+16|0,n=0,k=0,D=0,T=0,U=I=U-496|0,a[I+80|0]=0,(0|r)>0?(Je(I+288|0,d,r),w=r):w=0,a[w+(h=I+288|0)|0]=0,p=Hn(h)+h|0,y=(0|l)<0;;){if(C=o[0|s],w=s,s=s+1|0,C>>>0>9)for(;;){m:{b:{C:{I:{w:{k:switch((h=255&C)-14|0){case 4:break C;case 3:break I;case 0:break w;case 14:break k;default:break b}if(w=w+2|0,C=32,!y&1==(0|(s=o[0|s])))break m;a[0|p]=36,rn(h=p+1|0,s=br(128960,s)),p=Hn(s)+h|0;break m}h=o[w+2|0],C=o[0|s],A[I+36>>2]=127&o[w+3|0],A[I+32>>2]=4&h?80:83,En(I+48|0,85131,I+32|0),1&h&&(s=Hn(s=I+48|0)+s|0,a[0|s]=101,a[s+1|0]=0),2&(s=127&h)&&(h=Hn(h=I+48|0)+h|0,a[0|h]=105,a[h+1|0]=0),4&s&&(h=Hn(h=I+48|0)+h|0,a[0|h]=112,a[h+1|0]=0),8&s&&(h=Hn(h=I+48|0)+h|0,a[0|h]=118,a[h+1|0]=0),16&s&&(h=Hn(h=I+48|0)+h|0,a[0|h]=100,a[h+1|0]=0),32&s&&(h=Hn(h=I+48|0)+h|0,a[0|h]=102,a[h+1|0]=0),s>>>0>=64&&(s=Hn(s=I+48|0)+s|0,a[0|s]=113,a[s+1|0]=0),1&C&&(s=Hn(s=I+48|0)+s|0,a[0|s]=116,a[s+1|0]=0),w=w+4|0,p=rn(p,s=I+48|0)+Hn(s)|0,C=32;break m}w=w+2|0,C=o[a[0|s]+93871|0];break m}s=a[0|s],a[0|p]=76,h=((s=s+((0|s)<65?191:-65)|0)>>>0)/10|0,a[p+1|0]=h+48,C=s-b(h,10)|48,1==(0|T)&&(a[0|p]=C,C=76),w=w+2|0,p=p+2|0;break m}C=h>>>0<=31?o[h+93904|0]:32==(0|h)?95:C,w=s}if(a[0|p]=C,s=w+1|0,p=p+1|0,!((C=o[0|w])>>>0>=10))break}h=1;m:switch(0|C){case 1:h=n;case 8:a[0|p]=0,p=I+80|0,n=h,T=1;continue;case 2:a[0|p]=0,w=Hn(h=I+288|0)+h|0,p=o[84899]|o[84900]<<8,a[0|w]=p,a[w+1|0]=p>>>8,T=2,a[w+2|0]=o[84901],p=Hn(h)+h|0;continue;case 5:k=a[0|s],s=w+2|0;continue;case 9:D=(o[0|s]+b(o[w+2|0],255)|0)-256|0,s=w+3|0;continue;case 0:case 3:break m;default:continue}break}if(a[0|p]=0,p=g,(0|D)>0&&(A[I+16>>2]=D,En(g,85581,I+16|0),p=g+7|0),(0|k)>0&&(A[I>>2]=k,En(p,85694,I),p=Hn(p)+p|0),1&((0|(s=Hn(I+80|0)))>0|n)){1&n&&(a[0|p]=95,p=p+1|0);m:if(!((0|(w=s-1|0))<0|p>>>0>=g>>>0))for(;;){if(a[0|p]=o[(I+80|0)+w|0],p=p+1|0,(0|w)<=0)break m;if(w=w-1|0,!(p>>>0<g>>>0))break}a[0|p]=41,a[p+1|0]=32,p=p+2|0}a[0|p]=0,a[(n=I+288|0)+((g+3|0)-p|0)|0]=0,Es(p,n),(0|(n=Hn(g)))<=7&&(kt(n+g|0,32,8-n|0),n=8),a[n+g|0]=0,U=I+496|0,A[c+4>>2]=g,A[c>>2]=(0|r)>1?f+35|0:f,A[c+8>>2]=x,ts(v,89088,c)}n=m;break o}if(!o[0|p])break o;M=(0|(h=M+2|0))>=19?19:h,Ht(c+264|0,p),h=_t(c+268|0,g=p-1|0),k=o[0|g],v=g;p:{m:{b:{C:{I:{w:switch(f-10|0){case 13:if(h=(0|(N=o[0|n]))==(0|(f=o[0|p])),y=-1,32==(0|f)|(0|f)==(0|N))break C;if(f)break I;break b;case 7:n=x+2|0,m=A[c+268>>2],p=a[x+1|0];k:if(f=A[604+(((p=((0|p)<65?191:-65)+p|0)<<2)+e|0)>>2])f=!!(0|Fr(f,m));else{if((0|p)>7)break o;x:{if((0|(f=A[e+600>>2]))>0){if((m=m-f|0)-1>>>0<255)break x;break o}if((f=m-192|0)>>>0<=413){f=o[344+(o[f+94240|0]+e|0)|0]&1<<p;break k}if(m>>>0>255)break o}f=o[344+(e+m|0)|0]&1<<p}if(!f)break o;g=1+(g-h|0)|0,m=(2==(0|p)?19:20)-M|0;break p;case 8:if(n=x+2|0,h=a[x+1|0],!(h=A[4788+((((0|h)<65?191:-65)+h<<2)+e|0)>>2]))break o;k:{for(;;){if(7==(0|(k=o[0|h])))break o;if(126==(0|k)){y=0;break k}f=g;x:{y:{if((0|(x=(y=Hn(h))-1|0))>0)for(f=p-y|0,m=0,C=g;;){if(!o[0|(C=C-1|0)])break y;if((0|x)==(0|(m=m+1|0)))break}v:if(!((0|(m=o[0|f]))!=(0|k)|!m))for(;;){if((0|(k=o[0|(h=h+1|0)]))!=(0|(m=o[0|(f=f+1|0)])))break v;if(!m)break}if(!k)break x}for(f=h;m=o[0|f],f=h=f+1|0,m;);continue}break}if((0|y)<0)break o}m=20-E|0,g=1+(g-y|0)|0;break p;case 15:f=A[c+268>>2];k:{x:if(p=A[e+604>>2])p=!!(0|Fr(p,f));else{y:{if((0|(p=A[e+600>>2]))>0){if((f=f-p|0)-1>>>0<255)break y;break k}if((p=f-192|0)>>>0<=413){p=1&a[344+(o[p+94240|0]+e|0)|0];break x}if(f>>>0>255)break k}p=1&a[344+(e+f|0)|0]}if(p)break o}m=20-M|0,g=1+(g-h|0)|0;break p;case 1:if(A[c+268>>2]!=A[c+264>>2])break o;m=21-M|0,g=1+(g-h|0)|0;break p;case 5:if(!((p=A[c+268>>2])-48>>>0<10|p-2406>>>0<10))break o;m=21-M|0,g=1+(g-h|0)|0;break p;case 6:if(Rr(A[c+268>>2]))break o;m=21-E|0,g=1+(g-h|0)|0;break p;case 18:if(n=x+2|0,!(3==(0|(f=o[x+1|0]))|32==(240&f)))break s;if(Je(h=c+96|0,z,g=1+(A[t>>2]+(S+O|0)|0)|0),a[0|(h=h+g|0)]=32,a[h+1|0]=0,A[33265]=0,A[33266]=0,A[c+16>>2]=R,He(e,c+16|0,c+272|0,133060,0,0),m=23,!(3!=(0|f)|(0|(C=A[33265]))>=0|16384&A[33266]))break s;if(h=w,g=p,C>>>(15&f)&16384)break h;break o;case 11:if(f=1,21==o[0|n])for(;f=f+1|0,21==o[0|(n=n+1|0)];);if(A[e+8208>>2]<(0|f))break o;m=18+(f-M|0)|0;break p;case 0:if(m=19,h=w,g=p,A[e+8212>>2]>0)break h;break o;case 19:if(m=3,32==(0|(C=A[c+268>>2])))break p;for(f=1+(g-h|0)|0;;){k:{x:if(h=A[e+632>>2])h=!!(0|Fr(h,C));else{y:{if((0|(h=A[e+600>>2]))>0){if((C=C-h|0)-1>>>0<255)break y;break k}if((h=C-192|0)>>>0<=413){h=128&o[344+(o[h+94240|0]+e|0)|0];break x}if(C>>>0>255)break k}h=128&o[344+(e+C|0)|0]}if(h)break o}if(f=f-_t(c+268|0,f-1|0)|0,32==(0|(C=A[c+268>>2])))break}break p;case 16:if(m=1,h=w,g=p,A[e+8184>>2])break h;break o;case 9:if(m=1,h=w,g=p,K)break h;break o;case 36:for(;;){if(m=50,h=w,!(p=(255&k)-32|0))break o;if(14==(0|p))break h;k=o[0|(v=v-1|0)]}case 35:break w;default:break m}w:{if(h=k-32|0){if(13==(0|h))break w;break o}if(!X)break o}m=22-E|0;break p}I:{for(;;){y=-1,C=p,p=p-1|0;w:if(18==(0|N)&&(h=a[x+2|0],m=A[4788+((((0|h)<65?191:-65)+h<<2)+e|0)>>2]))for(te=C+1|0;;){if(7==(0|(v=o[0|m]))){y=-1;break w}if(126==(0|v)){y=0;break w}f=C;k:{if((0|(W=(y=Hn(m))-1|0))>0)for(f=te-y|0,k=0,h=C;;){if(!o[0|(h=h-1|0)])break k;if((0|W)==(0|(k=k+1|0)))break}x:if(!((0|(h=o[0|f]))!=(0|v)|!h))for(;;){if((0|(v=o[0|(m=m+1|0)]))!=(0|(h=o[0|(f=f+1|0)])))break x;if(!h)break}if(!v)break w}for(f=m;h=o[0|f],f=m=f+1|0,h;);}if(h=(0|(f=o[0|p]))==(0|N),32==(0|f)|(0|f)==(0|N))break I;if(!f){p=C;break b}if(-1!=(0|y))break}p=C;break b}p=C}g=h?p:g}m=0,g=(0|y)<0?g:p+1|0;break p}if((0|f)!=(0|k))break o;m=4,32!=(0|f)&&(m=128!=(192&f)?21-M|0:0)}h=w;break h}if((0|f)!=(0|k))break o;C=128!=(192&f)?21-E|0:0;break A}if(m=1,Y)break o}B=m+B|0;continue}if(h=a[x+1|0],w=o[x+3|0],g=o[x+2|0],1&!(A[e+8208>>2]|4&g)&a[e+84|0])break o;n=x+4|0,C=0,w=127&w|(127&g)<<8|h<<16;break A}c:if(!(v>>>0<=(f=A[t>>2]+r|0)>>>0)){for(;;){if(101!=o[0|f]){if(h=f>>>0<I>>>0,f=f+1|0,h)continue;break c}break}C=0,T=f;break A}C=0;break A}m=-20;break s}if(k=0,32!=(0|(f=A[c+268>>2])))for(C=I+y|0,m=0;;){if(!m){l:{u:if(g=A[e+632>>2])f=!!(0|Fr(g,f));else{c:{if((0|(g=A[e+600>>2]))>0){if((f=f-g|0)-1>>>0<255)break c;break l}if((g=f-192|0)>>>0<=413){f=128&o[344+(o[g+94240|0]+e|0)|0];break u}if(f>>>0>255)break l}f=128&o[344+(e+f|0)|0]}f&&(k=k+1|0)}f=A[c+268>>2]}l:if(g=A[e+632>>2])m=!!(0|Fr(g,f));else{u:{if((0|(g=A[e+600>>2]))>0){if(m=0,(f=f-g|0)-1>>>0<255)break u;break l}if((g=f-192|0)>>>0<=413){m=128&o[344+(o[g+94240|0]+e|0)|0];break l}if(m=0,f>>>0>255)break l}m=128&o[344+(e+f|0)|0]}if(C=Ht(c+268|0,C)+C|0,32==(0|(f=A[c+268>>2])))break}if(!((0|h)>(0|k))){C=18+(h-E|0)|0;break A}}for(;h=o[0|n],n=s=n+1|0,h;);if(7!=o[0|s])continue r;if(e=r+ee|0,A[t>>2]=A[t>>2]+(e||1),Q)break t;break n}h=w,I=v,g=p,B=C+B|0;continue}I=I+y|0,m=21-E|0;break s}I=I+y|0,m=20-E|0}h=w,g=p,B=m+B|0}}F=86135}A[i+12>>2]=J,A[i+8>>2]=$,A[i+4>>2]=F,A[i>>2]=Q}U=c+384|0}function se(e,t){var n,r=0,s=0,l=0,u=0,c=0,d=0,h=0,f=0,p=0,m=0,C=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0,N=0,G=0,F=0,P=0,Q=0,z=0,O=0,R=0;U=n=U-1168|0,A[n+928>>2]=0,A[n+932>>2]=0,A[n+920>>2]=0,A[n+924>>2]=0,A[n+912>>2]=0,A[n+916>>2]=0,A[n+904>>2]=0,A[n+908>>2]=0,A[n+896>>2]=0,A[n+900>>2]=0;e:{t:{if(e){if(o[0|e]|8&t)break t;break e}if(!(8&t))break e}if(fs(n+1088|0,e,40),16&t){if((0|Ar(rn(n+704|0,e)))<=0)break e;k=8&t}else(k=8&t)|o[n+1088|0]||(i[n+1088>>1]=o[85055]|o[85056]<<8,a[n+1090|0]=o[85057]),A[n+496>>2]=137584,A[n+500>>2]=47,A[n+504>>2]=47,En(r=n+512|0,85286,n+496|0),A[n+484>>2]=n+1088,A[n+480>>2]=r,En(r=n+704|0,85425,n+480|0),(0|Ar(r))>0||(A[n+468>>2]=47,A[n+472>>2]=47,A[n+464>>2]=137584,En(r=n+512|0,85648,n+464|0),A[n+452>>2]=n+1088,A[n+448>>2]=r,En(n+704|0,85425,n+448|0));if(s=k?86012:85055,!(x=et(n+704|0,85712))){if(r=0,3&t)break e;s=(0|Fn(r=n+1088|0))<0?s:r}if((w=2&t)||(r=A[47192])&&(as(r),A[47192]=0),E=rn(n+992|0,s),v=rn(n+944|0,s),w?((r=us(200992,43))&&(a[0|r]=0),A[n+432>>2]=e+3,En(e=n+704|0,86030,n+432|0),Es(200992,e)):(A[32972]=199592,fs(200992,e,40),a[201088]=0,a[201040]=0,A[50299]=200992,A[50298]=201088,A[50297]=201040),Se(w),x){for(M=A[30450],D=n+548|0,T=n+544|0,S=n+540|0,N=n+536|0,G=n+532|0,F=n+528|0,P=12|(e=n+512|0),Q=8|e,z=4|e;yt(n+704|0,190,x);){e=n+704|0;t:{if(35!=o[n+704|0]){n:if(!((0|(e=Hn(n+704|0)-1|0))<=0))for(;;){if(!(32==(0|(s=a[0|(r=(n+704|0)+e|0)]))|s-9>>>0<5))break n;if(a[0|r]=0,!((0|(e=e-1|0))>0))break}if(!(e=De(n+704|0)))break t}a[0|e]=0}e=n+704|0;t:if(r=o[n+704|0])for(;;){if(32==(0|(r=r<<24>>24))|r-9>>>0<5)break t;if(!(r=o[0|(e=e+1|0)]))break}if(a[0|e]=0,o[n+704|0])if(e=e+1|0,r=Nr(129744,n+704|0)){l=0,U=s=U-416|0;t:if(u=A[47192]){n:switch(r-19|0){case 16:if(A[s+32>>2]=s+412,1!=(0|ae(e,84249,s+32|0)))break t;A[u+324>>2]=A[s+412>>2];break t;case 8:dn(e,u+320|0,27);break t;case 2:if(A[s+48>>2]=188784,ae(e,84249,s+48|0),!(e=o[188784]))break t;A[u+152>>2]=e;break t;case 11:if(o[0|e])for(c=A[30450];;)if(r=e,e=e+1|0,!(32==(0|(l=a[0|r]))|l-9>>>0<5)){for(l=kn(r),A[s+412>>2]=l,(0|l)>0&&(l>>>0<=31?A[u+104>>2]=A[u+104>>2]|1<<l:l>>>0<=63?A[u+108>>2]=A[u+108>>2]|1<<l-32:(A[s+64>>2]=l,ts(c,84700,s- -64|0)),r=e);r=(e=r)+1|0,(l=a[0|e])-48>>>0<10|(32|l)-97>>>0<26;);if(!l)break}8&(e=A[u+104>>2])&&(A[u+124>>2]=46,A[u+128>>2]=44),4&e&&(A[u+124>>2]=0);break t;default:if(256!=(65280&r))break t;A[s+16>>2]=24+(u+((255&r)<<2)|0),ae(e,84249,s+16|0);break t;case 1:A[s+144>>2]=u,A[s+148>>2]=u+4,ae(e,85642,s+144|0);break t;case 3:if(r=0,kt(l=s+160|0,0,240),A[s+132>>2]=s+360,A[s+128>>2]=s+320,A[s+124>>2]=s+280,A[s+120>>2]=s+240,A[s+116>>2]=s+200,A[s+112>>2]=l,l=ae(e,85037,s+112|0),A[s+412>>2]=l,A[u+152>>2]=0,(0|l)<=0)break t;for(f=A[30450];;){r:if(mr(c=(s+160|0)+b(r,40)|0,85301)){s:{if((0|(h=A[34454]))>0)for(C=A[34455],e=0;;){if(!mr(c,C+b(e,68)|0))break s;if((0|h)==(0|(e=e+1|0)))break}A[s+96>>2]=c,ts(f,85562,s+96|0),l=A[s+412>>2];break r}a[156+(r+u|0)|0]=e}if(!((0|l)>(0|(r=r+1|0))))break}break t;case 9:A[s+88>>2]=u+20,A[s+84>>2]=u+16,A[s+80>>2]=u+8,ae(e,84778,s+80|0);break t;case 10:dn(e,u+12|0,29);break t;case 5:if((0|(f=xn(e,s+160|0)))<=0)break t;if(r=0,e=0,f>>>0>=4)for(C=-4&f,c=u+304|0;h=s+160|0,i[c+(e<<1)>>1]=A[h+(e<<2)>>2],i[c+((d=1|e)<<1)>>1]=A[h+(d<<2)>>2],i[c+((d=2|e)<<1)>>1]=A[h+(d<<2)>>2],i[c+((d=3|e)<<1)>>1]=A[h+(d<<2)>>2],e=e+4|0,(0|C)!=(0|(l=l+4|0)););if(!(l=3&f))break t;for(;i[304+(u+(e<<1)|0)>>1]=A[(s+160|0)+(e<<2)>>2],e=e+1|0,(0|l)!=(0|(r=r+1|0)););break t;case 6:if((0|(f=xn(e,s+160|0)))<=0)break t;if(r=0,e=0,f>>>0>=4)for(C=-4&f,c=u+296|0;h=s+160|0,a[e+c|0]=A[h+(e<<2)>>2],a[(d=1|e)+c|0]=A[h+(d<<2)>>2],a[(d=2|e)+c|0]=A[h+(d<<2)>>2],a[(d=3|e)+c|0]=A[h+(d<<2)>>2],e=e+4|0,(0|C)!=(0|(l=l+4|0)););if(!(l=3&f))break t;for(;a[296+(e+u|0)|0]=A[(s+160|0)+(e<<2)>>2],e=e+1|0,(0|l)!=(0|(r=r+1|0)););break t;case 7:if((0|(f=xn(e,s+160|0)))<=0)break t;if(r=0,e=0,f>>>0>=4)for(C=-4&f,c=u+304|0;d=h=c+(e<<1)|0,p=g[h>>1],h=s+160|0,i[d>>1]=p+g[h+(e<<2)>>1],i[(p=c+((d=1|e)<<1)|0)>>1]=g[p>>1]+g[h+(d<<2)>>1],i[(p=c+((d=2|e)<<1)|0)>>1]=g[p>>1]+g[h+(d<<2)>>1],i[(p=c+((d=3|e)<<1)|0)>>1]=g[p>>1]+g[h+(d<<2)>>1],e=e+4|0,(0|C)!=(0|(l=l+4|0)););if(!(l=3&f))break t;for(;i[304+(c=u+(e<<1)|0)>>1]=g[c+304>>1]+g[(s+160|0)+(e<<2)>>1],e=e+1|0,(0|l)!=(0|(r=r+1|0)););break t;case 4:a[u+169|0]=1;break t;case 0:}a[u+208|0]=1}else A[s>>2]=br(129568,r),ts(A[30450],89101,s);U=s+416|0}else{t:switch(Nr(131904,n+704|0)-1|0){case 1:if(w)continue;if(a[n+1040|0]=0,A[n+512>>2]=5,A[n+32>>2]=n+1040,A[n+36>>2]=n+512,ae(e,86237,n+32|0),1769103734==A[n+1040>>2]&7630433==A[n+1044>>2])continue;if((e=Hn(n+1040|0)+2|0)>>>0<99-y>>>0&&(a[0|(r=y+201088|0)]=A[n+512>>2],rn(r+1|0,n+1040|0),y=e+y|0),!O){if(e=0,(r=c=n+1040|0)||(r=A[57150])){if(e=86875,A[24+(s=U-32|0)>>2]=0,A[s+28>>2]=0,A[s+16>>2]=0,A[s+20>>2]=0,A[s+8>>2]=0,A[s+12>>2]=0,A[s>>2]=0,A[s+4>>2]=0,u=0,l=o[86875])if(o[86876]){for(;A[(u=s+(l>>>3&28)|0)>>2]=A[u>>2]|1<<l,l=o[e+1|0],e=e+1|0,l;);n:if(l=o[0|(e=r)])for(;;){if(!(A[s+(l>>>3&28)>>2]>>>l&1))break n;if(l=o[e+1|0],e=e+1|0,!l)break}u=e-r|0}else{for(e=r;s=e,e=e+1|0,o[0|s]==(0|l););u=s-r|0}if(o[0|(e=u+r|0)]){r=86875,U=l=U-32|0,s=a[86875];n:if(o[86876]&&s){if(kt(l,0,32),s=o[86875])for(;A[(u=l+(s>>>3&28)|0)>>2]=A[u>>2]|1<<s,s=o[r+1|0],r=r+1|0,s;);if(r=e,s=o[0|e])for(;;){if(A[l+(s>>>3&28)>>2]>>>s&1)break n;if(s=o[r+1|0],r=r+1|0,!s)break}}else r=Jt(e,s);U=l+32|0,o[0|(r=(r-e|0)+e|0)]?(A[57150]=r+1,a[0|r]=0):A[57150]=0}else A[57150]=0,e=0}r=rn(E,e),rn(v,e),Fn(rn(n+896|0,e)),A[47192]=Z(r),fs(A[32972]+40|0,c,20)}O=1;continue;case 0:if(w)continue;for(;r=e,e=e+1|0,32==(0|(s=a[0|r]))|s-9>>>0<5;);fs(201040,r,40);continue;case 2:A[n+1152>>2]=0,r=n+512|0,A[n+48>>2]=r,A[n+52>>2]=n+1152,ae(e,86237,n+48|0),a[201200]=Nr(132112,r),a[201201]=A[n+1152>>2];continue;case 4:A[n+64>>2]=v,ae(e,86939,n- -64|0);continue;case 3:A[n+80>>2]=n+896,ae(e,86939,n+80|0);continue;case 8:if(A[n+1152>>2]=100,A[n+1164>>2]=100,A[n+1148>>2]=100,A[n+112>>2]=n+1144,A[n+1144>>2]=0,A[n+96>>2]=n+512,A[n+100>>2]=n+1152,A[n+104>>2]=n+1164,A[n+108>>2]=n+1148,(0|ae(e,91156,n+96|0))<2)continue;if((e=A[n+512>>2])>>>0>8)continue;if((0|(r=A[n+1152>>2]))>=0&&(s=A[32972]+(e<<1)|0,r=I(m=2.56001*+(0|r))<2147483648?~~m:-2147483648,i[s+236>>1]=r,i[s+164>>1]=r),(0|(r=A[n+1164>>2]))>=0&&(s=A[32972]+(e<<1)|0,r=I(m=2.56001*+(0|r))<2147483648?~~m:-2147483648,i[s+254>>1]=r,i[s+182>>1]=r),(0|(s=A[n+1148>>2]))<0?r=A[32972]:(c=(r=A[32972])+(e<<1)|0,s=I(m=2.56001*+(0|s))<2147483648?~~m:-2147483648,i[c+200>>1]=s),i[218+((e<<1)+r|0)>>1]=A[n+1144>>2],e)continue;i[r+200>>1]=(0|b(i[r+200>>1],105))/100;continue;case 9:if(A[n+132>>2]=n+696,A[n+128>>2]=n+700,2!=(0|ae(e,87106,n+128|0)))continue;if(e=A[32972],r=A[n+700>>2],A[e+64>>2]=(r<<12)-36864,A[e+68>>2]=b(A[n+696>>2]-r|0,108),I(m=256*(+(r-82|0)/82*.25+1))<2147483648){A[e+116>>2]=~~m;continue}A[e+116>>2]=-2147483648;continue;case 35:R||Fn(n+896|0),A[n+1164>>2]=0,a[n+1156|0]=o[91267],A[n+1152>>2]=o[91263]|o[91264]<<8|o[91265]<<16|o[91266]<<24,A[n+144>>2]=n+1164,A[n+148>>2]=n+512,A[n+152>>2]=n+1152,(0|ae(e,91302,n+144|0))<2|A[49848]>59||(e=yn(n+512|0))&&(a[b(A[49848],3)+199408|0]=e,e=yn(n+1152|0),r=A[49848],s=b(r,3)+199408|0,a[s+1|0]=e,A[49848]=r+1,a[s+2|0]=A[n+1164>>2]),R=1;continue;case 10:A[n+1140>>2]=0,r=A[32972],A[r+100>>2]=0,A[n+164>>2]=r+100,A[n+160>>2]=r+96,ae(e,87106,n+160|0);continue;case 11:if(A[n+176>>2]=n+1140,1!=(0|ae(e,87268,n+176|0)))continue;A[A[32972]+88>>2]=A[n+1140>>2]<<5;continue;case 12:if(A[n+192>>2]=n+1140,1!=(0|ae(e,87268,n+192|0)))continue;A[A[32972]+92>>2]=A[n+1140>>2];continue;case 13:if(A[n+208>>2]=n+1140,1!=(0|ae(e,87268,n+208|0)))continue;r=A[32972],(0|(e=A[n+1140>>2]))>=5&&(A[r+108>>2]=1,A[n+1140>>2]=4,e=4),A[r+104>>2]=e+1;continue;case 14:for(A[n+552>>2]=-1,A[n+556>>2]=-1,A[n+544>>2]=-1,A[n+548>>2]=-1,A[n+536>>2]=-1,A[n+540>>2]=-1,A[n+528>>2]=-1,A[n+532>>2]=-1,A[n+240>>2]=F,A[n+244>>2]=G,A[n+248>>2]=N,A[n+252>>2]=S,A[n+256>>2]=T,A[n+260>>2]=D,A[n+520>>2]=-1,A[n+524>>2]=-1,A[n+512>>2]=-1,A[n+516>>2]=-1,A[n+228>>2]=z,A[n+232>>2]=Q,A[n+236>>2]=P,A[n+224>>2]=n+512,ae(e,84222,n+224|0),C=A[32972],e=0,l=A[n+516>>2],s=0;;){if(r=s,u=l,c=e,-1==(0|(s=A[(l=(e<<=2)+(n+512|0)|0)>>2]))&&(s=8e3,A[l>>2]=8e3,c&&(A[(n+512|0)+(4|e)>>2]=A[508+(e+n|0)>>2])),l=A[(n+512|0)+(4|e)>>2],!((0|r)>=(0|(s=(0|s)/8|0))||(0|(h=s-r|0))<=0||(f=r+1|0,e=r,1&h&&(a[344+(r+C|0)|0]=(0|u)>=255?255:u,e=f),(0|s)==(0|f))))for(f=l-u|0;p=C+344|0,d=u+((0|b(f,e-r|0))/(0|h)|0)|0,a[p+e|0]=(0|d)>=255?255:d,d=u+((0|b(f,(B=e+1|0)-r|0))/(0|h)|0)|0,a[p+B|0]=(0|d)>=255?255:d,(0|s)!=(0|(e=e+2|0)););if(e=c+2|0,!(c>>>0<10))break}continue;case 15:if(A[n+272>>2]=n+1140,1!=(0|ae(e,87268,n+272|0)))continue;A[A[32972]+112>>2]=(A[n+1140>>2]<<6)/100;continue;case 16:r=A[32972],A[(s=r+300|0)>>2]=0,A[s+4>>2]=0,A[(l=r+292|0)>>2]=0,A[l+4>>2]=0,A[(u=r+284|0)>>2]=0,A[u+4>>2]=0,A[(c=r+276|0)>>2]=0,A[c+4>>2]=0,A[n+316>>2]=r+304,A[n+312>>2]=s,A[n+308>>2]=r+296,A[n+304>>2]=l,A[n+300>>2]=r+288,A[n+296>>2]=u,A[n+292>>2]=r+280,A[n+288>>2]=c,r=ae(e,84553,n+288|0),e=A[32972],A[e+272>>2]=r,A[e+276>>2]=0-A[e+276>>2],A[e+284>>2]=0-A[e+284>>2],A[e+292>>2]=0-A[e+292>>2],A[e+300>>2]=0-A[e+300>>2];continue;case 17:r=A[32972],A[(s=r+336|0)>>2]=0,A[s+4>>2]=0,A[(l=r+328|0)>>2]=0,A[l+4>>2]=0,A[(u=r+320|0)>>2]=0,A[u+4>>2]=0,A[(c=r+312|0)>>2]=0,A[c+4>>2]=0,A[n+348>>2]=r+340,A[n+344>>2]=s,A[n+340>>2]=r+332,A[n+336>>2]=l,A[n+332>>2]=r+324,A[n+328>>2]=u,A[n+324>>2]=r+316,A[n+320>>2]=c,e=ae(e,84553,n+320|0),A[A[32972]+308>>2]=e;continue;case 36:r=A[32972],A[n+352>>2]=r+120,A[n+356>>2]=r+124,A[n+1140>>2]=ae(e,87106,n+352|0);continue;case 33:A[n+368>>2]=A[32972]+84,ae(e,87268,n+368|0),Ke(3);continue;case 31:r=A[32972],A[(s=r+156|0)>>2]=0,A[s+4>>2]=0,A[(l=r+148|0)>>2]=0,A[l+4>>2]=0,A[(u=r+140|0)>>2]=0,A[u+4>>2]=0,A[(c=r+132|0)>>2]=0,A[c+4>>2]=0,A[n+412>>2]=r+160,A[n+408>>2]=s,A[n+404>>2]=r+152,A[n+400>>2]=l,A[n+396>>2]=r+144,A[n+392>>2]=u,A[n+388>>2]=r+136,A[n+384>>2]=c,ae(e,84553,n+384|0),e=A[32972],A[e+152>>2]=A[e+152>>2]-40;continue;case 32:A[n+416>>2]=145740,ae(e,87268,n+416|0),Ke(3);continue;case 6:case 7:continue}A[n+16>>2]=n+704,ts(M,87359,n+16|0)}}cr(x)}t:{if((e=A[47192])|w){if(w)break t}else e=Z(E),A[47192]=e;n:{if(!k){if((0|(e=Fn(n+896|0)))<0&&(A[n>>2]=n+896,ts(A[30450],87567,n),e=0),A[A[32972]+60>>2]=e,r=A[47192],A[r+292>>2]=e,Ne(r,v,4&t),o[132848])break n;as(A[47192]),r=0;break e}A[A[32972]+60>>2]=0,A[e+292>>2]=0}a[y+201088|0]=0}r=A[32972]}return U=n+1168|0,r}function ae(e,t,n){var r,s,l,u=0,c=0,d=0,h=0,f=0,g=0,p=0,C=0,I=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0;U=l=U-16|0,A[l+12>>2]=n,U=u=U-144|0,r=kt(u,0,144),A[r+76>>2]=-1,A[r+44>>2]=e,A[r+32>>2]=18,A[r+84>>2]=e,u=t,M=n,e=0,U=s=U-304|0;e:{t:{n:if(A[r+4>>2]||(_n(r),A[r+4>>2])){if(!(t=o[0|u]))break e;r:{s:{a:{i:{for(;;){A:{o:if(32==(0|(t&=255))|t-9>>>0<5){for(;t=u,u=u+1|0,32==(0|(n=o[t+1|0]))|n-9>>>0<5;);for(Un(r,0,0);(0|(n=A[r+4>>2]))==A[r+104>>2]?n=pt(r):(A[r+4>>2]=n+1,n=o[0|n]),32==(0|n)|n-9>>>0<5;);u=A[r+4>>2],(0|(n=A[r+116>>2]))>0|(0|n)>=0&&(u=u-1|0,A[r+4>>2]=u),u=n=u-A[r+44>>2]|0,f=x+A[r+124>>2]|0,f=(c=n>>31)+((n=I+A[r+120>>2]|0)>>>0<I>>>0?f+1|0:f)|0,x=(I=n+u|0)>>>0<n>>>0?f+1|0:f}else{l:{u:{c:{if(37==o[0|u]){if(42==(0|(t=o[u+1|0])))break c;if(37!=(0|t))break u}if(Un(r,0,0),37!=o[0|u])(0|(t=A[r+4>>2]))==A[r+104>>2]?t=pt(r):(A[r+4>>2]=t+1,t=o[0|t]);else{for(;(0|(t=A[r+4>>2]))==A[r+104>>2]?t=pt(r):(A[r+4>>2]=t+1,t=o[0|t]),32==(0|t)|t-9>>>0<5;);u=u+1|0}if(o[0|u]!=(0|t)){if((0|(n=A[r+116>>2]))>0|(0|n)>=0&&(A[r+4>>2]=A[r+4>>2]-1),(0|t)>=0)break e;if(d=0,D)break e;break n}h=(c=t=A[r+4>>2]-A[r+44>>2]|0)>>31,t=x+A[r+124>>2]|0,d=((n=I+A[r+120>>2]|0)>>>0<I>>>0?t+1|0:t)+h|0,x=(I=n+c|0)>>>0<n>>>0?d+1|0:d,t=u;break o}g=0,t=u+2|0;break l}36!=o[u+2|0]|t-48>>>0>=10?(g=A[M>>2],M=M+4|0,t=u+1|0):(t=o[u+1|0]-48|0,A[12+(n=U-16|0)>>2]=M,t=(t>>>0>1?(t<<2)-4|0:0)+M|0,A[n+8>>2]=t+4,g=A[t>>2],t=u+3|0)}if(p=0,u=0,o[0|t]-48>>>0<10)for(;u=(o[0|t]+b(u,10)|0)-48|0,n=o[t+1|0],t=t+1|0,n-48>>>0<10;);109==(0|(w=o[0|t]))&&(C=0,p=!!(0|g),w=o[t+1|0],e=0,t=t+1|0),t=(n=t)+1|0,c=3,d=p;l:{u:switch(w-65|0){case 39:c=n+2|0,t=(n=104==o[n+1|0])?c:t,c=n?-2:-1;break l;case 43:c=n+2|0,t=(n=108==o[n+1|0])?c:t,c=n?3:1;break l;case 51:case 57:c=1;break l;case 11:c=2;break l;case 41:break l;case 0:case 2:case 4:case 5:case 6:case 18:case 23:case 26:case 32:case 34:case 35:case 36:case 37:case 38:case 40:case 45:case 46:case 47:case 50:case 52:case 55:break u;default:break r}c=0,t=n}d=c,E=(c=3==(47&(n=o[0|t])))?1:d;l:if(91!=(0|(v=c?32|n:n))){u:{if(110!=(0|v)){if(99!=(0|v))break u;u=(0|u)<=1?1:u;break l}gr(g,E,I,x);break o}for(Un(r,0,0);(0|(n=A[r+4>>2]))==A[r+104>>2]?n=pt(r):(A[r+4>>2]=n+1,n=o[0|n]),32==(0|n)|n-9>>>0<5;);n=A[r+4>>2],(0|(c=A[r+116>>2]))>0|(0|c)>=0&&(n=n-1|0,A[r+4>>2]=n),c=n=n-A[r+44>>2]|0,f=x+A[r+124>>2]|0,x=(d=n>>31)+((n=I+A[r+120>>2]|0)>>>0<I>>>0?f+1|0:f)|0,x=(I=n+c|0)>>>0<n>>>0?x+1|0:x}if(k=u,Un(r,u,y=u>>31),(0|(n=A[r+4>>2]))==A[r+104>>2]){if((0|pt(r))<0)break s}else A[r+4>>2]=n+1;(0|(n=A[r+116>>2]))>0|(0|n)>=0&&(A[r+4>>2]=A[r+4>>2]-1),n=16;l:{u:{c:{d:{h:switch(v-88|0){default:if((n=v-65|0)>>>0>6|!(1<<n&113))break l;case 9:case 13:case 14:case 15:if(ee(s+8|0,r,E,0),n=A[r+4>>2]-A[r+44>>2]|0,A[r+120>>2]!=(0-n|0)|A[r+124>>2]!=(0-((n>>31)+!!(0|n)|0)|0))break c;break a;case 3:case 11:case 27:if(115==(16|v)){if(kt(s+32|0,-1,257),a[s+32|0]=0,115!=(0|v))break u;a[s+65|0]=0,a[s+46|0]=0,i[s+42>>1]=0,i[s+44>>1]=0;break u}kt(s+32|0,h=94==(0|(c=o[t+1|0])),257),a[s+32|0]=0,n=h?t+2|0:t+1|0;f:{g:{p:{if(45!=(0|(t=o[(h?2:1)+t|0]))){if(93==(0|t))break p;c=94!=(0|c),t=n;break f}c=94!=(0|c),a[s+78|0]=c;break g}c=94!=(0|c),a[s+126|0]=c}t=n+1|0}for(;;){if(45==(0|(n=o[0|t]))){if(n=45,!(!(h=o[t+1|0])|93==(0|h))){if(d=t+1|0,h>>>0<=(t=o[t-1|0])>>>0)n=h;else for(;a[(t=t+1|0)+(s+32|0)|0]=c,(n=o[0|d])>>>0>t>>>0;);t=d}}else{if(!n)break s;if(93==(0|n))break u}a[33+(n+s|0)|0]=c,t=t+1|0}case 23:n=8;break d;case 12:case 29:n=10;break d;case 1:case 2:case 4:case 5:case 6:case 7:case 8:case 10:case 16:case 18:case 19:case 20:case 21:case 22:case 25:case 26:case 28:case 30:case 31:break l;case 0:case 24:case 32:break d;case 17:}n=0}h=0,f=0,c=0,d=0,w=0,U=B=U-16|0;d:if(1!=(0|n)&n>>>0<=36){for(;(0|(u=A[r+4>>2]))==A[r+104>>2]?u=pt(r):(A[r+4>>2]=u+1,u=o[0|u]),32==(0|u)|u-9>>>0<5;);h:{f:switch(u-43|0){case 0:case 2:break f;default:break h}w=45==(0|u)?-1:0,(0|(u=A[r+4>>2]))==A[r+104>>2]?u=pt(r):(A[r+4>>2]=u+1,u=o[0|u])}h:{f:{g:{p:{if(!(!!(0|n)&16!=(0|n)|48!=(0|u))){if((0|(u=A[r+4>>2]))==A[r+104>>2]?u=pt(r):(A[r+4>>2]=u+1,u=o[0|u]),88==(-33&u)){if(n=16,(0|(u=A[r+4>>2]))==A[r+104>>2]?u=pt(r):(A[r+4>>2]=u+1,u=o[0|u]),o[u+121329|0]<16)break g;(0|(n=A[r+116>>2]))>0|(0|n)>=0&&(A[r+4>>2]=A[r+4>>2]-1),Un(r,0,0);break d}if(n)break p;n=8;break g}if(!((n=n||10)>>>0>o[u+121329|0])){(0|(n=A[r+116>>2]))>0|(0|n)>=0&&(A[r+4>>2]=A[r+4>>2]-1),Un(r,0,0),A[56798]=28;break d}}if(10==(0|n)){if((c=u-48|0)>>>0<=9){for(n=0;d=(n=b(n,10)+c|0)>>>0<429496729,(0|(u=A[r+4>>2]))==A[r+104>>2]?u=pt(r):(A[r+4>>2]=u+1,u=o[0|u]),d&(c=u-48|0)>>>0<=9;);h=n}p:if(!(c>>>0>9)){for(n=sr(h,0,10,0),d=K;;){if(f=d,d=429496729==(0|(f=(h=n+c|0)>>>0<c>>>0?f+1|0:f))&h>>>0>=2576980378|f>>>0>429496729,(0|(n=A[r+4>>2]))==A[r+104>>2]?u=pt(r):(A[r+4>>2]=n+1,u=o[0|n]),d|(c=u-48|0)>>>0>9)break p;if(n=sr(h,f,10,0),!(-1==(0|(d=K))&~c>>>0>=n>>>0|-1!=(0|d)))break}n=10;break f}if(n=10,c>>>0<=9)break f;break h}}if(n-1&n){if((d=o[u+121329|0])>>>0<n>>>0){for(;h=(c=b(n,c)+d|0)>>>0<119304647,(0|(u=A[r+4>>2]))==A[r+104>>2]?u=pt(r):(A[r+4>>2]=u+1,u=o[0|u]),h&(d=o[u+121329|0])>>>0<n>>>0;);h=c}if(n>>>0<=d>>>0)break f;for(;;){if(c=sr(h,f,n,0),-1==(0|(k=K))&~(d&=255)>>>0<c>>>0)break f;if(f=k,f=(h=c+d|0)>>>0<d>>>0?f+1|0:f,(0|(u=A[r+4>>2]))==A[r+104>>2]?u=pt(r):(A[r+4>>2]=u+1,u=o[0|u]),n>>>0<=(d=o[u+121329|0])>>>0)break f;if(nn(B,n,0,0,0,h,f,0,0),A[B+8>>2]|A[B+12>>2])break}}else{if(k=a[84400+(b(n,23)>>>5&7)|0],(c=o[u+121329|0])>>>0<n>>>0){for(;h=(d=d<<k|c)>>>0<134217728,(0|(u=A[r+4>>2]))==A[r+104>>2]?u=pt(r):(A[r+4>>2]=u+1,u=o[0|u]),h&(c=o[u+121329|0])>>>0<n>>>0;);h=d}if(!(n>>>0<=c>>>0||(y=31&k,(63&k)>>>0>=32?(d=0,y=-1>>>y|0):y=(d=-1>>>y|0)|(1<<y)-1<<32-y,!d&h>>>0>y>>>0)))for(;;){if(T=255&c,c=h,u=31&k,(63&k)>>>0>=32?(f=c<<u,u=0):(f=(1<<u)-1&c>>>32-u|f<<u,u=c<<u),h=T|u,(0|(u=A[r+4>>2]))==A[r+104>>2]?u=pt(r):(A[r+4>>2]=u+1,u=o[0|u]),n>>>0<=(c=o[u+121329|0])>>>0)break f;if(!((0|d)==(0|f)&h>>>0<=y>>>0|d>>>0>f>>>0))break}}}if(!(o[u+121329|0]>=n>>>0)){for(;(0|(u=A[r+4>>2]))==A[r+104>>2]?u=pt(r):(A[r+4>>2]=u+1,u=o[0|u]),o[u+121329|0]<n>>>0;);A[56798]=68,w=0,h=-1,f=-1}}(0|(n=A[r+116>>2]))>0|(0|n)>=0&&(A[r+4>>2]=A[r+4>>2]-1),h=(n=h^w)-w|0,f=((u=w>>31)^f)-((n>>>0<w>>>0)+u|0)|0}else A[56798]=28;if(U=B+16|0,n=A[r+4>>2]-A[r+44>>2]|0,A[r+120>>2]==(0-n|0)&A[r+124>>2]==(0-((n>>31)+!!(0|n)|0)|0))break a;if(!(!g|112!=(0|v))){A[g>>2]=h;break l}gr(g,E,h,f);break l}if(!g)break l;u=A[s+16>>2],n=A[s+20>>2],c=A[s+8>>2],p=A[s+12>>2];c:switch(0|E){case 0:U=f=U-32|0;d:if(0|(d=(h=2147483647&n)-1065418752|0)>>>0<(k=h-1082064896|0)>>>0){if(h=(33554431&n)<<7|u>>>25,k=d=0,!(!d&16777216==(0|(u&=33554431))?!(c|p):!d&u>>>0<16777216)){d=h+1073741825|0;break d}if(d=h+1073741824|0,16777216^u|c|p|k)break d;d=(1&h)+d|0}else(!u&2147418112==(0|h)?!(c|p):h>>>0<2147418112)?(d=2139095040,h>>>0>1082064895||(d=0,(h=h>>>16|0)>>>0<16145||(Ut(f+16|0,c,p,u,d=65535&n|65536,h-16129|0),Lt(f,c,p,u,d,16257-h|0),u=A[f+8>>2],d=(33554431&A[f+12>>2])<<7|u>>>25,h=A[f>>2]|!!(A[f+16>>2]|A[f+24>>2]|A[f+20>>2]|A[f+28>>2]),p=A[f+4>>2],(!(c=0)&16777216==(0|(u&=33554431))?!(h|p):!c&u>>>0<16777216)?16777216^u|h|c|p||(d=(1&d)+d|0):d=d+1|0))):d=4194303&((33554431&n)<<7|u>>>25)|2143289344;U=f+32|0,A[g>>2]=-2147483648&n|d;break l;case 1:m[g>>3]=nt(c,p,u,n);break l;case 2:break c;default:break l}A[g>>2]=c,A[g+4>>2]=p,A[g+8>>2]=u,A[g+12>>2]=n;break l}c=(B=99!=(0|v))?31:u+1|0;u:if(1!=(0|E)){if(p){if(u=0,!(n=ie(c)))break i;for(;;){for(e=n;;){if((0|(n=A[r+4>>2]))==A[r+104>>2]?n=pt(r):(A[r+4>>2]=n+1,n=o[0|n]),!o[33+(n+s|0)|0]){c=0,C=e;break u}if(a[e+u|0]=n,(0|c)==(0|(u=u+1|0)))break}if(d=1,!(n=Oe(e,c=c<<1|1)))break}C=e,e=0;break r}if(u=0,g)for(;;){if((0|(e=A[r+4>>2]))==A[r+104>>2]?e=pt(r):(A[r+4>>2]=e+1,e=o[0|e]),!o[33+(e+s|0)|0]){c=0,C=e=g;break u}a[u+g|0]=e,u=u+1|0}for(;(0|(e=A[r+4>>2]))==A[r+104>>2]?e=pt(r):(A[r+4>>2]=e+1,e=o[0|e]),o[33+(e+s|0)|0];);e=0,C=0,c=0}else{if(n=g,p&&!(n=ie(c<<2)))break i;for(A[s+296>>2]=0,A[s+300>>2]=0,u=0;;){e=n;c:{for(;;){if((0|(n=A[r+4>>2]))==A[r+104>>2]?n=pt(r):(A[r+4>>2]=n+1,n=o[0|n]),!o[33+(n+s|0)|0])break c;a[s+27|0]=n,h=s+28|0,n=A[(d=(n=s+296|0)||228604)>>2];d:{h:{f:{g:{if(!(C=s+27|0)){if(n)break g;n=0;break d}if(!n){if((0|(f=(n=o[0|C])<<24>>24))>=0){h&&(A[h>>2]=n),n=!!(0|f);break d}if(!A[A[56841]>>2]){if(n=1,!h)break f;A[h>>2]=57343&f,n=1;break d}if((n=n-194|0)>>>0>50)break g;n=A[124752+(n<<2)>>2];break h}if(w=1,!(((E=(f=o[0|C])>>>3|0)-16|(n>>26)+E)>>>0>7))for(;;){if(w=w-1|0,(0|(n=f-128|n<<6))>=0){A[d>>2]=0,h&&(A[h>>2]=n),n=1-w|0;break d}if(!w)break h;if(128!=(192&(f=o[0|(C=C+1|0)])))break}}A[d>>2]=0,A[56798]=25,n=-1}break d}A[d>>2]=n,n=-2}if(-2!=(0|n)){if(C=0,-1==(0|n))break s;if(e&&(A[(u<<2)+e>>2]=A[s+28>>2],u=u+1|0),!(!p|(0|u)!=(0|c)))break}}if(d=1,n=Oe(e,(c=c<<1|1)<<2))continue;break r}break}if(C=0,c=e,s+296|0&&A[s+296>>2])break s}if(n=A[r+4>>2],(0|(h=A[r+116>>2]))>0|(0|h)>=0&&(n=n-1|0,A[r+4>>2]=n),n=(h=n-A[r+44>>2]|0)+A[r+120>>2]|0,f=A[r+124>>2]+(h>>31)|0,!((f=n>>>0<h>>>0?f+1|0:f)|n)|!(B|(0|n)==(0|k)&(0|f)==(0|y)))break A;p&&(A[g>>2]=e),99!=(0|v)&&(c&&(A[(u<<2)+c>>2]=0),C?a[u+C|0]=0:C=0),e=c}u=n=A[r+4>>2]-A[r+44>>2]|0,d=x+A[r+124>>2]|0,x=(c=n>>31)+((n=I+A[r+120>>2]|0)>>>0<I>>>0?d+1|0:d)|0,x=(I=n+u|0)>>>0<n>>>0?x+1|0:x,D=!!(0|g)+D|0}if(u=t+1|0,t=o[t+1|0])continue;break e}break}e=c;break a}d=1,C=0,e=0;break r}d=p;break t}d=p}if(D)break t}D=-1}d&&(Ee(C),Ee(e))}return U=s+304|0,U=r+144|0,U=l+16|0,D}function ie(e){var t,n=0,r=0,s=0,a=0,i=0,l=0,u=0,c=0,d=0,h=0;U=t=U-16|0;e:{t:{n:{r:{s:{a:{i:{A:{o:{if((e|=0)>>>0<=244){if(3&(n=(l=A[57152])>>>(r=(u=e>>>0<11?16:e+11&-8)>>>3|0)|0)){n=228648+(e=(r=r+(1&~n)|0)<<3)|0,s=A[e+228656>>2],(0|n)!=(0|(e=A[s+8>>2]))?(A[e+12>>2]=n,A[n+8>>2]=e):A[57152]=Xr(-2,r)&l,e=s+8|0,n=r<<3,A[s+4>>2]=3|n,A[4+(n=n+s|0)>>2]=1|A[n+4>>2];break e}if((h=A[57154])>>>0>=u>>>0)break o;if(n){n=228648+(e=(s=ds(0-(e=(0-(e=2<<r)|e)&n<<r)&e))<<3)|0,a=A[e+228656>>2],(0|n)!=(0|(e=A[a+8>>2]))?(A[e+12>>2]=n,A[n+8>>2]=e):(l=Xr(-2,s)&l,A[57152]=l),A[a+4>>2]=3|u,s=(e=s<<3)-u|0,A[4+(r=a+u|0)>>2]=1|s,A[e+a>>2]=s,h&&(n=228648+(-8&h)|0,i=A[57157],(e=1<<(h>>>3))&l?e=A[n+8>>2]:(A[57152]=e|l,e=n),A[n+8>>2]=i,A[e+12>>2]=i,A[i+12>>2]=n,A[i+8>>2]=e),e=a+8|0,A[57157]=r,A[57154]=s;break e}if(!(d=A[57153]))break o;for(r=A[228912+(ds(0-d&d)<<2)>>2],i=(-8&A[r+4>>2])-u|0,n=r;(e=A[n+16>>2])||(e=A[n+20>>2]);)i=(s=(n=(-8&A[e+4>>2])-u|0)>>>0<i>>>0)?n:i,r=s?e:r,n=e;if(c=A[r+24>>2],(0|(s=A[r+12>>2]))!=(0|r)){e=A[r+8>>2],A[e+12>>2]=s,A[s+8>>2]=e;break t}if(!(e=A[(n=r+20|0)>>2])){if(!(e=A[r+16>>2]))break A;n=r+16|0}for(;a=n,s=e,(e=A[(n=e+20|0)>>2])||(n=s+16|0,e=A[s+16>>2]););A[a>>2]=0;break t}if(u=-1,!(e>>>0>4294967231)&&(u=-8&(e=e+11|0),d=A[57153])){i=0-u|0,l=0,u>>>0<256||(l=31,u>>>0>16777215||(l=62+((u>>>38-(e=w(e>>>8|0))&1)-(e<<1)|0)|0));l:{u:{if(n=A[228912+(l<<2)>>2])for(e=0,r=u<<(31!=(0|l)?25-(l>>>1|0):0);;){if(!((a=(-8&A[n+4>>2])-u|0)>>>0>=i>>>0||(s=n,i=a,a))){i=0,e=n;break u}if(a=A[n+20>>2],n=A[16+((r>>>29&4)+n|0)>>2],e=a?(0|a)==(0|n)?e:a:e,r<<=1,!n)break}else e=0;if(!(e|s)){if(s=0,!(e=(0-(e=2<<l)|e)&d))break o;e=A[228912+(ds(e&0-e)<<2)>>2]}if(!e)break l}for(;i=(r=(n=(-8&A[e+4>>2])-u|0)>>>0<i>>>0)?n:i,s=r?e:s,e=(n=A[e+16>>2])||A[e+20>>2];);}if(!(!s|A[57154]-u>>>0<=i>>>0)){if(l=A[s+24>>2],(0|s)!=(0|(r=A[s+12>>2]))){e=A[s+8>>2],A[e+12>>2]=r,A[r+8>>2]=e;break n}if(!(e=A[(n=s+20|0)>>2])){if(!(e=A[s+16>>2]))break i;n=s+16|0}for(;a=n,r=e,(e=A[(n=e+20|0)>>2])||(n=r+16|0,e=A[r+16>>2]););A[a>>2]=0;break n}}}if((e=A[57154])>>>0>=u>>>0){s=A[57157],(n=e-u|0)>>>0>=16?(A[4+(r=s+u|0)>>2]=1|n,A[e+s>>2]=n,A[s+4>>2]=3|u):(A[s+4>>2]=3|e,A[4+(e=e+s|0)>>2]=1|A[e+4>>2],r=0,n=0),A[57154]=n,A[57157]=r,e=s+8|0;break e}if((c=A[57155])>>>0>u>>>0){n=c-u|0,A[57155]=n,e=(r=A[57158])+u|0,A[57158]=e,A[e+4>>2]=1|n,A[r+4>>2]=3|u,e=r+8|0;break e}if(e=0,d=u+47|0,A[57270]?r=A[57272]:(A[57273]=-1,A[57274]=-1,A[57271]=4096,A[57272]=4096,A[57270]=t+12&-16^1431655768,A[57275]=0,A[57263]=0,r=4096),(n=(a=d+r|0)&(i=0-r|0))>>>0<=u>>>0)break e;if((s=A[57262])&&s>>>0<(l=(r=A[57260])+n|0)>>>0|r>>>0>=l>>>0)break e;o:{if(!(4&o[229052])){l:{u:{c:{d:{if(s=A[57158])for(e=229056;;){if((r=A[e>>2])>>>0<=s>>>0&s>>>0<r+A[e+4>>2]>>>0)break d;if(!(e=A[e+8>>2]))break}if(-1==(0|(r=wr(0))))break l;if(l=n,(e=(s=A[57271])-1|0)&r&&(l=(n-r|0)+(e+r&0-s)|0),l>>>0<=u>>>0)break l;if((s=A[57262])&&s>>>0<(i=(e=A[57260])+l|0)>>>0|e>>>0>=i>>>0)break l;if((0|r)!=(0|(e=wr(l))))break c;break o}if((0|(r=wr(l=i&a-c)))==(A[e>>2]+A[e+4>>2]|0))break u;e=r}if(-1==(0|e))break l;if(u+48>>>0<=l>>>0){r=e;break o}if(-1==(0|wr(r=(r=A[57272])+(d-l|0)&0-r)))break l;l=r+l|0,r=e;break o}if(-1!=(0|r))break o}A[57263]=4|A[57263]}if(-1==(0|(r=wr(n)))|-1==(0|(e=wr(0)))|e>>>0<=r>>>0)break r;if((l=e-r|0)>>>0<=u+40>>>0)break r}e=A[57260]+l|0,A[57260]=e,e>>>0>p[57261]&&(A[57261]=e);o:{if(a=A[57158]){for(e=229056;;){if(((s=A[e>>2])+(n=A[e+4>>2])|0)==(0|r))break o;if(!(e=A[e+8>>2]))break}break a}for((e=A[57156])>>>0<=r>>>0&&e||(A[57156]=r),e=0,A[57265]=l,A[57264]=r,A[57160]=-1,A[57161]=A[57270],A[57267]=0;n=228648+(s=e<<3)|0,A[s+228656>>2]=n,A[s+228660>>2]=n,32!=(0|(e=e+1|0)););n=(s=l-40|0)-(e=r+8&7?-8-r&7:0)|0,A[57155]=n,e=e+r|0,A[57158]=e,A[e+4>>2]=1|n,A[4+(r+s|0)>>2]=40,A[57159]=A[57274];break s}if(8&o[e+12|0]|s>>>0>a>>>0|r>>>0<=a>>>0)break a;A[e+4>>2]=n+l,r=(e=a+8&7?-8-a&7:0)+a|0,A[57158]=r,e=(n=A[57155]+l|0)-e|0,A[57155]=e,A[r+4>>2]=1|e,A[4+(n+a|0)>>2]=40,A[57159]=A[57274];break s}s=0;break t}r=0;break n}p[57156]>r>>>0&&(A[57156]=r),n=r+l|0,e=229056;a:{i:{A:{o:{l:{u:{for(;;){if((0|n)!=A[e>>2]){if(e=A[e+8>>2])continue;break u}break}if(!(8&o[e+12|0]))break l}for(e=229056;;){if((n=A[e>>2])>>>0<=a>>>0&&(i=n+A[e+4>>2]|0)>>>0>a>>>0)break o;e=A[e+8>>2]}}if(A[e>>2]=r,A[e+4>>2]=A[e+4>>2]+l,A[4+(d=(r+8&7?-8-r&7:0)+r|0)>>2]=3|u,e=(l=n+(n+8&7?-8-n&7:0)|0)-(c=u+d|0)|0,(0|a)==(0|l)){A[57158]=c,e=A[57155]+e|0,A[57155]=e,A[c+4>>2]=1|e;break i}if(A[57157]==(0|l)){A[57157]=c,e=A[57154]+e|0,A[57154]=e,A[c+4>>2]=1|e,A[e+c>>2]=e;break i}if(1==(3&(i=A[l+4>>2]))){a=-8&i;l:if(i>>>0<=255){if(s=A[l+8>>2],n=i>>>3|0,(0|(r=A[l+12>>2]))==(0|s)){A[57152]=A[57152]&Xr(-2,n);break l}A[s+12>>2]=r,A[r+8>>2]=s}else{if(u=A[l+24>>2],(0|l)==(0|(r=A[l+12>>2])))if((n=A[(i=l+20|0)>>2])||(n=A[(i=l+16|0)>>2])){for(;s=i,(n=A[(i=(r=n)+20|0)>>2])||(i=r+16|0,n=A[r+16>>2]););A[s>>2]=0}else r=0;else n=A[l+8>>2],A[n+12>>2]=r,A[r+8>>2]=n;if(u){s=A[l+28>>2];u:{if(A[(n=228912+(s<<2)|0)>>2]==(0|l)){if(A[n>>2]=r,r)break u;A[57153]=A[57153]&Xr(-2,s);break l}if(A[u+(A[u+16>>2]==(0|l)?16:20)>>2]=r,!r)break l}A[r+24>>2]=u,(n=A[l+16>>2])&&(A[r+16>>2]=n,A[n+24>>2]=r),(n=A[l+20>>2])&&(A[r+20>>2]=n,A[n+24>>2]=r)}}i=A[4+(l=a+l|0)>>2],e=e+a|0}if(A[l+4>>2]=-2&i,A[c+4>>2]=1|e,A[e+c>>2]=e,e>>>0<=255){n=228648+(-8&e)|0,(r=A[57152])&(e=1<<(e>>>3))?e=A[n+8>>2]:(A[57152]=e|r,e=n),A[n+8>>2]=c,A[e+12>>2]=c,A[c+12>>2]=n,A[c+8>>2]=e;break i}if(i=31,e>>>0<=16777215&&(i=62+((e>>>38-(n=w(e>>>8|0))&1)-(n<<1)|0)|0),A[c+28>>2]=i,A[c+16>>2]=0,A[c+20>>2]=0,n=228912+(i<<2)|0,(s=A[57153])&(r=1<<i)){for(i=e<<(31!=(0|i)?25-(i>>>1|0):0),r=A[n>>2];;){if(n=r,(-8&A[r+4>>2])==(0|e))break A;if(r=i>>>29|0,i<<=1,!(r=A[16+(s=(4&r)+n|0)>>2]))break}A[s+16>>2]=c}else A[57153]=r|s,A[n>>2]=c;A[c+24>>2]=n,A[c+12>>2]=c,A[c+8>>2]=c;break i}for(n=(s=l-40|0)-(e=r+8&7?-8-r&7:0)|0,A[57155]=n,e=e+r|0,A[57158]=e,A[e+4>>2]=1|n,A[4+(r+s|0)>>2]=40,A[57159]=A[57274],A[(s=(e=(i+(i-39&7?39-i&7:0)|0)-47|0)>>>0<a+16>>>0?a:e)+4>>2]=27,e=A[57267],A[s+16>>2]=A[57266],A[s+20>>2]=e,e=A[57265],A[s+8>>2]=A[57264],A[s+12>>2]=e,A[57266]=s+8,A[57265]=l,A[57264]=r,A[57267]=0,e=s+24|0;A[e+4>>2]=7,n=e+8|0,e=e+4|0,n>>>0<i>>>0;);if((0|s)==(0|a))break s;if(A[s+4>>2]=-2&A[s+4>>2],i=s-a|0,A[a+4>>2]=1|i,A[s>>2]=i,i>>>0<=255){n=228648+(-8&i)|0,(r=A[57152])&(e=1<<(i>>>3))?e=A[n+8>>2]:(A[57152]=e|r,e=n),A[n+8>>2]=a,A[e+12>>2]=a,A[a+12>>2]=n,A[a+8>>2]=e;break s}if(e=31,i>>>0<=16777215&&(e=62+((i>>>38-(e=w(i>>>8|0))&1)-(e<<1)|0)|0),A[a+28>>2]=e,A[a+16>>2]=0,A[a+20>>2]=0,n=228912+(e<<2)|0,(s=A[57153])&(r=1<<e)){for(e=i<<(31!=(0|e)?25-(e>>>1|0):0),s=A[n>>2];;){if((0|i)==(-8&A[(n=s)+4>>2]))break a;if(r=e>>>29|0,e<<=1,!(s=A[16+(r=(4&r)+n|0)>>2]))break}A[r+16>>2]=a}else A[57153]=r|s,A[n>>2]=a;A[a+24>>2]=n,A[a+12>>2]=a,A[a+8>>2]=a;break s}e=A[n+8>>2],A[e+12>>2]=c,A[n+8>>2]=c,A[c+24>>2]=0,A[c+12>>2]=n,A[c+8>>2]=e}e=d+8|0;break e}e=A[n+8>>2],A[e+12>>2]=a,A[n+8>>2]=a,A[a+24>>2]=0,A[a+12>>2]=n,A[a+8>>2]=e}if(!((e=A[57155])>>>0<=u>>>0)){n=e-u|0,A[57155]=n,e=(r=A[57158])+u|0,A[57158]=e,A[e+4>>2]=1|n,A[r+4>>2]=3|u,e=r+8|0;break e}}A[56798]=48,e=0;break e}n:if(l){n=A[s+28>>2];r:{if(A[(e=228912+(n<<2)|0)>>2]==(0|s)){if(A[e>>2]=r,r)break r;d=Xr(-2,n)&d,A[57153]=d;break n}if(A[l+(A[l+16>>2]==(0|s)?16:20)>>2]=r,!r)break n}A[r+24>>2]=l,(e=A[s+16>>2])&&(A[r+16>>2]=e,A[e+24>>2]=r),(e=A[s+20>>2])&&(A[r+20>>2]=e,A[e+24>>2]=r)}n:if(i>>>0<=15)e=i+u|0,A[s+4>>2]=3|e,A[4+(e=e+s|0)>>2]=1|A[e+4>>2];else if(A[s+4>>2]=3|u,A[4+(a=s+u|0)>>2]=1|i,A[a+i>>2]=i,i>>>0<=255)n=228648+(-8&i)|0,(r=A[57152])&(e=1<<(i>>>3))?e=A[n+8>>2]:(A[57152]=e|r,e=n),A[n+8>>2]=a,A[e+12>>2]=a,A[a+12>>2]=n,A[a+8>>2]=e;else{e=31,i>>>0<=16777215&&(e=62+((i>>>38-(e=w(i>>>8|0))&1)-(e<<1)|0)|0),A[a+28>>2]=e,A[a+16>>2]=0,A[a+20>>2]=0,n=228912+(e<<2)|0;r:{if((r=1<<e)&d){for(e=i<<(31!=(0|e)?25-(e>>>1|0):0),u=A[n>>2];;){if((-8&A[(n=u)+4>>2])==(0|i))break r;if(r=e>>>29|0,e<<=1,!(u=A[16+(r=(4&r)+n|0)>>2]))break}A[r+16>>2]=a}else A[57153]=r|d,A[n>>2]=a;A[a+24>>2]=n,A[a+12>>2]=a,A[a+8>>2]=a;break n}e=A[n+8>>2],A[e+12>>2]=a,A[n+8>>2]=a,A[a+24>>2]=0,A[a+12>>2]=n,A[a+8>>2]=e}e=s+8|0;break e}t:if(c){n=A[r+28>>2];n:{if(A[(e=228912+(n<<2)|0)>>2]==(0|r)){if(A[e>>2]=s,s)break n;A[57153]=Xr(-2,n)&d;break t}if(A[c+(A[c+16>>2]==(0|r)?16:20)>>2]=s,!s)break t}A[s+24>>2]=c,(e=A[r+16>>2])&&(A[s+16>>2]=e,A[e+24>>2]=s),(e=A[r+20>>2])&&(A[s+20>>2]=e,A[e+24>>2]=s)}i>>>0<=15?(e=i+u|0,A[r+4>>2]=3|e,A[4+(e=e+r|0)>>2]=1|A[e+4>>2]):(A[r+4>>2]=3|u,A[4+(s=r+u|0)>>2]=1|i,A[s+i>>2]=i,h&&(n=228648+(-8&h)|0,a=A[57157],(e=1<<(h>>>3))&l?e=A[n+8>>2]:(A[57152]=e|l,e=n),A[n+8>>2]=a,A[e+12>>2]=a,A[a+12>>2]=n,A[a+8>>2]=e),A[57157]=s,A[57154]=i),e=r+8|0}return U=t+16|0,0|e}function Ae(e,t,n,r,s){var i,l=0,u=0,c=0,d=0,f=0,g=0,p=0,m=0,b=0,C=0,I=0,w=0,k=0,x=0,y=0,v=0,E=0;U=i=U-544|0,kt(i+320|0,0,100),kt(i+208|0,0,100),d=n?A[n>>2]:d,b=A[e+12>>2],f=A[36115];e:{t:{n:{r:{for(;;){if(l=(0|(l=o[t+u|0]))>=(0|f)?13:l,a[i+u|0]=l,!l){l=u;break r}if(c=(0|f)<=(0|(c=o[(l=1|u)+t|0]))?13:c,a[l+i|0]=c,!c)break r;if(200==(0|(u=u+2|0)))break}u=198,I=o[i+199|0];break n}if(!l)break t;I=o[i+(u=l-1|0)|0],1!=(0|l)&&(u=l-2|0)}if(y=8&d,A[i+536>>2]=(y>>>3|0?3:7)&d,d=o[i+u|0],f=1,p=(0|(g=ze(e,i,i+432|0,i+540|0,i+536|0,1)))>=0?g:0,k=o[0|i])for(u=i,l=k;l=A[144464+((255&l)<<2)>>2],2==o[l+11|0]&&(1048576&(l=A[l+4>>2])||(c=(2097152&l)>>>21|0,c|=l=12==o[A[144464+(o[0|(m=u+1|0)]<<2)>>2]+10|0],a[(i+208|0)+f|0]=c,C=A[144464+(o[(l?2:1)+u|0]<<2)>>2],c=o[C+11|0]-10>>>0<4294967289|!(32&o[C+6|0])&2==o[A[144464+(o[(l?3:2)+u|0]<<2)>>2]+11|0]?c:c?2:1,u=l?m:u,a[(i+320|0)+f|0]=c,f=f+1|0)),l=o[0|(u=u+1|0)];);u=n=n?p:g;n:{r:{s:{a:{i:{A:{o:{l:{u:{c:{d:{h:switch(A[e+8>>2]-1|0){case 11:if((0|(n=A[i+540>>2]))<2)break u;if(u=1,p=1&(l=n-1|0),2!=(0|n))break d;f=0;break c;case 8:if((0|(l=A[i+540>>2]))<2)break r;if(f=3&(c=l-1|0),u=1,l-2>>>0>=3)for(p=-4&c,c=0;d=a[0|(l=(i+432|0)+u|0)],a[0|l]=(0|d)<0?4:d,d=a[l+1|0],a[l+1|0]=(0|d)<0?4:d,d=a[l+2|0],a[l+2|0]=(0|d)<0?4:d,d=l,l=a[l+3|0],a[d+3|0]=(0|l)<0?4:l,u=u+4|0,(0|p)!=(0|(c=c+4|0)););if(!f)break r;for(l=0;c=a[0|(d=(i+432|0)+u|0)],a[0|d]=(0|c)<0?4:c,u=u+1|0,(0|f)!=(0|(l=l+1|0)););break r;case 7:if(!o[i+322|0]|a[i+321|0]>0)break r;case 0:if(A[i+536>>2]|A[i+540>>2]<3)break r;if(A[i+536>>2]=2,u=4,n)break n;a[i+434|0]=4;break n;case 1:if(A[i+536>>2])break n;f:{g:{if((0|(f=A[i+540>>2]))>=3){n=f-2|0,A[i+536>>2]=n,u=n;p:if(512&b&&(l=A[144464+(I<<2)>>2],2!=(0|(c=o[l+11|0])))){u=A[l>>2],l=i;m:{b:{if(26977!=(0|(p=A[e+212>>2]))){if(24942!=(0|p))break b;C:switch(u-110|0){case 0:case 5:if(u=n,2==o[A[144464+(d<<2)>>2]+11|0])break p}u=f-1|0;break m}if(115==(0|u)&&(u=n,2==o[A[144464+(d<<2)>>2]+11|0]))break p;u=f-1|0;break m}b:{C:{if(115==(0|u)){if(u=n,8!=(0|(c=o[A[144464+(d<<2)>>2]+11|0])))break C;break p}if(8!=(0|c))break b;c=o[A[144464+(d<<2)>>2]+11|0]}if(u=n,2==(255&c))break p}u=f-1|0}A[l+536>>2]=u}if(524288&b&&(a[(l=f-1|0)+(f=i+208|0)|0]<=a[n+f|0]||(A[i+536>>2]=l,u=l)),o[(i+432|0)+u|0]>1){l=u;break f}if(l=2,n=u-1|0,u>>>0>=2)break g;A[i+536>>2]=u+1;break f}n=1}l=n,A[i+536>>2]=l}if(u=4,a[0|(n=(i+432|0)+l|0)]>=0)break n;if(a[(l=(i+432|0)+l|0)-1|0]>=4&a[l+1|0]>3)break n;a[0|n]=4;break n;case 2:if(A[i+536>>2])break n;for(n=(u=A[i+540>>2])-1|0,n&=n>>31;;){if((0|(u=u-1|0))<=0)break s;if(!(a[0|(l=(i+432|0)+u|0)]>=0))break}A[i+536>>2]=u,u=4,a[0|l]=4;break n;case 3:if(A[i+536>>2])break r;if(l=(0|(u=A[i+540>>2]-3|0))<=1?1:u,A[i+536>>2]=l,u=4,n)break n;a[l+(i+432|0)|0]=4;break n;case 4:if(A[i+536>>2])break n;if(l=(n=A[i+540>>2])-3|0,A[i+536>>2]=l,(0|n)<=15){f:{g:switch(o[A[144464+(I<<2)>>2]+11|0]-2|0){case 0:l=a[n+94176|0];break f;case 2:l=a[n+94192|0];break f}l=a[n+94160|0]}A[i+536>>2]=l}u=4,a[(i+432|0)+l|0]=4;break n;case 5:if(A[i+536>>2])break n;if(f=-1,c=0,!((0|(n=(l=A[i+540>>2])-1|0))<2)){if(u=1,m=1&l,3!=(0|l))for(C=(-2&l)-4|0,l=0;a[(i+432|0)+u|0]<0&&(c=(d=(0|(p=a[(i+320|0)+u|0]))<(0|f))?c:u,f=d?f:p),a[(d=u+1|0)+(i+432|0)|0]<0&&(c=(p=(0|(x=a[d+(i+320|0)|0]))<(0|f))?c:d,f=p?f:x),u=u+2|0,d=(0|l)!=(0|C),l=l+2|0,d;);!m|a[(i+432|0)+u|0]>=0||(f=(l=(0|(d=a[(i+320|0)+u|0]))<(0|f))?f:d,c=l?c:u)}A[i+536>>2]=c,2!=o[n+(i+320|0)|0]|(0|f)>1?(0|f)>0||(c=1,A[i+536>>2]=1):(A[i+536>>2]=n,c=n),u=4,a[(i+432|0)+c|0]=4;break n;case 14:break a;case 12:break i;case 6:break h;default:break n}if(A[i+536>>2])break n;f=(n=A[i+540>>2])-1|0,A[i+536>>2]=f;h:if(!((0|n)<2))for(u=1;;){if(1==o[(i+432|0)+u|0]){f=u-1|0,A[i+536>>2]=f;break h}if((0|n)==(0|(u=u+1|0)))break}u=4,a[(i+432|0)+f|0]=4;break n}for(m=-2&l,f=0,c=0;l=o[0|(C=(d=i+432|0)+u|0)],w=C,x=a[(C=i+208|0)+u|0]>0,a[0|w]=x||4==(0|l)?3:l,v=4==(0|(d=o[0|(w=(l=u+1|0)+d|0)]))?3:d,d=a[l+C|0]>0,a[0|w]=d?3:v,f=d?l:x?u:f,u=u+2|0,(0|m)!=(0|(c=c+2|0)););}if(p&&(d=4==(0|(l=o[0|(c=(i+432|0)+u|0)]))?3:l,l=a[(i+208|0)+u|0]>0,a[0|c]=l?3:d,f=l?u:f),l=A[i+536>>2])break A;if((0|f)>0){A[i+536>>2]=f,l=f;break A}if((0|n)<6)break l;l=n-3|0;break o}if(l=A[i+536>>2])break A}l=n-1|0}A[i+536>>2]=l}u=4,a[(i+432|0)+l|0]=4;break n}if(A[i+536>>2])break n;l=1,A[i+536>>2]=1,o[i+209|0]|A[i+540>>2]<3|a[i+210|0]<=0||(l=2,A[i+536>>2]=2),u=4,a[i+432|l]=4;break n}if(A[i+536>>2])break r;if((0|(l=A[i+540>>2]))<3)break r;if(kt(i+432|1,0,l-1|0),A[i+536>>2]=2,n||(a[i+434|0]=4),u=4,l>>>0<4)break n;a[431+(l+i|0)|0]=3;break n}A[i+536>>2]=n,u=4;break n}u=n}!(256&b)|2&s||(0|(n=A[i+540>>2]))<3|(0|g)>2||4!=o[0|(l=(n=n+(i+432|0)|0)-1|0)]|2!=o[A[144464+(I<<2)>>2]+11|0]||(a[0|l]=1,a[n-2|0]=4);n:{r:{if(y)g=A[i+540>>2];else{if(n=a[i+433|0],!(!(4096&b)|3!=(0|(g=A[i+540>>2])))){if(4==(0|n)){a[i+434|0]=3;break r}if(4==o[i+434|0]){a[i+433|0]=3;break r}}if(!(!(8192&b)|(0|n)>=0|(0|g)<4|a[i+434|0]<4)){a[i+433|0]=3;break r}}if(c=0,(0|g)<2)break n}for(f=(0|u)<4?4:3,C=128&b,x=64&b,w=32&b,p=g-1|0,v=16&b,E=!(32768&b),I=0,d=0,u=1;;){r:{s:if((0|(l=a[0|(m=(i+432|0)+u|0)]))>=0)c=f;else{c=3;a:{i:if(!(!(!v|(0|f)>3)&(0|u)==(0|p))){if(!(1&(I|E)))break a;if(!(a[431+(i+u|0)|0]>1)){if((0|(l=a[(n=u+1|0)+(i+432|0)|0]))>=2){if(4!=(0|f))break i;if(c=4,l>>>0>=3)break i}else if(!(!w|3!=(0|f))){f=3;break r}if(!x|u>>>0<2)break a;if(c=o[(i+320|0)+u|0])break a;if((0|p)>(0|(l=u))){for(;;){if(a[(i+320|0)+l|0]>0)break r;if((0|p)==(0|(l=l+1|0)))break}if(c)break a}if(a[n+(i+320|0)|0]<=0)break a;break r}c=f}l=o[0|m];break s}a[0|m]=f,I=1,c=3,l=f}s:{if(l<<24>>24>=4){if(n=d||u,!d|!C)break s;a[0|m]=3}f=c;break r}f=c,d=n}if(c=1,(0|g)==(0|(u=u+1|0)))break}}if(r=!y|(0|r)>=0?r:A[((0|g)<3?16:20)+e>>2],f=0,l=0,c){if(I=3&(n=g-1|0),c=0,g-2>>>0<3)u=1;else for(y=-4&n,u=1,d=0;l=(n=(0|(l=(m=(0|(l=(p=(0|(l=(g=(0|(p=a[(n=i+432|0)+u|0]))<(0|l))?l:p))>(0|(m=a[(C=u+1|0)+n|0])))?l:m))>(0|(w=a[(x=u+2|0)+n|0])))?l:w))>(0|(v=a[(w=u+3|0)+n|0])))?l:v,f=n?m?p?g?f:u:C:x:w,u=u+4|0,(0|y)!=(0|(d=d+4|0)););if(I)for(;l=(n=(0|(d=a[(i+432|0)+u|0]))<(0|l))?l:d,f=n?f:u,u=u+1|0,(0|I)!=(0|(c=c+1|0)););}if((0|r)<0?r=l:(0|r)<=(0|l)&(0|l)>4||(a[(i+432|0)+f|0]=r),I=t+197|0,g=1,!(1&s)&&(n=A[144464+(k<<2)>>2])){if(l=i,!(1!=(0|(c=o[n+11|0]))&15!=(0|k)))for(;n=o[0|(l=l+1|0)],1==(0|(c=o[A[144464+(n<<2)>>2]+11|0]))|15==(0|n););!(48&(n=A[e+4>>2]))|2!=(0|c)||(a[0|t]=(32&n)>>>5|0&&a[i+433|0]>3?11:23,t=t+1|0)}n:if(!(t>>>0>=I>>>0))for(p=65536&b,m=2&b,y=4&b,u=i;;){if(!(l=o[0|u]))break n;if(s=u,u=u+1|0,n=A[144464+(l<<2)>>2]){r:{s:{a:switch(o[n+11|0]){case 0:A[e+8200>>2]=0;break r;case 2:if(!(16&o[n+6|0]))break s}if(20!=o[0|u])break r}if((0|(k=A[i+540>>2]))<(0|g))break e;d=a[0|(b=(i+432|0)+g|0)],A[e+8200>>2]=d;s:{a:{if(!((0|(n=d))>1)){if(c=k-1|0,!(!y|(0|g)<2|(0|r)<2)&&(n=0,(0|c)==(0|g)))break a;if(n=1,!(1==(0|g)|m|(k-2|0)==(0|g)&a[c+(i+432|0)|0]<2|(0|c)==(0|g)||a[431+(i+g|0)|0]>=0&&(n=d,p))){n=0,a[0|b]=0;break a}}if(n&&(0|n)<2)break s}a[0|t]=o[n+94151|0],t=t+1|0,d=a[0|b]}c=(0|r)>(0|d),12==o[0|u]&&1&(k=A[e+28>>2])&&(u=(16&k?(0|f)!=(0|g):(0|n)<4)?s+2|0:u),r=c?r:d,g=g+1|0}if(1!=(0|l)&&(a[0|t]=l,t=t+1|0),!(t>>>0<I>>>0))break}}a[0|t]=0}return void(U=i+544|0)}T(86136,86634,1353,94208),h()}function oe(e,t,n,r,s,a,i,o,l){var u,c=0,d=0,h=0,f=0,g=0,m=0,b=0,C=0,I=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0,N=0,G=0,F=0,P=0,Q=0,z=0,O=0,R=0,L=0,W=0,_=0;U=u=U-336|0,f=o,m=65535&l,g=r,h=65535&s,x=-2147483648&(s^l);e:{if(!((I=l>>>16&32767)-32767>>>0>4294934529&(b=s>>>16&32767)-32767>>>0>=4294934530)){if(!(!r&2147418112==(0|(c=2147483647&s))?!(t|n):c>>>0<2147418112)){C=r,x=32768|s;break e}if(!(!o&2147418112==(0|(s=2147483647&l))?!(a|i):s>>>0<2147418112)){C=o,x=32768|l,t=a,n=i;break e}if(!(t|r|2147418112^c|n)){if(!(a|o|2147418112^s|i)){t=0,n=0,x=2147450880;break e}x|=2147418112,t=0,n=0;break e}if(!(a|o|2147418112^s|i)){t=0,n=0;break e}if(!(t|r|n|c)){C=(t=!(a|o|s|i))?0:C,x=t?2147450880:x,t=0,n=0;break e}if(!(a|o|s|i)){x|=2147418112,t=0,n=0;break e}65535==(0|c)|c>>>0<65535&&(l=r=!(h|g),c=r?t:g,o=r<<=6,Ut(u+320|0,t,n,g,h,(r=r+(32==(0|(l=w(l?n:h)))?w(c)+32|0:l)|0)-15|0),y=16-r|0,g=A[u+328>>2],h=A[u+332>>2],n=A[u+324>>2],t=A[u+320>>2]),s>>>0>65535||(o=r=!(f|m),l=r?a:f,s=r<<=6,Ut(u+304|0,a,i,f,m,(r=r+(32==(0|(o=w(o?i:m)))?w(l)+32|0:o)|0)-15|0),y=(r+y|0)-16|0,f=A[u+312>>2],m=A[u+316>>2],a=A[u+304>>2],i=A[u+308>>2])}if(D=s=65536|m,T=f,c=s<<15|(r=f)>>>17,nn(u+288|0,r=s=r<<15|i>>>17,o=c,0,0,l=0-r|0,c=1963258675-(c+!!(0|r)|0)|0,0,0),nn(u+272|0,0-(r=A[u+296>>2])|0,0-(A[u+300>>2]+!!(0|r)|0)|0,0,0,l,c,0,0),nn(u+256|0,l=(r=A[u+280>>2])<<1|A[u+276>>2]>>>31,r=A[u+284>>2]<<1|r>>>31,0,0,s,o,0,0),nn(u+240|0,l,r,0,0,0-(c=A[u+264>>2])|0,0-(A[u+268>>2]+!!(0|c)|0)|0,0,0),nn(u+224|0,c=(l=A[u+248>>2])<<1|A[u+244>>2]>>>31,r=A[u+252>>2]<<1|l>>>31,0,0,s,o,0,0),nn(u+208|0,c,r,0,0,0-(l=A[u+232>>2])|0,0-(A[u+236>>2]+!!(0|l)|0)|0,0,0),nn(u+192|0,l=(r=A[u+216>>2])<<1|A[u+212>>2]>>>31,r=A[u+220>>2]<<1|r>>>31,0,0,s,o,0,0),nn(u+176|0,l,r,0,0,0-(c=A[u+200>>2])|0,0-(A[u+204>>2]+!!(0|c)|0)|0,0,0),nn(u+160|0,l=s,r=o,0,0,o=(f=(s=A[u+184>>2])<<1|A[u+180>>2]>>>31)-1|0,s=(A[u+188>>2]<<1|s>>>31)-!f|0,0,0),nn(u+144|0,a<<15,i<<15|a>>>17,0,0,r=o,s,0,0),k=u+112|0,B=A[u+168>>2],o=A[u+172>>2],d=(f=A[u+160>>2])+(l=A[u+152>>2])|0,c=(m=A[u+164>>2])+A[u+156>>2]|0,l=c=l>>>0>d>>>0?c+1|0:c,c=(c=(0|m)==(0|c)&d>>>0<f>>>0|c>>>0<m>>>0)>>>0>(m=c+B|0)>>>0?o+1|0:o,nn(k,r,s,0,0,0-(o=(f=!l&d>>>0>1|!!(0|l))+m|0)|0,0-(!!(0|o)+(c=f>>>0>o>>>0?c+1|0:c)|0)|0,0,0),nn(u+128|0,1-d|0,0-((d>>>0>1)+l|0)|0,0,0,r,s,0,0),Q=(b-I|0)+y|0,k=s=A[u+116>>2],f=(r=A[u+112>>2])<<1,b=c=s<<1|r>>>31,r=c,M=o=A[u+140>>2],r=r+(c=o<<1|(s=A[u+136>>2])>>>31)|0,s=r=(o=(l=s<<1|A[u+132>>2]>>>31)+f|0)>>>0<l>>>0?r+1|0:r,E=r=r-(o>>>0<13927)|0,B=r,z=c=65536|h,O=g,L=(r=g)<<1,W=c=c<<1|r>>>31,N=c,G=r=sr(E,d=0,c,0),v=c=K,y=t<<1,I=r=n<<1|t>>>31,m=c=0,E=(0|s)==(0|E)&(l=o-13927|0)>>>0<o>>>0|s>>>0>E>>>0,s=(0|s)==(0|b)&o>>>0<f>>>0|s>>>0<b>>>0,r=A[u+120>>2],c=o=A[u+124>>2]<<1|r>>>31,c=(r=(d=M>>>31|0)+(r=r<<1|k>>>31)|0)>>>0<d>>>0?c+1|0:c,d=(o=r)>>>0>(r=r+s|0)>>>0?c+1|0:c,d=(s=r)>>>0>(r=r+E|0)>>>0?d+1|0:d,s=r-1|0,c=sr(I,m,E=d-!r|0,b=0),o=K+v|0,k=(0|v)==(0|(o=(r=c+G|0)>>>0<c>>>0?o+1|0:o))&r>>>0<G>>>0|o>>>0<v>>>0,M=s,s=sr(s,c=0,S=(R=n>>>31|0)|g<<1,v=0),c=K+o|0,d=0,f=c=s>>>0>(g=s+r|0)>>>0?c+1|0:c,d=(s=r=(0|c)==(0|o)&r>>>0>g>>>0|o>>>0>c>>>0)>>>0>(r=r+k|0)>>>0?1:d,s=sr(N,m,E,b),c=K+d|0,k=r=s+r|0,r=r>>>0<s>>>0?c+1|0:c,s=sr(N,m,M,v),h=K,o=s,s=sr(S,v,E,b),c=K+h|0,s=c=s>>>0>(d=o+s|0)>>>0?c+1|0:c,r=r+(c=(0|h)==(0|c)&o>>>0>d>>>0|c>>>0<h>>>0)|0,k=h=k+s|0,h=r=h>>>0<s>>>0?r+1|0:r,c=d+f|0,s=c=(r=(s=0)+g|0)>>>0<s>>>0?c+1|0:c,o=(0|c)==(0|f)&r>>>0<g>>>0|c>>>0<f>>>0,c=h,d=o,F=o=o+k|0,d=c=d>>>0>o>>>0?c+1|0:c,k=r,h=r,g=s,G=l,r=sr(l,0,S,v),o=K,s=r,l=sr(B,C,I,C),c=K+o|0,l=(0|o)==(0|(c=(r=r+l|0)>>>0<l>>>0?c+1|0:c))&r>>>0<s>>>0|o>>>0>c>>>0,o=c,s=sr(M,v,P=-2&y,0),c=K+c|0,s=c=s>>>0>(f=s+r|0)>>>0?c+1|0:c,r=(0|c)==(0|o)&r>>>0>f>>>0|o>>>0>c>>>0,o=0,r=((l=r+l|0)>>>0<r>>>0?1:o)+g|0,c=d,l=r=(h=l+h|0)>>>0<l>>>0?r+1|0:r,o=r=(0|r)==(0|g)&h>>>0<k>>>0|r>>>0<g>>>0,_=r=r+F|0,k=c=o>>>0>r>>>0?c+1|0:c,r=sr(N,m,G,C),F=K,N=r,o=sr(E,b,P,C),c=K+F|0,g=r=r+o|0,d=r+(m=sr(B,C,S,v))|0,r=(o=r>>>0<o>>>0?c+1|0:c)+K|0,r=d>>>0<m>>>0?r+1|0:r,b=d,m=d+(c=sr(I,C,M,v))|0,d=K+r|0,S=(0|r)==(0|(d=c>>>0>m>>>0?d+1|0:d))&m>>>0<b>>>0|r>>>0>d>>>0,c=((r=(r=(r=(0|r)==(0|o)&g>>>0>b>>>0|r>>>0<o>>>0)+(c=(0|o)==(0|F)&g>>>0<N>>>0|o>>>0<F>>>0)|0)+S|0)|(M=0))+l|0,g=c=(o=d)>>>0>(b=o+h|0)>>>0?c+1|0:c,r=(0|l)==(0|c)&h>>>0>b>>>0|l>>>0>c>>>0,c=k,o=r,M=r=r+_|0,l=c=o>>>0>r>>>0?c+1|0:c,r=sr(B,C,P,C),B=K,h=r,o=sr(I,C,G,C),c=K+B|0,o=(0|(c=(r=r+o|0)>>>0<o>>>0?c+1|0:c))==(0|B)&r>>>0<h>>>0|c>>>0<B>>>0,h=c,r=c+f|0,c=(o|(k=0))+s|0,h=(0|s)==(0|(c=r>>>0<h>>>0?c+1|0:c))&r>>>0<f>>>0|s>>>0>c>>>0,d=(o=c)+(c=m)|0,c=0,c=((s=r=(0|o)==(0|(d=(f=(m=0)+r|0)>>>0<m>>>0?d+1|0:d))&r>>>0>f>>>0|o>>>0>d>>>0)>>>0>(r=r+h|0)>>>0?1:c)+g|0,d=l,s=c=(s=r)>>>0>(r=r+b|0)>>>0?c+1|0:c,l=d=(l=o=(0|g)==(0|c)&r>>>0<b>>>0|c>>>0<g>>>0)>>>0>(o=o+M|0)>>>0?d+1|0:d,131071==(0|d)|d>>>0<131071?(O=L|R,z=v|W,nn(u+80|0,r,s,o,l,a,i,T,D),m=d=A[u+84>>2],c=t<<17,g=(n=(f=0)-(h=A[u+88>>2])|0)-(d=!!(d|(t=A[u+80>>2])))|0,h=(c-(A[u+92>>2]+(h>>>0>f>>>0)|0)|0)-(n>>>0<d>>>0)|0,f=0-t|0,m=0-(!!(0|t)+m|0)|0,t=Q+16382|0):(nn(u+96|0,r=(1&s)<<31|r>>>1,s=o<<31|s>>>1,o=(1&l)<<31|o>>>1,l=l>>>1|0,a,i,T,D),I=g=A[u+100>>2],g=(f=0-(y=A[u+104>>2])|0)-(h=!!(g|(d=A[u+96>>2])))|0,h=((t<<16)-(A[u+108>>2]+(m>>>0<y>>>0)|0)|0)-(h>>>0>f>>>0)|0,f=0-d|0,m=0-(!!(0|d)+I|0)|0,y=t,I=n,t=Q+16383|0),(0|t)>=32767)x|=2147418112,t=0,n=0;else{if((0|t)>0)d=h<<1|g>>>31,g=g<<1|m>>>31,h=d,y=o,I=65535&l|t<<16,d=m<<1|f>>>31,l=f<<1;else{if((0|t)<=-113){t=0,n=0;break e}Lt(u- -64|0,r,s,o,l,1-t|0),Ut(u+48|0,y,I,O,z,t+112|0),nn(u+32|0,a,i,T,D,r=A[u+64>>2],s=A[u+68>>2],y=A[u+72>>2],I=A[u+76>>2]),t=A[u+40>>2],f=(n=A[u+56>>2])-(g=t<<1|(d=A[u+36>>2])>>>31)|0,h=A[u+60>>2]-((A[u+44>>2]<<1|t>>>31)+(n>>>0<g>>>0)|0)|0,c=(t=A[u+32>>2])<<1,g=f-(t=(0|(o=d<<1|t>>>31))==(0|(l=A[u+52>>2]))&c>>>0>(n=A[u+48>>2])>>>0|o>>>0>l>>>0)|0,h=h-(t>>>0>f>>>0)|0,d=l-((n>>>0<c>>>0)+o|0)|0,l=n-c|0}t=l,nn(u+16|0,a,i,T,D,3,0,0,0),nn(u,a,i,T,D,5,0,0,0),o=d+(n=0)|0,o=l>>>0>(t=t+(c=1&r)|0)>>>0?o+1|0:o,l=t,i=(0|i)==(0|o)&t>>>0>a>>>0|i>>>0<o>>>0,d=h,t=(0|n)==(0|o)&t>>>0<c>>>0|n>>>0>o>>>0,c=s,n=c=(n=t=(t=(0|(d=t>>>0>(a=t+g|0)>>>0?d+1|0:d))==(0|D))&(0|a)==(0|T)?i:t&a>>>0>T>>>0|d>>>0>D>>>0)>>>0>(t=t+r|0)>>>0?c+1|0:c,r=(0|s)==(0|c)&t>>>0<r>>>0|s>>>0>c>>>0,c=I,c=(s=r)>>>0>(r=r+y|0)>>>0?c+1|0:c,i=r,h=(0|(s=A[u+20>>2]))==(0|o)&p[u+16>>2]<l>>>0|s>>>0<o>>>0,s=A[u+28>>2],s=c>>>0<2147418112&((0|(r=A[u+24>>2]))==(0|a)&(0|s)==(0|d)?h:(0|s)==(0|d)&r>>>0<a>>>0|s>>>0<d>>>0),r=n,c=(n=t=(0|n)==(0|(r=(h=s)>>>0>(s=t+s|0)>>>0?r+1|0:r))&t>>>0>s>>>0|n>>>0>r>>>0)>>>0>(t=t+i|0)>>>0?c+1|0:c,i=t,o=(0|(n=A[u+4>>2]))==(0|o)&p[u>>2]<l>>>0|n>>>0<o>>>0,n=A[u+12>>2],n=d=(n=t=c>>>0<2147418112&((0|(t=A[u+8>>2]))==(0|a)&(0|n)==(0|d)?o:(0|n)==(0|d)&t>>>0<a>>>0|n>>>0<d>>>0))>>>0>(t=t+s|0)>>>0?r+1|0:r,s=(0|r)==(0|d)&t>>>0<s>>>0|r>>>0>d>>>0,r=c,a=s,C|=s=s+i|0,x|=r=a>>>0>s>>>0?r+1|0:r}}A[e>>2]=t,A[e+4>>2]=n,A[e+8>>2]=C,A[e+12>>2]=x,U=u+336|0}function le(e,t,n,r,s){var i,l,u,c=0,d=0,h=0,f=0,p=0,m=0,b=0,C=0,I=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0,N=0;if(U=l=U-80|0,u=A[n+8>>2],!s|!g[n+4>>1]||(A[s+8>>2]=0),i=kt(r,0,152),A[i+44>>2]=o[u+14|0],A[i+40>>2]=o[u+15|0],r=g[u+8>>1]){for(r=A[34459]+(r<<1)|0,w=256&t,k=n+32|0,v=n-32|0,E=n- -64|0,B=n+96|0,M=n+-64|0,D=n-28|0,T=1&t,S=n-24|0,x=A[30450];;){c=15&(p=(t=g[r>>1])>>>8|0);e:{t:{n:{r:{s:{a:{i:{A:{o:{l:{u:{c:switch(0|(h=t>>>12|0)){case 10:break i;case 9:break A;case 6:break o;case 2:case 3:break l;case 1:break u;case 0:break c;case 11:case 12:case 13:case 14:case 15:break a;default:break s}d=255&t;c:{d:{h:switch(0|c){case 13:if(d)break d;c=r,t=0;break c;case 0:c=r;f:switch(d-1|0){case 1:break e;case 0:break t}A[l+20>>2]=Kr(l+75|0,A[u>>2]),A[l+16>>2]=t,ts(x,85851,l+16|0);break e;case 5:if(2!=o[A[144464+(o[n+34|0]<<2)>>2]+11|0])break e;A[i+20>>2]=d;break e;case 12:break h;default:break r}A[i+44>>2]=A[i+44>>2]+(t<<24>>31&-256|d);break e}a[i+132|0]=o[r+3|0],c=r+2|0,a[i+133|0]=o[0|c],t=2,d>>>0<3||(a[i+134|0]=o[r+5|0],c=r+4|0,a[i+135|0]=o[0|c],t=4,d>>>0<5||(a[i+136|0]=o[r+7|0],c=r+6|0,a[i+137|0]=o[0|c],t=6,d>>>0<7||(a[i+138|0]=o[r+9|0],c=r+8|0,a[i+139|0]=o[0|c],t=8,d>>>0<9||(a[i+140|0]=o[r+11|0],c=r+10|0,a[i+141|0]=o[0|c],t=10,d>>>0<11||(a[i+142|0]=o[r+13|0],c=r+12|0,a[i+143|0]=o[0|c],t=12,d>>>0<13||(a[i+144|0]=o[r+15|0],c=r+14|0,a[i+145|0]=o[0|c],t=14,d>>>0<15||(a[i+146|0]=o[r+17|0],c=r+16|0,a[i+147|0]=o[0|c],t=16)))))))}a[132+(t+i|0)|0]=0,d=b;break t}if(!e|c>>>0>7)break e;if(h=n,2!=o[A[144464+(o[n+2|0]<<2)>>2]+11|0]&&(h=k,2!=o[A[144464+(o[n+34|0]<<2)>>2]+11|0]))break e;if(!(1&(c=A[e+56>>2]))&&16&o[0|n])break e;d=15&o[h+3|0],d=2&c&&o[h+6|0]<=d>>>0?4:d;u:{c:{d:{h:switch((c=7&p)-3|0){case 1:break c;case 0:break h;default:break d}if(d>>>0>3)break u;break e}if(A[102832+(c<<2)>>2]>(0|d))break u;break e}if(o[h+6|0]>d>>>0)break e}A[i+8>>2]=255&t,d=1;break n}if(8192==(57344&t)){for(N=A[32972],p=1,y=0;;){f=255&t,c=(m=4095&t)>>>8|0;l:if(m>>>0<=3583){6==(0|(d=(c>>>0)%7|0))&&(d=g[r+2>>1]),I=0,c=n;u:{c:{d:switch(0|d){case 6:if(h=0,g[n+36>>1]|g[n+68>>1])break l;case 3:c=E;break c;case 9:if(h=0,g[n+36>>1]|g[n+68>>1])break l;if(c=B,!g[n+100>>1])break u;break l;case 7:if(h=0,g[n+36>>1])break l;for(d=1;;){if(2==o[A[144464+(o[2+(c=(d<<5)+n|0)|0]<<2)>>2]+11|0])break c;if(g[4+(((d=d+1|0)<<5)+n|0)>>1])break}break l;case 5:if(h=0,g[n+4>>1])break l;case 0:I=1,c=v;break c;case 4:if(h=0,g[n+36>>1])break l;case 2:c=k;break c;case 8:if(h=0,!s)break l;if(I=1,A[(c=s)+8>>2])break u;break l;case 10:break d;default:break c}if(h=0,g[n+4>>1]|g[D>>1])break l;I=1,c=M;break u}c:switch(0|d){case 0:case 5:break c;default:break u}c=(1==o[c+2|0]?-32:0)+c|0}if(w?(d=A[144464+(o[c+2|0]<<2)>>2],A[c+8>>2]=d):d=A[c+8>>2],m>>>0<=1791){if(h=1,A[A[144464+(f<<2)>>2]>>2]==A[d>>2])break l;if(!(!I|2!=o[d+11|0])){h=(0|f)==o[d+13|0];break l}h=(0|f)==o[d+12|0];break l}f=31&m,h=0;u:switch(m>>>5&7){case 0:h=(0|f)==o[d+11|0];break l;case 1:h=(0|f)==(15&g[d+6>>1]);break l;case 2:h=A[d+4>>2]>>>f&1;break l;case 4:break u;default:break l}u:switch(0|f){case 0:case 1:case 2:case 3:case 4:if(2!=o[A[144464+(o[c+2|0]<<2)>>2]+11|0]){if(2!=o[A[144464+(o[c+34|0]<<2)>>2]+11|0])break l;c=c+32|0}d=15&o[c+3|0],d=!e|!(2&o[e+56|0])?d:o[c+6|0]<=d>>>0?4:d;c:{d:switch(f-3|0){case 1:h=o[c+6|0]<=d>>>0;break l;case 0:if(h=1,d>>>0<=3)break c;break l}if(h=1,A[102832+(f<<2)>>2]>(0|d))break l}h=0;break l;case 17:if(!o[d+11|0]){h=1;break l}h=(32&o[n+1|0])>>>5|0;break l;case 18:h=0!=g[c+4>>1];break l;case 19:if(h=1,g[c+36>>1])break l;h=!o[A[c+40>>2]+11|0];break l;case 9:if(g[c+4>>1])break l;for(;;){if(h=!!(0|(d=12&o[c-29|0])),d)break l;if(g[4+(c=c-32|0)>>1])break}break l;case 10:h=2!=o[d+11|0];break l;case 11:for(;;){if(h=!!(0|(d=g[c+36>>1])),d)break l;if(d=c,c=c+32|0,2==o[A[d+40>>2]+11|0])break}break l;case 12:if(h=1,2==(254&o[d+11|0]))break l;h=(16&o[d+4|0])>>>4|0;break l;case 13:for(;h=(2==o[A[c+8>>2]+11|0])+h|0,d=g[c+4>>1],c=c-32|0,!d;);h=1==(0|h);break l;case 14:for(;h=(2==o[A[c+8>>2]+11|0])+h|0,d=g[c+4>>1],c=c-32|0,!d;);h=2==(0|h);break l;case 16:break u;default:break l}h=(16&o[0|c])>>>4|0}else if(h=0,15==(0|c)){u:switch(f-1|0){case 0:h=T;break l;case 1:break u;default:break l}h=0!=A[N+132>>2]}l:if(1970>>>(c=(d=65535&t)>>>12|0)&1)c=a[c+102848|0];else{u:switch(0|c){case 0:if(c=1,3328!=(3840&d))break l;c=1+(1+(255&d)>>>1|0)|0;break l;case 6:c=(d>>>9&7)-5>>>0<2?12:1;break l;case 2:case 3:c=3328==(0|(c=3840&d))||1536==(0|c)?2:1;break l}c=4,(d=g[r+4>>1])>>>0>61439||(c=2==(0|d)?3:2)}if(r=((c=3==g[(r=(c<<1)+r|0)>>1])<<1)+r|0,c^=h,p=y?c|p:c&p,y=4096&t,8192!=(57344&(t=g[r>>1])))break}if(!(1&p))if(26624!=(63488&t)){l:if(1970>>>(c=t>>>12|0)&1)c=a[c+102848|0];else{u:switch(0|c){case 0:if(c=1,3328!=(3840&t))break l;c=1+(1+(255&t)>>>1|0)|0;break l;case 6:c=(t>>>9&7)-5>>>0<2?12:1;break l;case 2:case 3:c=3328==(0|(t&=3840))||1536==(0|t)?2:1;break l}c=4,(t=g[r+4>>1])>>>0>61439||(c=2==(0|t)?3:2)}r=((24576==(65024&g[(t=(c<<1)+r|0)>>1]))<<1)+t|0}else r=((255&t)<<1)+r|0}c=r-2|0,d=b;break t}o:switch(c>>>1|0){case 0:r=(((255&t)<<1)+r|0)-2|0;break e;case 5:A[i>>2]=2|A[i>>2],((t=o[A[n+40>>2]+12|0])-28&255)>>>0<=5&&(c=g[4+(t=((t<<2)+r|0)-112|0)>>1],t=g[t+2>>1],A[i+96>>2]=t>>>4<<24>>24,A[i+76>>2]=(15&t)<<18|c<<2),r=r+24|0;break e;case 6:break o;default:break e}((t=o[A[S>>2]+13|0])-28&255)>>>0<=5&&(c=g[4+(t=((t<<2)+r|0)-112|0)>>1],t=g[t+2>>1],A[i+100>>2]=t>>>4<<24>>24,A[i+80>>2]=(15&t)<<18|c<<2),r=r+24|0;break e}t=g[(r=r+2|0)>>1]|t<<16&983040;A:switch(c-1|0){case 0:if((0|C)>9)break e;A[(l+32|0)+(C<<2)>>2]=r,r=(A[34459]+(t<<1)|0)-2|0,C=C+1|0;break e;case 1:A[i+124>>2]=t;break e;case 2:break A;default:break e}A[i+128>>2]=t;break e}A[108+(c=((1!=(0|c))<<3)+i|0)>>2]=g[r+2>>1]|(255&t)<<16,t=g[r+4>>1]<<16,r=r+6|0,A[c+112>>2]=t|g[r>>1];break e}if(d=g[(c=r+2|0)>>1],m=t>>>4|0,A[88+(p=((f=h-11|0)<<2)+i|0)>>2]=255&m,A[p+68>>2]=t<<18&3932160|d<<2,2==(0|(r=g[r+4>>1]))){r=c;break e}if(d=t>>>0<=53247?r>>>0>61439?2:1:b-(4==(0|f))|0,h-13>>>0>1)break t;A[p+88>>2]=m<<24>>24;break t}A[l+4>>2]=Kr(l+75|0,A[u>>2]),A[l>>2]=t,ts(x,85851,l);break e}A[4+((c<<2)+i|0)>>2]=d,d=w&&1==(0|c)?1:b}c=r}1!=(0|d)|(0|C)<=0?(r=c,b=d):(r=A[(l+32|0)+((C=C-1|0)<<2)>>2],b=0)}if(r=r+2|0,1==(0|b))break}!s|2!=o[n+17|0]||(e=A[n+4>>2],A[s>>2]=A[n>>2],A[s+4>>2]=e,e=A[n+28>>2],A[s+24>>2]=A[n+24>>2],A[s+28>>2]=e,e=A[n+20>>2],A[s+16>>2]=A[n+16>>2],A[s+20>>2]=e,e=A[n+12>>2],A[s+8>>2]=A[n+8>>2],A[s+12>>2]=e),a[n+23|0]=A[i+44>>2],(e=A[i+68>>2])?(A[n+24>>2]=e,e=i+88|0):(A[n+24>>2]=A[i+72>>2],e=i+92|0),A[n+28>>2]=A[e>>2]}U=l+80|0}function ue(e,t,n,r,s,i){var l,u=0,c=0,d=0,h=0,f=0,g=0,p=0,m=0,C=0,I=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0;U=l=U-848|0;e:if(!(!A[e+104>>2]|8&o[s+2|0]|193==A[47202])){for(A[r>>2]=0,A[33272]=0,A[33274]=i,a[l+192|0]=0,A[33273]=l+192;h=(i=h)+1|0,a[0|(k=t+i|0)]-48>>>0<10;);A[56798]=0,E=l+188|0,g=-2147483648,U=w=U-16|0;t:if(u=o[0|t]){f=t;n:{for(;;){if(!(32==(0|(u=u<<24>>24))|u-9>>>0<5))break n;if(u=o[f+1|0],f=f+1|0,!u)break}break t}n:switch((u=o[0|f])-43|0){case 0:case 2:break n;default:break t}C=45==(0|u)?-1:0,f=f+1|0}else f=t;for(;u=-48,(((p=a[0|f])-48&255)>>>0<10||(u=-87,(p-97&255)>>>0<26||(u=-55,!((p-65&255)>>>0>25))))&&!((0|(p=u+p|0))>=10);)nn(w,10,0,0,0,m,I,0,0),u=1,A[w+8>>2]|A[w+12>>2]||(y=sr(m,I,10,0),-1==(0|(v=K))&~p>>>0<y>>>0||(u=v,I=(m=p+y|0)>>>0<p>>>0?u+1|0:u,x=1,u=d)),f=f+1|0,d=u;E&&(A[E>>2]=x?f:t);t:{n:{if(d)A[56798]=68,m=-2147483648,I=0;else if(!I&m>>>0<2147483648)break n;if(!C){A[56798]=68,g=2147483647;break t}if(!(!I&m>>>0<=2147483648)){A[56798]=68;break t}}g=(C^m)-C|0}if(U=w+16|0,C=g,!(A[56798]|A[l+188>>2]==(0|t))){t:{n:{r:{if(!(!((0|(p=64&o[e+109|0]?4:3))!=(0|i)|A[e+124>>2]!=a[t-2|0])&a[t-3|0]-48>>>0<10)){s:{if(32!=A[e+124>>2]){if(!(16&o[e+105|0]))break r;if(3==(0|i))break s;break r}if(3!=(0|i))break r}if(4&o[s+2|0]|a[t-2|0]-48>>>0>=10)break r}a[133104]=0,a[l+288|0]=0,B=1;break n}if(a[133104]=0,A[33275]=0,a[l+288|0]=0,M=1,x=0,48==o[0|t])break t}x=Et(e,t,k,s,0)}46!=o[0|k]|a[t+h|0]-48>>>0<10|1&a[s+13|0]|a[k+2|0]-48>>>0<10||(a[0|k]=0);t:if(!x||(y=1,26741==A[e+212>>2])){if(g=l+256|0,A[l+844>>2]=g,c=h,64&o[s+1|0]&&(a[l+256|0]=45,g=l+256|1,A[l+844>>2]=g,c=i+2|0),f=o[t+c|0]){for(;!(32==(255&f)|(0|c)>28)&&(u=A[l+844>>2],A[l+844>>2]=u+1,a[0|u]=f,f=o[(c=c+1|0)+t|0]););g=A[l+844>>2]}if(a[0|g]=0,y=1,u=a[l+256|0]){if(!(d=A[e+136>>2])||mr(l+256|0,d)){if(u-48>>>0<10)break t;if(A[l+176>>2]=l+256,En(u=l+800|0,88653,l+176|0),!Mn(e,u,133104))break t;A[r>>2]=128|A[r>>2],A[l+160>>2]=l+256,En(u=l+800|0,88773,l+160|0),Mn(e,u,133116),y=0}x=2}}E=A[s>>2],a[l+352|0]=0,a[l+624|0]=0;t:{n:{r:if(!(!M|48!=o[0|t]||32==(0|(u=a[t+1|0]))|(0|u)==A[e+128>>2])){s:{if(2==(0|i)){if(58!=o[t+3|0]|a[t+5|0]-48>>>0>=10)break s;if(!(32==(0|(u=a[t+7|0]))|u-9>>>0<5))break s;break r}if((0|i)>3)break n}if(48==o[0|t]&&!((0|(u=i-1|0))<=0))for(c=0;;){if(Mn(e,88875,Hn(d=l+288|0)+d|0),48!=o[(c=c+1|0)+t|0])break r;if(!((0|u)>(0|c)))break}}r:{s:{if(!(32==(0|(u=a[0|k]))&&16&o[e+105|0])){if(v=2,m=i+2|0,(0|u)==A[e+124>>2])break s;I=1,g=0,u=0;break r}v=1,m=i+2|0}if(4&o[s+14|0])g=1,u=0,I=1;else for(u=0,f=1,c=i,I=1;;){d=u,u=f,f=(w=c+v|0)+t|0,c=0;s:{for(;;){if(g=1,!(a[c+f|0]-48>>>0>=10)){if((0|p)!=(0|(c=c+1|0)))continue;break s}break}u=d;break r}if(a[f+p|0]-48>>>0<10){u=d;break r}if(c=0,a[f-1|0]-48>>>0<10){u=d;break r}s:{for(;;){if(48==o[(c+w|0)+t|0]){if((0|p)!=(0|(c=c+1|0)))continue;break s}break}I=0}if((0|(d=a[(c=p+w|0)+t|0]))!=A[e+124>>2]&(!(16&o[e+105|0])|32!=(0|d)))break r;if(m=c+2|0,4&o[2+(b(f=u+1|0,12)+s|0)|0])break}}c=!C;r:if(!(!I|!(64&o[1+(b(u,12)+s|0)|0])|26741!=A[e+212>>2])){s:switch(o[0|(d=t+m|0)]-97|0){case 0:case 4:break s;default:break r}s:{a:{i:{A:switch((f=o[d+1|0])-116|0){case 6:break r;case 1:case 2:case 3:case 4:case 5:break a;case 0:break A;default:break i}if(116!=o[d+2|0])break s;break r}if(32==(0|f))break r}if(!(!!((0|C)%1e3|0)&1!=(0|u))&&108==(0|f))break r}A[33274]=1|A[33274]}m=32768&E,c&=B;r:if(A[e+128>>2]!=a[0|k]|a[t+h|0]-48>>>0>=10){s:{if(!c){if(c=0,d=1,!((0|u)>0&g))break s;C=(h=xe(e,C,u,I,l+624|0))?0:C,c=!!(0|h),f=0;break r}c=1,C=0,1==A[33275]&&(A[l+144>>2]=u+1,En(h=l+800|0,89026,l+144|0),Mn(e,h,l+688|0)||(A[l+128>>2]=u,En(h=l+800|0,89026,l+128|0),Mn(e,h,l+624|0)))}d=1,f=0}else Mn(e,88882,l+624|0),d=0,f=256;g=m?2:x;r:{if(u|o[l+624|0]|46!=o[0|k]){if(u)break r}else Mn(e,89192,l+624|0);if(A[l+844>>2]=t,a[t+1|0]-48>>>0<10)for(;h=A[l+844>>2],A[l+844>>2]=h+1,a[h+2|0]-48>>>0<10;);if(a[A[l+844>>2]-1|0]-48>>>0>=10||(A[l+416>>2]=A[l+844>>2]-1,He(e,l+416|0,l+192|0,r,4,s)&&(A[33272]=2)),o[l+192|0]|48==o[A[l+844>>2]]||He(e,l+844|0,l+192|0,r,4,s)&&(A[33272]=1),M){if(!g&d&&(A[l+112>>2]=C,En(s=l+800|0,89214,l+112|0),Mn(e,s,n)))break t;if(1&a[e+110|0]){for(h=t;32!=(32|o[0|h]);)h=h+1|0;A[l+416>>2]=h,37==o[h+1|0]&&(Mn(e,89328,n),s=Hn(n),a[A[l+416>>2]+1|0]=32,n=n+s|0)}}}Te(e,C,l+416|0,c,u,g|f|B),!(2&o[e+109|0])|(0|u)<=0?(A[l+60>>2]=15,A[l- -64>>2]=l+624,A[l+56>>2]=l+416,A[l+52>>2]=l+352,A[l+48>>2]=l+288,En(n,89415,l+48|0)):(A[l+88>>2]=15,A[l+96>>2]=l+416,A[l+92>>2]=l+352,A[l+84>>2]=l+624,A[l+80>>2]=l+288,En(n,89346,l+80|0));r:if(!d)for(;;){for(i=i+1|0,d=0;d=(h=d)+1|0,a[(u=i+h|0)+t|0]-48>>>0<10;);s=2;s:{a:{i:{A:{o:{l:switch((d=57344&A[e+104>>2])-8192>>>13|0){case 6:break a;case 2:break i;case 0:case 4:case 5:break A;case 1:break o;case 3:break l;default:break s}s=5}if(48==(0|(d=o[0|(c=t+i|0)])))for(;Mn(e,88875,u=l+688|0),Es(n,u),h=h-1|0,48==(0|(d=o[0|(c=(i=i+1|0)+t|0)])););if((0|s)<(0|h)|(d<<24>>24)-48>>>0>=10)break s;s=l+688|0,Te(e,kn(c),s,0,0,0),Es(n,s),i=i+h|0;break s}if(Te(e,kn(s=t+i|0),l+416|0,0,0,0),!(8192==(0|d)&48!=o[0|s])){if(A[l+16>>2]=h,En(s=l+800|0,89508,l+16|0),!Mn(e,s,l+688|0))break s;Es(49152==(0|d)?n:l+416|0,l+688|0)}Es(n,l+416|0),i=u;break s}if((0|h)>4)break s;if(48==o[0|(s=t+i|0)])break s;Te(e,i=kn(s),s=l+688|0,0,0,0),Es(n,s),i=u;break s}if(!((0|h)<=1))for(;;){if(A[l+32>>2]=a[t+i|0],En(s=l+800|0,89575,l+32|0),!Mn(e,s,l+688|0))break s;if(Es(n,l+688|0),i=i+1|0,!((0|(h=h-1|0))>1))break}}s:if(!((d=o[0|(h=t+i|0)])-48>>>0>=10||Hn(n)>>>0>=190))for(;;){if(s=l+688|0,Ie(e,a[0|h]-48|0,0,2,s),u=Hn(n),A[l>>2]=15,A[l+4>>2]=s,En(n+u|0,89594,l),(d=o[0|(h=(i=i+1|0)+t|0)])-48>>>0>=10)break s;if(!(Hn(n)>>>0<=189))break}if(Mn(e,89678,l+688|0)&&Es(n,l+688|0),A[e+128>>2]!=(0|d)|a[1+(t+i|0)|0]-48>>>0>=10)break r;Mn(e,88882,s=l+688|0),Es(n,s)}if(!(s=o[0|n])|21==(0|s)||(s=Ht(l+184|0,t=1+(t+i|0)|0),i=A[l+184>>2],!(2&o[e+106|0])|32!=(0|i)||(Ht(l+184|0,t+s|0),i=A[l+184>>2]),Br(i)|I||(e=Hn(n)+n|0,a[0|e]=11,a[e+1|0]=0)),A[r>>2]=-2147483648|A[r>>2],A[33275]=A[33275]-1,c=1,y)break e;A[33264]=1;break e}A[r>>2]=-129&A[r>>2],c=0;break e}c=1}}return U=l+848|0,c}function ce(e,t,n,r){var s,l,u=0,c=0,d=0,h=0,f=0,p=0,m=0,C=0,I=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0,N=0;if(U=s=U-416|0,v=g[n+8>>1],I=o[n+10|0],64&(l=A[n>>2])){for(A[n>>2]=-65&l,a[199388]=1,d=A[47202],m=A[49846],f=A[47352],p=A[47351],h=A[47350];;){u=(c=A[198304+(p<<2)>>2])>>8;e:{t:switch((31&c)-9|0){case 0:d=u;break e;case 4:m=u;break e;case 3:break t;default:break e}f=c>>>0>=256?u+f|0:0}if(!(!(128&c)&(0|h)>(0|(p=p+1|0))))break}A[47352]=f,A[47351]=p,A[49846]=m,A[47202]=d}m=0;e:if(!((0|(u=A[49572]))>997))if(1048576&l||!o[0|t])o[199388]&&(A[49572]=u+1,a[199388]=0,A[(e=190288+(u<<3)|0)>>2]=983042,A[e+4>>2]=0),a[189088]=0;else if(!((0|u)>990)){(0|(u=A[e+8224>>2]))>0&&(A[e+8224>>2]=u-1),d=512&l?r:r+4|0,f=16==(240&A[47202]),(x=2&l)&&((0|(c=A[47200]))<3||(0|(u=A[47350]))>243||(o[199388]&&(A[(p=198300+(u<<2)|0)>>2]=-129&A[p>>2]),A[47350]=u+1,a[199388]=1,E=3==(0|c)?20:c,A[198304+(u<<2)>>2]=E<<8|193)),h=f?d:r;t:{n:{if(!(8&l)){for(;r=o[(u=C)+t|0],a[u+(s+240|0)|0]=r,223&r&&(C=u+1|0,u>>>0<160););if(a[s+66|0]=0,C=s- -64|2,m=ht(A[47192],t,n,C),A[s+412>>2]=m,!(4096&m))break n;Je(t,s+240|0,u);break e}r:if(Sn(t,87276,3))je(t,189088,s+240|0);else{if(p=0,223&(u=o[0|(C=t+3|0)]))for(;a[(s+240|0)+p|0]=ar(u<<24>>24),p=p+1|0,223&(u=o[0|(C=C+1|0)]););a[(r=s+240|0)+p|0]=0,u=0;s:if(!((0|(n=A[34461]))<=0)){for(;;){if(!mr(r,b(u,44)+137856|0)){A[34457]=u;break s}if((0|n)==(0|(u=u+1|0)))break}u=n}if((0|(n=(0|n)==(0|u)?-1:u))<=0)break r;Zr(n),a[189090]=0,a[189089]=n,a[189088]=21}m=-2147483648,A[s+412>>2]=-2147483648,r=-1;break t}if(!(!(8388608&m)|8&o[n+12|0])){for(U=f=U-208|0,p=A[e+60>>2],c=t;r=c,c=c+1|0,32!=o[0|r];);Ht(f+204|0,c);n:if(Br(A[f+204>>2])){d=rn(f,189088),c=(!(256&p)|(k=ne(e,c,n+12|0,0))>>>15)&!(67108864&k)&21!=o[189088];r:{s:{if(512&p){if(!(c&!(16&o[n+12|0])))break s;break r}if(c)break r}rn(189088,d);break n}if(a[0|r]=45,A[n>>2]=-2&A[n>>2],m=0,c=189088,w=ne(A[47192],t,n,0),A[s+412>>2]=w,!((0|p)<=0)&&(d=o[189088])){for(;m=(2==o[A[144464+(d<<2)>>2]+11|0])+m|0,d=o[0|(c=c+1|0)];);if(!((31&p)>=(0|m))){a[0|r]=32,A[s+412>>2]=ne(A[47192],t,n,0);break n}}A[s+412>>2]=128|(w||k),A[33264]=1}U=f+208|0}if(r=-1,21==o[189088]){if(p=rn(s+16|0,132848),f=A[s+412>>2],c=Je(t,s+240|0,u),d=s- -64|1,(0|(r=Dn(o[189089]?189089:87315,188772,189296)))<0||(A[n>>2]=4194304|A[n>>2],o[s+66|0]?(i[s+64>>1]=8192,f=ne(A[47193],d,n,0)):f=ht(A[47193],c,n,C)),21==o[189088]&&(u=Je(c,s+240|0,u),(0|(r=Dn(o[189089]?189089:87315,188772,189296)))<0||(A[n>>2]=4194304|A[n>>2],o[s+66|0]?(i[s+64>>1]=8192,f=ne(A[47193],d,n,0)):f=ht(A[47193],u,n,C)),m=4096,21==o[189088]))break e;A[s+412>>2]=f,(0|r)>=0||(a[189090]=0,i[94544]=3341,-1==(0|r)&&(rn(132848,p),Zr(A[A[32972]+60>>2]),r=A[A[32972]+60>>2]))}m=A[s+412>>2],128&l||(h=268435456&m&&(0|h)<=1?1:h,!(256&m)|528&l|A[e+8224>>2]|2&o[n-11|0]||(A[e+8224>>2]=3,h=(0|h)<=4?4:h)),h=(0|h)<=0&&A[49846]>2?1:h}if(n=o[199388],!((0|h)<=0|(0|(C=A[49572]))>990)){A[49572]=C+1,c=1&n,n=0,i[(u=190288+(C<<3)|0)>>1]=c?2:0,a[u+7|0]=0,a[u+3|0]=0,c=h>>>0>1,a[u+2|0]=c?9:11,i[u+4>>1]=0,A[e+8236>>2]=0;t:if(!(!(u=c?h-2|0:0)|(0|(C=A[49572]))>990))for(d=e+8236|0;;){if(A[49572]=C+1,i[(c=190288+(C<<3)|0)>>1]=0,a[c+7|0]=0,a[c+3|0]=0,f=u>>>0>1,a[c+2|0]=f?9:11,i[c+4>>1]=0,A[d>>2]=0,C=A[49572],(0|(u=f?u-2|0:0))<=0)break t;if(!((0|C)<991))break}A[e+8228>>2]=0,A[e+8232>>2]=0}a[199388]=1&n,!x|1!=A[47200]||(A[49572]=C+2,a[199388]=0,i[(u=190288+(C<<3)|0)>>1]=1&n?2:0,a[u+7|0]=0,i[u+2>>1]=10,i[u+4>>1]=0,i[u+12>>1]=0,A[u+8>>2]=1179648,a[u+15|0]=0,1&l&&fn(a[t+1|0])&&(n=o[199388],a[199388]=0,t=A[49572],A[49572]=t+2,i[(t=190288+(t<<3)|0)>>1]=n?2:0,a[t+7|0]=0,i[t+2>>1]=10,i[t+4>>1]=0,i[t+12>>1]=0,A[t+8>>2]=1179648,a[t+15|0]=0)),u=I>>>0<31;t:if(!((0|r)<0))if(t=A[49572],n=o[190290+((h=t-1|0)<<3)|0],9!=o[189088]|21!=o[189089])21!=(0|n)&&(c=o[199388],a[199388]=0,a[7+(n=190288+(t<<3)|0)|0]=0,i[n+2>>1]=21,i[n+4>>1]=0,i[n>>1]=c?2:0,h=t),A[49572]=h+1,a[190295+(h<<3)|0]=r;else{if(21!=(0|n))break t;A[49572]=h}t=2047&v,n=(u?I:31)<<11,f=(B=128&l)?o[A[144464+(o[189088]<<2)>>2]+11|0]?189088:189089:189088,(h=o[0|f])|!(1&a[199388])||(h=23,a[0|f]=23,a[f+1|0]=0),M=t|n,d=A[49572];t:if(h)if((0|d)>994)t=0;else for(S=(-2147483648==(-1610612736&m))<<4,v=M+1|0,N=e+8233|0,t=0,c=1,k=0,D=1,I=-1,x=-1,u=0;;){p=f+1|0;n:{if(255!=(0|(w=255&h))){if(n=A[144464+(w<<2)>>2])break n;A[s>>2]=w,U=n=U-16|0,A[n+12>>2]=s,ms(132552,87474,s),U=n+16|0,d=A[49572]}if(!(h=o[0|p]))break t;if(f=p,(0|d)<995)continue;break t}n:if(21!=(0|(y=255&h)))if(1!=(0|(f=o[n+11|0]))){n=v;r:switch(y-12|0){case 8:a[3+(n=190288+((I=d-1|0)<<3)|0)|0]=c,i[n>>1]=4|g[n>>1],n=u;break n;case 0:i[(n=190280+(d<<3)|0)>>1]=8|g[n>>1],n=u;break n;case 10:m|=16384,A[s+412>>2]=m,n=u;break n;case 3:break n}w=o[199388],a[199388]=0,a[7+(n=190288+(y=d<<3)|0)|0]=0,a[n+2|0]=h,i[n+4>>1]=u,u=(w?2:0)|S,i[n>>1]=u,2==(0|f)?((0|c)>=4&&(a[189076]=1),(0|I)<0||(0|(t=d-1|0))!=(0|I)&&(a[190291+(t<<3)|0]=c),i[n>>1]=4|u,T=(t=(0|c)>(0|x))?d:T,x=t?c:x,u=1,k&&(a[n+7|0]=k),I=d,k=0,t=c):(!D|!(64&o[0|N])||(i[n>>1]=8|u),u=c),d=d+1|0,A[49572]=d,a[y+190291|0]=t,n=0,D=0,c=u}else{if(!g[n+8>>1]){c=o[n+14|0],n=u;break n}if((0|I)<0){n=u,k=w;break n}a[190295+(I<<3)|0]=h,n=u}else A[(n=190288+(d<<3)|0)>>2]=1376256,i[n+4>>1]=0,a[n+7|0]=o[f+1|0],A[49572]=d+1,Zr(o[f+1|0]),p=f+2|0,d=A[49572],n=u;if(!(h=o[0|p]))break t;if(f=p,u=n,!((0|d)<995))break}else t=0;131072&l&&(n=d+1|0,A[49572]=n,c=o[199388],a[199388]=0,a[7+(u=190288+(d<<3)|0)|0]=0,i[u+2>>1]=27,i[u+4>>1]=0,i[u>>1]=c?2:0,d=n),B||(i[190292+(C<<3)>>1]=M),A[e+8228>>2]=0,2!=o[A[144464+(o[190282+(d<<3)|0]<<2)>>2]+11|0]|(0|t)<4||(A[e+8228>>2]=1),(0|r)>=0&&(rn(132848,s+16|0),Zr(A[A[32972]+60>>2]),n=o[199388],a[199388]=0,r=A[49572],i[(t=190288+(r<<3)|0)>>1]=n?2:0,i[t+2>>1]=21,i[t+4>>1]=0,a[t+7|0]=A[A[32972]+60>>2],d=r+1|0,A[49572]=d),(0|E)>0&&(a[199388]=0,A[49572]=d+1,A[(t=190288+(d<<3)|0)>>2]=655362,n=A[47350],A[47350]=n+1,a[t+7|0]=0,i[t+4>>1]=0,A[198304+(n<<2)>>2]=E<<8|225),1024&m&&(i[(t=190288+(T<<3)|0)>>1]=64|g[t>>1]),A[e+8232>>2]=m}return U=s+416|0,m}function de(e,t,n,r,s){var i=0,l=0,u=0,c=0,d=0,h=0,f=0,g=0,p=0,m=0,C=0,I=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0,N=0;e:if(t){if(w=s<<4,l=(t=A[33268])+n|0,!((0|t)<=0||(i=o[0|(c=w+129360|0)],f=o[c+1|0]-i<<8,f=1!=(0|t)?(0|f)/(0|t)|0:f,(0|n)>=(0|l))))for(g=f>>>0>255,C=f>>>8|0,i<<=8,c=0-f>>>8|0,y=(0|f)<=0,t=n;y?(d=(h=(h=(0|(u=(0|(u=A[101024+(a[b(t,6)+e|0]<<2)>>2]))<(0|c)?c:u))>=18?18:u)+(u=(0|(u=(0|(i=i+f|0))/256|0))>0?u:0)|0)>>>0>=254?254:h,u=u>>>0>=254?254:u):(u=b(t,6)+e|0,a[u+2|0]=g|o[u+2|0],u=(h=(0|(u=(0|i)/256|0))>0?u:0)>>>0>=254?254:h,d=(h=h+C|0)>>>0>=254?254:h,i=i+f|0),h=b(t,6)+e|0,a[h+5|0]=u,a[h+4|0]=d,(0|l)!=(0|(t=t+1|0)););if(2&o[188785]?(c=A[33271],A[33270]=c):c=A[33270],C=(g=o[3+(i=129360+(t=s<<4)|0)|0])-(u=o[i+2|0])<<8,y=A[i+4>>2],(0|n)>0?(E=101056,k=5,h=(0|C)/(o[t+129368|0]-1|0)|0):(E=A[12+(t=t+129360|0)>>2],k=o[t+10|0],h=0),(0|l)<(0|c)){for(f=(0|n)<=0,I=((t=C>>31)^C)-t|0,p=129360+(s<<4)|0,u<<=8,v=g<<8,g=0;;){t:{if(d=b(l,6)+e|0,!(!(1&f)&(0|(i=a[0|d]))<4)){n=0,t=l;n:if(1&(5==(0|i)|f)){for(;(0|(h=a[b(t,6)+e|0]))<=6&&(n=((0|h)>3)+n|0,(0|c)!=(0|(t=t+1|0))););if(m=0,(0|(x=(0|(t=o[p+8|0]))>(0|n)?n:t))<2){h=0,g=u;break n}h=(0|C)/(x-1|0)|0,g=u}else(0|x)>0?g=h+g|0:(g=v+(b(I,a[m+E|0])>>6)|0,(0|k)>(0|(m=m+1|0))||(E=A[p+12>>2],m=0));if(x=x-1|0,!((0|i)<4)){a[0|d]=6,n=(t=(0|(t=(0|g)/256|0))>0?t:0)+(((n=(i=A[y+(i<<2)>>2])>>31)^i)-n|0)|0;break t}}3!=(0|i)?(t=(0|g)/256|0,(63&o[d-6|0])>>>0>=3?(n=(i=A[y+(i<<2)>>2])>>31,n=(t=(0|(t=t-a[p+9|0]|0))>0?t:0)+((n^i)-n|0)|0):n=(t=(0|t)>0?t:0)+(((n=(i=A[y+(i<<2)>>2])>>31)^i)-n|0)|0):n=(t=(0|(t=(0|g)/256|0))>0?t:0)+(((n=(i=A[y+12>>2])>>31)^i)-n|0)|0}if(a[d+5|0]=t>>>0>=254?254:t,f=0,t=(0|n)>0?n:0,a[d+4|0]=t>>>0>=254?254:t,a[d+2|0]=o[d+2|0]|i>>>31,(0|c)==(0|(l=l+1|0)))break}l=c}if(!(o[133068]||(3==(268435455&s)&&(t=b(l,6)+e|0,a[t+2|0]=2|o[t+2|0]),A[33269]?(t=o[5+(i=100768+(s<<4)|0)|0],u=i+3|0,n=o[i+4|0]-t|0):(t=o[2+(n=100768+(s<<4)|0)|0],u=w+100768|0,n=o[n+1|0]-t|0),i=b(l,6)+e|0,a[i+5|0]=t>>>0>=254?254:t,a[i+2|0]=o[i+2|0]|n>>>31,t=(h=t)+(((t=n>>31)^n)-t|0)|0,a[i+4|0]=t>>>0>=254?254:t,n=b(c,6)+e|0,a[n+1|0]=o[0|u],t=l+1|0,4==o[0|n]&&(a[0|n]=6),(0|(n=r-t|0))<=0||(s=o[12+(l=100768+(s<<4)|0)|0],l=o[l+13|0]-s<<8,l=1!=(0|n)?(0|l)/(0|n)|0:l,(0|t)>=(0|r)))))for(h=l>>>0>255,f=l>>>8|0,n=s<<8,s=0-l>>>8|0,g=(0|l)<=0;g?(u=(c=(u=(0|(i=(0|s)>(0|(i=A[101024+(a[b(t,6)+e|0]<<2)>>2]))?s:i))>=18?18:i)+(i=(0|(i=(0|(n=n+l|0))/256|0))>0?i:0)|0)>>>0>=254?254:c,c=i>>>0>=254?254:i):(i=b(t,6)+e|0,a[i+2|0]=h|o[i+2|0],c=(i=(0|(i=(0|n)/256|0))>0?i:0)>>>0>=254?254:i,u=(i=i+f|0)>>>0>=254?254:i,n=n+l|0),i=b(t,6)+e|0,a[i+5|0]=c,a[i+4|0]=u,(0|r)!=(0|(t=t+1|0)););}else{if(t=(k=A[34455])+b(s,68)|0,l=o[t+24|0],c=o[t+25|0],i=(t=A[33268])+n|0,!((0|t)<=0||(d=c-l<<8,d=1!=(0|t)?(0|d)/(0|t)|0:d,(0|n)>=(0|i))))for(h=d>>>0>255,f=d>>>8|0,t=l<<8,c=0-d>>>8|0,g=(0|d)<=0;g?(l=(l=(C=(0|(l=(0|(l=A[101024+(a[b(n,6)+e|0]<<2)>>2]))<(0|c)?c:l))>=18?18:l)+(u=(0|(l=(0|(t=t+d|0))/256|0))>0?l:0)|0)>>>0>=254?254:l,u=u>>>0>=254?254:u):(l=b(n,6)+e|0,a[l+2|0]=h|o[l+2|0],u=(l=(0|(l=(0|t)/256|0))>0?l:0)>>>0>=254?254:l,l=(l=l+f|0)>>>0>=254?254:l,t=t+d|0),C=b(n,6)+e|0,a[C+5|0]=u,a[C+4|0]=l,(0|i)!=(0|(n=n+1|0)););2&o[188785]?(n=A[33271],A[33270]=n):n=A[33270],c=n,t=k+b(s,68)|0;t:if(255!=(0|(f=o[t+33|0])))for(;;){if((0|(c=c-1|0))<(0|i)){c=n;break t}if(!(a[b(c,6)+e|0]<4))break}if((0|n)>(0|i)){for(T=((l=(M=(g=o[t+32|0])-(d=o[0|(u=t+31|0)])<<8)>>31)^M)-l|0,v=255==(0|(t=o[0|(h=t+30|0)])),C=f<<8,y=d<<8,S=g<<8,w=k+b(s,68)|0,N=255!=(0|t),g=0,f=0,t=1,d=0;;){t:{if(p=b(i,6)+e|0,!(!(1&t)&(0|(I=a[0|p]))<4)){n:if(1&(5==(0|I)|t)){r:if(N){if(B=1,t=0,l=h,!((0|c)<=(0|(d=i+1|0)))){for(;;){if(l=h,(0|(f=a[b(d,6)+e|0]))>6)break r;if(t=((0|f)>3)+t|0,(0|c)==(0|(d=d+1|0)))break}l=h}}else{if(t=0,d=i,l=u,(0|c)<=(0|i))break r;for(;;){if(l=u,(0|(f=a[b(d,6)+e|0]))>6)break r;if(t=((0|f)>3)+t|0,(0|c)==(0|(d=d+1|0)))break}l=u}if(f=o[0|l]<<8,D=0,(0|(d=(0|t)<(0|(l=o[w+34|0]))?t:l))<2){E=0;break n}E=(0|M)/(d-1|0)|0}else(0|i)!=(0|c)?B?(v=1,d=d+1|0,B=0,f=y):(0|d)>0?(f=f+E|0,B=0):(B=0,f=(b(a[16+(w+D|0)|0],T)>>6)+S|0,D=(0|(t=D+1|0))<o[w+35|0]?t:0):(v=2,f=C);if(d=d-1|0,!((0|I)<4)){t=l=i+1|0;n:if(!((0|n)<=(0|i)))for(;;){if(a[b(t,6)+e|0]>1)break n;if(!((0|n)>=(0|(t=t+1|0))))break}a[0|p]=6,a[p+1|0]=o[w+26|0],g=0,m=o[w+27|0],i=(0|(i=(0|f)/256|0))>0?i:0,a[p+5|0]=i>>>0>=254?254:i,i=i+m|0,a[p+4|0]=i>>>0>=254?254:i,x=t-l|0;break t}}if((0|I)>=2){t=l=i+1|0;n:if(!((0|n)<=(0|i)))for(;;){if(a[b(t,6)+e|0]>1)break n;if(!((0|n)>=(0|(t=t+1|0))))break}g=0,i=(0|(i=(0|f)/256|0))>0?i:0,a[p+5|0]=i>>>0>=254?254:i,m=A[100976+(I<<2)>>2],a[p+2|0]=o[p+2|0]|m>>>31,i=(0|(i=(I=i)+(((i=m>>31)^m)-i|0)|0))>0?i:0,a[p+4|0]=i>>>0>=254?254:i,x=t-l|0}else(0|x)<=1?(m=a[36+(w+v|0)|0],t=0):(m=a[36+(t=w+v|0)|0],t=(a[t+39|0]-m|0)/(x-1|0)|0),l=A[100976+(I<<2)>>2],a[p+2|0]=o[p+2|0]|l>>>31,t=(0|(t=(((0|f)/256|0)+m|0)+b(t,g)|0))>0?t:0,a[p+5|0]=t>>>0>=254?254:t,t=(0|(t=t+(((I=l)^(l>>=31))-l|0)|0))>0?t:0,a[p+4|0]=t>>>0>=254?254:t,g=g+1|0,l=i+1|0}if(t=0,(0|n)==(0|(i=l)))break}i=n}if(o[133068])break e;if(l=b(i,6)+e|0,A[33269]?(u=k+b(s,68)|0,t=o[u+47|0],c=o[u+46|0]-t|0,u=u+45|0):(u=k+b(s,68)|0,t=o[u+44|0],c=o[u+43|0]-t|0,u=u+42|0),u=o[0|u],h=(((h=c>>31)^c)-h|0)+t|0,a[l+4|0]=h>>>0>=254?254:h,a[l+5|0]=t>>>0>=254?254:t,t=b(i,6)+e|0,a[t+2|0]=o[t+2|0]|c>>>31,n=b(n,6)+e|0,a[n+1|0]=u,t=i+1|0,4==o[0|n]&&(a[0|n]=6),(0|(n=r-t|0))<=0)break e;if(l=k+b(s,68)|0,s=o[l+48|0],l=o[l+49|0]-s<<8,l=1!=(0|n)?(0|l)/(0|n)|0:l,(0|t)>=(0|r))break e;for(h=l>>>0>255,f=l>>>8|0,n=s<<8,s=0-l>>>8|0,g=(0|l)<=0;g?(u=(c=(u=(0|(i=(0|s)>(0|(i=A[101024+(a[b(t,6)+e|0]<<2)>>2]))?s:i))>=18?18:i)+(i=(0|(i=(0|(n=n+l|0))/256|0))>0?i:0)|0)>>>0>=254?254:c,c=i>>>0>=254?254:i):(i=b(t,6)+e|0,a[i+2|0]=h|o[i+2|0],c=(i=(0|(i=(0|n)/256|0))>0?i:0)>>>0>=254?254:i,u=(i=i+f|0)>>>0>=254?254:i,n=n+l|0),i=b(t,6)+e|0,a[i+5|0]=c,a[i+4|0]=u,(0|r)!=(0|(t=t+1|0)););}}function he(){var e,t=0,n=0,r=0,s=0,o=0,l=0,u=0,c=0,d=0,h=0,f=0,p=0,m=0,C=0,I=0;if((0|(e=A[36455]))!=(0|(c=A[36454]))){e:if(!((0|(m=A[36427]))<0|(0|c)==(0|m))){n=f=A[8+(216192+((d=m)<<4)|0)>>2];t:{for(;;){if((r=A[(l=216192+((d=(0|(r=d-1|0))<0?169:r)<<4)|0)>>2])-5>>>0<2)break t;n:{if((0|r)<=4){if(A[l+12>>2]!=(0|n))break t;if(r=g[l+4>>1],A[l+12>>2]=f,n=A[l+8>>2],16&(t=g[n>>1]))break n;for(I=32&t?(b(r,12)>>>0)/10|0:r,s=0,r=n,u=0;;){t=g[n>>1];r:if(!(u>>>0<3&&8&t)){if(t=t<<16>>16,(0|(C=(h=i[2+((p=u<<1)+n|0)>>1])-(o=i[2+(p=f+p|0)>>1])|0))>(0|(h=(0|b(I,(0|b(A[200944+(u<<2)>>2],(0|C)>0?h+(o<<1)|0:(h<<1)+o|0))/3e3|0))/256|0)))s||((0|t)<0?r=n:(r=0,t=(0|(t=A[44469]+1|0))<=169?t:0,A[44469]=t,(t=177888+(s=t<<6)|0)&&(r=g[n+4>>1]|g[n+6>>1]<<16,o=g[n>>1]|g[n+2>>1]<<16,i[t>>1]=o,i[t+2>>1]=o>>>16,i[t+4>>1]=r,i[t+6>>1]=r>>>16,r=g[n+60>>1]|g[n+62>>1]<<16,o=g[n+56>>1]|g[n+58>>1]<<16,i[t+56>>1]=o,i[t+58>>1]=o>>>16,i[t+60>>1]=r,i[t+62>>1]=r>>>16,r=g[n+52>>1]|g[n+54>>1]<<16,o=g[n+48>>1]|g[n+50>>1]<<16,i[t+48>>1]=o,i[t+50>>1]=o>>>16,i[t+52>>1]=r,i[t+54>>1]=r>>>16,r=g[n+44>>1]|g[n+46>>1]<<16,o=g[n+40>>1]|g[n+42>>1]<<16,i[t+40>>1]=o,i[t+42>>1]=o>>>16,i[t+44>>1]=r,i[t+46>>1]=r>>>16,r=g[n+36>>1]|g[n+38>>1]<<16,o=g[n+32>>1]|g[n+34>>1]<<16,i[t+32>>1]=o,i[t+34>>1]=o>>>16,i[t+36>>1]=r,i[t+38>>1]=r>>>16,r=g[n+28>>1]|g[n+30>>1]<<16,o=g[n+24>>1]|g[n+26>>1]<<16,i[t+24>>1]=o,i[t+26>>1]=o>>>16,i[t+28>>1]=r,i[t+30>>1]=r>>>16,r=g[n+20>>1]|g[n+22>>1]<<16,o=g[n+16>>1]|g[n+18>>1]<<16,i[t+16>>1]=o,i[t+18>>1]=o>>>16,i[t+20>>1]=r,i[t+22>>1]=r>>>16,r=g[n+12>>1]|g[n+14>>1]<<16,o=g[n+8>>1]|g[n+10>>1]<<16,i[t+8>>1]=o,i[t+10>>1]=o>>>16,i[t+12>>1]=r,i[t+14>>1]=r>>>16,a[s+177904|0]=0,i[t>>1]=32768|g[t>>1],r=t))),t=h+g[p+2>>1]|0;else{if((0-h|0)<=(0|C))break r;s||((0|t)<0?r=n:(r=0,t=(0|(t=A[44469]+1|0))<=169?t:0,A[44469]=t,(t=177888+(s=t<<6)|0)&&(r=g[n+4>>1]|g[n+6>>1]<<16,o=g[n>>1]|g[n+2>>1]<<16,i[t>>1]=o,i[t+2>>1]=o>>>16,i[t+4>>1]=r,i[t+6>>1]=r>>>16,r=g[n+60>>1]|g[n+62>>1]<<16,o=g[n+56>>1]|g[n+58>>1]<<16,i[t+56>>1]=o,i[t+58>>1]=o>>>16,i[t+60>>1]=r,i[t+62>>1]=r>>>16,r=g[n+52>>1]|g[n+54>>1]<<16,o=g[n+48>>1]|g[n+50>>1]<<16,i[t+48>>1]=o,i[t+50>>1]=o>>>16,i[t+52>>1]=r,i[t+54>>1]=r>>>16,r=g[n+44>>1]|g[n+46>>1]<<16,o=g[n+40>>1]|g[n+42>>1]<<16,i[t+40>>1]=o,i[t+42>>1]=o>>>16,i[t+44>>1]=r,i[t+46>>1]=r>>>16,r=g[n+36>>1]|g[n+38>>1]<<16,o=g[n+32>>1]|g[n+34>>1]<<16,i[t+32>>1]=o,i[t+34>>1]=o>>>16,i[t+36>>1]=r,i[t+38>>1]=r>>>16,r=g[n+28>>1]|g[n+30>>1]<<16,o=g[n+24>>1]|g[n+26>>1]<<16,i[t+24>>1]=o,i[t+26>>1]=o>>>16,i[t+28>>1]=r,i[t+30>>1]=r>>>16,r=g[n+20>>1]|g[n+22>>1]<<16,o=g[n+16>>1]|g[n+18>>1]<<16,i[t+16>>1]=o,i[t+18>>1]=o>>>16,i[t+20>>1]=r,i[t+22>>1]=r>>>16,r=g[n+12>>1]|g[n+14>>1]<<16,o=g[n+8>>1]|g[n+10>>1]<<16,i[t+8>>1]=o,i[t+10>>1]=o>>>16,i[t+12>>1]=r,i[t+14>>1]=r>>>16,a[s+177904|0]=0,i[t>>1]=32768|g[t>>1],r=t))),t=g[p+2>>1]-h|0}s=1,i[2+((u<<1)+r|0)>>1]=t,A[l+8>>2]=r}if(6==(0|(u=u+1|0)))break}f=r}if((0|c)!=(0|d))continue;break t}break}f=n}for(r=0;;){if((n=A[(d=216192+(m<<4)|0)>>2])-5>>>0<2)break e;if((0|n)<=4){if(n=A[d+8>>2],t=g[d+4>>1],r){if((0|n)!=(0|r))break e;A[d+8>>2]=f}else f=n;if(16&(r=g[f>>1]))break e;for(p=32&r?(b(t,6)>>>0)/5|0:t,s=0,n=r=A[d+12>>2],u=0;;){t:{n:if((0|(c=(l=i[2+((t=u<<1)+r|0)>>1])-(t=i[2+(h=t+f|0)>>1])|0))>(0|(l=(0|b(p,(0|b(A[200944+(u<<2)>>2],(0|c)>0?l+(t<<1)|0:(l<<1)+t|0))/3e3|0))/256|0))){if(!s){if(i[r>>1]<0){n=r,t=t+l|0;break n}n=(0|(n=A[44469]+1|0))<=169?n:0,A[44469]=n,s=g[r+20>>1]|g[r+22>>1]<<16,t=16+(n=177888+(n<<6)|0)|0,c=g[r+16>>1]|g[r+18>>1]<<16,i[t>>1]=c,i[t+2>>1]=c>>>16,i[t+4>>1]=s,i[t+6>>1]=s>>>16,t=g[r+4>>1]|g[r+6>>1]<<16,s=g[r>>1]|g[r+2>>1]<<16,i[n>>1]=s,i[n+2>>1]=s>>>16,i[n+4>>1]=t,i[n+6>>1]=t>>>16,t=g[r+12>>1]|g[r+14>>1]<<16,s=g[r+8>>1]|g[r+10>>1]<<16,i[n+8>>1]=s,i[n+10>>1]=s>>>16,i[n+12>>1]=t,i[n+14>>1]=t>>>16,t=g[r+28>>1]|g[r+30>>1]<<16,s=g[r+24>>1]|g[r+26>>1]<<16,i[n+24>>1]=s,i[n+26>>1]=s>>>16,i[n+28>>1]=t,i[n+30>>1]=t>>>16,t=g[r+36>>1]|g[r+38>>1]<<16,s=g[r+32>>1]|g[r+34>>1]<<16,i[n+32>>1]=s,i[n+34>>1]=s>>>16,i[n+36>>1]=t,i[n+38>>1]=t>>>16,t=g[r+44>>1]|g[r+46>>1]<<16,s=g[r+40>>1]|g[r+42>>1]<<16,i[n+40>>1]=s,i[n+42>>1]=s>>>16,i[n+44>>1]=t,i[n+46>>1]=t>>>16,t=g[r+52>>1]|g[r+54>>1]<<16,s=g[r+48>>1]|g[r+50>>1]<<16,i[n+48>>1]=s,i[n+50>>1]=s>>>16,i[n+52>>1]=t,i[n+54>>1]=t>>>16,t=g[r+60>>1]|g[r+62>>1]<<16,s=g[r+56>>1]|g[r+58>>1]<<16,i[n+56>>1]=s,i[n+58>>1]=s>>>16,i[n+60>>1]=t,i[n+62>>1]=t>>>16,a[n+16|0]=0,i[n>>1]=32768|g[n>>1],t=g[h+2>>1]}t=t+l|0}else{if((0|c)>=(0-l|0))break t;s||(i[r>>1]<0?n=r:(n=(0|(n=A[44469]+1|0))<=169?n:0,A[44469]=n,s=g[r+20>>1]|g[r+22>>1]<<16,t=16+(n=177888+(n<<6)|0)|0,c=g[r+16>>1]|g[r+18>>1]<<16,i[t>>1]=c,i[t+2>>1]=c>>>16,i[t+4>>1]=s,i[t+6>>1]=s>>>16,t=g[r+4>>1]|g[r+6>>1]<<16,s=g[r>>1]|g[r+2>>1]<<16,i[n>>1]=s,i[n+2>>1]=s>>>16,i[n+4>>1]=t,i[n+6>>1]=t>>>16,t=g[r+12>>1]|g[r+14>>1]<<16,s=g[r+8>>1]|g[r+10>>1]<<16,i[n+8>>1]=s,i[n+10>>1]=s>>>16,i[n+12>>1]=t,i[n+14>>1]=t>>>16,t=g[r+28>>1]|g[r+30>>1]<<16,s=g[r+24>>1]|g[r+26>>1]<<16,i[n+24>>1]=s,i[n+26>>1]=s>>>16,i[n+28>>1]=t,i[n+30>>1]=t>>>16,t=g[r+36>>1]|g[r+38>>1]<<16,s=g[r+32>>1]|g[r+34>>1]<<16,i[n+32>>1]=s,i[n+34>>1]=s>>>16,i[n+36>>1]=t,i[n+38>>1]=t>>>16,t=g[r+44>>1]|g[r+46>>1]<<16,s=g[r+40>>1]|g[r+42>>1]<<16,i[n+40>>1]=s,i[n+42>>1]=s>>>16,i[n+44>>1]=t,i[n+46>>1]=t>>>16,t=g[r+52>>1]|g[r+54>>1]<<16,s=g[r+48>>1]|g[r+50>>1]<<16,i[n+48>>1]=s,i[n+50>>1]=s>>>16,i[n+52>>1]=t,i[n+54>>1]=t>>>16,t=g[r+60>>1]|g[r+62>>1]<<16,s=g[r+56>>1]|g[r+58>>1]<<16,i[n+56>>1]=s,i[n+58>>1]=s>>>16,i[n+60>>1]=t,i[n+62>>1]=t>>>16,a[n+16|0]=0,i[n>>1]=32768|g[n>>1],t=g[h+2>>1])),t=t-l|0}s=1,i[2+((u<<1)+n|0)>>1]=t,A[d+12>>2]=n}if(6==(0|(u=u+1|0)))break}f=n}if((0|e)==(0|(m=(0|(n=m+1|0))<=169?n:0)))break}}A[36454]=e}}function fe(e,t){var n,r,s=0,a=0,i=0,o=0,h=0,f=0,g=0,p=0,C=0,w=0,k=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0,N=0,G=0,F=0,P=0;U=n=U-48|0,d(+e),a=0|l(1),s=0|l(0),r=a;e:{t:{n:{if((h=2147483647&a)>>>0<=1074752122){if(598523==(1048575&a))break n;if(h>>>0<=1073928572){if((0|r)>0|(0|r)>=0){o=(e+=-1.5707963267341256)+-6077100506506192e-26,m[t>>3]=o,m[t+8>>3]=e-o-6077100506506192e-26,a=1;break e}o=(e+=1.5707963267341256)+6077100506506192e-26,m[t>>3]=o,m[t+8>>3]=e-o+6077100506506192e-26,a=-1;break e}if((0|r)>0|(0|r)>=0){o=(e+=-3.1415926534682512)+-1.2154201013012384e-10,m[t>>3]=o,m[t+8>>3]=e-o-1.2154201013012384e-10,a=2;break e}o=(e+=3.1415926534682512)+1.2154201013012384e-10,m[t>>3]=o,m[t+8>>3]=e-o+1.2154201013012384e-10,a=-2;break e}if(h>>>0<=1075594811){if(h>>>0<=1075183036){if(1074977148==(0|h))break n;if((0|r)>0|(0|r)>=0){o=(e+=-4.712388980202377)+-1.8231301519518578e-10,m[t>>3]=o,m[t+8>>3]=e-o-1.8231301519518578e-10,a=3;break e}o=(e+=4.712388980202377)+1.8231301519518578e-10,m[t>>3]=o,m[t+8>>3]=e-o+1.8231301519518578e-10,a=-3;break e}if(1075388923==(0|h))break n;if((0|r)>0|(0|r)>=0){o=(e+=-6.2831853069365025)+-2.430840202602477e-10,m[t>>3]=o,m[t+8>>3]=e-o-2.430840202602477e-10,a=4;break e}o=(e+=6.2831853069365025)+2.430840202602477e-10,m[t>>3]=o,m[t+8>>3]=e-o+2.430840202602477e-10,a=-4;break e}if(h>>>0>1094263290)break t}s=(D=(o=e+-1.5707963267341256*(p=.6366197723675814*e+6755399441055744-6755399441055744))-(w=6077100506506192e-26*p))<-.7853981633974483,a=I(p)<2147483648?~~p:-2147483648,s?(a=a-1|0,w=6077100506506192e-26*(p+=-1),o=e+-1.5707963267341256*p):D>.7853981633974483&&(a=a+1|0,w=6077100506506192e-26*(p+=1),o=e+-1.5707963267341256*p),e=o-w,m[t>>3]=e,d(+e),s=0|l(1),l(0),((i=h>>>20|0)-(s>>>20&2047)|0)<17||(w=o,e=(o-=e=6077100506303966e-26*p)-(w=20222662487959506e-37*p-(w-o-e)),m[t>>3]=e,d(+e),s=0|l(1),l(0),(i-(s>>>20&2047)|0)<50||(w=o,e=(o-=e=20222662487111665e-37*p)-(w=84784276603689e-45*p-(w-o-e)),m[t>>3]=e)),m[t+8>>3]=o-e-w;break e}if(h>>>0>=2146435072)e-=e,m[t>>3]=e,m[t+8>>3]=e,a=0;else{for(u(0,0|s),u(1,1048575&r|1096810496),e=+c(),a=0,s=1;i=(n+16|0)+(a<<3)|0,o=+(0|(a=I(e)<2147483648?~~e:-2147483648)),m[i>>3]=o,e=16777216*(e-o),a=1,i=s,s=0,i;);for(m[n+32>>3]=e,a=2;a=(s=a)-1|0,0==m[(n+16|0)+(s<<3)>>3];);if(T=n+16|0,i=0,U=f=U-560|0,h=b(M=(0|(h=((a=(h>>>20|0)-1046|0)-3|0)/24|0))>0?h:0,-24)+a|0,((k=A[28105])+(g=(E=s+1|0)-1|0)|0)>=0)for(a=k+E|0,s=M-g|0;m[(f+320|0)+(i<<3)>>3]=(0|s)<0?0:+A[112432+(s<<2)>>2],s=s+1|0,(0|a)!=(0|(i=i+1|0)););for(v=h-24|0,a=0,i=(0|k)>0?k:0,y=(0|E)<=0;;){if(y)e=0;else for(C=a+g|0,s=0,e=0;e=m[(s<<3)+T>>3]*m[(f+320|0)+(C-s<<3)>>3]+e,(0|E)!=(0|(s=s+1|0)););if(m[(a<<3)+f>>3]=e,s=(0|a)==(0|i),a=a+1|0,s)break}F=47-h|0,S=48-h|0,P=h-25|0,a=k;t:{for(;;){if(e=m[(a<<3)+f>>3],s=0,i=a,!(C=(0|a)<=0))for(;y=(f+480|0)+(s<<2)|0,g=I(o=5.960464477539063e-8*e)<2147483648?~~o:-2147483648,g=I(e=-16777216*(o=+(0|g))+e)<2147483648?~~e:-2147483648,A[y>>2]=g,e=m[((i=i-1|0)<<3)+f>>3]+o,(0|a)!=(0|(s=s+1|0)););e=bn(e,v),e+=-8*x(.125*e),e-=+(0|(y=I(e)<2147483648?~~e:-2147483648));n:{r:{s:{if(N=(0|v)<=0){if(v)break s;g=A[476+((a<<2)+f|0)>>2]>>23}else B=i=(a<<2)+f|0,i=(g=A[i+476>>2])-((s=g>>S)<<S)|0,A[B+476>>2]=i,y=s+y|0,g=i>>F;if((0|g)<=0)break n;break r}if(g=2,!(e>=.5)){g=0;break n}}if(s=0,i=0,!C)for(;G=A[(B=(f+480|0)+(s<<2)|0)>>2],C=16777215,i||(C=16777216,G)?(A[B>>2]=C-G,i=1):i=0,(0|a)!=(0|(s=s+1|0)););r:if(!N){s=8388607;s:switch(0|P){case 1:s=4194303;break;case 0:break s;default:break r}A[476+(C=(a<<2)+f|0)>>2]=A[C+476>>2]&s}y=y+1|0,2==(0|g)&&(e=1-e,g=2,i&&(e-=bn(1,v)))}if(0!=e)break;if(i=0,!((0|k)>=(0|(s=a)))){for(;i=A[(f+480|0)+((s=s-1|0)<<2)>>2]|i,(0|s)>(0|k););if(i){for(h=v;h=h-24|0,!A[(f+480|0)+((a=a-1|0)<<2)>>2];);break t}}for(s=1;i=s,s=s+1|0,!A[(f+480|0)+(k-i<<2)>>2];);for(i=a+i|0;;){if(g=a+E|0,a=a+1|0,m[(f+320|0)+(g<<3)>>3]=A[112432+(M+a<<2)>>2],s=0,e=0,(0|E)>0)for(;e=m[(s<<3)+T>>3]*m[(f+320|0)+(g-s<<3)>>3]+e,(0|E)!=(0|(s=s+1|0)););if(m[(a<<3)+f>>3]=e,!((0|a)<(0|i)))break}a=i}(e=bn(e,24-h|0))>=16777216?(v=(f+480|0)+(a<<2)|0,s=I(o=5.960464477539063e-8*e)<2147483648?~~o:-2147483648,i=I(e=-16777216*+(0|s)+e)<2147483648?~~e:-2147483648,A[v>>2]=i,a=a+1|0):(s=I(e)<2147483648?~~e:-2147483648,h=v),A[(f+480|0)+(a<<2)>>2]=s}if(e=bn(1,h),!((0|a)<0)){for(s=a;i=s,m[(s<<3)+f>>3]=e*+A[(f+480|0)+(s<<2)>>2],s=s-1|0,e*=5.960464477539063e-8,i;);if(C=0,!((0|a)<0))for(h=(0|k)>0?k:0,i=a;;){for(v=h>>>0<C>>>0?h:C,k=a-i|0,s=0,e=0;e=m[115200+(s<<3)>>3]*m[(s+i<<3)+f>>3]+e,E=(0|s)!=(0|v),s=s+1|0,E;);if(m[(f+160|0)+(k<<3)>>3]=e,i=i-1|0,s=(0|a)!=(0|C),C=C+1|0,!s)break}}if(e=0,(0|a)>=0)for(s=a;i=s,s=s-1|0,e+=m[(f+160|0)+(i<<3)>>3],i;);if(m[n>>3]=g?-e:e,e=m[f+160>>3]-e,s=1,(0|a)>0)for(;e+=m[(f+160|0)+(s<<3)>>3],i=(0|s)!=(0|a),s=s+1|0,i;);m[n+8>>3]=g?-e:e,U=f+560|0,a=7&y,e=m[n>>3],(0|r)<0?(m[t>>3]=-e,m[t+8>>3]=-m[n+8>>3],a=0-a|0):(m[t>>3]=e,m[t+8>>3]=m[n+8>>3])}}return U=n+48|0,a}function ge(){var e=0,t=0,n=0,r=0,s=0,l=0,u=0,c=0,d=0,h=0,f=0,g=0,C=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0,N=0,G=0,F=0,P=0,Q=0,z=0,O=0,R=0,L=0,W=0,_=0,V=0,H=0,U=0,j=0,Y=0,X=0,q=0,Z=0,J=0,$=0,ee=0;A[55925]=0,e=A[56772],A[56772]=e+1,n=A[55961],C=A[55922],k=An(39.89822670059037*(t=+(0|e))),h=An(22.30530784048753*t),t=+(0|C)/50*(+(0|n)/100)*(An(14.765485471872028*t)+(k+h))*10,e=I(t)<2147483648?~~t:-2147483648,A[56607]=e+A[56607];e:if(!(A[55923]<=0)){for(;;){for(n=sr(A[33209],0,1103515245,0),e=K,e=cs(n=n+12345|0,e=n>>>0<12345?e+1|0:e),A[33209]=e,e=8191+((e>>>0)%16383|0)|0,A[55929]=e,z=+(0|e),t=.75*m[28387]+z,m[28387]=t,O=(0|(e=A[55924]))>(0|(T=A[55928]))?.5*t:t,_=(s=.033*+A[56652])>0?1-s:1,n=A[56650]<<2,G=1==(0|(N=A[55921]))&&(0|n)>263?263:n,V=111136+((R=A[56651])<<1)|0,H=111136+((F=A[56658])<<1)|0,U=(0|F)>0,L=A[55918],j=b(L,40),Y=A[55925],X=m[27967],W=A[56607],t=m[27979],y=m[27969],c=m[27970],P=A[56780],B=A[56654],g=m[27976],w=m[27972],v=m[28388],E=m[28389],C=A[55927],r=m[28383],f=A[55926],M=A[55956],q=m[27975],h=m[28131],l=m[28130],u=m[28123],x=m[28121],d=m[28122],S=m[28120],D=m[28119],Z=m[28129],J=m[28128],$=m[28127],ee=sn(0*m[27968]),Q=0;;){k=l;t:{n:switch(N-1|0){case 0:v=0,l=x*u,u=d,d=r=l+(D*(v=(0|e)<=2?m[111312+(e<<3)>>3]:v)+S*u);break t;case 1:if(r=0,(0|e)>=(0|C)){E=0;break t}l=m[27965]-m[27966],m[27965]=l,r=.028*(E=l+E);break t;case 2:if(!f){M=100,r=0;break t}M=100,n=I(l=+(0|e)/+(0|f)*100)<2147483648?~~l:-2147483648,r=+i[110928+((0|n)%100<<1)>>1],r=t*((+i[110928+((n+1|0)%100<<1)>>1]-r)*(l-+(0|n))+r);break t;case 3:break n;default:break t}f?(M=256,n=I(l=+(0|e)/+(0|f)*256)<2147483648?~~l:-2147483648,r=+i[111344+((0|n)%256<<1)>>1],r=t*((+i[111344+((n+1|0)%256<<1)>>1]-r)*(l-+(0|n))+r)):(M=256,r=0)}if((0|e)>=(0|f)&&((0|W)>0?(e=(0|j)/(0|W)|0,g=0,w=0,w=F>>>0<=87?.001*+i[H>>1]:w,g=R>>>0<=87?.001*+i[V>>1]*.1:g,T=e>>U,C=(0|(n=(f=(e-1|0)<=(0|G))?e-2|0:G))<=40?40:n,l=+i[111776+((C=f||(0|n)<40?C:G)<<1)>>1],m[27966]=l,x=l,l=+(0|C),m[27965]=x*l*.333,B=(0|(n=e-C|0))>(0|B)?B:n,P=0-(n=(0|P)<0?0-B|0:B)|0,D=(l*=.00833)*l,D*=1-(S=(x=(l=$e(X*+((0|L)/(0|C)|0)))*ee)+x)-(x=l*-l),e=4!=(0|(f=e+n|0))):(A[55930]=0,A[55931]=0,A[55932]=0,A[55933]=0,T=4,g=0,w=0,f=4,e=0),c=(e|=!Y)?s:c,y=e?_:y,e=0),e=e+1|0,l=r=Z*h+($*r+J*k),h=k,4==(0|(Q=Q+1|0)))break}if(A[55926]=f,A[55956]=M,A[55924]=e,m[28383]=r,A[55927]=C,m[28389]=E,m[28388]=v,m[27972]=w,m[27976]=g,A[55928]=T,A[56654]=B,A[56780]=P,m[27970]=c,m[27969]=y,m[28122]=d,m[28120]=S,m[28119]=D,m[28123]=u,m[28121]=x,m[28131]=h,m[28130]=r,5==(0|N)&&(r=6e3*((t=+(0|e)/+(0|f))+t+-1),m[28383]=r),t=r*y+m[28384]*c,m[28383]=t,m[28384]=t,(0|e)<(0|C)&&(t=g*z+t,m[28383]=t),c=O*m[27974],k=t*m[27973]+c,h=0,2!=A[55916]&&(h=m[27987],d=m[27986],m[27987]=d,t=c+t*w,m[27986]=t,c=m[28059],u=m[28058],m[28059]=u,t=c*m[28057]+(m[28055]*(h*m[27985]+(m[27983]*t+d*m[27984]))+u*m[28056]),m[28058]=t,h=m[28049],c=m[28051],d=m[28048],u=m[28047],s=m[28050],m[28051]=s,t=h*c+(u*t+d*s),m[28050]=t,h=m[28043],c=m[28041],d=m[28040],u=m[28039],s=m[28042],m[28043]=s,t=c*h+(u*t+d*s),m[28042]=t,h=m[28035],c=m[28033],d=m[28032],u=m[28031],s=m[28034],m[28035]=s,t=c*h+(u*t+d*s),m[28034]=t,h=m[28027],c=m[28025],d=m[28024],u=m[28023],s=m[28026],m[28027]=s,t=c*h+(u*t+d*s),m[28026]=t,h=m[28019],c=m[28017],d=m[28016],u=m[28015],s=m[28018],m[28019]=s,t=c*h+(u*t+d*s),m[28018]=t,h=m[28011],c=m[28009],d=m[28008],u=m[28007],s=m[28010],m[28011]=s,t=c*h+(u*t+d*s),m[28010]=t,h=m[28003],c=m[28001],d=m[28e3],u=m[27999],s=m[28002],m[28003]=s,t=c*h+(u*t+d*s),m[28002]=t,h=m[27995],c=m[27993],d=m[27992],u=m[27991],s=m[27994],m[27995]=s,h=c*h+(u*t+d*s),m[27994]=h),t=m[28385],m[28385]=k,c=m[28075],d=m[28074],m[28075]=d,u=m[28067],s=m[28066],m[28067]=s,c=c*m[28073]+(m[28071]*k+d*m[28072]),m[28074]=c,d=u*m[28065]+(m[28063]*k+s*m[28064]),m[28066]=d,u=m[28081],s=m[28083],l=m[28079],r=m[28080],g=m[28082],m[28083]=g,k=u*s+(l*(t=q*O+k-t)+r*g),m[28082]=k,u=m[28091],s=m[28089],l=m[28087],r=m[28088],g=m[28090],m[28091]=g,u=s*u+(l*t+r*g),m[28090]=u,s=m[28099],l=m[28097],r=m[28095],g=m[28096],w=m[28098],m[28099]=w,s=l*s+(r*t+g*w),m[28098]=s,l=m[28107],r=m[28105],g=m[28103],w=m[28104],y=m[28106],m[28107]=y,l=r*l+(g*t+w*y),m[28106]=l,r=m[28115],g=m[28113],w=m[28111],y=m[28112],v=m[28114],m[28115]=v,r=g*r+(w*t+y*v),m[28114]=r,g=m[28139],w=m[28137],y=m[28136],v=m[28135],E=m[27971],x=m[28138],m[28139]=x,t=w*g+(v*(t*E-(r-(l-(s-(u-(k-(h+c+d)))))))+y*x),m[28138]=t,t=m[27977]*(t*+A[50779]),r=+(0|(e=I(t)<2147483648?~~t:-2147483648)),(0|(e=A[50776]))<A[50773]&&(f=e+1|0,n=A[50772],(C=A[50774])?(A[50776]=f,e=b(C,a[e+n|0])):(C=o[e+n|0],n=a[n+f|0],A[50776]=e+2,e=C|n<<8),r+=+((0|b(A[50775],(0|b(e,A[50780]))/1024|0))/40|0)),(0|(e=A[55962]))<=63&&(A[55962]=e+1,r=r*+(0|e)*.015625),(0|(e=A[55963]))<=0||(e=e-1|0,A[55963]=e,r=r*+(0|e)*.015625,e||(A[55962]=0)),n=(e=A[51293])+1|0,A[51293]=n,f=b(i[205184+(e<<1)>>1],A[50755])>>8,e=I(r)<2147483648?~~r:-2147483648,(0|n)>=5500&&(A[51293]=0),n=A[51290],A[51290]=n+1,e=(0|(e=(0|(e=e+f|0))<=-32768?-32768:e))>=32767?32767:e,a[0|n]=e,n=A[51290],A[51290]=n+1,a[0|n]=e>>>8,f=(n=A[51292])+1|0,A[51292]=f,i[205184+(n<<1)>>1]=e,(0|f)>=5500&&(A[51292]=0),f=1,A[56606]=A[56606]+1,p[54046]<A[51290]+2>>>0)break e;if(e=A[55925]+1|0,A[55925]=e,!((0|e)<A[55923]))break}f=0}return f}function pe(e,t,n,r,s,l,u){var c,d,h,f=0,g=0,p=0,C=0,I=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0,N=0;U=c=U-80|0,A[c+76>>2]=t,h=c+55|0,d=c+56|0;e:{t:{n:{r:{s:for(;;){if(p=t,(2147483647^x)<(0|f))break r;x=f+x|0;a:{i:{A:{if(g=o[0|(f=p)])for(;;){o:{l:if(t=255&g){if(37!=(0|t))break o;for(g=f;;){if(37!=o[g+1|0]){t=g;break l}if(f=f+1|0,I=o[g+2|0],g=t=g+2|0,37!=(0|I))break}}else t=f;if((0|(f=f-p|0))>(0|(T=2147483647^x)))break r;if(e&&hs(e,p,f),f)continue s;A[c+76>>2]=t,f=t+1|0,y=-1,36!=o[t+2|0]|a[t+1|0]-48>>>0>=10||(y=a[t+1|0]-48|0,B=1,f=t+3|0),A[c+76>>2]=f,w=0;l:if((t=(g=a[0|f])-32|0)>>>0>31)k=f;else if(k=f,75913&(t=1<<t))for(;;){if(k=f+1|0,A[c+76>>2]=k,w|=t,(t=(g=a[f+1|0])-32|0)>>>0>=32)break l;if(f=k,!(75913&(t=1<<t)))break}l:if(42!=(0|g)){if((0|(v=$n(c+76|0)))<0)break r;g=A[c+76>>2]}else{if(36!=o[k+2|0]|a[k+1|0]-48>>>0>=10){if(B)break A;if(g=k+1|0,!e){A[c+76>>2]=g,B=0,v=0;break l}t=A[n>>2],A[n>>2]=t+4,B=0,t=A[t>>2]}else A[((a[k+1|0]<<2)+s|0)-192>>2]=10,g=k+3|0,B=1,t=A[((a[k+1|0]<<3)+r|0)-384>>2];if(A[c+76>>2]=g,v=t,(0|t)>=0)break l;v=0-v|0,w|=8192}if(f=0,C=-1,46==o[0|g])if(42!=o[g+1|0])A[c+76>>2]=g+1,C=$n(c+76|0),t=A[c+76>>2],D=1;else{if(36!=o[g+3|0]|a[g+2|0]-48>>>0>=10){if(B)break A;t=g+2|0,C=0,e&&(g=A[n>>2],A[n>>2]=g+4,C=A[g>>2])}else A[((a[g+2|0]<<2)+s|0)-192>>2]=10,t=g+4|0,C=A[((a[g+2|0]<<3)+r|0)-384>>2];A[c+76>>2]=t,D=~C>>>31|0}else t=g,D=0;for(;;){if(E=f,k=28,I=t,(f=a[0|t])-123>>>0<4294967238)break n;if(t=I+1|0,!((f=o[123983+(f+b(E,58)|0)|0])-1>>>0<8))break}A[c+76>>2]=t;l:{u:{if(27!=(0|f)){if(!f)break n;if((0|y)>=0){A[(y<<2)+s>>2]=f,f=A[4+(g=(y<<3)+r|0)>>2],A[c+64>>2]=A[g>>2],A[c+68>>2]=f;break u}if(!e)break a;bt(c- -64|0,f,n,u);break l}if((0|y)>=0)break n}if(f=0,!e)continue s}g=-65537&w,w=8192&w?g:w,y=0,M=84065,k=d;l:{u:{c:{d:{h:{f:{g:{p:{m:{b:{C:{I:{w:{k:{x:{y:switch(f=a[0|I],(f=E&&3==(15&f)?-33&f:f)-88|0){case 11:break l;case 9:case 13:case 14:case 15:break u;case 27:break g;case 12:case 17:break b;case 23:break C;case 0:case 32:break I;case 24:break w;case 22:break k;case 29:break x;case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 10:case 16:case 18:case 19:case 20:case 21:case 25:case 26:case 28:case 30:case 31:break i}y:switch(f-65|0){case 0:case 4:case 5:case 6:break u;case 2:break h;case 1:case 3:break i}if(83==(0|f))break f;break i}g=A[c+64>>2],I=A[c+68>>2],M=84065;break m}f=0;k:switch(255&E){case 0:case 1:case 6:A[A[c+64>>2]>>2]=x;continue s;case 2:p=A[c+64>>2],A[p>>2]=x,A[p+4>>2]=x>>31;continue s;case 3:i[A[c+64>>2]>>1]=x;continue s;case 4:a[A[c+64>>2]]=x;continue s;case 7:break k;default:continue s}p=A[c+64>>2],A[p>>2]=x,A[p+4>>2]=x>>31;continue s}C=C>>>0<=8?8:C,w|=8,f=120}if(p=d,S=32&f,(g=A[c+64>>2])|(I=A[c+68>>2]))for(;a[0|(p=p-1|0)]=S|o[124512+(15&g)|0],N=!I&g>>>0>15|!!(0|I),E=I,I=I>>>4|0,g=(15&E)<<28|g>>>4,N;);if(!(A[c+64>>2]|A[c+68>>2])|!(8&w))break p;M=84065+(f>>>4|0)|0,y=2;break p}if(f=d,I=p=A[c+68>>2],p|(g=A[c+64>>2]))for(;a[0|(f=f-1|0)]=7&g|48,E=!I&g>>>0>7|!!(0|I),I=(p=I)>>>3|0,g=(7&p)<<29|g>>>3,E;);if(p=f,!(8&w))break p;C=(0|(f=d-p|0))<(0|C)?C:f+1|0;break p}g=A[c+64>>2],I=f=A[c+68>>2],(0|f)<0?(I=p=0-(I+!!(0|g)|0)|0,g=0-g|0,A[c+64>>2]=g,A[c+68>>2]=p,y=1,M=84065):2048&w?(y=1,M=84066):M=(y=1&w)?84067:84065}p=Kn(g,I,d)}if((0|C)<0&&D)break r;if(w=D?-65537&w:w,!(C|!!((f=A[c+64>>2])|(g=A[c+68>>2])))){p=d,C=0;break i}C=(0|(f=!(f|g)+(d-p|0)|0))<(0|C)?C:f;break i}if(k=(f=(f=Zt(p=(f=A[c+64>>2])||84639,0,I=C>>>0>=2147483647?2147483647:C))?f-p|0:I)+p|0,(0|C)>=0){w=g,C=f;break i}if(w=g,C=f,o[0|k])break r;break i}if(C){g=A[c+64>>2];break d}f=0,lr(e,32,v,0,w);break c}A[c+12>>2]=0,A[c+8>>2]=A[c+64>>2],g=c+8|0,A[c+64>>2]=g,C=-1}f=0;d:{for(;;){if(!(p=A[g>>2]))break d;if(!((p=(0|(I=Xt(c+4|0,p)))<0)|I>>>0>C-f>>>0)){if(g=g+4|0,C>>>0>(f=f+I|0)>>>0)continue;break d}break}if(p)break t}if(k=61,(0|f)<0)break n;if(lr(e,32,v,f,w),f)for(k=0,g=A[c+64>>2];;){if(!(p=A[g>>2]))break c;if((k=(p=Xt(c+4|0,p))+k|0)>>>0>f>>>0)break c;if(hs(e,c+4|0,p),g=g+4|0,!(f>>>0>k>>>0))break}else f=0}lr(e,32,v,f,8192^w),f=(0|f)<(0|v)?v:f;continue s}if((0|C)<0&&D)break r;if(k=61,(0|(f=0|Ns[0|l](e,m[c+64>>3],v,C,w,f)))>=0)continue s;break n}a[c+55|0]=A[c+64>>2],C=1,p=h,w=g;break i}g=o[f+1|0],f=f+1|0}if(e)break e;if(!B)break a;for(f=1;;){if(e=A[(f<<2)+s>>2]){if(bt((f<<3)+r|0,e,n,u),x=1,10!=(0|(f=f+1|0)))continue;break e}break}if(x=1,f>>>0>=10)break e;for(;;){if(A[(f<<2)+s>>2])break A;if(10==(0|(f=f+1|0)))break}break e}k=28;break n}if((0|(g=(0|C)>(0|(I=k-p|0))?C:I))>(2147483647^y))break r;if(k=61,(0|T)<(0|(f=(0|(C=g+y|0))<(0|v)?v:C)))break n;lr(e,32,f,C,w),hs(e,M,y),lr(e,48,f,C,65536^w),lr(e,48,g,I,0),hs(e,p,I),lr(e,32,f,C,8192^w);continue}break}x=0;break e}k=61}A[56798]=k}x=-1}return U=c+80|0,x}function me(e,t,n,r,s,a,i,o,l){var u,c,d,h=0,f=0,g=0,p=0,m=0,b=0,C=0,I=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0,N=0,G=0,F=0,P=0,Q=0,z=0,O=0,R=0,L=0,W=0,_=0,V=0,H=0;U=u=U-96|0,y=65535&l,m=-2147483648&(s^l),D=C=65535&s;e:{if(!((c=l>>>16&32767)-32767>>>0>4294934529&(d=s>>>16&32767)-32767>>>0>=4294934530)){if(h=r,!(!r&2147418112==(0|(I=k=2147483647&s))?!(t|n):I>>>0<2147418112)){g=r,m=32768|s;break e}if(!(!(s=o)&2147418112==(0|(b=k=2147483647&l))?!(a|i):b>>>0<2147418112)){g=o,m=32768|l,t=a,n=i;break e}if(!(t|h|2147418112^I|n)){if(!(s|a|i|b)){m=2147450880,t=0,n=0;break e}m|=2147418112,t=0,n=0;break e}if(!(s|a|2147418112^b|i)){if(s=t|h,r=n|I,t=0,n=0,!(r|s)){m=2147450880;break e}m|=2147418112;break e}if(!(t|h|n|I)){t=0,n=0;break e}if(!(s|a|i|b)){t=0,n=0;break e}65535==(0|I)|I>>>0<65535&&(k=(h=!(r|C))<<6,s=w(l=h?t:r)+32|0,Ut(u+80|0,t,n,r,C,(l=k+(32==(0|(l=w(h?n:C)))?s:l)|0)-15|0),x=16-l|0,r=A[u+88>>2],D=A[u+92>>2],n=A[u+84>>2],t=A[u+80>>2]),b>>>0>65535||(C=(l=!(o|y))<<6,h=w(s=l?a:o)+32|0,Ut(u- -64|0,a,i,o,y,(s=C+(32==(0|(s=w(l?i:y)))?h:s)|0)-15|0),x=16+(x-s|0)|0,o=A[u+72>>2],y=A[u+76>>2],a=A[u+64>>2],i=A[u+68>>2])}if(s=a,a=i<<15|a>>>17,R=n,k=sr(v=-32768&(l=s<<15),s=0,n,0),M=s=K,L=a,I=t,t=sr(a,0,t,0),a=K+s|0,n=t>>>0>(l=t+k|0)>>>0?a+1|0:a,h=0,t=sr(I,f,v,f),s=(a=l)+K|0,C=s=t>>>0>(b=h+t|0)>>>0?s+1|0:s,W=(0|a)==(0|s)&h>>>0>b>>>0|s>>>0<a>>>0,_=r,E=sr(v,f,r,0),V=K,t=sr(R,f,L,f),h=K+V|0,h=t>>>0>(B=t+E|0)>>>0?h+1|0:h,t=y<<15|o>>>17,r=sr(T=o<<15|i>>>17,0,I,f),a=K+h|0,N=a=r>>>0>(S=r+B|0)>>>0?a+1|0:a,a=(r=(0|n)==(0|M)&l>>>0<k>>>0|n>>>0<M>>>0)+a|0,y=a=n>>>0>(G=n+S|0)>>>0?a+1|0:a,i=G,n=a,D=sr(v,f,F=65536|D,p),H=K,r=sr(_,g,L,f),s=K+H|0,l=s=r>>>0>(P=r+D|0)>>>0?s+1|0:s,t=sr(Q=-2147483648|t,0,I,f),a=K+s|0,a=t>>>0>(z=t+P|0)>>>0?a+1|0:a,t=sr(T,g,R,f),O=a,a=a+K|0,k=t>>>0>(M=t+z|0)>>>0?a+1|0:a,s=n+M|0,a=v=(t=0)>>>0>(I=t+i|0)>>>0?s+1|0:s,n=(t=I+W|0)>>>0<I>>>0?a+1|0:a,x=((d+c|0)+x|0)-16383|0,r=sr(Q,g,R,f),o=K,s=sr(F,g,L,f),a=K+o|0,p=(0|o)==(0|(a=s>>>0>(i=s+r|0)>>>0?a+1|0:a))&r>>>0>i>>>0|a>>>0<o>>>0,o=a,s=sr(T,g,_,g),a=K+a|0,s=a=(r=s+i|0)>>>0<s>>>0?a+1|0:a,i=(0|a)==(0|o)&r>>>0<i>>>0|a>>>0<o>>>0,a=0,a=(o=i)>>>0>(i=i+p|0)>>>0?1:a,o=i,i=sr(Q,g,F,g),a=K+a|0,W=o=o+i|0,i=i>>>0>o>>>0?a+1|0:a,o=r,f=s,s=(0|h)==(0|V)&E>>>0>B>>>0|h>>>0<V>>>0,a=0,s=((p=h=(0|h)==(0|N)&B>>>0>S>>>0|h>>>0>N>>>0)>>>0>(h=s+h|0)>>>0?1:a)+f|0,a=i,p=s=(r=r+h|0)>>>0<h>>>0?s+1|0:s,E=r,s=r=(0|s)==(0|f)&r>>>0<o>>>0|s>>>0<f>>>0,h=r=r+W|0,i=a=s>>>0>r>>>0?a+1|0:a,s=sr(T,g,F,g),f=K,r=sr(Q,g,_,g),a=K+f|0,r=a=r>>>0>(o=r+s|0)>>>0?a+1|0:a,s=(a=(0|f)==(0|a)&s>>>0>o>>>0|a>>>0<f>>>0)+i|0,i=s=r>>>0>(B=r+h|0)>>>0?s+1|0:s,a=o+p|0,s=a=(r=(s=0)+E|0)>>>0<s>>>0?a+1|0:a,o=(0|p)==(0|a)&r>>>0<E>>>0|a>>>0<p>>>0,a=i,a=(i=o+(f=B)|0)>>>0<o>>>0?a+1|0:a,E=i,o=r,h=s,s=(r=(r=(r=(0|l)==(0|H)&D>>>0>P>>>0|l>>>0<H>>>0)+(l=(0|l)==(0|O)&P>>>0>z>>>0|l>>>0>O>>>0)|0)+(s=(0|k)==(0|O)&M>>>0<z>>>0|k>>>0<O>>>0)|0)+h|0,a=i=a,h=i=(o=(0|(s=(r=l=(p=k)+o|0)>>>0<p>>>0?s+1|0:s))==(0|h)&o>>>0>r>>>0|s>>>0<h>>>0)+E|0,i=a=o>>>0>i>>>0?a+1|0:a,o=r,a=0,l=s,s=s+((f=p=(0|y)==(0|v)&I>>>0<G>>>0|y>>>0>v>>>0)>>>0>(p=p+((0|y)==(0|N)&S>>>0>G>>>0|y>>>0<N>>>0)|0)>>>0?1:a)|0,a=i,l=a=(i=o=(0|(s=(r=r+p|0)>>>0<p>>>0?s+1|0:s))==(0|l)&r>>>0<o>>>0|s>>>0<l>>>0)>>>0>(o=o+h|0)>>>0?a+1|0:a,65536&a?x=x+1|0:(h=C>>>31|0,a=l<<1|o>>>31,o=o<<1|s>>>31,l=a,a=s<<1|r>>>31,r=r<<1|n>>>31,s=a,a=C<<1|b>>>31,b<<=1,C=a,a=n<<1|t>>>31,t=t<<1|h,n=a|(i=0)),(0|x)>=32767)m|=2147418112,t=0,n=0;else{t:{if((0|x)<=0){if((i=1-x|0)>>>0<=127){Ut(u+48|0,b,C,t,n,a=x+127|0),Ut(u+32|0,r,s,o,l,a),Lt(u+16|0,b,C,t,n,i),Lt(u,r,s,o,l,i),b=A[u+32>>2]|A[u+16>>2]|!!(A[u+48>>2]|A[u+56>>2]|A[u+52>>2]|A[u+60>>2]),C=A[u+36>>2]|A[u+20>>2],t=A[u+40>>2]|A[u+24>>2],n=A[u+44>>2]|A[u+28>>2],r=A[u>>2],s=A[u+4>>2],i=A[u+8>>2],a=A[u+12>>2];break t}t=0,n=0;break e}i=o,a=65535&l|x<<16}g|=i,m|=a,(!t&-2147483648==(0|n)?!(b|C):(0|n)>0|(0|n)>=0)?t|b|-2147483648^n|C?(t=r,n=s):(h=m,m=(r=(0|(a=s))==(0|(n=(n=t=1&r)>>>0>(t=t+r|0)>>>0?a+1|0:a))&t>>>0<r>>>0|n>>>0<a>>>0)>>>0>(g=r+g|0)>>>0?h+1|0:h):(r=(0|s)==(0|(n=(t=r+1|0)?s:s+1|0))&t>>>0<r>>>0|n>>>0<s>>>0,s=m,m=(g=r+g|0)>>>0<r>>>0?s+1|0:s)}}A[e>>2]=t,A[e+4>>2]=n,A[e+8>>2]=g,A[e+12>>2]=m,U=u+96|0}function be(e,t,n,r,s,i,l){var u,c=0,d=0,h=0,f=0,g=0,p=0,m=0,b=0,C=0,I=0,w=0,k=0,x=0,y=0,v=0;U=u=U-480|0,A[u+476>>2]=0,A[u+456>>2]=0,A[u+460>>2]=0,A[u+448>>2]=0,A[u+452>>2]=0,A[u+440>>2]=0,A[u+444>>2]=0,A[u+432>>2]=0,A[u+436>>2]=0,c=0;e:if(A[e+684>>2]){for(m=l?A[l>>2]:m;h=o[t+c|0],a[(u+112|0)+c|0]=h,d=c+1|0,h&&(h=c>>>0<158,c=d,h););if(a[d+(u+112|0)|0]=0,!((I=268435456&i)|!(8&A[47197]))){d=0;t:if(223&(h=o[0|t]))for(c=0;;){if(a[(u+272|0)+c|0]=h,!(223&(h=o[(d=c+1|0)+t|0])))break t;if(f=c>>>0<118,c=d,!f)break}a[(c=u+272|0)+d|0]=0,A[u+48>>2]=c,ts(A[47195],(0|i)>=0?87019:86877,u+48|0)}A[u+464>>2]=t,A[e+8208>>2]=0,A[e+8212>>2]=0,s&&(a[0|s]=0);t:{n:if(223&(c=o[0|t]))for(w=536870912&i,k=4096&i,x=u+105|0,d=t,h=0;;){f=Ht(u+476|0,d),C=!!(0|fn(A[u+476>>2]))+C|0,p=o[7668+(c=(g=255&c)+e|0)|0];r:if(!((b=A[u+476>>2])-48>>>0<10|b-2406>>>0<10)|(C?o[e+170|0]:0)){s:if((h=A[u+476>>2]-A[e+600>>2]|0)>>>0>127||!(h=A[6192+((h<<2)+e|0)>>2])){if(p){for(b=5168+((g<<2)+e|0)|0,p=p+(c=o[c+7924|0])|0,y=g|o[d+1|0]<<8,h=0;A[7184+(d=(c<<2)+e|0)>>2]==(0|y)&&(A[u+472>>2]=A[u+464>>2],re(e,u+472|0,t,2,A[d+6704>>2],u+432|0,i,m),(0|(d=A[u+432>>2]))>0&&(d=d+35|0,A[u+432>>2]=d),h=1,re(e,u+464|0,t,1,A[b>>2],u+448|0,i,m),A[u+448>>2]>(0|d)||(d=A[u+444>>2],A[u+456>>2]=A[u+440>>2],A[u+460>>2]=d,d=A[u+436>>2],A[u+448>>2]=A[u+432>>2],A[u+452>>2]=d,A[u+464>>2]=A[u+472>>2])),p>>>0>(c=c+1|0)>>>0;);if(h)break s}a:{i:{if(!(c=A[5168+((g<<2)+e|0)>>2])){if(re(e,u+464|0,t,0,A[e+5168>>2],u+448|0,i,m),A[u+448>>2])break a;if(16&o[188808])break i;if(h=Ht(u+468|0,g=(d=A[u+464>>2])-1|0),c=A[u+468>>2],!(A[e+600>>2]<=0|(0|c)>577)){if(Rr(c)){A[u+32>>2]=21,En(n,87049,u+32|0);break t}c=A[u+468>>2]}if(57384==(0|c)&&((0|(p=A[e+92>>2]))<=A[47352]||(A[47352]=p)),ss(c)&&((0|(c=A[e+72>>2]))<=A[47352]||(A[47352]=c)),!((p=(c=A[u+468>>2])-192|0)>>>0>413)&&(p=o[p+94240|0])&&(h=h-1|0,!(32==o[d-2|0]&32==o[h+d|0]))){for(A[u+472>>2]=g,a[0|g]=p;f=o[(c=d)+h|0],a[0|c]=f,d=c+1|0,32!=(0|f););if((0|h)>0&&kt(c,32,h),A[e+24>>2]&&!((0|Pr(94222,A[u+468>>2]))<=0)){A[u+464>>2]=g,h=0;break r}h=0,a[0|n]=0,A[u+464>>2]=t,A[e+8208>>2]=0,A[e+8212>>2]=0;break r}if(!(c=at(c)))break i;if((0|(d=A[c+4>>2]))==A[e+600>>2])break i;if((0|d)==A[e+188>>2]){A[u+4>>2]=xr(u- -64|0,A[e+192>>2]),A[u>>2]=21,En(n,87218,u);break t}if(!(4&o[c+16|0]))break i;A[u+20>>2]=xr(u- -64|0,A[c+12>>2]),A[u+16>>2]=21,En(n,87218,u+16|0);break t}if(re(e,u+464|0,t,1,c,u+448|0,i,m),A[u+448>>2])break a}i:if(!((c=A[u+476>>2])-768>>>0<112)){if(fn(c)){if(a[(f+A[u+464>>2]|0)-1|0]<33&(0|C)<=1)break i;if(a[0|n]=0,!l)break n;A[l>>2]=4096|A[l>>2];break n}wt(e,A[u+476>>2],-1,u+272|0,0),o[u+272|0]&&(A[u+448>>2]=1,A[u+452>>2]=u+272)}A[u+464>>2]=(f+A[u+464>>2]|0)-1;break s}A[e+288>>2]=0}else re(e,u+464|0,t,f,h,u+448|0,i,m);if(d=(c=A[u+452>>2])||86135,A[u+452>>2]=d,h=0,!(A[u+448>>2]<=0)){if(c=1|A[u+456>>2],(0|i)<0)break e;if(!(21!=o[0|d]|k)){rn(n,d);break t}if(!(!(8&A[47197])|I))s:if(c=A[47195],(0|(f=A[c+76>>2]))>=0&(!f|A[56823]!=(-1073741825&f)))g=A[(f=c+76|0)>>2],A[f>>2]=g||1073741823,10==A[c+80>>2]||(0|(g=A[c+20>>2]))==A[c+16>>2]?Wn(c):(A[c+20>>2]=g+1,a[0|g]=10),A[f>>2]=0;else{if(10!=A[c+80>>2]&&(0|(f=A[c+20>>2]))!=A[c+16>>2]){A[c+20>>2]=f+1,a[0|f]=10;break s}Wn(c)}if(f=-32769&(c=A[u+456>>2]),A[u+456>>2]=f,!(!s|!f|(1024&c?w:0))){e=A[u+464>>2],rn(s,d),c=f|(v=(n=e)-Je(t,e=u+112|0,Hn(e))|0,1024==(1151&c)?v:0);break e}(c=A[u+460>>2])&&(a[0|c]=69),an(e,n,r,d)}}else a[u+104|0]=95,Je(x,d,f),c=1,a[105+(u+f|0)|0]=0,Mn(e,u+104|0,u- -64|0),h-1>>>0<=4294967293&&(c=Hn(c=u- -64|0)+c|0,a[0|c]=11,a[c+1|0]=0,c=0),an(e,n,r,u- -64|0),A[u+464>>2]=d+f,h=c;if(d=A[u+464>>2],!(223&(c=o[0|d])))break}Je(t,e=u+112|0,Hn(e))}c=0}return U=u+480|0,c}function Ce(e,t){var n,r=0,s=0,i=0,l=0,u=0,c=0,d=0,h=0,f=0,g=0,p=0,m=0,C=0,I=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0;U=n=U-2976|0,A[t>>2]=1,r=A[e+20>>2],A[(u=n+2960|0)>>2]=A[e+16>>2],A[u+4>>2]=r,r=A[e+12>>2],A[(u=n+2952|0)>>2]=A[e+8>>2],A[u+4>>2]=r,r=A[e+4>>2],A[n+2944>>2]=A[e>>2],A[n+2948>>2]=r,A[50303]||xt();e:if(e=A[n+2948>>2],o[0|e]&&e||((e=A[n+2944>>2])||(e=(e=A[n+2952>>2])||85055,A[n+2944>>2]=e),fs(r=n+80|0,e,60),en(r,0),!(i=Nt(201216,r))||(A[n+2948>>2]=A[i+4>>2]+1,o[n+2958|0]|o[n+2956|0]|o[n+2957|0]))){I=n+1536|0,U=m=U-336|0;t:if(!(!(e=A[4+(C=n+2944|0)>>2])|!o[0|e])){if((0|(w=Hn(e)))>=0){for(r=w>>>0>=79?79:w,h=1;e=ar(a[A[C+4>>2]+s|0]),a[(m+256|0)+s|0]=e,h=(45==(255&e))+h|0,e=(0|r)!=(0|s),s=s+1|0,e;);if(1!=(0|h))break t}h=1}if((0|(f=A[50303]))<=0)A[I>>2]=0,e=0;else{for(u=(0|h)>=0;;){d=A[201216+(y<<2)>>2];t:if(Sn(A[d+8>>2],88032,3)){if((e=A[C+4>>2])&&Sn(e,91687,3)){if(u){e=100;n:if(h){if(r=0,s=A[d+4>>2],!(k=o[0|s])){if(!Sn(m+256|0,90013,9))break n;break t}for(;;){for(v=1,c=s+1|0,x=1,E=0,s=0;(0|s)<(0|w)&&45!=(0|(e=a[(m+256|0)+s|0]))||(e=0),E=((g=45==(0|(p=o[s+c|0])))&!!(0|(x=(g?0:p)<<24>>24==(0|e)?x:0)))+E|0,s=s+1|0,v=g+v|0,p;);if(s=s+c|0,(g=x+E|0)&&(r=(0|(e=b((c=(0|(e=h-g|0))<=0?5:5-e|0)-((0|(e=v-g|0))>0?e:0)|0,100)-(k<<24>>24<<1)|0))>(0|r)?e:r),!(k=o[0|s]))break}if(!(e=r))break t}(r=A[C>>2])&&(e=mr(r,A[d>>2])?mr(r,A[d+8>>2])?e:e+400|0:e+500|0),((s=o[C+12|0])-1&255)>>>0>1||((r=o[d+12|0])-1&255)>>>0>1||(e=(0|r)!=(0|s)?e-50|0:e+50|0),s=o[C+13|0],e=2!=o[d+12|0]|s>>>0>12?e:o[d+13|0]>12?e+5|0:e,(r=o[d+13|0])&&((r=((s?b(s,100):3e3)>>>0)/(r>>>0)|0)>>>0<=99&&(r=1e4/(r>>>0)|0),e=(c=e)+((e=5-(((r-100&65535)>>>0)/10|0)|0)>>31&e)|0,e=s?e+10|0:e),e=(0|e)<=1?1:e}else{if(Sn(A[d+8>>2],m+256|0,w))break t;e=100}A[I+(l<<2)>>2]=d,A[d+16>>2]=e}else A[I+(l<<2)>>2]=d;l=l+1|0}if((0|f)==(0|(y=y+1|0)))break}A[I+(l<<2)>>2]=0,e=0,l&&(tt(I,l,8),e=l)}if(U=m+336|0,h=e,e||(A[t>>2]=0,e=Nt(201216,85055),A[n+1536>>2]=e,h=!!(0|e)),t=o[n+2957|0],u=2,2!=(0|(e=o[n+2956|0]))&&(u=2,(t-1&255)>>>0<12||(M=1!=(0|e),u=1==(0|e))),f=(l=A[132136+(u<<2)>>2])+(p=t>>>0<60)|0,e=0,(0|h)>0)for(r=0;;){i=A[(n+1536|0)+(B<<2)>>2];t:{n:{r:{if(M){if(p)break n;if(t=0,r)break n}else{if(t=o[i+12|0],r|p)break r;t=(0|t)!=(0|u)}if(s=0,t|o[i+13|0]<60)break t;break n}if((0|t)!=(0|u)){s=r;break t}}A[(n+80|0)+(r<<2)>>2]=i,s=r+1|0}t:if(o[i+15|0]){if(g=0,t=e,r=s,!((0|e)>11))for(;;){if((s=o[0|f])||(f=l,s=o[0|l]),e=A[i+12>>2],c=b(t,24)+202624|0,A[c+8>>2]=A[i+8>>2],A[c+12>>2]=e,e=A[i+4>>2],A[c>>2]=A[i>>2],A[c+4>>2]=e,e=A[i+20>>2],A[c+16>>2]=A[i+16>>2],A[c+20>>2]=e,a[c+14|0]=s,A[(n+80|0)+(r<<2)>>2]=c,f=f+1|0,r=r+1|0,e=t+1|0,(g=g+1|0)>>>0>=o[i+15|0])break t;if(s=(0|t)<11,t=e,!s)break}}else r=s;if((0|(B=B+1|0))==(0|h))break}else{if(!i)break e;r=0}t:if(!(!(s=o[0|f])|(0|e)>=12))for(;;){if(t=A[i+12>>2],l=b(e,24)+202624|0,A[l+8>>2]=A[i+8>>2],A[l+12>>2]=t,t=A[i+4>>2],A[l>>2]=A[i>>2],A[l+4>>2]=t,t=A[i+20>>2],A[l+16>>2]=A[i+16>>2],A[l+20>>2]=t,a[l+14|0]=s,A[(n+80|0)+(r<<2)>>2]=l,r=r+1|0,!(s=o[0|(f=f+1|0)]))break t;if(t=(0|e)<11,e=e+1|0,!t)break}r?(e=A[(n+80|0)+(o[n+2958|0]%(0|r)<<2)>>2],(t=o[e+14|0])?(a[202976]=0,A[n+48>>2]=47,En(n+2971|0,91351,n+48|0),a[n+2971|0]=0,t>>>0<=9?(A[n+20>>2]=t,A[n+16>>2]=n+2971,En(202976,91378,n+16|0)):(A[n+36>>2]=t-10,A[n+32>>2]=n+2971,En(202976,91503,n+32|0)),e=A[e+8>>2],A[n+4>>2]=202976,A[n>>2]=e,e=202912,En(202912,87760,n)):e=A[e+8>>2]):e=0}else{if(e=A[i+8>>2],!o[202976])break e;A[n+64>>2]=e,A[n+68>>2]=202976,e=202912,En(202912,87760,n- -64|0)}return U=n+2976|0,e}function Ie(e,t,n,r,s){var i,l,u=0,c=0,d=0,h=0,f=0,g=0,p=0;U=i=U-464|0,a[i+432|0]=0,a[i+368|0]=0,a[i+304|0]=0,a[i+292|0]=0,f=(0|t)/10|0,u=A[33273];e:{if(!(l=2&r)|2!=A[33272]){p=32&r?113:111,h=1&r,g=t-b(f,10)|0;t:{n:{r:{s:{a:{i:{A:{o:if(o[0|u])u=0;else{l:{if(8&r){if(A[i+288>>2]=t,En(c=i+452|0,91198,i+288|0),u=Mn(e,c,i+304|0)){c=0;break o}A[i+272>>2]=t,En(c=i+452|0,91314,i+272|0),u=Mn(e,c,i+304|0),c=0}else{if(!h)break l;if(d=rn(i+432|0,133104),4&r){if(A[i+260>>2]=p,A[i+256>>2]=t,En(c=i+452|0,91324,i+256|0),u=Mn(e,c,i+304|0),o[133116]&&u)break A;if(c=u,u)break o}A[i+244>>2]=p,A[i+240>>2]=t,En(c=i+452|0,91384,i+240|0),c=u=Mn(e,c,i+304|0)}if(u)break o}l:{if(l){if(!(1&a[133096]))break l;A[i+208>>2]=t,En(u=i+452|0,91498,i+208|0),u=Mn(e,u,i+304|0)}else d=A[e+108>>2],A[i+224>>2]=t,En(u=i+452|0,(0|n)>=2?91700:(262144&d)>>>18|0?91534:91700,i+224|0),u=Mn(e,u,i+304|0);if(u)break o}!h|!(32&o[e+109|0])?(A[i+192>>2]=t,En(u=i+452|0,91766,i+192|0),u=Mn(e,u,i+304|0)):u=0}if(!(16&r)|(0|t)>9)break a;u=c;break i}if(rn(d,133116),!(16&r)|(0|t)>9)break s}Mn(e,88875,i+368|0);break n}if(!u)break r;u=c}a[i+368|0]=0;break n}r:if(h&&(A[i+180>>2]=p,A[i+176>>2]=f,En(u=i+452|0,91846,i+176|0),Mn(e,u,i+368|0))){if(c=1,!g|!(16&o[e+109|0]))break r;Es(i+368|0,133104)}else c||(A[i+160>>2]=f,En(c=i+452|0,512&r?91936:92016,i+160|0),Mn(e,c,i+368|0),c=0);if(u=g,o[i+368|0]||(u=g,16&o[e+106|0]&&(A[i+144>>2]=254&f,En(u=i+452|0,92016,i+144|0),Mn(e,u,i+368|0),u=(0|t)%20|0)),a[i+304|0]=0,f=u,(0|u)<=0)u=c;else{if(l&&(u=A[33273],o[0|u])){rn(i+304|0,u),a[i+432|0]=0,d=h;break t}if(d=0,8&r&&(A[i+128>>2]=f,En(r=i+452|0,91314,i+128|0),d=Mn(e,r,i+304|0)),!h|16&o[e+104|0]||(A[i+116>>2]=p,A[i+112>>2]=f,En(r=i+452|0,91384,i+112|0),c=(d=Mn(e,r,i+304|0))?1:c),u=c,!d){r:{if(!l|!(1&A[33274])){if(!(16&o[e+104|0])&&l)break r;c=A[e+108>>2],A[i+96>>2]=f,En(r=i+452|0,(0|n)>=2?91700:(262144&c)>>>18|0?91534:91700,i+96|0),n=Mn(e,r,i+304|0)}else A[i+80>>2]=f,En(n=i+452|0,91498,i+80|0),n=Mn(e,n,i+304|0);if(n)break n}A[i+64>>2]=f,En(n=i+452|0,91766,i- -64|0),Mn(e,n,i+304|0)}}}d=h,o[i+432|0]|u|!h||((0|t)<20|(16&o[e+104|0]?0:g)||(Mn(e,92162,i+432|0),d=1,!o[i+432|0]))&&(Mn(e,92205,i+432|0),d=1)}if(!(!(n=a[i+304|0])|!(48&(t=A[e+104>>2]))|!o[i+368|0])){if(Mn(e,90824,i+292|0),!d|!(8&o[e+109|0])||(a[i+292|0]=0),16&o[e+104|0]){A[i+28>>2]=i+432,A[i+24>>2]=i+368,A[i+20>>2]=i+292,A[i+16>>2]=i+304,En(s,91059,i+16|0),r=1;break e}A[i+12>>2]=i+432,A[i+8>>2]=i+304,A[i+4>>2]=i+292,A[i>>2]=i+368,En(s,91059,i),r=1;break e}512&t&&(!n|(0|(t=Hn(i+368|0)-1|0))<0||(u=2!=o[A[144464+(a[0|(t=t+(i+368|0)|0)]<<2)>>2]+11|0],1==(0|(r=o[A[144464+(n<<2)>>2]+11|0]))&&(r=o[A[144464+(a[i+305|0]<<2)>>2]+11|0]),u|2!=(255&r)||(a[0|t]=0))),!(8&o[e+110|0])|!o[i+432|0]?(A[i+56>>2]=i+432,A[i+52>>2]=i+304,A[i+48>>2]=i+368,En(s,92282,i+48|0)):(A[i+36>>2]=i+304,A[i+32>>2]=i+368,(0|(t=En(s,90368,i+32|0)))>0&&(t=2==o[A[144464+(o[(n=t-1|0)+s|0]<<2)>>2]+11|0]?n:t),rn(t+s|0,i+432|0))}else rn(s,u);r=0}e:if(268435456&(e=A[e+104>>2])){if((0|Hn(s))<=0)break e;for(t=0,e=0;6==o[0|(n=e+s|0)]&&(t&&(a[0|n]=5),t=1),e=e+1|0,(0|Hn(s))>(0|e););}else if(256&e&&(t=0,!((0|(e=(h=Hn(s))-1|0))<0))){if(e)for(g=-2&h,u=0;6==o[0|(c=e+s|0)]?(n=1,t&&(a[0|c]=5)):n=t,6==o[0|(c=c-1|0)]?(t=1,n&&(a[0|c]=5)):t=n,e=e-2|0,(0|g)!=(0|(u=u+2|0)););1&h&&(!t|6!=o[0|(e=e+s|0)]||(a[0|e]=5))}return U=i+464|0,r}function we(e,t,n,r){var s,l,u=0,c=0,d=0,h=0,f=0,g=0,p=0;if(U=s=U-352|0,a[s+304|0]=0,a[s+224|0]=0,a[s+64|0]=0,d=A[A[47192]+292>>2],p=Ht(s+348|0,t),57344==(1048320&(u=A[s+348>>2]))&&(u&=255,A[s+348>>2]=u),2&r&&dr(u)&&Mn(e,85437,s+304|0),u=qr(A[s+348>>2],e),A[s+348>>2]=u,g=1&r,wt(e,u,a[0|(l=t+p|0)],s+224|0,g),!(t=o[s+224|0])){e:if((t=rr(A[s+348>>2]))&&(A[s+348>>2]=16383&t,4&r)){t:switch(1073741823&(t>>=14)){case 0:case 3:break e}Mn(e,t=A[131232+(t<<2)>>2],s+304|0),o[s+304|0]||(a[s+306|0]=gs(84744),f=t,t=s+304|3,Mn(A[47194],f,t),o[s+307|0]&&(i[s+304>>1]=5385,t=Hn(t)+(s+304|0)|0,a[t+5|0]=0,a[t+4|0]=d,a[t+3|0]=21))}wt(e,A[s+348>>2],a[0|l],s+224|0,g),t=o[s+224|0]}e:{t:{if(t&=255){if(21!=(0|t))break t;rn(n,s+224|0),p=0;break e}if(t=1632,!((0|(u=A[s+348>>2]))<1632)){for(h=103360;;){if((0|u)>=(t+10|0)){if(!(t=A[(h=h+4|0)>>2]))break t;if((0|t)<=(0|u))continue;break t}break}(0|(t=48+(u-t|0)|0))<=0||wt(e,t,0,s+224|0,g)}}t:{n:{r:{s:{if(t=at(A[s+348>>2])){if(u=A[t+4>>2],!t|1&(h=A[t+16>>2])||(c=A[47192],A[c+600>>2]==(0|u)|A[c+188>>2]==(0|u)|A[c+184>>2]==(0|u)||(a[s+144|0]=0,Mn(c,A[t>>2],s- -64|0)?(0|(c=A[47192]))!=(0|e)&&(d=A[e+292>>2],rn(s+144|0,s- -64|0),a[s+66|0]=A[c+292>>2]):(a[s+66|0]=gs(84744),Mn(A[47194],A[t>>2],s+144|0)),o[s+144|0]&&(i[s+64>>1]=5385,rn(3|(c=s- -64|0),f=s+144|0),c=Hn(f)+c|0,a[c+5|0]=0,a[c+4|0]=d,a[c+3|0]=21))),o[s+224|0])break t;if(!u)break s;if(d=A[47192],A[d+188>>2]!=(0|u))break s;t=A[d+192>>2];break n}if(o[s+224|0])break t;h=0,u=0;break r}if((t=A[t+12>>2])&&!(2&h))break n}t=25966}if((A[e+212>>2]==(0|t)&27503!=(0|t)||(a[s+226|0]=gs(xr(s+47|0,t)),(t=A[47194])&&((0|(d=A[s+348>>2]))>55215||(0|(c=d-44032|0))<0?wt(t,d,a[0|l],s+224|3,g):(a[s+52|0]=32,t=f=s+53|0,d-50500>>>0>=588&&(t=Qn(4352+((c>>>0)/588|0)|0,f)+f|0),Qn(4449+(((d=(c>>>0)/28|0)>>>0)%21|0)|0,t),Qn(4519+(c-b(d,28)|0)|0,t+3|0),a[t+6|0]=32,a[t+7|0]=0,a[s+227|0]=0,t=s+224|3,be(A[47194],f,t,77,0,0,0),Ae(A[47194],t,0,-1,0)),t=s+224|3,21==o[s+227|0]&&(a[s+226|0]=gs(s+224|4),wt(A[47194],A[s+348>>2],a[0|l],t,g)),Zr(A[A[32972]+60>>2]),o[s+227|0]&&(i[s+224>>1]=5385,t=Hn(t)+(s+224|0)|0,a[t+3|0]=21,g=A[e+292>>2],a[t+5|0]=0,a[t+4|0]=g)),!o[s+224|0]))&&(16&h||(Br(A[s+348>>2])&&Mn(A[47192],85683,s+224|0),o[s+224|0]||(tr(A[s+348>>2])||Mn(A[47192],85778,s+224|0),o[s+224|0]||je(85992,s+224|0,0))),!(8&h)||4&r)){if(t=A[s+348>>2],10240!=(0|u)?(A[s+32>>2]=t,En(s+52|0,86013,s+32|0)):(u=s+52|0,1&t&&(a[s+52|0]=49,u=s+53|0),2&t&&(a[0|u]=50,u=u+1|0),4&t&&(a[0|u]=51,u=u+1|0,t=A[s+348>>2]),8&t&&(a[0|u]=52,u=u+1|0,t=A[s+348>>2]),16&t&&(a[0|u]=53,u=u+1|0,t=A[s+348>>2]),32&t&&(a[0|u]=54,u=u+1|0,t=A[s+348>>2]),64&t&&(a[0|u]=55,u=u+1|0,t=A[s+348>>2]),128&t&&(a[0|u]=56,u=u+1|0),a[0|u]=0),t=s+224|0,h=o[s+52|0])for(u=s+52|0;t=Hn(t)+t|0,a[0|t]=23,t=t+1|0,wt(A[47192],h<<24>>24,0,t,1),(r=o[0|t])&&21!=(0|r)||(0|(r=a[0|u]))<97||je(A[130860+((255&r)<<2)>>2],t,0),h=o[0|(u=u+1|0)];);t=Hn(t)+t|0,a[0|t]=9,a[t+1|0]=0}}t=Hn(n),2&o[e+144|0]?(A[s+16>>2]=255,A[s+28>>2]=s+304,A[s+24>>2]=s+224,A[s+20>>2]=s- -64,En(s+144|0,86210,s+16|0)):(A[s>>2]=255,A[s+12>>2]=s+224,A[s+8>>2]=s+304,A[s+4>>2]=s- -64,En(s+144|0,86210,s)),Hn(s+144|0)+t>>>0>199||rn(t+n|0,s+144|0)}return U=s+352|0,p}function ke(e,t,n,r,s,l,u){var c,d=0,f=0,g=0,m=0,C=0,I=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,S=0,N=0,G=0,F=0,P=0,Q=0,z=0;U=c=U-528|0,y=u?A[u>>2]:0,S=A[s+4>>2];e:{t:{if(A[e+220>>2]>0){fs(f=c+352|0,t,160),U=I=U-176|0,k=1-(w=A[e+220>>2])|0,x=A[e+224>>2],v=A[e+216>>2],m=f;n:{r:{for(;;){if(E=Ht(I+172|0,m),d=A[I+172>>2]){if((0|d)<(0|w)|(0|d)>(0|v))break r;if(x){if((0|(d=a[x+(d-w|0)|0]))<=0)break r}else d=d+k|0;if(m=m+E|0,a[C+I|0]=d,d=160,160!=(0|(C=C+1|0)))continue}else d=C;break}if(x=0,a[d+I|0]=0,k=a[0|I],A[I+172>>2]=k,k){for(N=2+(v-w|0)|0,w=d=I;;){v=d+1|0;s:{if((E=A[e+8180>>2])&&(C=0,!((0|(m=i[E>>1]))>(0|(M=(a[0|v]<<8)+k|0)))))for(;;){if((0|m)==(0|M)){k=C+N|0,A[I+172>>2]=k,d=d+2|0;break s}if(!((0|M)>=(0|(m=i[E+((C=C+1|0)<<1)>>1]))))break}d=v}if(B=63&k|B<<6,(0|(C=x+6|0))<8?x=C:(x=x-2|0,a[0|w]=B>>x,w=w+1|0),k=a[0|d],A[I+172>>2]=k,!k)break}(0|x)<=0||(a[0|w]=B<<8-x,w=w+1|0)}else w=I;a[0|w]=0,Je(f,I,d=w-I|0),w=64|d;break n}w=Hn(f)}U=I+176|0,I=f}else w=Hn(t),I=t;if(f=o[0|I]){for(d=0,C=I;g=1023&(g=(g<<3)+f|0)^g>>>8,d=d+1|0,f=o[0|(C=C+1|0)];);d=d+g&1023}else d=0;if(g=A[692+((d<<2)+e|0)>>2]){if(d=o[0|g])break t;d=0;break e}if(d=0,!s)break e;A[s>>2]=0;break e}for(E=1073741824&S,M=2048&l,S=512&y,N=65536&y,G=1&y,F=2&y,y=8&l,P=1024&l,v=4&l,Q=63&w,z=e+8233|0;;){l=(255&d)+g|0;t:{n:if((127&(d=o[g+1|0]))==(0|w)&&!Sn(I,g+2|0,Q)){g=2+((63&d)+g|0)|0;r:{if(d<<24>>24<0)x=0,a[0|r]=0;else{if((0|(x=Hn(g)))>=160)break r;rn(r,g),g=1+(g+x|0)|0}if(f=0,l>>>0<=g>>>0)d=n,m=0;else{C=0,m=0;s:{for(;;){g=(d=g)+1|0;a:if((d=o[0|d])>>>0>=100){if(k=A[e+320>>2],d>>>0>=132){C|=k>>>d-132&1;break a}C|=!(k>>>d-100&1)}else{if(d>>>0>=81){k=d-80|0,B=l-g|0;i:if(u)for(d=0;;){if(D=b(d,12)+u|0,!o[D+10|0])break i;if(C=!!(12&o[D+1|0])|C,D=(0|d)!=(0|k),d=d+1|0,!D)break}if(Zn(n,g,B)|1&C)break n;A[33264]=k,d=n+B|0,m|=128,g=l;break s}d>>>0>=65?(m=15&d|-16&m,m=12&~d?m:512|m):d>>>0>=32?f|=1<<d-32:m|=1<<d}if(!(l>>>0>g>>>0))break}if(d=n,1&C)break t}if(65536&f&&!v)break t;if(P&&49152&f)break t}if(v){if(16384&f)break t;if(!y&&32768&f)break t}if((F?0:512&f)|(G?0:1024&f)|(N?0:33554432&m))break t;if(!(!(131072&f)|p[A[47192]+8204>>2]<=d>>>0|E)|(S?0:262144&f)|(8&o[A[47192]+8242|0]?0:8192&f))break t;if(16&f){if(!A[e+8184>>2]&(!y|!A[e+8192>>2]))break t;if(!(!y|25966!=A[e+212>>2])&&2097152&A[e+8232>>2])break t}if((A[e+8188>>2]?0:64&f)|(!A[e+8196>>2]|M?32&f:0))break t;if(!(!(65536&m)|26741!=A[e+212>>2]|128&o[0|z])|(A[47192]!=(0|e)?524288&f:0))break t;s:{a:{i:{if(!s){if(!x)break i;break s}if(A[s+4>>2]=f,A[s>>2]=1073741824|m,x)break a}if(d=0,!(8&o[188788]))break e;cn(s,e=c+272|0),A[c>>2]=t,A[c+4>>2]=e,ts(A[47195],89330,c);break e}A[s>>2]=-1073741824|m}if(8&o[188788]&&(St(r,c- -64|0),o[A[47192]+172|0]==(m>>>29&1)&&(!u|!(128&m)?(A[c+48>>2]=t,ts(A[47195],89426,c+48|0)):(Je(e=c+352|0,r=n,n=d-n|0),a[351+(n+c|0)|0]=0,A[c+32>>2]=t,A[c+36>>2]=e,ts(A[47195],89397,c+32|0)),cn(s,e=c+272|0),t=A[47195],A[c+16>>2]=c- -64,A[c+20>>2]=e,ts(t,89534,c+16|0))),o[Ht(c- -64|0,I)+I|0]|!s)break e;if(fn(A[c+64>>2]))break e;A[s>>2]=134217728|A[s>>2];break e}T(89236,86634,2467,94846),h()}g=l}if(!(d=o[0|g]))break}d=0}return U=c+528|0,d}function xe(e,t,n,r,s){var i,l=0,u=0;U=i=U-304|0,a[i+278|0]=0;e:{if((0|t)>0){if(1&r){if(2&r&&(A[i+164>>2]=n,A[i+160>>2]=t,En(l=i+290|0,89701,i+160|0),l=Mn(e,l,i+224|0)))break e;if(1&a[133096]&&(A[i+148>>2]=n,A[i+144>>2]=t,En(l=i+290|0,89757,i+144|0),l=Mn(e,l,i+224|0)))break e;if(A[i+132>>2]=n,A[i+128>>2]=t,En(l=i+290|0,89894,i+128|0),l=Mn(e,l,i+224|0))break e}if(A[i+116>>2]=n,A[i+112>>2]=t,En(l=i+290|0,89974,i+112|0),l=Mn(e,l,i+224|0))break e}if((0|(u=(0|t)%100|0))>=20&&Mn(e,90022,i+278|0),1&r){if(2&r){l=u-11|0;t:{n:{r:switch((448&A[A[47192]+108>>2])-64>>>6|0){case 0:if(l>>>0<9)break n;if(r=90418,1==(0|(l=(0|t)%10|0)))break t;if(l-2>>>0>=3)break n;r=90453;break t;case 1:if(t-2>>>0>=3)break n;r=90453;break t;case 2:if(l>>>0<9|((0|t)%10|0)-2>>>0>=3)break n;r=90453;break t;case 3:if(r=90508,l>>>0<9)break t;r=(r=(0|t)%10|0)?1==(0|r)?90453:90586:90508;break t;case 4:break r;default:break n}if(!(l>>>0<9)){if(r=90537,1==(0|(l=(0|t)%10|0)))break t;if(!(l-2>>>0>=3)){r=90453;break t}}}r=90586}if(A[i+100>>2]=n,A[i+96>>2]=r,En(r=i+290|0,90058,i+96|0),l=0,Mn(e,r,i+224|0))break e}if(r=u-11|0,1&a[133096]){t:{n:{r:switch((448&A[A[47192]+108>>2])-64>>>6|0){case 0:if(r>>>0<9)break n;if(l=90418,1==(0|(u=(0|t)%10|0)))break t;if(u-2>>>0>=3)break n;l=90453;break t;case 1:if(t-2>>>0>=3)break n;l=90453;break t;case 2:if(r>>>0<9|((0|t)%10|0)-2>>>0>=3)break n;l=90453;break t;case 3:if(l=90508,r>>>0<9)break t;l=(l=(0|t)%10|0)?1==(0|l)?90453:90586:90508;break t;case 4:break r;default:break n}if(!(r>>>0<9)){if(l=90537,1==(0|(u=(0|t)%10|0)))break t;if(!(u-2>>>0>=3)){l=90453;break t}}}l=90586}if(A[i+84>>2]=n,A[i+80>>2]=l,En(u=i+290|0,90110,i+80|0),l=0,Mn(e,u,i+224|0))break e}t:{n:{r:switch((448&A[A[47192]+108>>2])-64>>>6|0){case 0:if(r>>>0<9)break n;if(l=90418,1==(0|(u=(0|t)%10|0)))break t;if(u-2>>>0>=3)break n;l=90453;break t;case 1:if(t-2>>>0>=3)break n;l=90453;break t;case 2:if(r>>>0<9|((0|t)%10|0)-2>>>0>=3)break n;l=90453;break t;case 3:if(l=90508,r>>>0<9)break t;l=(l=(0|t)%10|0)?1==(0|l)?90453:90586:90508;break t;case 4:break r;default:break n}if(!(r>>>0<9)){if(l=90537,1==(0|(u=(0|t)%10|0)))break t;if(!(u-2>>>0>=3)){l=90453;break t}}}l=90586}if(A[i+68>>2]=n,A[i+64>>2]=l,En(u=i+290|0,90139,i- -64|0),l=0,Mn(e,u,i+224|0))break e}else r=u-11|0;t:{n:{r:switch((448&A[A[47192]+108>>2])-64>>>6|0){case 0:if(r>>>0<9)break n;if(l=90418,1==(0|(r=(0|t)%10|0)))break t;if(r-2>>>0>=3)break n;l=90453;break t;case 1:if(t-2>>>0>=3)break n;l=90453;break t;case 2:if(r>>>0<9|((0|t)%10|0)-2>>>0>=3)break n;l=90453;break t;case 3:if(l=90508,r>>>0<9)break t;l=(r=(0|t)%10|0)?1==(0|r)?90453:90586:90508;break t;case 4:break r;default:break n}if(!(r>>>0<9)){if(l=90537,1==(0|(r=(0|t)%10|0)))break t;if(!(r-2>>>0>=3)){l=90453;break t}}}l=90586}A[i+52>>2]=n,A[i+48>>2]=l,En(r=i+290|0,90218,i+48|0),l=0,Mn(e,r,i+224|0)||((0|n)<4||(A[i+32>>2]=n-1,En(r=i+290|0,89026,i+32|0),Mn(e,r,i+176|0)||(Mn(e,90273,i+224|0),A[33275]=3)),o[i+224|0]||(A[i+16>>2]=t,En(r=i+290|0,90303,i+16|0),(l=Mn(e,r,i+224|0))||Mn(e,90347,i+224|0),A[33275]=2))}return A[i+4>>2]=i+224,A[i>>2]=i+278,En(s,90368,i),U=i+304|0,!(1!=(0|t)|1!=(0|n))&&(t=1,32&o[e+106|0])||(t=l),t}function ye(e,t,n,r){var s,l=0,u=0,c=0,d=0,h=0,f=0,p=0;U=s=U+-64|0,i[s+48>>1]=0,A[s+40>>2]=0,A[s+44>>2]=0,A[s+32>>2]=0,A[s+36>>2]=0,A[s+24>>2]=0,A[s+28>>2]=0,A[s+16>>2]=0,A[s+20>>2]=0,A[s+8>>2]=0,A[s+12>>2]=0,A[s>>2]=0,A[s+4>>2]=0,l=t;e:{for(;;){t:{n:{if(69!=(0|(u=o[0|l]))){if(32!=(0|u))break n;if(r&&(a[Je(u=r,t,r=(0|(r=l-t|0))>=159?159:r)+r|0]=0),r=63&n)break t;break e}a[0|l]=101}l=l+1|0;continue}break}if(1&n){t:if((l=l-1|0)>>>0<t>>>0)u=r;else for(u=r;;){if(128!=(192&o[0|l]))break t;if(u=u+1|0,!((l=l-1|0)>>>0>=t>>>0))break}c=r-1|0}else c=r,u=r;if(1!=(0|r))for(;;){r=c;t:if(!((l=l-1|0)>>>0<t>>>0))for(;;){if(128!=(192&o[0|l]))break t;if(u=u+1|0,!((l=l-1|0)>>>0>=t>>>0))break}t:if(!((l=l-1|0)>>>0<t>>>0))for(;;){if(128!=(192&o[0|l]))break t;if(u=u+1|0,!((l=l-1|0)>>>0>=t>>>0))break}if(c=r-2|0,!((0|r)>2))break}if((0|u)<=0)c=0;else{if(d=3&(c=(r=(t=u-1|0)>>>0>=48?48:t)+1|0),t=0,u=0,r>>>0>=3)for(p=-4&c,r=0;h=l+u|0,a[u+s|0]=o[0|h],a[0|h]=32,h=(f=1|u)+l|0,a[s+f|0]=o[0|h],a[0|h]=32,h=(f=2|u)+l|0,a[s+f|0]=o[0|h],a[0|h]=32,h=(f=3|u)+l|0,a[s+f|0]=o[0|h],a[0|h]=32,u=u+4|0,(0|p)!=(0|(r=r+4|0)););if(d)for(;r=l+u|0,a[u+s|0]=o[0|r],a[0|r]=32,u=u+1|0,(0|d)!=(0|(t=t+1|0)););}}if(a[s+c|0]=0,d=65520&n,!(512&n)|105!=o[0|(r=l-1|0)]||(a[0|r]=121),u=4|d,256&n){e:{t:{n:{if(25966!=(0|(t=A[e+212>>2]))){if(28268!=(0|t))break n;if(a[0|r]<0)break e;if(128&(t=a[0|(c=l-2|0)]))break e;if(d=A[e+632>>2])t=!!(0|Fr(d,t));else{if((0|(d=A[e+600>>2]))>0&&(t=t-d|0)-1>>>0>254)break e;t=128&o[344+(e+t|0)|0]}if(!t)break e;if(t=a[0|r],d=A[e+612>>2])t=!!(0|Fr(d,t));else{r:{if((0|(d=A[e+600>>2]))>0){if((t=t-d|0)-1>>>0<255)break r;break e}if((0|t)<0)break e}t=4&o[344+(e+t|0)|0]}if(!t)break e;t=a[l-3|0];r:{if(d=A[e+632>>2])t=!!(0|Fr(d,t));else{s:{if((0|(d=A[e+600>>2]))>0){if((t=t-d|0)-1>>>0<255)break s;break r}if((0|t)<0)break r}t=128&o[344+(e+t|0)|0]}if(t)break e}a[0|l]=o[0|r],a[0|r]=o[0|c],a[l+1|0]=32;break e}if(c=a[l-2|0],t=A[e+632>>2])t=!!(0|Fr(t,c));else{r:{if((0|(t=A[e+600>>2]))>0){if((c=c-t|0)-1>>>0<255)break r;break t}if((0|c)<0)break t}t=128&o[344+(e+c|0)|0]}if(!t)break t;if(c=a[0|r],t=A[e+608>>2])t=!!(0|Fr(t,c));else{if((0|(t=A[e+600>>2]))>0){if((c=c-t|0)-1>>>0>=255)break t}else if((0|c)<0)break t;t=2&o[344+(e+c|0)|0]}if(!t)break t;u=Sn(87771,l-3|0,3)?20|d:u;break e}u=A[e+204>>2]?20|d:u;break e}(99==o[0|r]||(c=o[1+(t=l-2|0)|0]<<8,29554==(o[0|t]|c)|29289==(c|o[0|t])||29301==(o[0|(t=l-2|0)]|o[t+1|0]<<8)||!Sn(88115,l-3|0,3)||29550==(o[0|(t=l-2|0)]|o[t+1|0]<<8)|117==o[0|r]||!Sn(88384,l-5|0,5)||1735287154==(o[0|(t=l-4|0)]|o[t+1|0]<<8|o[t+2|0]<<16|o[t+3|0]<<24)||1735549292==(o[0|t]|o[t+1|0]<<8|o[t+2|0]<<16|o[t+3|0]<<24)))&&(u=20|d)}16&u&&(Qn(A[e+204>>2],l),8&o[188788]&&ns(88683,6,A[47195]))}return A[e+8184>>2]|!(2048&n)||(A[e+8184>>2]=1),115!=g[s>>1]&&Sn(s,88850,3)||(u|=8),U=s- -64|0,39==o[0|s]?65531&u:u}function ve(e,t,n,r,s,a,i,o,l){var u,c=0,d=0,h=0,f=0,g=0,p=0,m=0,b=0,C=0,I=0;U=u=U-112|0,c=2147483647&l;e:{if(h=!(t|n),(r|(d=2147483647&s)?d-2147418112>>>0<2147549184:h)||!(!o&-2147418112==(0|(g=c-2147418112|0))?a|i:-2147418112==(0|g)&!!(0|o)|g>>>0>2147549184)){if(!(!r&2147418112==(0|d)?h:d>>>0<2147418112)){o=r,l=32768|s,a=t,i=n;break e}if(!(!o&2147418112==(0|c)?!(a|i):c>>>0<2147418112)){l|=32768;break e}if(!(t|r|2147418112^d|n)){f=r,o=(r=!(t^a|r^o|n^i|s^l^-2147483648))?0:f,l=r?2147450880:s,a=r?0:t,i=r?0:n;break e}if(!(a|o|2147418112^c|i))break e;if(!(t|r|n|d)){if(a|o|i|c)break e;a&=t,i&=n,o&=r,l&=s;break e}if(!(a|o|i|c)){a=t,i=n,o=r,l=s;break e}}d=(h=b=(f=(0|c)==(0|d))&(0|r)==(0|o)?(0|n)==(0|i)&t>>>0<a>>>0|n>>>0<i>>>0:f&r>>>0<o>>>0|c>>>0>d>>>0)?a:t,g=h?i:n,C=f=h?l:s,h=h?o:r,m=65535&f,r=b?r:o,I=s=b?s:l,f=s>>>16&32767,(p=C>>>16&32767)||(l=s=!(h|m),c=s?d:h,o=s<<=6,Ut(u+96|0,d,g,h,m,(s=s+(32==(0|(l=w(l?g:m)))?w(c)+32|0:l)|0)-15|0),h=A[u+104>>2],m=A[u+108>>2],g=A[u+100>>2],p=16-s|0,d=A[u+96>>2]),a=b?t:a,i=b?n:i,o=r,l=65535&I,f||(s=t=!(o|l),c=t?a:o,n=t<<=6,Ut(u+80|0,a,i,o,l,(t=t+(32==(0|(s=w(s?i:l)))?w(c)+32|0:s)|0)-15|0),f=16-t|0,o=A[u+88>>2],l=A[u+92>>2],i=A[u+84>>2],a=A[u+80>>2]),n=l<<3|o>>>29,t=o<<3|i>>>29,n|=524288,o=h<<3|g>>>29,l=m<<3|h>>>29,b=C^I,s=i<<3|a>>>29,r=a<<3,(0|f)!=(0|p)&&((a=p-f|0)>>>0>127?(t=0,n=0,s=0,r=1):(Ut(u- -64|0,r,s,t,n,128-a|0),Lt(u+48|0,r,s,t,n,a),t=A[u+56>>2],n=A[u+60>>2],s=A[u+52>>2],r=A[u+48>>2]|!!(A[u+64>>2]|A[u+72>>2]|A[u+68>>2]|A[u+76>>2]))),h=r,c=s,f=o,m=524288|l,s=g<<3|d>>>29,g=d<<3,d=s;t:if((0|b)<0){if(a=0,i=0,o=0,l=0,!(h^g|t^f|c^d|n^m))break e;if(r=g-h|0,s=d-((h>>>0>g>>>0)+c|0)|0,o=(a=f-t|0)-(i=(0|c)==(0|d)&h>>>0>g>>>0|c>>>0>d>>>0)|0,l=t=(m-((t>>>0>f>>>0)+n|0)|0)-(a>>>0<i>>>0)|0,t>>>0>524287)break t;a=t=!(o|l),i=t?r:o,n=t<<=6,Ut(u+32|0,r,s,o,l,t=(t=t+(32==(0|(a=w(a?s:l)))?w(i)+32|0:a)|0)-12|0),p=p-t|0,o=A[u+40>>2],l=A[u+44>>2],r=A[u+32>>2],s=A[u+36>>2]}else s=c+d|0,a=(0|c)==(0|(s=(r=h+g|0)>>>0<g>>>0?s+1|0:s))&r>>>0<h>>>0|s>>>0<c>>>0,c=n+m|0,c=(t=t+f|0)>>>0<f>>>0?c+1|0:c,1048576&(l=(o=t+a|0)>>>0<t>>>0?c+1|0:c)&&(r=1&h|(1&s)<<31|r>>>1,s=o<<31|s>>>1,p=p+1|0,o=(1&l)<<31|o>>>1,l=l>>>1|0);if(n=0,d=-2147483648&C,(0|p)>=32767)o=n,l=2147418112|d,a=0,i=0;else if(f=0,(0|p)>0?f=p:(Ut(u+16|0,r,s,o,l,p+127|0),Lt(u,r,s,o,l,1-p|0),r=A[u>>2]|!!(A[u+16>>2]|A[u+24>>2]|A[u+20>>2]|A[u+28>>2]),s=A[u+4>>2],o=A[u+8>>2],l=A[u+12>>2]),g=7&r,r=(0|(t=o<<29|s>>>3))==(0|(i=(r=(7&s)<<29|r>>>3)>>>0>(a=(g>>>0>4)+r|0)>>>0?t+1|0:t))&r>>>0>a>>>0|t>>>0>i>>>0,t=n|(7&l)<<29|o>>>3,l=d|l>>>3&65535|f<<16,l=t>>>0>(o=r+t|0)>>>0?l+1|0:l,4!=(0|g)){if(!g)break e}else c=i+(t=0)|0,l=(t=(0|t)==(0|(i=(r=a)>>>0>(a=a+(n=1&a)|0)>>>0?c+1|0:c))&n>>>0>a>>>0|t>>>0>i>>>0)>>>0>(o=t+o|0)>>>0?l+1|0:l}A[e>>2]=a,A[e+4>>2]=i,A[e+8>>2]=o,A[e+12>>2]=l,U=u+112|0}function Ee(e){var t=0,n=0,r=0,s=0,a=0,i=0,o=0;e:if(e|=0){a=(r=e-8|0)+(e=-8&(t=A[e-4>>2]))|0;t:if(!(1&t)){if(!(3&t))break e;if((r=r-(t=A[r>>2])|0)>>>0<p[57156])break e;if(e=e+t|0,A[57157]==(0|r)){if(!(3&~(t=A[a+4>>2])))return A[57154]=e,A[a+4>>2]=-2&t,A[r+4>>2]=1|e,void(A[e+r>>2]=e)}else{if(t>>>0<=255){if(s=A[r+8>>2],t=t>>>3|0,(0|(n=A[r+12>>2]))==(0|s)){A[57152]=A[57152]&Xr(-2,t);break t}A[s+12>>2]=n,A[n+8>>2]=s;break t}if(o=A[r+24>>2],(0|r)==(0|(t=A[r+12>>2])))if((n=A[(s=r+20|0)>>2])||(n=A[(s=r+16|0)>>2])){for(;i=s,(n=A[(s=(t=n)+20|0)>>2])||(s=t+16|0,n=A[t+16>>2]););A[i>>2]=0}else t=0;else n=A[r+8>>2],A[n+12>>2]=t,A[t+8>>2]=n;if(!o)break t;s=A[r+28>>2];n:{if(A[(n=228912+(s<<2)|0)>>2]==(0|r)){if(A[n>>2]=t,t)break n;A[57153]=A[57153]&Xr(-2,s);break t}if(A[o+(A[o+16>>2]==(0|r)?16:20)>>2]=t,!t)break t}if(A[t+24>>2]=o,(n=A[r+16>>2])&&(A[t+16>>2]=n,A[n+24>>2]=t),!(n=A[r+20>>2]))break t;A[t+20>>2]=n,A[n+24>>2]=t}}if(!(r>>>0>=a>>>0)&&1&(t=A[a+4>>2])){t:{if(!(2&t)){if(A[57158]==(0|a)){if(A[57158]=r,e=A[57155]+e|0,A[57155]=e,A[r+4>>2]=1|e,A[57157]!=(0|r))break e;return A[57154]=0,void(A[57157]=0)}if(A[57157]==(0|a))return A[57157]=r,e=A[57154]+e|0,A[57154]=e,A[r+4>>2]=1|e,void(A[e+r>>2]=e);e=(-8&t)+e|0;n:if(t>>>0<=255){if(s=A[a+8>>2],t=t>>>3|0,(0|(n=A[a+12>>2]))==(0|s)){A[57152]=A[57152]&Xr(-2,t);break n}A[s+12>>2]=n,A[n+8>>2]=s}else{if(o=A[a+24>>2],(0|a)==(0|(t=A[a+12>>2])))if((n=A[(s=a+20|0)>>2])||(n=A[(s=a+16|0)>>2])){for(;i=s,(n=A[(s=(t=n)+20|0)>>2])||(s=t+16|0,n=A[t+16>>2]););A[i>>2]=0}else t=0;else n=A[a+8>>2],A[n+12>>2]=t,A[t+8>>2]=n;if(o){s=A[a+28>>2];r:{if(A[(n=228912+(s<<2)|0)>>2]==(0|a)){if(A[n>>2]=t,t)break r;A[57153]=A[57153]&Xr(-2,s);break n}if(A[o+(A[o+16>>2]==(0|a)?16:20)>>2]=t,!t)break n}A[t+24>>2]=o,(n=A[a+16>>2])&&(A[t+16>>2]=n,A[n+24>>2]=t),(n=A[a+20>>2])&&(A[t+20>>2]=n,A[n+24>>2]=t)}}if(A[r+4>>2]=1|e,A[e+r>>2]=e,A[57157]!=(0|r))break t;return void(A[57154]=e)}A[a+4>>2]=-2&t,A[r+4>>2]=1|e,A[e+r>>2]=e}if(e>>>0<=255)return t=228648+(-8&e)|0,(n=A[57152])&(e=1<<(e>>>3))?e=A[t+8>>2]:(A[57152]=e|n,e=t),A[t+8>>2]=r,A[e+12>>2]=r,A[r+12>>2]=t,void(A[r+8>>2]=e);s=31,e>>>0<=16777215&&(s=62+((e>>>38-(t=w(e>>>8|0))&1)-(t<<1)|0)|0),A[r+28>>2]=s,A[r+16>>2]=0,A[r+20>>2]=0,i=228912+(s<<2)|0;t:{n:{if((n=A[57153])&(t=1<<s)){for(s=e<<(31!=(0|s)?25-(s>>>1|0):0),t=A[i>>2];;){if(n=t,(-8&A[t+4>>2])==(0|e))break n;if(t=s>>>29|0,s<<=1,!(t=A[16+(i=n+(4&t)|0)>>2]))break}A[i+16>>2]=r,A[r+24>>2]=n}else A[57153]=t|n,A[i>>2]=r,A[r+24>>2]=i;A[r+12>>2]=r,A[r+8>>2]=r;break t}e=A[n+8>>2],A[e+12>>2]=r,A[n+8>>2]=r,A[r+24>>2]=0,A[r+12>>2]=n,A[r+8>>2]=e}e=A[57160]-1|0,A[57160]=e||-1}}}function Be(e,t,n){var r,s=0,l=0,u=0,c=0,d=0,h=0,f=0,g=0,p=0,m=0,C=0,I=0;U=r=U-176|0;e:{if(32&t)m=n-((0|n)>1)|0;else{l=zt(e,93302);t:{n:{r:{if(2!=(0|t)){if(l)break r;t=0;break e}if(m=n+1|0,g=56+(C=b(n,76)+133152|0)|0,p=zt(e,89360),u=zt(e,93318),c=zt(e,93426),d=zt(e,93499),l)break n;break t}m=n+1|0,g=56+(C=b(n,76)+133152|0)|0,d=0}for(e=0,h=34!=(0|(s=A[l-4>>2]))?39==(0|s)?s:0:s,I=b(n,76)+133208|0;;){if(s=e,!(e=A[l>>2]))break t;n:{if(!h){if(32==(0|e)|e-9>>>0<5)break t;if(47!=(0|e))break n;break t}if(92!=(0|s)&&(0|e)==(0|h))break t}if(l=l+4|0,!((0|(f=Qn(e,f+I|0)+f|0))<16))break}}h=0,a[f+g|0]=0,f=b(n,76)+133168|0,l=0;t:if(p)for(e=0,g=34!=(0|(s=A[p-4>>2]))?39==(0|s)?s:0:s;;){if(s=e,!(e=A[p>>2]))break t;n:{if(!g){if(32==(0|e)|e-9>>>0<5)break t;if(47!=(0|e))break n;break t}if(92!=(0|s)&&(0|e)==(0|g))break t}if(p=p+4|0,!((0|(l=Qn(e,l+f|0)+l|0))<36))break}if(a[l+f|0]=0,!(!u|A[u>>2]-48>>>0>=10)){for(;h=(A[u>>2]+b(h,10)|0)-48|0,A[(u=u+4|0)>>2]-48>>>0<10;);(0|h)<=0||(h=h-1|0)}if(s=b(n,76)+133152|0,A[s+4>>2]=h,e=0,l=0,!(!c|A[c>>2]-48>>>0>=10))for(;l=(A[c>>2]+b(l,10)|0)-48|0,A[(c=c+4|0)>>2]-48>>>0<10;);A[s+12>>2]=l,l=b(n,76)+133152|0;t:{n:if(d){for(;n=a[e+93099|0],(s=A[(e<<2)+d>>2])&&(e=e+1|0,(0|n)==(0|s)););r:{s:switch(s-34|0){case 0:case 5:break s;default:break r}if(!n){e=0;break t}}for(e=0;n=a[e+93116|0],(s=A[(e<<2)+d>>2])&&(e=e+1|0,(0|n)==(0|s)););r:{s:switch(s-34|0){case 0:case 5:break s;default:break r}if(!n){e=1;break t}}for(e=0;n=a[e+93197|0],(s=A[(e<<2)+d>>2])&&(e=e+1|0,(0|n)==(0|s)););r:switch(s-34|0){case 0:case 5:break r;default:break n}if(!n){e=2;break t}}e=3}A[l+8>>2]=A[131156+(e<<3)>>2],A[C>>2]=t}if(rn(137776,133168),n=rn(r+96|0,133208),a[r+157|0]=A[33291],a[r+156|0]=A[33290],e=A[33289],A[r+152>>2]=0,a[r+158|0]=e,(0|m)>0)for(u=0;;){if(c=1,t=b(u,76)+133152|0,o[0|(e=t+16|0)]&&Nt(0,e)&&(rn(137776,e),c=0,a[0|n]=0,a[r+158|0]=0,i[r+156>>1]=0),o[0|(e=t+56|0)]){d=rn(n,e),s=A[33679];t:if(o[0|(e=s)])for(;;){if(!mr(e=e+1|0,d)){rn(d,s+1|0);break t}if(e=1+(Hn(e)+e|0)|0,!o[0|e])break}c&&(a[137776]=0)}if((e=A[t+8>>2])&&(a[r+156|0]=e),(e=A[t+12>>2])&&(a[r+157|0]=e),(e=A[t+4>>2])&&(a[r+158|0]=e),(0|m)==(0|(u=u+1|0)))break}A[r+148>>2]=n,A[r+144>>2]=137776,(e=Ce(r+144|0,r+172|0))?us(e,43)||(t=o[r+156|0],!o[134672]|((0|t)!=o[134724]?t:0)||(A[r>>2]=e,A[r+4>>2]=134672,En(t=r+16|0,93533,r),e=137776,fs(137776,t,40))):e=92003,t=0,mr(e,134784)&&(rn(134784,e),t=131072)}return U=r+176|0,t}function Me(e,t){var n,r=0,s=0,a=0,i=0,o=0;n=e+t|0;e:{t:if(!(1&(r=A[e+4>>2]))){if(!(3&r))break e;t=(r=A[e>>2])+t|0;n:{if((0|(e=e-r|0))!=A[57157]){if(r>>>0<=255){if(a=A[e+8>>2],r=r>>>3|0,(0|(s=A[e+12>>2]))!=(0|a))break n;A[57152]=A[57152]&Xr(-2,r);break t}if(o=A[e+24>>2],(0|(r=A[e+12>>2]))==(0|e))if((s=A[(a=e+20|0)>>2])||(s=A[(a=e+16|0)>>2])){for(;i=a,(s=A[(a=(r=s)+20|0)>>2])||(a=r+16|0,s=A[r+16>>2]););A[i>>2]=0}else r=0;else s=A[e+8>>2],A[s+12>>2]=r,A[r+8>>2]=s;if(!o)break t;a=A[e+28>>2];r:{if(A[(s=228912+(a<<2)|0)>>2]==(0|e)){if(A[s>>2]=r,r)break r;A[57153]=A[57153]&Xr(-2,a);break t}if(A[o+(A[o+16>>2]==(0|e)?16:20)>>2]=r,!r)break t}if(A[r+24>>2]=o,(s=A[e+16>>2])&&(A[r+16>>2]=s,A[s+24>>2]=r),!(s=A[e+20>>2]))break t;A[r+20>>2]=s,A[s+24>>2]=r;break t}if(3&~(r=A[n+4>>2]))break t;return A[57154]=t,A[n+4>>2]=-2&r,A[e+4>>2]=1|t,void(A[n>>2]=t)}A[a+12>>2]=s,A[s+8>>2]=a}t:{if(!(2&(r=A[n+4>>2]))){if(A[57158]==(0|n)){if(A[57158]=e,t=A[57155]+t|0,A[57155]=t,A[e+4>>2]=1|t,A[57157]!=(0|e))break e;return A[57154]=0,void(A[57157]=0)}if(A[57157]==(0|n))return A[57157]=e,t=A[57154]+t|0,A[57154]=t,A[e+4>>2]=1|t,void(A[e+t>>2]=t);t=(-8&r)+t|0;n:if(r>>>0<=255){if(a=A[n+8>>2],r=r>>>3|0,(0|(s=A[n+12>>2]))==(0|a)){A[57152]=A[57152]&Xr(-2,r);break n}A[a+12>>2]=s,A[s+8>>2]=a}else{if(o=A[n+24>>2],(0|n)==(0|(r=A[n+12>>2])))if((a=A[(s=n+20|0)>>2])||(a=A[(s=n+16|0)>>2])){for(;i=s,(a=A[(s=(r=a)+20|0)>>2])||(s=r+16|0,a=A[r+16>>2]););A[i>>2]=0}else r=0;else s=A[n+8>>2],A[s+12>>2]=r,A[r+8>>2]=s;if(o){a=A[n+28>>2];r:{if(A[(s=228912+(a<<2)|0)>>2]==(0|n)){if(A[s>>2]=r,r)break r;A[57153]=A[57153]&Xr(-2,a);break n}if(A[o+(A[o+16>>2]==(0|n)?16:20)>>2]=r,!r)break n}A[r+24>>2]=o,(s=A[n+16>>2])&&(A[r+16>>2]=s,A[s+24>>2]=r),(s=A[n+20>>2])&&(A[r+20>>2]=s,A[s+24>>2]=r)}}if(A[e+4>>2]=1|t,A[e+t>>2]=t,A[57157]!=(0|e))break t;return void(A[57154]=t)}A[n+4>>2]=-2&r,A[e+4>>2]=1|t,A[e+t>>2]=t}if(t>>>0<=255)return r=228648+(-8&t)|0,(s=A[57152])&(t=1<<(t>>>3))?t=A[r+8>>2]:(A[57152]=t|s,t=r),A[r+8>>2]=e,A[t+12>>2]=e,A[e+12>>2]=r,void(A[e+8>>2]=t);a=31,t>>>0<=16777215&&(a=62+((t>>>38-(r=w(t>>>8|0))&1)-(r<<1)|0)|0),A[e+28>>2]=a,A[e+16>>2]=0,A[e+20>>2]=0,i=228912+(a<<2)|0;t:{if((s=A[57153])&(r=1<<a)){for(a=t<<(31!=(0|a)?25-(a>>>1|0):0),r=A[i>>2];;){if(s=r,(-8&A[r+4>>2])==(0|t))break t;if(r=a>>>29|0,a<<=1,!(r=A[16+(i=s+(4&r)|0)>>2]))break}A[i+16>>2]=e,A[e+24>>2]=s}else A[57153]=r|s,A[i>>2]=e,A[e+24>>2]=i;return A[e+12>>2]=e,void(A[e+8>>2]=e)}t=A[s+8>>2],A[t+12>>2]=e,A[s+8>>2]=e,A[e+24>>2]=0,A[e+12>>2]=s,A[e+8>>2]=t}}function De(e){var t=0,n=0,r=0,s=0,i=0,l=0,u=0,c=0,d=0,h=0,f=0,g=0,p=0;if(!(t=a[88105]))return e;if(e=us(e,t)){if(!o[88106])return e;if(o[e+1|0]){if(!o[88107]){s=!!(0|(n=o[e+1|0]));e:if(n&&(0|(t=n|o[0|e]<<8))!=(0|(u=o[88106]|o[88105]<<8)))for(n=e+1|0;;){if(s=!!(0|(r=o[(e=n)+1|0])),!r)break e;if(n=e+1|0,(0|u)==(0|(t=r|t<<8&65280)))break}return s?e:0}if(o[e+2|0]){if(!o[88108]){n=e+2|0,s=!!(0|(t=o[e+2|0]));e:if(t&&(0|(t=o[e+1|0]<<16|o[0|e]<<24|t<<8))!=(0|(u=o[88106]<<16|o[88105]<<24|o[88107]<<8)))for(;;){if(e=n+1|0,s=!!(0|(r=o[n+1|0])),!r)break e;if(n=e,(0|u)==(0|(t=(t|r)<<8)))break}else e=n;return s?e-2|0:0}if(o[e+3|0]){if(!o[88109]){n=e+3|0,s=!!(0|(t=o[e+3|0]));e:if(t&&(0|(t=t|o[e+1|0]<<16|o[0|e]<<24|o[e+2|0]<<8))!=(0|(u=(e=o[88105]|o[88106]<<8|o[88107]<<16|o[88108]<<24)<<24|(65280&e)<<8|e>>>8&65280|e>>>24)))for(;;){if(e=n+1|0,s=!!(0|(r=o[n+1|0])),!r)break e;if(n=e,(0|u)==(0|(t=r|t<<8)))break}else e=n;return s?e-3|0:0}u=e,U=c=U-1056|0,A[(e=c+1048|0)>>2]=0,A[e+4>>2]=0,A[(e=c+1040|0)>>2]=0,A[e+4>>2]=0,A[c+1032>>2]=0,A[c+1036>>2]=0,A[c+1024>>2]=0,A[c+1028>>2]=0;e:{t:{n:{r:{if(t=o[88105]){for(;;){if(!o[i+u|0])break t;if(i=i+1|0,A[((255&t)<<2)+c>>2]=i,A[(e=(c+1024|0)+(t>>>3&28)|0)>>2]=A[e>>2]|1<<t,!(t=o[i+88105|0]))break}if(e=1,d=-1,i>>>0>1)break r}else d=-1,e=1;l=-1,n=1;break n}for(r=1,t=1;;){r:if((0|(l=o[88105+(t+d|0)|0]))!=(0|(s=o[e+88105|0])))s>>>0<l>>>0?(r=e-d|0,n=e,t=1):(d=n,n=n+1|0,r=1,t=1);else{if((0|t)==(0|r)){n=n+r|0,t=1;break r}t=t+1|0}if(!(i>>>0>(e=n+t|0)>>>0))break}if(n=1,l=-1,i>>>0<=1)e=r;else{for(e=0,s=1,t=1;;){r:if((0|(f=o[88105+(t+l|0)|0]))!=(0|(h=o[n+88105|0])))h>>>0>f>>>0?(s=n-l|0,e=n,t=1):(l=e,e=e+1|0,s=1,t=1);else{if((0|t)==(0|s)){e=e+s|0,t=1;break r}t=t+1|0}if(!(i>>>0>(n=e+t|0)>>>0))break}e=r,n=s}}for(t=e,Sn(88105,(r=(e=l+1>>>0>d+1>>>0)?n:t)+88105|0,f=(h=e?l:d)+1|0)?(r=((e=~h+i|0)>>>0<h>>>0?h:e)+1|0,s=0):s=i-r|0,p=i-1|0,g=63|i,l=0,e=u;;){if(!(u-e>>>0>=i>>>0))if(n=Zt(u,0,g)){if(u=n,n-e>>>0<i>>>0)break t}else u=u+g|0;n=o[e+p|0],t=i;n:{if(A[(c+1024|0)+(n>>>3&28)>>2]>>>n&1)if((0|(n=A[(n<<2)+c>>2]))==(0|i)){r:{if(d=o[(n=(t=f)>>>0>l>>>0?t:l)+88105|0])for(;;){if(o[e+n|0]!=(255&d))break r;if(!(d=o[88105+(n=n+1|0)|0]))break}for(;;){if(t>>>0<=l>>>0)break e;if(o[88105+(t=t-1|0)|0]!=o[e+t|0])break}t=r,l=s;break n}t=n-h|0}else t=(n=i-n|0)>>>0>l>>>0?n:l;l=0}e=e+t|0}}e=0}U=c+1056|0,n=e}}}}return n}function Te(e,t,n,r,s,i){var l,u,c,d,h=0,f=0,g=0;if(U=l=U-560|0,a[l+448|0]=0,a[l+144|0]=0,a[l+120|0]=0,c=34&i,u=t-b(f=(0|t)/100|0,100)|0,1&(d=64&o[e+106|0]?(0|t)>999|i:0)|(0|t)>99){e:{t:{n:{if(!(!c|u)){if(!Mn(e,90606,l+304|0))break n;break e}if(u)break t}if(Mn(e,90691,l+304|0))break e}Mn(e,90725,l+304|0)}h=i,(0|t)<1e3||(h=i,!(8&o[e+105|0])|t-2e3>>>0<4294967196&&(a[l+208|0]=0,xe(e,h=(f>>>0)/10|0,r=16384&A[e+108>>2]?0:s+1|0,!((t>>>0)%1e3|0)|c,l+272|0)||Ie(e,h,s,28012==A[e+212>>2]?520:(0|r)<4?(A[e+108>>2]>>>r&1)<<3:0,l+208|0),2&o[e+109|0]?(A[l+108>>2]=15,A[l+100>>2]=15,A[l+104>>2]=l+208,A[l+96>>2]=l+272,En(l+144|0,90761,l+96|0)):(A[l+92>>2]=15,A[l+84>>2]=15,A[l+88>>2]=l+272,A[l+80>>2]=l+208,En(l+144|0,90761,l+80|0)),r=1,1&(!!(0|(f=f-b(h,10)|0))|d)||(a[l+304|0]=0),h=1|i)),a[l+208|0]=0;e:if(!(~d&(0|f)<=0))if(!(4&o[e+106|0])|!(1&h|o[l+144|0])||Mn(e,90824,l+120|0),!c|(16&o[e+109|0]?0:u)||(A[l+64>>2]=f,En(r=l+548|0,90875,l- -64|0),g=Mn(e,r,l+208|0),!(4096&A[e+108>>2])|(0|u)<=0||Es(l+208|0,133104)),r=1,1&(~d|!!(0|f))){t:{n:{r:{s:{if(!(131072&A[e+108>>2])||1&h|1!=(0|f)){if(u|g||(A[l+48>>2]=f,En(r=l+548|0,90985,l+48|0),g=Mn(e,r,l+208|0)),g)break s;if(A[l+32>>2]=f,En(r=l+548|0,91027,l+32|0),Mn(e,r,l+208|0))break s;if(1!=(0|f))break n;break r}if(!g)break r}a[l+304|0]=0;break t}if(r=1,4&o[e+105|0])break e}Ie(e,f,s,0,l+208|0)}r=1}else Mn(e,88875,l+208|0);A[l+28>>2]=l+304,A[l+24>>2]=l+208,A[l+20>>2]=l+120,A[l+16>>2]=l+144,En(l+448|0,91059,l+16|0)}else h=i;a[l+132|0]=0;e:{t:{if((0|u)>0)16&o[e+109|0]&&2&h||(!(1&h)|s&&(0|t)<=100||!(64&(r=A[e+104>>2]))&(!(8388608&r)|u>>>0>9)||Mn(e,90824,l+132|0),!(1&h|o[l+144|0])|!(524288&A[e+104>>2])|f||Mn(e,90824,l+132|0)),a[l+336|0]=0;else if(a[l+336|0]=0,!u&r)break t;if(s?(i=A[e+108>>2],t=(0|s)<4?(i>>>s&1)<<3:0):(r=c?3:2,t=32&i|((0|t)<100?1&h?r:4|r:r),i=A[e+108>>2]),t=1==(0|s)&&28012==A[e+212>>2]?520|t:t,1048576&i&&(r=16|t,t=(0|f)>0||1&h?r:t),!Ie(e,u,s,256&h|t,l+336|0)|!(128&o[e+104|0]))break e;a[l+132|0]=0;break e}o[133104]&&((0|(e=Hn(l+448|0)))<=0||10==o[447+(e=e+l|0)|0]&&(a[e+447|0]=0),rn(l+336|0,133104))}A[l+8>>2]=15,A[l+12>>2]=l+336,A[l+4>>2]=l+132,A[l>>2]=l+448,En(n,91101,l),U=l+560|0}function Se(e){var t,n,r,s=0,l=0,u=0,c=0,d=0,h=0,f=0,g=0,p=0,C=0,I=0,w=0;for(s=A[32972],A[s+64>>2]=290816,A[s+68>>2]=4104,A[s+96>>2]=0,A[s+100>>2]=0,A[s+120>>2]=90,A[s+124>>2]=100,A[s+112>>2]=64,A[s+116>>2]=256,A[s+104>>2]=5,A[s+108>>2]=0,A[s+84>>2]=100,A[s+88>>2]=64,l=A[50754],A[s+132>>2]=0,A[s+136>>2]=0,A[s+128>>2]=l,A[s+140>>2]=0,A[s+144>>2]=0,A[s+148>>2]=0,A[s+152>>2]=0,A[s+156>>2]=0,A[s+160>>2]=0,A[36435]=450,A[s+92>>2]=2,A[50870]=0,A[50871]=0,A[50872]=0,A[50873]=0,A[50880]=0,A[50881]=0,A[50882]=0,A[50883]=0,A[50890]=0,A[50891]=0,A[50892]=0,A[50893]=0,u=-3.141592653589793/+A[50754],m[25429]=u,d=-2*u,m[25430]=d,t=(u=$e(200*u))*-u,m[25434]=t,m[25439]=t,m[25444]=t,u=(d=u*sn(2e3*d))+d,m[25433]=u,m[25438]=u,m[25443]=u,d=1-u-t,m[25432]=d,m[25437]=d,m[25442]=d,A[50902]=0,A[50903]=0,A[50900]=0,A[50901]=0,m[25449]=t,m[25448]=u,A[50912]=0,A[50913]=0,m[25447]=d,A[50910]=0,A[50911]=0,m[25454]=t,m[25453]=u,A[50922]=0,A[50923]=0,m[25452]=d,A[50920]=0,A[50921]=0,m[25459]=t,m[25458]=u,A[50932]=0,A[50933]=0,m[25457]=d,A[50930]=0,A[50931]=0,m[25464]=t,m[25463]=u,m[25462]=d,A[50942]=0,A[50943]=0,A[50940]=0,A[50941]=0,m[25469]=t,m[25468]=u,m[25467]=d,A[50952]=0,A[50953]=0,A[50950]=0,A[50951]=0,m[25474]=t,m[25473]=u,m[25472]=d,n=A[32972],l=0;i[236+(h=(l<<1)+n|0)>>1]=256,i[h+164>>1]=256,s=o[l+105376|0]<<1,i[h+254>>1]=s,i[h+182>>1]=s,i[h+200>>1]=o[l+105385|0]<<1,A[308+(s=(c=l<<2)+n|0)>>2]=A[c+105408>>2],A[s+272>>2]=0,i[h+218>>1]=0,A[c+200944>>2]=(0|b(A[c+105456>>2],22050))/A[50754],9!=(0|(l=l+1|0)););for(C=A[32961],l=0,r=n+344|0;;){if(s=f,g=C,h=l,-1==(0|(f=A[(l=131840+(c=l<<2)|0)>>2]))&&(f=8e3,A[l>>2]=8e3,h&&(A[131840+(4|c)>>2]=A[c+131836>>2])),C=A[131840+(4|c)>>2],!((0|s)>=(0|(f=(0|f)/8|0))||(0|(p=f-s|0))<=0||(c=s+1|0,l=s,1&p&&(a[344+(s+n|0)|0]=(0|g)>=255?255:g,l=c),(0|c)==(0|f))))for(I=C-g|0;c=((0|b(l-s|0,I))/(0|p)|0)+g|0,a[l+r|0]=(0|c)>=255?255:c,w=((0|b((c=l+1|0)-s|0,I))/(0|p)|0)+g|0,a[c+r|0]=(0|w)>=255?255:w,(0|f)!=(0|(l=l+2|0)););if(l=h+2|0,!(h>>>0<10))break}l=A[32972],A[l+80>>2]=232,A[l+72>>2]=256,A[l+76>>2]=238,e||(A[49848]=0),i[l+200>>1]=(0|b(i[l+200>>1],105))/100}function Ne(e,t,n){var r,s=0,i=0,l=0,u=0,c=0,d=0,h=0,f=0;U=r=U-288|0,132848!=(0|t)&&Ft(132848,t,40),(0|(s=e+228|0))!=(0|t)&&Ft(s,t,40),A[r+88>>2]=t,A[r+84>>2]=47,A[r+80>>2]=137584,En(s=r+96|0,84089,r+80|0),i=Ar(s),(s=A[e+688>>2])&&(Ee(s),A[e+688>>2]=0),s=et(r+96|0,84577);e:if((0|i)>0&&s)if(n=ie(i),A[e+688>>2]=n,n)if(d=wn(n,i,s),cr(s),d>>>0<=1032)A[r+16>>2]=r+96,ts(A[30450],85164,r+16|0),n=2;else if(s=A[e+688>>2],n=A[s+4>>2],!(1024!=(0|(i=A[s>>2]))|(0|n)<=0)&(0|n)<134217729){s=n+s|0,A[e+684>>2]=s,f=kt(e+5168|0,0,1024),kt(e+7664|0,0,260),kt(e+7924|0,255,256),kt(e+4788|0,0,380),kt(e+6192|0,0,512);t:if(7!=(0|(n=o[0|s])))for(;;){if(6!=(0|(i=255&n))){if(!i)break t;i=A[e+684>>2],A[r+72>>2]=n<<24>>24,A[r+64>>2]=132848,A[r+68>>2]=s-i,ts(A[30450],88950,r- -64|0);break}n:{r:{s:{a:{i:switch((i=o[0|(n=s+1|0)])-18|0){case 0:break a;case 2:break i;default:break s}for(n=4+(-4&n)|0,A[e+180>>2]=n;n=(s=n)+1|0,!As(s););for(;i=o[0|s],n=s,s=s+1|0,7!=(0|i););break n}if(n=s+3|0,(0|(s=((0|(s=a[s+2|0]))<65?191:-65)+s|0))>94)break r;A[4788+((s<<2)+e|0)>>2]=n;break r}n=1+((u=Hn(n))+n|0)|0;s:switch(0|u){case 1:A[5168+((i<<2)+e|0)>>2]=n;break r;case 0:A[f>>2]=n;break r}u=o[s+2|0],1!=(0|i)?(s=A[e+7664>>2],255==o[0|(h=7924+(l=e+i|0)|0)]&&(a[0|h]=s),a[0|(l=l+7668|0)]=o[0|l]+1,A[6704+(l=(s<<2)+e|0)>>2]=n,A[e+7664>>2]=s+1,A[l+7184>>2]=i|u<<8):A[6188+((u<<2)+e|0)>>2]=n}if(7!=o[0|n])for(;n=1+(Hn(n)+n|0)|0,7!=o[0|n];);}n=o[0|(s=n+1|0)]}for(s=A[e+688>>2]+8|0;;){for(A[692+((n=c<<2)+e|0)>>2]=s;i=o[0|s];)s=s+i|0;for(s=s+1|0,A[692+((4|n)+e|0)>>2]=s;n=o[0|s];)s=n+s|0;if(s=s+1|0,1024==(0|(c=c+2|0)))break}n=0,(0|(e=A[e+324>>2]))<=0|e>>>0<=d>>>0||(A[r+48>>2]=t,ts(A[30450],85519,r+48|0))}else A[r+40>>2]=n,A[r+36>>2]=i,A[r+32>>2]=r+96,ts(A[30450],85349,r+32|0),n=2;else cr(s),n=3;else{if(n||(A[r>>2]=r+96,ts(A[30450],84963,r)),n=1,!s)break e;cr(s)}return U=r+288|0,n}function Ge(e){var t,n=0,r=0;for(t=kt(e+344|0,0,256),a[e+364|0]=1,a[e+356|0]=1,a[e+357|0]=1,a[e+358|0]=1,a[e+359|0]=1,a[e+360|0]=1,a[e+361|0]=1,a[e+362|0]=1,a[e+363|0]=1,a[e+348|0]=1,a[e+349|0]=1,a[e+350|0]=1,a[e+351|0]=1,a[e+352|0]=1,a[e+353|0]=1,a[e+354|0]=1,a[e+355|0]=1,a[e+431|0]=3,a[e+429|0]=3,a[e+430|0]=3,a[e+406|0]=3,a[e+407|0]=3,a[e+408|0]=3,a[e+409|0]=3,a[e+410|0]=3,a[e+411|0]=3,a[e+412|0]=3,a[e+413|0]=3,a[e+414|0]=3,a[e+415|0]=3,a[e+416|0]=3,a[e+417|0]=3,a[e+418|0]=3,a[e+419|0]=3,a[e+420|0]=3,a[e+421|0]=3,a[e+440|0]=3,a[e+441|0]=3,a[e+442|0]=3,a[e+443|0]=3,r=21;a[344+(n=e+r|0)|0]=4|o[n+344|0],58!=(0|(n=r+1|0));)a[0|(n=n+t|0)]=4|o[0|n],a[2+(n=r+t|0)|0]=4|o[n+2|0],a[n+3|0]=4|o[n+3|0],r=r+4|0;a[e+346|0]=4|o[e+346|0],a[e+347|0]=4|o[e+347|0],a[e+432|0]=4|o[e+432|0],a[e+433|0]=4|o[e+433|0],a[e+434|0]=4|o[e+434|0],a[e+435|0]=4|o[e+435|0],a[e+436|0]=4|o[e+436|0],a[e+437|0]=4|o[e+437|0],a[e+438|0]=4|o[e+438|0],a[e+439|0]=4|o[e+439|0],a[e+467|0]=4|o[e+467|0],a[e+468|0]=4|o[e+468|0],a[e+470|0]=4|o[e+470|0],a[e+471|0]=4|o[e+471|0],a[e+348|0]=64|o[e+348|0],a[e+349|0]=64|o[e+349|0],a[e+350|0]=64|o[e+350|0],a[e+351|0]=64|o[e+351|0],a[e+352|0]=64|o[e+352|0],a[e+353|0]=64|o[e+353|0],a[e+354|0]=64|o[e+354|0],a[e+355|0]=64|o[e+355|0],a[e+356|0]=64|o[e+356|0],a[e+357|0]=64|o[e+357|0],a[e+358|0]=64|o[e+358|0],a[e+359|0]=64|o[e+359|0],a[e+360|0]=64|o[e+360|0],a[e+361|0]=64|o[e+361|0],a[e+362|0]=64|o[e+362|0],a[e+363|0]=64|o[e+363|0],a[e+364|0]=64|o[e+364|0],a[e+406|0]=64|o[e+406|0],a[e+407|0]=64|o[e+407|0],a[e+408|0]=64|o[e+408|0],a[e+409|0]=64|o[e+409|0],a[e+410|0]=64|o[e+410|0],a[e+411|0]=64|o[e+411|0],a[e+412|0]=64|o[e+412|0],a[e+413|0]=64|o[e+413|0],a[e+414|0]=64|o[e+414|0],a[e+415|0]=64|o[e+415|0],a[e+416|0]=64|o[e+416|0],a[e+417|0]=64|o[e+417|0],a[e+418|0]=64|o[e+418|0],a[e+419|0]=64|o[e+419|0],a[e+420|0]=64|o[e+420|0],a[e+440|0]=64|o[e+440|0],a[e+441|0]=64|o[e+441|0],a[e+429|0]=64|o[e+429|0],a[e+430|0]=64|o[e+430|0],a[e+431|0]=64|o[e+431|0],a[e+442|0]=64|o[e+442|0],a[e+443|0]=64|o[e+443|0],A[e+40>>2]=1,A[e+204>>2]=A[e+600>>2]+77}function Fe(e,t,n,r,s,a,i,o,l){var u,c=0,d=0,h=0,f=0,g=0,p=0,m=0,b=0,C=0,I=0;U=u=U-128|0;e:{t:{if(Tt(a,i,o,l,0,0,0,0)){d=65535&l;n:r:{if(32767!=(0|(f=l>>>16&32767))){if(c=4,f)break r;c=a|o|i|d?3:2;break n}c=!(a|o|i|d)}if(32767!=(0|(g=32767&(C=s>>>16|0)))&&c)break t}me(u+16|0,t,n,r,s,a,i,o,l),oe(u,t=A[u+16>>2],r=A[u+20>>2],s=A[u+24>>2],n=A[u+28>>2],t,r,s,n),r=A[u+8>>2],s=A[u+12>>2],o=A[u>>2],l=A[u+4>>2];break e}if(f=o,(0|Tt(t,n,c=r,p=2147483647&s,a,i,o,h=2147483647&l))<=0){if(Tt(t,n,c,p,a,i,f,h)){o=t,l=n;break e}me(u+112|0,t,n,r,s,0,0,0,0),r=A[u+120>>2],s=A[u+124>>2],o=A[u+112>>2],l=A[u+116>>2]}else{if(m=l>>>16&32767,g?(l=n,o=t):(me(u+96|0,t,n,c,p,0,0,0,1081540608),c=A[u+104>>2],p=o=A[u+108>>2],g=(o>>>16|0)-120|0,l=A[u+100>>2],o=A[u+96>>2]),m||(me(u+80|0,a,i,f,h,0,0,0,1081540608),f=A[u+88>>2],h=a=A[u+92>>2],m=(a>>>16|0)-120|0,i=A[u+84>>2],a=A[u+80>>2]),b=f,I=65535&h|65536,p=65535&p|65536,(0|g)>(0|m)){for(;;){if(f=(h=c-b|0)-(d=(0|i)==(0|l)&a>>>0>o>>>0|i>>>0>l>>>0)|0,(0|(d=(p-((c>>>0<b>>>0)+I|0)|0)-(d>>>0>h>>>0)|0))>0|(0|d)>=0){if(c=o,!((o=o-a|0)|f|(l=l-((a>>>0>c>>>0)+i|0)|0)|d)){me(u+32|0,t,n,r,s,0,0,0,0),r=A[u+40>>2],s=A[u+44>>2],o=A[u+32>>2],l=A[u+36>>2];break e}d=d<<1|f>>>31,c=f<<1|l>>>31}else d=p<<1|c>>>31,c=c<<1|l>>>31;if(p=d,d=l<<1|o>>>31,o<<=1,l=d,!((0|(g=g-1|0))>(0|m)))break}g=m}if(f=(h=c-b|0)-(d=(0|i)==(0|l)&a>>>0>o>>>0|i>>>0>l>>>0)|0,h=d=(p-((c>>>0<b>>>0)+I|0)|0)-(d>>>0>h>>>0)|0,(0|d)<0)f=c,h=p;else if(c=o,!((o=o-a|0)|f|(l=l-((a>>>0>c>>>0)+i|0)|0)|h)){me(u+48|0,t,n,r,s,0,0,0,0),r=A[u+56>>2],s=A[u+60>>2],o=A[u+48>>2],l=A[u+52>>2];break e}if(65535==(0|h)|h>>>0<65535)for(;t=l>>>31|0,g=g-1|0,p=l<<1|o>>>31,o<<=1,l=p,n=t,t=h<<1|f>>>31,f=n|f<<1,h=t,t>>>0<65536;);t=32768&C,(0|g)<=0?(me(u- -64|0,o,l,f,65535&h|(t|g+120)<<16,0,0,0,1065811968),r=A[u+72>>2],s=A[u+76>>2],o=A[u+64>>2],l=A[u+68>>2]):(r=f,s=65535&h|(t|g)<<16)}}A[e>>2]=o,A[e+4>>2]=l,A[e+8>>2]=r,A[e+12>>2]=s,U=u+128|0}function Pe(e,t,n){var r,s,i=0,l=0,u=0,c=0,d=0,h=0,f=0,g=0,p=0;if(U=r=U-1040|0,(0|(l=qn(e,589824,0)))>=0&&((i=Dr(1,2072))?A[i+8>>2]=l:(v(0|l),i=0)),s=i,i){e:if(i=zn(s))for(p=A[30450],g=(r+96|0)+t|0;;){if((0|(l=A[50303]))>=348){A[r+4>>2]=350,A[r>>2]=l+1,ts(p,91860,r);break e}if(46!=o[i+19|0])if(A[r+88>>2]=i+19,A[r+84>>2]=47,A[r+80>>2]=e,En(i=r+96|0,91924,r+80|0),-31!=(0|(i=Ar(i)))){if(!((0|i)<=0)&&(f=et(r+96|0,85712))){u=0,a[r+832|0]=0,a[r+752|0]=0,A[r+360>>2]=0,A[r+356>>2]=4,d=0;t:for(;;){for(h=299-d|0;yt(r+912|0,120,f);){i=r+912|0;n:{if(35!=o[r+912|0]){r:if(!((0|(i=Hn(r+912|0)-1|0))<=0))for(;;){if(!(32==(0|(l=a[0|(c=(r+912|0)+i|0)]))|l-9>>>0<5))break r;if(a[0|c]=0,!((0|(i=i-1|0))>0))break}if(!(i=De(r+912|0)))break n}a[0|i]=0}i=r+912|0;n:if(l=o[r+912|0])for(;;){if(tr(l<<24>>24))break n;if(!(l=o[0|(i=i+1|0)]))break}if(a[0|i]=0,o[r+912|0]){i=i+1|0;n:switch(Nr(131904,r+912|0)-1|0){case 0:for(;l=i,i=i+1|0,32==(0|(c=a[0|l]))|c-9>>>0<5;);fs(r+832|0,l,80);continue;case 1:if(a[r+672|0]=0,A[r+364>>2]=5,l=r+672|0,A[r+16>>2]=l,A[r+20>>2]=r+364,ae(i,86237,r+16|0),(l=Hn(l)+2|0)>>>0>=h>>>0)continue;a[0|(i=(r+368|0)+d|0)]=A[r+364>>2],rn(i+1|0,r+672|0),u=u+1|0,d=l+d|0;continue t;case 2:if(A[r+52>>2]=r+360,A[r+48>>2]=r+752,ae(i,86237,r+48|0),!n)continue;A[r+32>>2]=g,ts(p,92042,r+32|0);continue;case 5:break n;default:continue}A[r+64>>2]=r+356,ae(i,87268,r- -64|0)}}break}a[(r+368|0)+d|0]=0,l=Nr(132112,r+752|0),u?(c=Hn(g)+d|0,h=Je((u=Dr(28+(Hn(r+832|0)+c|0)|0,1))+24|0,r+368|0,i=d+1|0),A[u+4>>2]=h,i=rn(i+h|0,g),A[u>>2]=i,A[u+8>>2]=i,o[r+832|0]&&(A[u>>2]=rn(2+(c+h|0)|0,r+832|0)),i=A[r+360>>2],a[u+14|0]=0,a[u+12|0]=l,a[u+13|0]=i,a[u+15|0]=A[r+356>>2],cr(f),i=A[50303],A[50303]=i+1,A[201216+(i<<2)>>2]=u):cr(f)}}else Pe(r+96|0,t,n);if(!(i=zn(s)))break}os(A[s+8>>2]),Ee(s)}U=r+1040|0}function Qe(e,t){var n,r=0,s=0,l=0,u=0,c=0,d=0,h=0,f=0,g=0;U=n=U-352|0;e:if(e||(e=A[136284+(t<<4)>>2])){47!=o[0|e]&&(A[n+12>>2]=e,A[n+4>>2]=47,A[n+8>>2]=47,A[n>>2]=137584,En(e=n+16|0,84114,n)),a[n+240|0]=0;t:{n:{if(r=et(e,84577)){if(-1==(0|jr(r,20)))break t;if(l=Hr(r),s=Hr(r),c=Hr(r),!(65537!=(0|l)|(0|s)!=A[50754])&(0|c)==s<<1)break n;cr(r),i[n+256>>1]=o[84864]|o[84865]<<8,e=o[84852]|o[84853]<<8|o[84854]<<16|o[84855]<<24,A[n+240>>2]=o[84848]|o[84849]<<8|o[84850]<<16|o[84851]<<24,A[n+244>>2]=e,e=o[84860]|o[84861]<<8|o[84862]<<16|o[84863]<<24,A[n+248>>2]=o[84856]|o[84857]<<8|o[84858]<<16|o[84859]<<24,A[n+252>>2]=e,U=l=U-16|0;r:{if((r=Hn(e=n+240|0))>>>0>=6&&!Sn(c=(e+r|0)-6|0,84274,6)){for(h=100;;){for(d=0,U=r=U-16|0,o[227196]||(a[227197]=N(),a[227196]=1),g=+D(),I(u=g/1e3)<0x8000000000000000?(f=I(u)>=1?~~(u>0?k(x(2.3283064365386963e-10*u),4294967295):y(2.3283064365386963e-10*(u-+(~~u>>>0>>>0))))>>>0:0,s=~~u>>>0):(f=-2147483648,s=0),A[r>>2]=s,A[r+4>>2]=f,u=1e3*(g-(+(sr(s,f,1e3,0)>>>0)+4294967296*+(0|K)))*1e3,s=I(u)<2147483648?~~u:-2147483648,A[r+8>>2]=s,s=c+(r>>>4|0)^b(A[r+8>>2],65537);a[c+d|0]=65+(15&s|s<<1&32),s=s>>>5|0,6!=(0|(d=d+1|0)););if(U=r+16|0,A[l>>2]=384,(0|(r=qn(e,194,l)))>=0)break r;if(h=h-1|0,20!=A[56798]||!h)break}Je(c,84274,6)}else A[56798]=28;r=-1}U=l+16|0,(0|r)<0||os(r)}if(!(r=et(e,84577))){e=ur(0,A[56798],e);break e}}if((0|(l=Ar(e)))<0){cr(r),e=ur(0,0-l|0,e);break e}if(-1==(0|jr(r,0))){t=A[56798],cr(r),e=ur(0,t,e);break e}if(!(s=Oe(A[(c=136280+(t<<4)|0)>>2],l))){cr(r),e=48;break e}if((0|wn(s,l,r))!=(0|l)){t=A[56798],cr(r),o[n+240|0]&&_r(n+240|0),Ee(s),e=ur(0,t,e);break e}cr(r),o[n+240|0]&&_r(n+240|0),A[136276+(t<<4)>>2]=(o[s+40|0]|o[s+41|0]<<8|o[s+42|0]<<16|o[s+43|0]<<24)/2,A[c>>2]=s,e=0;break e}t=A[56798],cr(r),e=ur(0,t,e)}else e=28;return U=n+352|0,e}function ze(e,t,n,r,s,i){var l,u=0,c=0,d=0,h=0,f=0,p=0,m=0,b=0,C=0,I=0,w=0,k=0,x=0,y=0;for(a[0|n]=1,l=1&i,x=1,C=-1,I=-1,h=1,i=t;;){y=k-2|0,w=f,m=I;e:{t:{for(;;){if(!(p=o[0|i])){I=m,f=w;break e}if(i=i+1|0,b=A[144464+(p<<2)>>2]){n:{if(1!=(0|(u=o[b+11|0]))){if(16&o[b+6|0]|2!=(0|u))break n;a[0|(f=n+h|0)]=C,u=(0|C)<4|(0|m)>(0|C),!(2&o[b+4|0])|!l|(0|C)>=0||(a[0|f]=1),f=u?w:h,I=u?m:C,C=-1,h=h+1|0;break t}if(!g[b+8>>1]){u=0,d=h;r:if(8!=(0|p))u=o[b+14|0],A[s>>2]&&u>>>0>=4||(m=(0|u)<(0|m)?m:u,C=u);else{for(;;){if(p=u,d=d-1|0,A[s>>2]|(0|d)<=0)break r;if((0|(b=a[0|(c=n+d|0)]))>3)break r;if(u=p+1|0,!(b>>>0<2))break}if(a[0|c]=4,w=(0|m)<4?d:w,m=(0|m)<=4?4:m,d>>>0<2)break r;if(b=3&(d=~p+k|0),u=1,y-p>>>0>=3)for(p=-4&d,d=0;4==o[0|(c=n+u|0)]&&(a[0|c]=3),4==o[c+1|0]&&(a[c+1|0]=3),4==o[c+2|0]&&(a[c+2|0]=3),4==o[c+3|0]&&(a[c+3|0]=3),u=u+4|0,(0|p)!=(0|(d=d+4|0)););if(c=0,!b)break r;for(;4==o[0|(p=n+u|0)]&&(a[0|p]=3),u=u+1|0,(0|b)!=(0|(c=c+1|0)););}if(x)continue;break e}}break}}I=m,f=w,20==(0|p)&&(a[n+h|0]=l&&(0|C)<0?1:C,h=h+1|0)}if(a[0|t]=p,k=h-1|0,t=t+1|0,x=(0|h)<99)continue}break}a[n+h|0]=1,a[0|t]=0;e:if((0|(t=A[s>>2]))>0)I=4,(0|t)>=(0|h)&&(A[s>>2]=k,t=k),a[t+n|0]=4,f=A[s>>2];else if(5==(0|I)&&(I=4,!((0|h)<2))){if(i=1,m=1&(t=h-1|0),2!=(0|h))for(w=-2&t,d=0;;){c=4;t:{n:{r:switch(o[0|(t=(u=i)+n|0)]-4|0){case 1:break n;case 0:break r;default:break t}c=2&o[e+14|0]?1:3,u=f}a[0|t]=c,f=u}c=4;t:{n:{r:switch(o[0|(t=(u=i+1|0)+n|0)]-4|0){case 1:break n;case 0:break r;default:break t}c=2&o[e+14|0]?1:3,u=f}a[0|t]=c,f=u}if(i=i+2|0,(0|w)==(0|(d=d+2|0)))break}if(m){c=4;t:{n:switch(o[0|(t=n+i|0)]-4|0){case 1:break t;case 0:break n;default:break e}c=2&o[e+14|0]?1:3,i=f}a[0|t]=c,f=i}}return A[s>>2]=f,A[r>>2]=h,I}function Oe(e,t){var n,r,s=0,a=0,i=0,o=0,l=0,u=0,c=0,d=0,h=0;if(!e)return ie(t);if(t>>>0>=4294967232)return A[56798]=48,0;n=t>>>0<11?16:t+11&-8,i=-8&(r=A[4+(o=e-8|0)>>2]);e:if(3&r){l=i+o|0;t:if(i>>>0>=n>>>0){if((a=i-n|0)>>>0<16)break t;A[o+4>>2]=1&r|n|2,A[4+(s=o+n|0)>>2]=3|a,A[l+4>>2]=1|A[l+4>>2],Me(s,a)}else if(A[57158]!=(0|l))if(A[57157]!=(0|l)){if(2&(a=A[l+4>>2]))break e;if((c=i+(-8&a)|0)>>>0<n>>>0)break e;h=c-n|0;n:if(a>>>0<=255){if(i=A[l+8>>2],s=a>>>3|0,(0|(a=A[l+12>>2]))==(0|i)){A[57152]=A[57152]&Xr(-2,s);break n}A[i+12>>2]=a,A[a+8>>2]=i}else{if(d=A[l+24>>2],(0|(u=A[l+12>>2]))==(0|l))if((s=A[(i=l+20|0)>>2])||(s=A[(i=l+16|0)>>2])){for(;a=i,u=s,(s=A[(i=s+20|0)>>2])||(i=u+16|0,s=A[u+16>>2]););A[a>>2]=0}else u=0;else s=A[l+8>>2],A[s+12>>2]=u,A[u+8>>2]=s;if(d){a=A[l+28>>2];r:{if(A[(s=228912+(a<<2)|0)>>2]==(0|l)){if(A[s>>2]=u,u)break r;A[57153]=A[57153]&Xr(-2,a);break n}if(A[(A[d+16>>2]==(0|l)?16:20)+d>>2]=u,!u)break n}A[u+24>>2]=d,(s=A[l+16>>2])&&(A[u+16>>2]=s,A[s+24>>2]=u),(s=A[l+20>>2])&&(A[u+20>>2]=s,A[s+24>>2]=u)}}h>>>0<=15?(A[o+4>>2]=1&r|c|2,A[4+(s=o+c|0)>>2]=1|A[s+4>>2]):(A[o+4>>2]=1&r|n|2,A[4+(a=o+n|0)>>2]=3|h,A[4+(s=o+c|0)>>2]=1|A[s+4>>2],Me(a,h))}else{if((a=i+A[57154]|0)>>>0<n>>>0)break e;(s=a-n|0)>>>0>=16?(A[o+4>>2]=1&r|n|2,A[4+(i=o+n|0)>>2]=1|s,A[(a=a+o|0)>>2]=s,A[a+4>>2]=-2&A[a+4>>2]):(A[o+4>>2]=a|1&r|2,A[4+(s=a+o|0)>>2]=1|A[s+4>>2],s=0,i=0),A[57157]=i,A[57154]=s}else{if((i=i+A[57155]|0)>>>0<=n>>>0)break e;A[o+4>>2]=1&r|n|2,s=i-n|0,A[4+(a=o+n|0)>>2]=1|s,A[57155]=s,A[57158]=a}s=o}else{if(n>>>0<256)break e;if(i>>>0>=n+4>>>0&&(s=o,i-n>>>0<=A[57272]<<1>>>0))break e;s=0}return s?s+8|0:(o=ie(t))?(Je(o,e,t>>>0>(s=(3&(s=A[e-4>>2])?-4:-8)+(-8&s)|0)>>>0?s:t),Ee(e),o):0}function Re(){var e,t,n=0,r=0;return e=Or(12),A[e>>2]=22050,t=Or(432),A[(r=t)+4>>2]=0,A[r+8>>2]=0,A[r>>2]=132304,A[r+32>>2]=0,A[r+12>>2]=0,A[r+16>>2]=0,A[r+20>>2]=0,A[r+24>>2]=0,kt(r+40|0,0,376),A[r+420>>2]=0,A[r+424>>2]=-1,a[r+416|0]=1,n=kt(Or(408),0,408),A[r+28>>2]=n,a[n+8|0]=1,A[e+4>>2]=r,n=Or(1096),A[n+8>>2]=22050,A[n+4>>2]=22050,A[n>>2]=132352,A[n+64>>2]=22050,A[n+56>>2]=0,A[n+60>>2]=0,A[n+32>>2]=0,A[n+36>>2]=0,A[n+24>>2]=22050,A[n+16>>2]=0,A[n+20>>2]=0,A[n+40>>2]=0,A[n+44>>2]=0,a[n+48|0]=0,A[n+128>>2]=0,A[n+132>>2]=0,i[n+96>>1]=0,A[n+72>>2]=22050,A[n+136>>2]=0,A[n+140>>2]=0,i[n+168>>1]=0,A[n+144>>2]=22050,A[n+200>>2]=0,A[n+204>>2]=0,A[n+208>>2]=0,A[n+212>>2]=0,A[n+216>>2]=22050,i[n+240>>1]=0,A[n+280>>2]=0,A[n+284>>2]=0,A[n+272>>2]=0,A[n+276>>2]=0,A[n+288>>2]=22050,i[n+312>>1]=0,A[n+344>>2]=0,A[n+348>>2]=0,A[n+352>>2]=0,A[n+356>>2]=0,A[n+360>>2]=22050,i[n+384>>1]=0,A[n+416>>2]=0,A[n+420>>2]=0,A[n+424>>2]=0,A[n+428>>2]=0,A[n+432>>2]=22050,i[n+456>>1]=0,A[n+488>>2]=0,A[n+492>>2]=0,A[n+496>>2]=0,A[n+500>>2]=0,A[n+504>>2]=22050,i[n+528>>1]=1,A[n+560>>2]=0,A[n+564>>2]=0,A[n+568>>2]=0,A[n+572>>2]=0,i[n+600>>1]=0,A[n+576>>2]=22050,A[n+640>>2]=0,A[n+644>>2]=0,A[n+632>>2]=0,A[n+636>>2]=0,i[n+680>>1]=0,A[n+656>>2]=22050,A[n+648>>2]=22050,A[n+720>>2]=0,A[n+724>>2]=0,A[n+712>>2]=0,A[n+716>>2]=0,i[n+752>>1]=0,A[n+728>>2]=22050,A[n+792>>2]=0,A[n+796>>2]=0,A[n+784>>2]=0,A[n+788>>2]=0,i[n+824>>1]=0,A[n+800>>2]=22050,A[n+864>>2]=0,A[n+868>>2]=0,A[n+856>>2]=0,A[n+860>>2]=0,A[n+872>>2]=22050,i[n+896>>1]=0,A[n+936>>2]=0,A[n+940>>2]=0,A[n+928>>2]=0,A[n+932>>2]=0,i[n+968>>1]=0,A[n+944>>2]=22050,A[n+1008>>2]=0,A[n+1012>>2]=0,A[n+1e3>>2]=0,A[n+1004>>2]=0,i[n+1040>>1]=0,A[n+1016>>2]=22050,A[n+1088>>2]=0,A[(r=n+1080|0)>>2]=0,A[r+4>>2]=0,A[(r=n+1072|0)>>2]=0,A[r+4>>2]=0,A[e+8>>2]=n,Ns[A[A[n>>2]+4>>2]](n,t),e}function Le(e,t,n){var r=0,s=0,a=0,i=0,l=0,u=0,c=0,d=0,h=0,f=0,g=0;e:if(h=A[50759]){if(r=A[50980],s=b(r,80)+222176|0,(0|(u=(0|(s=(0|(s=(A[s+12>>2]+A[s>>2]|0)/(0|e)|0))<(0|(d=((0|b(A[50754],19))/40<<16)/(0|e)|0))?s:d))>=399?399:s))>=0&&(kt(t,0,4+(u<<2)|0),r=A[50980]),(0|r)>=0)for(f=A[50801];;){if(a=b(i,80)+222176|0,A[a+4>>2]&&(l=A[a>>2])){if(g=l+A[a+12>>2]|0,r=1+((l-A[a+8>>2]|0)/(0|e)|0)|0,(0|l)>(0|(r=b(s=(0|r)<=1?1:r,e))))for(;A[(c=(s<<2)+t|0)>>2]=A[c>>2]+b(A[a+4>>2],o[((l-r|0)/(A[a+8>>2]>>8)|0)+f|0]),s=s+1|0,(0|l)>(0|(r=e+r|0)););if(!((0|r)>=(0|g)))for(;A[(c=(s<<2)+t|0)>>2]=A[c>>2]+b(A[a+4>>2],o[((r-l|0)/(A[a+12>>2]>>8)|0)+f|0]),s=s+1|0,(0|g)>(0|(r=e+r|0)););}if(!((0|(i=i+1|0))<=A[50980]))break}if(s=1,!((0|(a=65536e3/(0|e)|0))<=0||(0|(r=b(A[55565],10)))<=0))for(a=(0|r)/(0|a)|0;A[(l=(s<<2)+t|0)>>2]=A[l>>2]+r,s=s+1|0,(0|(r=r-a|0))>0;);if((0|i)<=8)for(;s=203216+(r=i<<2)|0,a=b(i,80)+222176|0,l=A[a+4>>2]>>14,A[s>>2]=(0|b(b(l,l),5))/2,n?r=A[r+203264>>2]:(l=r+203264|0,r=A[a>>2]/(0|e)|0,A[l>>2]=r),(0|r)>=(0|d)&&(A[s>>2]=0),9!=(0|(i=i+1|0)););if(s=0,(0|u)>=0)for(r=0;a=A[(i=(r<<2)+t|0)>>2]>>15,a=b(a,a)>>8,A[i>>2]=a,(0|s)<=524287999&&(A[i>>2]=b(a,o[344+((s>>19)+h|0)|0])>>13),s=e+s|0,i=(0|r)!=(0|u),r=r+1|0,i;);if(A[t+4>>2]=(0|b(A[t+4>>2],o[203300]?6:10))/8,1&n)for(e=A[50826],r=1;;){if(A[203312+(n=r<<2)>>2]=A[t+n>>2]-A[e+n>>2]>>3,30==(0|(n=r+1|0)))break e;A[203312+(n<<=2)>>2]=A[t+n>>2]-A[e+n>>2]>>3,r=r+2|0}}else u=1;return u}function We(e,t,n,r){var s,l=0,u=0;U=s=U-176|0,a[0|e]=0,i[s+80>>1]=24320,A[s+104>>2]=0,A[s+108>>2]=0,a[82+(Qn(n,l=s+80|2)+s|0)|0]=0;e:{t:{if(!r){if(r=s+80|1,A[s+12>>2]=r,He(t,s+12|0,s+16|0,s+104|0,0,0)||(A[s+12>>2]=l,He(t,s+12|0,s+16|0,s+104|0,0,0)||(a[s+81|0]=32,be(t,l,s+16|0,60,0,0,0))),(n=o[s+16|0])&&21!=(0|n))break t;n:{if(25966!=A[t+212>>2]){if(Dn(85719,188772,189296),a[s+81|0]=95,A[s+12>>2]=r,He(A[47193],s+12|0,s+16|0,s+104|0,0,0)||(A[s+12>>2]=l,He(A[47193],s+12|0,s+16|0,s+104|0,0,0)),o[s+16|0])break n;Zr(A[A[32972]+60>>2]),n=o[s+16|0]}if(255&n)break t;t=o[87124]|o[87125]<<8|o[87126]<<16|o[87127]<<24,n=o[87120]|o[87121]<<8|o[87122]<<16|o[87123]<<24,a[0|e]=n,a[e+1|0]=n>>>8,a[e+2|0]=n>>>16,a[e+3|0]=n>>>24,a[e+4|0]=t,a[e+5|0]=t>>>8,a[e+6|0]=t>>>16,a[e+7|0]=t>>>24,a[e+16|0]=o[87136],t=o[87132]|o[87133]<<8|o[87134]<<16|o[87135]<<24,n=o[87128]|o[87129]<<8|o[87130]<<16|o[87131]<<24,a[e+8|0]=n,a[e+9|0]=n>>>8,a[e+10|0]=n>>>16,a[e+11|0]=n>>>24,a[e+12|0]=t,a[e+13|0]=t>>>8,a[e+14|0]=t>>>16,a[e+15|0]=t>>>24;break e}r=s+16|0,l=s+104|0,U=n=U-112|0,(u=A[47193])?(Ae(u,r,l,-1,0),St(l=r,r=n+48|0),t=A[t+212>>2],a[n+43|0]=t>>>24,a[0|(u=(l=n+43|0)+(t>>>0>16777215)|0)]=t>>>16,a[0|(u=u+!!(16711680&t)|0)]=t>>>8,a[0|(u=u+!!(65280&t)|0)]=t,a[u+!!(255&t)|0]=0,A[n+16>>2]=85719,A[n+24>>2]=l,A[n+20>>2]=r,En(e,85662,n+16|0)):(Ae(t,r,l,-1,0),St(r,t=n+48|0),A[n>>2]=t,En(e,85451,n)),U=n+112|0,Zr(A[A[32972]+60>>2]);break e}if(A[s+12>>2]=l,He(t,s+12|0,s+16|0,s+104|0,0,0),!o[s+16|0])break e}Ae(n=t,t=s+16|0,s+104|0,-1,0),St(n=t,t=s+112|0),A[s>>2]=t,En(e,85451,s)}return U=s+176|0,e}function _e(e,t){var n,r=0,s=0,i=0,o=0,l=0,u=0,c=0,d=0,h=0,f=0,g=0,p=0,m=0,b=0,C=0,I=0,w=0,k=0;if(U=n=U-112|0,A[n+72>>2]=-1,A[(r=n- -64|0)>>2]=-1,A[r+4>>2]=-1,A[n+56>>2]=-1,A[n+60>>2]=-1,A[n+48>>2]=-1,A[n+52>>2]=-1,A[n+40>>2]=-1,A[n+44>>2]=-1,A[n+32>>2]=-1,A[n+36>>2]=-1,A[n+24>>2]=-1,A[n+28>>2]=-1,A[n+16>>2]=-1,A[n+20>>2]=-1,(0|t)>0){for(i=A[n+72>>2],o=A[n+68>>2],l=A[n+64>>2],u=A[n+60>>2],c=A[n+56>>2],d=A[n+52>>2],h=A[n+48>>2],f=A[n+44>>2],g=A[n+40>>2],p=A[n+36>>2],m=A[n+32>>2],b=A[n+28>>2],C=A[n+24>>2],I=A[n+20>>2],w=A[n+16>>2];s=i,i=(0|(i=A[60+(r=134912+(k<<6)|0)>>2]))<0?s:i,s=o,o=(0|(o=A[r+56>>2]))<0?s:o,s=l,l=(0|(l=A[r+52>>2]))<0?s:l,s=u,u=(0|(u=A[r+48>>2]))<0?s:u,s=c,c=(0|(c=A[r+44>>2]))<0?s:c,s=d,d=(0|(d=A[r+40>>2]))<0?s:d,s=h,h=(0|(h=A[r+36>>2]))<0?s:h,s=f,f=(0|(f=A[r+32>>2]))<0?s:f,s=g,g=(0|(g=A[r+28>>2]))<0?s:g,s=p,p=(0|(p=A[r+24>>2]))<0?s:p,s=m,m=(0|(m=A[r+20>>2]))<0?s:m,s=b,b=(0|(b=A[r+16>>2]))<0?s:b,s=C,C=(0|(C=A[r+12>>2]))<0?s:C,s=I,I=(0|(I=A[r+8>>2]))<0?s:I,w=(0|(r=A[r+4>>2]))<0?w:r,(0|(k=k+1|0))!=(0|t););A[n+72>>2]=i,A[n+68>>2]=o,A[n+64>>2]=l,A[n+60>>2]=u,A[n+56>>2]=c,A[n+52>>2]=d,A[n+48>>2]=h,A[n+44>>2]=f,A[n+40>>2]=g,A[n+36>>2]=p,A[n+32>>2]=m,A[n+28>>2]=b,A[n+24>>2]=C,A[n+20>>2]=I,A[n+16>>2]=w}for(t=0;;){if((0|(r=A[(i=t<<2)+(n+16|0)>>2]))!=A[(i=i+134848|0)>>2]){a[n+80|0]=0;e:{t:switch(t-1|0){case 4:A[47201]=r-1;break e;case 5:A[47200]=r;break e;case 0:case 1:case 2:case 3:case 11:break t;default:break e}A[n+4>>2]=r,A[n>>2]=1,A[n+8>>2]=a[t+102812|0],En(n+80|0,91942,n)}A[i>>2]=r,r=n+80|0,rn(A[e>>2]+189424|0,r),A[e>>2]=A[e>>2]+Hn(r)}if(15==(0|(t=t+1|0)))break}U=n+112|0}function Ve(e){var t,n,r,s=0,i=0,l=0,u=0;for(s=17,A[e+328>>2]=17,A[e+224>>2]=0,A[e+216>>2]=1105,A[e+220>>2]=1072,A[e+600>>2]=1056,A[e+8180>>2]=105296,l=kt(e+344|0,0,256),a[e+393|0]=1,a[e+365|0]=1,a[e+360|0]=1,a[e+545|0]=1,a[e+529|0]=1,a[e+391|0]=1,a[e+379|0]=1,a[e+374|0]=1,a[e+489|0]=1,a[e+487|0]=1,a[e+398|0]=1,a[e+387|0]=1,a[e+388|0]=2,a[e+389|0]=1,a[e+390|0]=1,a[e+385|0]=2,a[e+383|0]=2,a[e+368|0]=1,a[e+369|0]=2,i=104224;a[0|(s=s+l|0)]=4|o[0|s],s=l+o[i+1|0]|0,a[0|s]=4|o[0|s],s=l+o[i+2|0]|0,a[0|s]=4|o[0|s],s=o[0|(i=i+3|0)],104251!=(0|i););a[e+386|0]=8|o[e+386|0],a[e+382|0]=8|o[e+382|0],a[e+384|0]=8|o[e+384|0],a[e+369|0]=16|o[e+369|0],a[e+370|0]=16|o[e+370|0],a[e+371|0]=16|o[e+371|0],i=o[e+361|0],l=o[e+362|0],s=o[e+363|0],u=o[e+364|0],t=o[e+366|0],n=o[e+367|0],a[e+372|0]=16|o[e+372|0],a[e+373|0]=16|o[e+373|0],a[e+375|0]=16|o[e+375|0],a[e+376|0]=16|o[e+376|0],a[e+377|0]=16|o[e+377|0],a[e+378|0]=16|o[e+378|0],a[e+380|0]=16|o[e+380|0],a[e+381|0]=16|o[e+381|0],a[e+383|0]=16|o[e+383|0],a[e+385|0]=16|o[e+385|0],r=o[e+388|0],a[e+367|0]=48|n,a[e+366|0]=40|t,a[e+364|0]=48|u,a[e+363|0]=48|s,a[e+362|0]=48|l,a[e+361|0]=48|i,a[e+388|0]=80|r,i=o[e+390|0],l=o[e+391|0],s=o[e+393|0],a[e+360|0]=128|o[e+360|0],u=o[e+365|0],a[e+393|0]=192|s,a[e+365|0]=128|u,a[e+368|0]=128|o[e+368|0],a[e+374|0]=128|o[e+374|0],a[e+379|0]=128|o[e+379|0],a[e+387|0]=128|o[e+387|0],s=o[e+389|0],a[e+391|0]=192|l,a[e+390|0]=192|i,a[e+389|0]=128|s,a[e+529|0]=128|o[e+529|0],a[e+545|0]=128|o[e+545|0],a[e+489|0]=128|o[e+489|0],a[e+487|0]=128|o[e+487|0],a[e+398|0]=128|o[e+398|0]}function He(e,t,n,r,s,l){var u,c=0,d=0,h=0,f=0,g=0,p=0;U=u=U-192|0,c=g=A[t>>2];e:{t:{for(;d=1,(0|(h=a[0|c]))>=0||(d=2,h>>>0<4294967264||(d=h>>>0<4294967280?3:4)),!(32!=o[0|(h=d+c|0)]|46!=o[h+1|0]);){if(f-160>>>0<4294967135)break t;Je((p=u+32|0)+f|0,c,d),a[(d=d+f|0)+p|0]=46,c=h+3|0,f=d+1|0}if(f){for(d=0;h=d,d=d+1|0,223&o[c+h|0];);if(!(1+(p=h+f|0)>>>0>160)&&(Je((d=u+32|0)+f|0,c,h),a[d+p|0]=0,ke(e,d,c,n,r,s,l))){A[r>>2]=128|A[r>>2],A[33264]=f,e=1;break e}}}for(c=0;;){if(g=(d=g)+1|0,223&(d=o[0|d]))if(!c|46!=(0|d)|a[31+(c+u|0)|0]-48>>>0>=10){if(a[(u+32|0)+c|0]=d,d=159,159!=(0|(c=c+1|0)))continue}else d=c;else d=c;break}a[(c=u+32|0)+d|0]=0,c=ke(e,c,g,n,r,s,l);t:if(8&o[r+3|0]){if(!mr(n,h=e+268|0)){if(h=A[e+288>>2]+1|0,A[e+288>>2]=h,(0|h)<4)break t;a[0|n]=0;break t}fs(h,n,20),A[e+288>>2]=1}else A[e+288>>2]=0;t:{if(!c){if(c=0,8&o[r+5|0]&&(h=Ht(u+28|0,c=u+32|95==o[u+32|0]),it(e,A[u+28>>2],n),c=c+h|0),!(d>>>0<2|c)){if(a[0|n]=0,!(16&s&&101==o[0|(c=31+(d+u|0)|0)])){if(!(4096&s))break t;if(o[0|(c=(d=(u+32|0)+d|0)-1|0)]!=o[d-2|0])break t}a[0|c]=0,c=ke(e,u+32|0,g,n,r,s,l)}if(!c)break t}if(f=A[r>>2],o[e+172|0]&&(f^=536870912,A[r>>2]=f),e=1,!(536870912&f))break e;2&s&&(i[66448]=8192,A[u+16>>2]=n,En(132898,87470,u+16|0),e=A[t>>2],A[t>>2]=132898,8&o[188788]&&(Je(t=u+32|0,r=e,e=c-e|0),a[e+t|0]=0,A[u+4>>2]=132898,e=A[47195],A[u>>2]=t,ts(e,87652,u)))}a[0|n]=0,e=0}return U=u+192|0,e}function Ue(e,t){var n=0,r=0,s=0;n=31&e;e:{t:{n:{if(96==(0|(e&=96)))e=-1;else{if(64!=(0|e))break n;e=1}if(n>>>0>=15)break e;t=A[203136+(n<<2)>>2]+b(e,t)|0;break t}if(n>>>0>=15)break e}e=A[105616+(r=n<<2)>>2],A[r+203136>>2]=(0|t)>=0?(0|e)>(0|t)?t:e:0}e:{t:{n:{r:{s:switch(n-1|0){case 5:if(!(e=A[50759]))break t;A[54728]=A[50982],t=A[50979],n=A[50978],kt(205184,0,11e3),A[51293]=0,t=(n=(s=(0|(r=A[50789]))>0)?130:(0|n)>=5499?5499:n)?s?r:(0|t)>=100?100:t:0,A[50755]=t,n=(0|b(n,A[50754]))/1e3|0,A[51292]=n,A[54729]=(0|t)>20?n<<1:t?n:0,A[33037]=(0|b(500-t|0,(0|b(o[A[50797]+105596|0],(0|b(A[50787],55))/100|0))/16|0))/500;break r;case 0:break s;case 2:case 12:break e;case 4:break n;default:break t}if(!(e=A[50759]))break t}return t=256,(0|(n=(0|(n=A[50785]))>=101?101:n))>=51&&(t=256+(((b(n,25)-1250&65535)>>>0)/50|0)|0),i[e+164>>1]=(0|b(i[e+236>>1],t))/256,i[e+166>>1]=(0|b(i[e+238>>1],t))/256,i[e+168>>1]=(0|b(i[e+240>>1],t))/256,i[e+170>>1]=(0|b(i[e+242>>1],t))/256,i[e+172>>1]=(0|b(i[e+244>>1],t))/256,i[e+174>>1]=(0|b(i[e+246>>1],t))/256,e=A[50790],i[102e3]=(0|b(i[102036],b(e,-3)+256|0))/256,void(i[101999]=(0|b(i[102035],b(e,-6)+256|0))/256)}A[50759]&&(A[54728]=A[50982],e=A[50979],t=A[50978],kt(205184,0,11e3),A[51293]=0,e=(t=(r=(0|(n=A[50789]))>0)?130:(0|t)>=5499?5499:t)?r?n:(0|e)>=100?100:e:0,A[50755]=e,t=(0|b(t,A[50754]))/1e3|0,A[51292]=t,A[54729]=(0|e)>20?t<<1:e?t:0,A[33037]=(0|b(500-e|0,(0|b(o[A[50797]+105596|0],(0|b(A[50787],55))/100|0))/16|0))/500)}return}A[33037]=(0|b(o[A[50797]+105596|0],(0|b(A[50787],55))/100|0))/16}function je(e,t,n){var r=0,s=0,i=0,l=0,u=0,c=0,d=0,h=0,f=0,g=0;n&&(A[n>>2]=0);e:{t:if(!((0|(r=a[0|e]))<0)){for(;;){if(32==(0|(i=255&r))|i-9>>>0<5){if((0|(r=a[0|(e=e+1|0)]))>=0)continue;break t}break}if(!(255&r))break e}for(;;){if(32==(0|(r=c=255&r))|r-9>>>0<5)break e;if(124!=(0|c)||124==(0|(r=o[0|(i=e+1|0)]))){t:{if((0|(f=A[36115]))>=2){for(r=1,i=-1,d=0;;){n:if(!(!(h=A[144464+(r<<2)>>2])|15==o[h+11|0])){u=A[h>>2];r:{s:{if(c>>>0>=33){if(g=0,l=0,(255&u)==(0|c)&&(l=1,(s=o[e+1|0])>>>0<33|(0|s)!=(u>>>8&255)||(l=2,(s=o[e+2|0])>>>0<33|(0|s)!=(u>>>16&255)||(l=(s=(s=o[e+3|0])>>>0>32&(0|s)==(u>>>24|0))?4:3,g=0-s|0))),(0|i)>=(0|l))break n;if(s=4,!(1&g))break s;break r}if(l=0,(0|i)>=0)break n}if(u>>>((s=l)<<3)&255)break n}d=o[h+10|0],i=s}if((0|f)==(0|(r=r+1|0)))break}if(d)break t}return n&&Ht(n,e),void(a[0|t]=0)}a[0|t]=d,e=((0|i)<=1?1:i)+e|0,t=i=t+1|0;t:if(21==(0|d)){n:if(32==(0|(s=o[0|e]))|s-9>>>0<5)r=i;else if(r=i,s)for(;;){if(a[0|r]=ar(s),r=r+1|0,32==(0|(s=o[0|(e=e+1|0)]))|s-9>>>0<5)break n;if(!s)break}if(a[0|r]=0,!s){if(t=r,mr(i,85593))break t;return void(a[0|i]=0)}a[0|r]=124,t=r+1|0}r=o[0|e]}else e=i;if(!(255&r))break}}a[0|t]=0}function Ye(e,t){var n=0,r=0,s=0,a=0,i=0;e:{t:{n:{r:{s:switch((0|(n=A[e+4>>2]))==A[e+104>>2]?n=pt(e):(A[e+4>>2]=n+1,n=o[0|n]),n-43|0){case 0:case 2:break s;default:break r}if(a=45==(0|n),i=!t,(0|(n=A[e+4>>2]))==A[e+104>>2]?n=pt(e):(A[e+4>>2]=n+1,n=o[0|n]),i|(t=n-58|0)>>>0>4294967285)break n;if(A[e+116>>2]<0)break t;A[e+4>>2]=A[e+4>>2]-1;break t}t=n-58|0}if(!(t>>>0<4294967286)){if((t=n-48|0)>>>0<10){for(;s=(0|(r=(r=b(r,10)+n|0)-48|0))<214748364,(0|(t=A[e+4>>2]))==A[e+104>>2]?n=pt(e):(A[e+4>>2]=t+1,n=o[0|t]),s&(t=n-48|0)>>>0<=9;);s=r>>31}n:if(!(t>>>0>=10))for(;;){if(t=(r=sr(r,s,10,0))+n|0,n=K,n=t>>>0<r>>>0?n+1|0:n,r=t-48|0,s=n-(t>>>0<48)|0,(0|(t=A[e+4>>2]))==A[e+104>>2]?n=pt(e):(A[e+4>>2]=t+1,n=o[0|t]),(t=n-48|0)>>>0>9)break n;if(!(r>>>0<2061584302&(0|s)<=21474836|(0|s)<21474836))break}if(t>>>0<10)for(;(0|(t=A[e+4>>2]))==A[e+104>>2]?t=pt(e):(A[e+4>>2]=t+1,t=o[0|t]),t-48>>>0<10;);(0|(t=A[e+116>>2]))>0|(0|t)>=0&&(A[e+4>>2]=A[e+4>>2]-1),e=r,r=a?0-e|0:e,s=a?0-(!!(0|e)+s|0)|0:s;break e}}if(s=-2147483648,!(A[e+116>>2]<0))return A[e+4>>2]=A[e+4>>2]-1,K=-2147483648,0}return K=s,r}function Ke(e){var t=0,n=0,r=0,s=0;if(A[36432]=110,A[36433]=100,A[36434]=450,A[36430]=5,t=A[203136+(2==(0|e)?32:8)>>2],r=A[32972],(0|(n=A[r+84>>2]))>0&&(t=(0|b(t,n))/100|0),n=(0|t)>=359?359:t,n=(0|(t=(0|t)>=450?450:t))>399?6:(0|t)>379?7:o[((0|n)<=80?80:n)+101856|0],1&e&&(A[32526]=(0|b(n,A[r+72>>2]))/256,A[32527]=(0|b(n,A[r+76>>2]))/256,A[32528]=(0|b(n,A[r+80>>2]))/256,n>>>0>7||(s=n-1|0,A[32528]=s,A[32526]=n,A[32527]=s)),2&e){e=A[r+72>>2];e:{t:{n:{r:{s:{a:{i:{A:{if((0|t)>=351)r=t-350|0,A[36432]=85-(((255&r)>>>0)/3|0)&255,r=60-(r>>>3|0)|0;else{if((0|t)<251)break A;r=t-250|0,A[36432]=110-(r>>>2|0),r=110-(r>>>1|0)|0}if(A[36433]=r,e=(0|b(e,n))/256|0,A[36431]=110+((0|b(e,150))/128|0),t>>>0<=349)break i;if(n=t-350|0,A[36431]=o[n+102224|0],t>>>0<390)break s;if(A[36434]=450+((t+112<<24>>24)/-2<<24>>24),t>>>0<441)break a;A[36434]=860-t,e=12;break t}e=(0|b(e,n))/256|0,A[36431]=(0|t)>=170?110+((0|b(e,150))/128|0)|0:128+((e<<7)/130|0)|0}e=(e<<8)/115|0;break t}if(e=12,t>>>0>430)break t;if(e=13,t>>>0<=400)break r;break t}if(e=(e<<8)/115|0,A[36428]=e,t>>>0<375)break n}e=14;break t}if((0|t)<351)break e;e=o[n+102336|0]}A[36428]=e}A[36429]=(0|e)<=16?16:e}}function Xe(e,t,n){var r,s,a,l;r=.000244140625*+A[50767],m[n>>3]=r,m[n+40>>3]=.015625*+A[e+112>>2],m[n+48>>3]=.015625*+A[e+276>>2],m[n+56>>3]=.00390625*+(0|b(i[e+166>>1],i[t+4>>1]))+ +i[e+220>>1],m[n+64>>3]=.00390625*+(0|b(i[e+168>>1],i[t+6>>1]))+ +i[e+222>>1],m[n+72>>3]=.00390625*+(0|b(i[e+170>>1],i[t+8>>1]))+ +i[e+224>>1],m[n+80>>3]=.00390625*+(0|b(i[e+172>>1],i[t+10>>1]))+ +i[e+226>>1],m[n+88>>3]=.00390625*+(0|b(i[e+174>>1],i[t+12>>1]))+ +i[e+228>>1],s=i[e+230>>1],a=i[e+176>>1],l=i[t+14>>1],A[n+112>>2]=0,A[n+116>>2]=1080623104,A[n+104>>2]=0,A[n+108>>2]=1081032704,m[n+96>>3]=.00390625*+(0|b(a,l))+ +(0|s),o[t+40|0]?(A[n+184>>2]=0,A[n+188>>2]=1072693248,m[n+104>>3]=o[t+40|0]<<1):(A[n+184>>2]=0,A[n+188>>2]=0),m[n+120>>3]=.00390625*+i[e+202>>1]*+(o[t+35|0]<<1),m[n+128>>3]=.00390625*+i[e+204>>1]*+(o[t+36|0]<<1),m[n+136>>3]=.00390625*+i[e+206>>1]*+(o[t+37|0]<<1),t=o[t+38|0],e=i[e+208>>1],A[n+176>>2]=0,A[n+180>>2]=1079574528,A[n+160>>2]=0,A[n+164>>2]=1083129856,A[n+152>>2]=0,A[n+156>>2]=1083129856,A[n+352>>2]=0,A[n+356>>2]=1072693248,A[n+168>>2]=0,A[n+172>>2]=1079574528,m[n+144>>3]=.00390625*+(0|e)*+(t<<1),e=A[50779],m[n+368>>3]=r,m[n+360>>3]=+(0|e)/100*3}function qe(e){var t=0;q(e,jt(e));e:{t:{n:{r:{s:{a:{i:{A:{o:{l:{if((0|(e=-1048576&K))<268435455|(0|e)<=268435455){u:{c:{if((0|e)<33554431|(0|e)<=33554431){if((0|e)<8388607|(0|e)<=8388607){if(t=524328,!0&-2147483648==(0|e))break e;if(0|-2143289344!=(0|e))break t;return 557096}if(!0&8388608==(0|e))break c;if(0|16777216!=(0|e))break t;return 524358}if((0|e)>71303167)break u;if(!0&33554432==(0|e))break n;if(0|67108864!=(0|e))break t}return 266270}if(!0&71303168==(0|e))break l;if(!0&134217728==(0|e))break r;if(0|138412032!=(0|e))break t;return 294942}if((0|e)<542113791|(0|e)<=542113791){if((0|e)<536870911|(0|e)<=536870911){if(!0&268435456==(0|e))break s;if(0|272629760!=(0|e))break t;return 299028}if(!0&536870912==(0|e))break i;if(!0&538968064==(0|e))break a;if(0|541065216!=(0|e))break t;return 569389}if((0|e)<1075838975|(0|e)<=1075838975){if(!0&542113792==(0|e))break l;if(0|1073741824!=(0|e))break t;return 532520}if(!0&1075838976==(0|e))break A;if(!0&1077936128==(0|e))break o;if(0|1078984704!=(0|e))break t}return 299038}return 565288}return 1581096}return 536621}return 1585197}return 266260}return 262174}return 2396190}t=16384}return t}function Ze(e,t,n,r,s,a){var i,l,u=0,c=0,d=0,h=0;if(l=8388607&e,c=A[34456],u=o[0|(e=l+c|0)]|o[e+1|0]<<8){i=!(d=o[e+2|0]),e=A[36434]<<i,(0|n)<=0?n=u:(n=(0|b(A[50754],n))/1e3<<i,e=(0|e)<(0|(h=(0|b(n,e))/(0|u)|0))?h:e),s=(0|s)>0?(0|b(n,s))/256|0:n,n=(0|b(s,A[36431]))/256|0,n=(0|e)<(0|(n=(4&r)>>>2|0&&(0|n)>(0|s)?s:n))?n:e,d||(u=u>>>1|0,n=(0|n)/2|0);e:if(!((0|a)<0)){if(r=l+4|0,256&t)e=A[50758],A[36439]=e,A[(t=216192+(e<<4)|0)>>2]=7,A[t+8>>2]=r+c,A[t+4>>2]=u<<16|n,a=d|a<<8;else{if(e=A[50758],A[36439]=e,A[(e=216192+(e<<4)|0)>>2]=6,a=d|a<<8,A[e+12>>2]=a,A[e+8>>2]=r+c,c=e,e=b(t=u>>>2|0,3),s=(0|n)>(0|u),A[c+4>>2]=s?e:n,c=A[50758]+1|0,A[50758]=(0|c)<=169?c:0,(0|e)<(0|(n=s?n-e|0:0)))for(s=t<<1,d=r+(d?t:s)|0;t=A[50758],A[36439]=t,A[(t=216192+(t<<4)|0)>>2]=6,A[t+4>>2]=s,A[t+12>>2]=a,A[t+8>>2]=d+A[34456],t=A[50758]+1|0,A[50758]=(0|t)<=169?t:0,(0|e)<(0|(n=n-s|0)););if((0|n)<=0)break e;e=A[50758],A[36439]=e,A[(t=216192+(e<<4)|0)>>2]=6,A[t+4>>2]=n,A[t+8>>2]=A[34456]+(r+(u-n<<i)|0)}A[12+(216192+(e<<4)|0)>>2]=a,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0}}}function Je(e,t,n){var r,s=0,i=0;if(n>>>0>=512)return G(0|e,0|t,0|n),e;r=e+n|0;e:if(3&(e^t))if(r>>>0<4)n=e;else if((s=r-4|0)>>>0<e>>>0)n=e;else for(n=e;a[0|n]=o[0|t],a[n+1|0]=o[t+1|0],a[n+2|0]=o[t+2|0],a[n+3|0]=o[t+3|0],t=t+4|0,s>>>0>=(n=n+4|0)>>>0;);else{t:if(3&e)if(n)for(n=e;;){if(a[0|n]=o[0|t],t=t+1|0,!(3&(n=n+1|0)))break t;if(!(n>>>0<r>>>0))break}else n=e;else n=e;if(!((s=-4&r)>>>0<64||(i=s+-64|0)>>>0<n>>>0))for(;A[n>>2]=A[t>>2],A[n+4>>2]=A[t+4>>2],A[n+8>>2]=A[t+8>>2],A[n+12>>2]=A[t+12>>2],A[n+16>>2]=A[t+16>>2],A[n+20>>2]=A[t+20>>2],A[n+24>>2]=A[t+24>>2],A[n+28>>2]=A[t+28>>2],A[n+32>>2]=A[t+32>>2],A[n+36>>2]=A[t+36>>2],A[n+40>>2]=A[t+40>>2],A[n+44>>2]=A[t+44>>2],A[n+48>>2]=A[t+48>>2],A[n+52>>2]=A[t+52>>2],A[n+56>>2]=A[t+56>>2],A[n+60>>2]=A[t+60>>2],t=t- -64|0,i>>>0>=(n=n- -64|0)>>>0;);if(n>>>0>=s>>>0)break e;for(;A[n>>2]=A[t>>2],t=t+4|0,s>>>0>(n=n+4|0)>>>0;);}if(n>>>0<r>>>0)for(;a[0|n]=o[0|t],t=t+1|0,(0|r)!=(0|(n=n+1|0)););return e}function $e(e){var t=0,n=0,r=0,s=0,a=0,i=0,o=0,h=0;d(+e),t=0|l(1),l(0);e:{if((r=(t=t>>>20&2047)-969|0)>>>0<63)h=t;else{if((0|r)<0)return e+1;if(!(t>>>0<1033)){if(d(+e),r=0|l(1),n=0,!(0|l(0))&-1048576==(0|r))break e;return t>>>0>=2047?e+1:(0|r)<0?(m[8+(t=U-16|0)>>3]=12882297539194267e-247,12882297539194267e-247*m[t+8>>3]):(m[8+(t=U-16|0)>>3]=3105036184601418e216,3105036184601418e216*m[t+8>>3])}}if(n=m[14409],a=(n=(e=(n=(s=m[14408]*e+n)-n)*m[14411]+(n*m[14410]+e))*e)*n*(e*m[14415]+m[14414]),n*=e*m[14413]+m[14412],d(+s),l(1),o=0|l(0),e=a+(n+(m[115376+(r=o<<4&2032)>>3]+e)),i=A[(r=r+115384|0)>>2],t=(o<<13)+(t=A[r+4>>2])|0,t=(r=(r=i)+(i=0)|0)>>>0<i>>>0?t+1|0:t,!h)return-2147483648&o?(u(0,0|r),u(1,t+1071644672|0),(e=(s=(n=+c())*e)+n)<1&&(A[8+(t=U-16|0)>>2]=0,A[t+12>>2]=1048576,m[t+8>>3]=22250738585072014e-324*m[t+8>>3],e=0==(e=(a=e+1)+(s+(n-e)+(e+(1-a)))+-1)?0:e),e*=22250738585072014e-324):(u(0,0|r),u(1,t-1058013184|0),e=5486124068793689e288*((n=+c())*e+n)),e;u(0,0|r),u(1,0|t),n=(n=+c())*e+n}return n}function et(e,t){var n,r=0,s=0,i=0,l=0;U=n=U-16|0;e:{if(us(84270,a[0|t])){if(s=2,us(t,43)||(s=114!=o[0|t]),s=us(t,120)?128|s:s,i=s=us(t,101)?524288|s:s,l=64|s,i=114==(0|(s=o[0|t]))?i:l,i=119==(0|s)?512|i:i,A[n>>2]=438,A[n+4>>2]=0,(e=0|M(-100,0|e,32768|(97==(0|s)?1024|i:i),0|n))>>>0>=4294963201&&(A[56798]=0-e,e=-1),(0|e)<0)break e;U=s=U-32|0;t:{n:{if(us(84270,a[0|t])){if(r=ie(1176))break n}else A[56798]=28;t=0;break t}kt(r,0,144),us(t,43)||(A[r>>2]=114==o[0|t]?8:4),97==o[0|t]?(1024&(t=0|B(0|e,3,0))||(t|=1024,A[s+16>>2]=t,A[s+20>>2]=t>>31,B(0|e,4,s+16|0)),t=128|A[r>>2],A[r>>2]=t):t=A[r>>2],A[r+80>>2]=-1,A[r+48>>2]=1024,A[r+60>>2]=e,A[r+44>>2]=r+152,8&t||(A[s>>2]=s+24,A[s+4>>2]=0,0|S(0|e,21523,0|s)||(A[r+80>>2]=10)),A[r+40>>2]=10,A[r+36>>2]=11,A[r+32>>2]=12,A[r+12>>2]=13,o[227205]||(A[r+76>>2]=-1),A[r+56>>2]=A[56816],(t=A[56816])&&(A[t+52>>2]=r),A[56816]=r,t=r}if(U=s+32|0,r=t)break e;v(0|e)}else A[56798]=28;r=0}return U=n+16|0,r}function tt(e,t,n){var r,s=0,a=0,i=0,o=0,l=0;if(i=e,U=r=U-208|0,A[r+8>>2]=1,A[r+12>>2]=0,o=t<<2){for(A[r+16>>2]=4,A[r+20>>2]=4,t=4,s=4,a=2;e=t,t=(s+4|0)+t|0,A[(r+16|0)+(a<<2)>>2]=t,a=a+1|0,s=e,t>>>0<o>>>0;);if((e=(i+o|0)-4|0)>>>0<=i>>>0)a=0,t=1,e=0;else{for(a=1,t=1;3&~a?(p[(r+16|0)+((s=t-1|0)<<2)>>2]>=e-i>>>0?Pt(i,n,r+8|0,t,0,r+16|0):vn(i,n,t,r+16|0),1!=(0|t)?(Qr(r+8|0,s),t=1):(Qr(r+8|0,1),t=0)):(vn(i,n,t,r+16|0),zr(r+8|0,2),t=t+2|0),a=1|(s=A[r+8>>2]),A[r+8>>2]=a,e>>>0>(i=i+4|0)>>>0;);a=s>>>0>1,e=0!=A[r+12>>2]}if(Pt(i,n,r+8|0,t,0,r+16|0),a|1!=(0|t)|e)for(;(0|t)<=1?(zr(s=r+8|0,e=vr(s)),a=A[r+8>>2],e=e+t|0):(Qr(s=r+8|0,2),A[r+8>>2]=7^A[r+8>>2],zr(s,1),Pt((l=i-4|0)-A[(o=r+16|0)+((e=t-2|0)<<2)>>2]|0,n,s,t-1|0,1,o),Qr(s,1),a=1|A[r+8>>2],A[r+8>>2]=a,Pt(l,n,s,e,1,o)),t=e,i=i-4|0,A[r+12>>2]|1!=(0|t)|1!=(0|a););}U=r+208|0}function nt(e,t,n,r){var s,a=0,i=0,o=0;U=s=U-32|0,o=a=2147483647&r,i=a-1006698496|0;e:if(0|(a=a-1140785152|0)>>>0>i>>>0){if(a=n<<4|t>>>28,n=r<<4|n>>>28,134217728==(0|(t&=268435455))&!!(0|e)|t>>>0>134217728){i=n+1073741824|0,i=(a=a+1|0)?i:i+1|0;break e}if(i=n+1073741824|0,e|134217728!=(0|t))break e;i=(e=1&a)>>>0>(a=e+a|0)>>>0?i+1|0:i}else(!n&2147418112==(0|o)?!(e|t):o>>>0<2147418112)?(a=0,i=2146435072,o>>>0>1140785151||(i=0,(o=o>>>16|0)>>>0<15249||(Ut(s+16|0,e,t,n,a=65535&r|65536,o-15233|0),Lt(s,e,t,n,a,15361-o|0),a=(t=A[s+8>>2])<<4,t=A[s+12>>2]<<4|t>>>28,n=A[s>>2],o=i=A[s+4>>2],a|=i>>>28,i=t,134217728==(0|(e=268435455&o))&!!(0|(t=n|!!(A[s+16>>2]|A[s+24>>2]|A[s+20>>2]|A[s+28>>2])))|e>>>0>134217728?i=(a=a+1|0)?i:i+1|0:t|134217728!=(0|e)||(i=(e=a)>>>0>(a=a+(1&a)|0)>>>0?i+1|0:i)))):(a=n<<4|t>>>28,i=524287&(e=r<<4|n>>>28)|2146959360);return U=s+32|0,u(0,0|a),u(1,-2147483648&r|i),+c()}function rt(e){var t,n=0,r=0,s=0,a=0,i=0;if(d(+e),i=0|l(1),s=0|l(0),2047==(0|(a=i>>>20&2047)))return(e*=1)/e;if(!(r=s<<1)&2145386496==(0|(n=i<<1|s>>>31))|n>>>0<2145386496)return!r&2145386496==(0|n)?0*e:e;if(a)n=1048575&i|1048576;else{if(a=0,r=s<<12,(0|(n=i<<12|s>>>20))>0|(0|n)>=0)for(;a=a-1|0,n=n<<1|r>>>31,r<<=1,(0|n)>0|(0|n)>=0;);r=31&(n=1-a|0),(63&n)>>>0>=32?(n=s<<r,s=0):(n=(1<<r)-1&s>>>32-r|i<<r,s<<=r)}if(r=s,(0|a)>1023){for(;;){if(!((0|(s=n+-1048576|0))<0||(n=s)|r))return 0*e;if(n=n<<1|r>>>31,r<<=1,!((0|(a=a-1|0))>1023))break}a=1023}if(!((0|(s=n+-1048576|0))<0||(n=s)|r))return 0*e;if(1048575==(0|n)|n>>>0<1048575)for(;a=a-1|0,s=n>>>0<524288,n=n<<1|r>>>31,r<<=1,s;);return t=-2147483648&i,(0|a)>0?n=n+-1048576|a<<20:(s=1-a|0,i=n,a=r,r=31&s,(63&s)>>>0>=32?(n=0,r=i>>>r|0):(n=i>>>r|0,r=((1<<r)-1&i)<<32-r|a>>>r)),u(0,0|r),u(1,n|t),+c()}function st(e,t,n,r,s){var i,l=0,u=0;U=i=U-160|0;e:{t:{n:{r:switch((l=o[t+10|0])-15|0){case 6:break n;case 0:break r;default:break t}a[0|e]=0;break e}A[i>>2]=b(o[n+7|0],44)+137856,En(e,86002,i),e=Hn(e)+e|0;break e}if(r){if(a[i+140|0]=0,n?le(0,0,n,i+8|0,0):Jn(l,i+8|0),n=i+140|0,l=o[i+140|0]){if(32==(0|l)){a[0|e]=0;break e}224&(l=l<<24>>24)||(s&&(A[s>>2]=l),n=i+141|0)}if(!((0|(s=Hn(n)))<=0)){e=rn(e,n)+s|0,a[0|e]=0;break e}}s=0;t:if(!(!(n=255&(l=A[t>>2]))|47==(0|n))){if(r){if(95==(0|(u=255&l)))break t;n:{r:{if(35==(0|u)){if(u=3,2!=o[t+11|0])break r;break t}if((u=n-32|0)>>>0>95)break n}n=g[93952+(u<<1)>>1]}s=Qn(n,e)}else a[0|e]=l,s=1;for(;;){if(!(n=255&(l>>=8))|47==(0|n))break t;if(r){if(35==(0|n)&2==o[t+11|0])break t;if(n-48>>>0<10)continue;(u=n-32|0)>>>0<=95&&(n=g[93952+(u<<1)>>1]),s=Qn(n,e+s|0)+s|0}else a[e+s|0]=l,s=s+1|0}}a[0|(e=e+s|0)]=0}return U=i+160|0,e}function at(e){var t,n=0;t=e,n=131280;e:{t:{if(!((0|e)<=1023||(n=131300,e>>>0<1328||(n=131320,e>>>0<1424||(n=131340,e>>>0<1536||(n=131360,e>>>0<1792||(n=131380,e>>>0<1872||(n=131400,e>>>0<2432||(n=131420,e>>>0<2560||(n=131440,e>>>0<2688||(n=131460,e>>>0<2816||(n=131480,e>>>0<2944||(n=131500,e>>>0<3072||(n=131520,e>>>0<3200||(n=131540,e>>>0<3328||(n=131560,e>>>0<3456||(n=131580,e>>>0<3584||(n=131600,e>>>0<3712||(n=131620,e>>>0<3840||(n=131640,e>>>0<4096||(n=131660,e>>>0<4256||(n=131680,e>>>0<4352||(n=131700,e>>>0<4608||(n=131720,e>>>0<5024||(n=131740,e>>>0<10496||(n=131760,e>>>0<12544||(n=131780,e>>>0<40960))))))))))))))))))))))))))){if(e>>>0>=55296)break t;n=131800}if((0|t)>=g[(e=n)+8>>1])break e}e=0}return e}function it(e,t,n){var r,s=0,o=0,l=0,u=0;U=r=U-208|0,a[r+80|0]=0;e:{if((s=t-224|0)>>>0<=158)t=101072+(s<<1)|0;else{if((t=t-592|0)>>>0>88)break e;t=101392+(t<<1)|0}if(t=g[t>>1]){if(l=t<<16>>16,u=(s=63&t)>>>0>37?s+59|0:i[101584+(s<<1)>>1],s=t>>>6|0,(0|l)<0)s=59+(63&s)|0,t=t>>>12&7;else{if(!(o=31&s))break e;s=0,t=t>>>11&15}(o=Mn(e,A[129920+(o<<3)>>2],r+112|0))&&nr(e,u,r+176|0)&&(t&&4096&Mn(e,A[129920+(t<<3)>>2],r+80|0)&&(n=Hn(t=rn(n,r+80|0)),a[r+80|0]=0,n=t+n|0),s?(nr(t=e,s,e=r+144|0),A[r+68>>2]=r+80,A[r- -64>>2]=e,A[r+60>>2]=6,A[r+52>>2]=23,A[r+56>>2]=r+176,A[r+48>>2]=r+112,En(n,84101,r+48|0)):(0|l)<0?rn(n,r+176|0):1&A[e+144>>2]|4096&o?(A[r+36>>2]=23,A[r+40>>2]=6,A[r+44>>2]=r+176,A[r+32>>2]=r+112,En(n,84430,r+32|0)):(A[r+16>>2]=23,A[r+8>>2]=23,A[r>>2]=4,A[r+12>>2]=r+112,A[r+4>>2]=r+176,En(n,84802,r)))}}U=r+208|0}function At(){Mr(),A[55928]=0,A[55926]=0,A[55927]=0,A[55924]=0,A[56244]=0,A[56245]=0,A[56246]=0,A[56247]=0,A[56260]=0,A[56261]=0,A[56262]=0,A[56263]=0,A[56276]=0,A[56277]=0,A[56278]=0,A[56279]=0,A[55974]=0,A[55975]=0,A[55972]=0,A[55973]=0,A[55988]=0,A[55989]=0,A[55990]=0,A[55991]=0,A[56004]=0,A[56005]=0,A[56006]=0,A[56007]=0,A[56020]=0,A[56021]=0,A[56022]=0,A[56023]=0,A[56036]=0,A[56037]=0,A[56038]=0,A[56039]=0,A[56052]=0,A[56053]=0,A[56054]=0,A[56055]=0,A[56068]=0,A[56069]=0,A[56070]=0,A[56071]=0,A[56086]=0,A[56087]=0,A[56084]=0,A[56085]=0,A[56102]=0,A[56103]=0,A[56100]=0,A[56101]=0,A[56118]=0,A[56119]=0,A[56116]=0,A[56117]=0,A[56134]=0,A[56135]=0,A[56132]=0,A[56133]=0,A[56150]=0,A[56151]=0,A[56148]=0,A[56149]=0,A[56166]=0,A[56167]=0,A[56164]=0,A[56165]=0,A[56182]=0,A[56183]=0,A[56180]=0,A[56181]=0,A[56198]=0,A[56199]=0,A[56196]=0,A[56197]=0,A[56214]=0,A[56215]=0,A[56212]=0,A[56213]=0,A[56230]=0,A[56231]=0,A[56228]=0,A[56229]=0}function ot(e,t){var n=0,r=0,s=0,a=0,i=0,o=0,l=0,u=0,c=0,d=0;e:{if((0|(a=A[e+4>>2]))==A[e>>2])if((i=A[e+8>>2])>>>0<(n=A[e+12>>2])>>>0)n=(s=(1+(n-i>>2)|0)/2<<2)+i|0,(0|a)!=(0|i)&&(mt(n=n-(r=i-a|0)|0,a,r),a=A[e+8>>2]),A[e+4>>2]=n,A[e+8>>2]=s+a;else{if((r=(0|n)==(0|a)?1:n-a>>1)>>>0>=1073741824)break e;if(c=(l=Or(n=r<<2))+n|0,o=n=(r+3&-4)+l|0,(0|a)!=(0|i)){if(d=-4&(i=i-a|0),s=n,r=a,i=1+((u=i-4|0)>>>2|0)&7)for(o=0;A[s>>2]=A[r>>2],r=r+4|0,s=s+4|0,(0|i)!=(0|(o=o+1|0)););if(o=n+d|0,!(u>>>0<28))for(;A[s>>2]=A[r>>2],A[s+4>>2]=A[r+4>>2],A[s+8>>2]=A[r+8>>2],A[s+12>>2]=A[r+12>>2],A[s+16>>2]=A[r+16>>2],A[s+20>>2]=A[r+20>>2],A[s+24>>2]=A[r+24>>2],A[s+28>>2]=A[r+28>>2],r=r+32|0,(0|o)!=(0|(s=s+32|0)););}A[e+12>>2]=c,A[e+8>>2]=o,A[e+4>>2]=n,A[e>>2]=l,a&&(Ee(a),n=A[e+4>>2])}else n=a;return A[n-4>>2]=A[t>>2],void(A[e+4>>2]=A[e+4>>2]-4)}Vr(),h()}function lt(e,t,n){var r=0,s=0,a=0,i=0,A=0,o=0,l=0,u=0,c=0;e:{t:{n:{r:{s:{a:{i:{A:{o:{if(t){if(!n)break o;break A}return j=(t=e)-b(e=(e>>>0)/(n>>>0)|0,n)|0,Y=0,K=0,e}if(!e)break i;break a}if(!((r=n-1|0)&n))break s;a=0-(i=(w(n)+33|0)-w(t)|0)|0;break n}return j=0,Y=t-b(e=(t>>>0)/0|0,0)|0,K=0,e}if((r=32-w(t)|0)>>>0<31)break r;break t}if(j=e&r,Y=0,1==(0|n))break e;return n=31&(r=ds(n)),(63&r)>>>0>=32?e=t>>>n|0:(s=t>>>n|0,e=((1<<n)-1&t)<<32-n|e>>>n),K=s,e}i=r+1|0,a=63-r|0}if(r=31&(s=63&i),s>>>0>=32?(s=0,A=t>>>r|0):(s=t>>>r|0,A=((1<<r)-1&t)<<32-r|e>>>r),r=31&(a&=63),a>>>0>=32?(t=e<<r,e=0):(t=(1<<r)-1&e>>>32-r|t<<r,e<<=r),i)for(u=-1==(0|(r=n-1|0))?-1:0;o=s<<1|A>>>31,A=(s=A<<1|t>>>31)-(l=n&(a=u-(o+(s>>>0>r>>>0)|0)>>31))|0,s=o-(s>>>0<l>>>0)|0,t=t<<1|e>>>31,e=c|e<<1,c=o=1&a,i=i-1|0;);return j=A,Y=s,K=t<<1|e>>>31,o|e<<1}j=e,Y=t,e=0,t=0}return K=t,e}function ut(e,t){var n=0,r=0,s=0,a=0,i=0,o=0,l=0,u=0,c=0,d=0;e:{if((0|(n=A[e+8>>2]))==A[e+12>>2])if((r=A[e+4>>2])>>>0>(i=A[e>>2])>>>0)s=mt((a=(1+(r-i>>2)|0)/-2<<2)+r|0,r,n=n-r|0)+n|0,A[e+8>>2]=s,A[e+4>>2]=a+A[e+4>>2];else{if((a=(0|n)==(0|i)?1:n-i>>1)>>>0>=1073741824)break e;if(c=(o=Or(s=a<<2))+s|0,s=a=(-4&a)+o|0,(0|n)!=(0|r)){if(d=-4&(n=n-r|0),u=1+((l=n-4|0)>>>2|0)&7)for(s=0,n=a;A[n>>2]=A[r>>2],r=r+4|0,n=n+4|0,(0|u)!=(0|(s=s+1|0)););else n=a;if(s=a+d|0,!(l>>>0<28))for(;A[n>>2]=A[r>>2],A[n+4>>2]=A[r+4>>2],A[n+8>>2]=A[r+8>>2],A[n+12>>2]=A[r+12>>2],A[n+16>>2]=A[r+16>>2],A[n+20>>2]=A[r+20>>2],A[n+24>>2]=A[r+24>>2],A[n+28>>2]=A[r+28>>2],r=r+32|0,(0|s)!=(0|(n=n+32|0)););}A[e+12>>2]=c,A[e+8>>2]=s,A[e+4>>2]=a,A[e>>2]=o,i&&(Ee(i),s=A[e+8>>2])}else s=n;return A[s>>2]=A[t>>2],void(A[e+8>>2]=A[e+8>>2]+4)}Vr(),h()}function ct(e,t){var n,r=0,s=0,i=0,l=0,u=0;s=189088,U=n=U-320|0,A[n+312>>2]=0,i=ze(e,l=rn(n+112|0,189088),n,n+316|0,n+312|0,0),r=A[n+316>>2];e:if((0|t)<=3){if((0|r)<2)break e;if(i=3&(t=r-1|0),e=1,r-2>>>0>=3)for(u=-4&t,t=0;a[0|(r=e+n|0)]>=4&&(a[0|r]=3),a[1+(r=e+n|0)|0]>=4&&(a[r+1|0]=3),a[r+2|0]>=4&&(a[r+2|0]=3),a[r+3|0]>=4&&(a[r+3|0]=3),e=e+4|0,(0|u)!=(0|(t=t+4|0)););if(!i)break e;for(t=0;a[0|(r=e+n|0)]>=4&&(a[0|r]=3),e=e+1|0,(0|i)!=(0|(t=t+1|0)););}else if(e=1,!((0|r)<=1)){for(;;){if((0|i)>a[0|(u=e+n|0)]){if((0|r)!=(0|(e=e+1|0)))continue;break e}break}a[0|u]=t}if(e=o[0|l])for(t=1;r=A[144464+((255&e)<<2)>>2],2!=o[r+11|0]|16&o[r+6|0]||(i=255&(r=a[t+n|0]),(0|r)<2&&i||(a[0|s]=o[i+94151|0],s=s+1|0,e=o[0|l]),t=t+1|0),a[0|s]=e,s=s+1|0,e=o[0|(l=l+1|0)];);a[0|s]=0,U=n+320|0}function dt(e){var t=0,n=0,r=0,s=0,a=0,i=0;n=t=A[(e|=0)>>2],A[e>>2]=t+1;e:{t:{n:{r:{s:{a:{i:switch(((a=o[0|t])>>>4|0)-8|0){case 0:case 1:case 2:case 3:break t;case 7:break s;case 6:break a;case 4:case 5:break i;default:break e}if((r=t+2|0)>>>0>=(s=A[e+4>>2])>>>0)break r;if(A[e>>2]=r,128!=(192&(n=o[n+1|0])))break n;return 63&n|a<<6&1984}if((r=t+3|0)>>>0>=(s=A[e+4>>2])>>>0)break r;if(n=t+2|0,A[e>>2]=n,128!=(192&(t=o[t+1|0]))){r=n;break n}if(A[e>>2]=r,128!=(192&(n=o[0|n])))break n;return 63&n|(63&t|a<<6&960)<<6}if(!((s=A[e+4>>2])>>>0<=(n=t+4|0)>>>0)){if(r=t+2|0,A[e>>2]=r,128!=(192&(s=o[t+1|0])))break n;if(r=t+3|0,A[e>>2]=r,128!=(192&(i=o[t+2|0])))break n;if(A[e>>2]=n,t=o[0|r],r=n,128!=(192&t))break n;return 0|((e=63&t|i<<6&4032|(63&s|a<<6&960)<<12)>>>0>=1114112?65533:e)}}A[e>>2]=s;break t}A[e>>2]=r-1}a=65533}return 0|a}function ht(e,t,n,r){var s,l,u=0,c=0,d=0,h=0,f=0,g=0;if(U=s=U-432|0,!(!r|!(536870912&(l=ne(e,t,n,r))))&&(i[s+48>>1]=8192,r=rn(s+48|2,r),o[0|r])){for(d=s+224|0,u=1,h=200;;){if(Ht(s+44|0,r),t=dr(A[s+44>>2]),c=A[n>>2],t?(A[n>>2]=2|c,Qn(ar(A[s+44>>2]),r)):A[n>>2]=-3&c,g=A[33264],ne(e,r,n,0),1&u?(A[s+16>>2]=189088,c=Cn(d,h,84130,s+16|0)):(A[s+32>>2]=15,A[s+36>>2]=189088,c=Cn(d,h,84434,s+32|0)),u=(t=A[33264])+1|0,A[33264]=u,t>>>0<=2147483646)for(;;)if(t=r,r=r+1|0,32==(0|(f=a[0|t]))|f-9>>>0<5){for(;t=(r=t)+1|0,32==(0|(f=a[0|r]))|f-9>>>0<5;);if(u=u-1|0,A[33264]=u,!((0|u)>0))break}if(d=d+c|0,A[33264]=g,!(o[0|r]&&(u=0,(0|(h=h-c|0))>1)))break}(s+224|0)!=(0|d)&&(A[s>>2]=s+224,Cn(189088,200,84130,s))}return U=s+432|0,l}function ft(e,t,n,r,s,l,u,c){var d,h;d=A[32972],h=A[d+116>>2],i[e+8>>1]=g[e+8>>1]+l,l=32&c?0-l|0:l,i[e+10>>1]=l+g[e+10>>1],i[e+12>>1]=l+g[e+12>>1],r=(0|r)>(0|(l=((l=(0|b(t,h))/256|0)-(t=i[e+6>>1])|0)/2|0))?l:r,i[e+6>>1]=((0|n)<(0|r)?r:n)+t;e:{t:switch(s-1|0){case 0:t=(0|(t=235-(n=i[e+4>>1])|0))<=-100?-100:t,i[e+4>>1]=((0|t)>=-60?-60:t)+n;break e;case 1:t=(0|(t=(0|(t=235-(n=i[e+4>>1])|0))<=-300?-300:t))>=-150?-150:t,i[e+4>>1]=t+n,i[e+2>>1]=t+g[e+2>>1];break e;case 2:break t;default:break e}t=(0|(t=(0|(t=100-(n=i[e+4>>1])|0))<=-400?-400:t))>-300?-400:t,i[e+4>>1]=t+n,i[e+2>>1]=t+g[e+2>>1]}A[d+132>>2]||(a[e+20|0]=(b(o[e+20|0],u)>>>0)/100,a[e+21|0]=(b(o[e+21|0],u)>>>0)/100,a[e+22|0]=(b(o[e+22|0],u)>>>0)/100,a[e+23|0]=(b(o[e+23|0],u)>>>0)/100,a[e+24|0]=(b(o[e+24|0],u)>>>0)/100,a[e+25|0]=(b(o[e+25|0],u)>>>0)/100)}function gt(e){var t,n=0,r=0,s=0,i=0;U=t=U-48|0;e:{if(e){o[0|e]||(e=Gn(84285),o[0|e]&&e||(e=Gn(121696),o[0|e]&&e||(e=Gn(84614),o[0|e]&&e||(e=84891))));t:{for(;;){if(!(!(r=o[e+n|0])|47==(0|r))){if(s=23,23!=(0|(n=n+1|0)))continue;break t}break}s=n}r=84891;t:{n:{if(n=o[0|e],(o[e+s|0]|46==(0|n)||(r=e,67==(0|n)))&&!o[r+1|0]||!mr(r,84891)||!mr(r,85136)){if(n=121652,46==o[r+1|0])break n;e=0;break t}if(n=A[56851])for(;;){if(!mr(r,n+8|0))break n;if(!(n=A[n+32>>2]))break}(e=ie(36))&&(n=A[30414],A[e>>2]=A[30413],A[e+4>>2]=n,Je(n=e+8|0,r,s),a[n+s|0]=0,A[e+32>>2]=A[56851],A[56851]=e),n=e||121652}e=n}if(-1==(0|e))break e;A[56809]=e}else e=A[56809];i=e?e+8|0:84309}return U=t+48|0,i}function pt(e){var t=0,n=0,r=0,s=0,i=0,o=0,l=0,u=0,c=0;u=!!((t=A[e+112>>2])|(r=A[e+116>>2])),s=t,o=t=(i=A[e+4>>2])-(l=A[e+44>>2])|0,n=t+A[e+120>>2]|0,t=A[e+124>>2]+(t>>31)|0;e:{if(!(((0|(t=n>>>0<o>>>0?t+1|0:t))>=(0|r)&n>>>0>=s>>>0|(0|t)>(0|r))&u)){if((0|(u=Gr(e)))>=0)break e;i=A[e+4>>2],l=A[e+44>>2]}return A[e+112>>2]=-1,A[e+116>>2]=-1,A[e+104>>2]=i,r=(o=n)+(n=l-i|0)|0,t=(n>>31)+t|0,A[e+120>>2]=r,A[e+124>>2]=n>>>0>r>>>0?t+1|0:t,-1}return t=(r=n+1|0)?t:t+1|0,i=A[e+4>>2],l=A[e+8>>2],o=s=A[e+116>>2],s|(n=A[e+112>>2])&&(s=n-r|0,(0|(n=o-(t+(n>>>0<r>>>0)|0)|0))>=(0|(o=(c=l-i|0)>>31))&s>>>0>=c>>>0|(0|n)>(0|o)||(l=s+i|0)),A[e+104>>2]=l,r=(s=(n=A[e+44>>2])-i|0)+r|0,t=(s>>31)+t|0,A[e+120>>2]=r,A[e+124>>2]=r>>>0<s>>>0?t+1|0:t,n>>>0>=i>>>0&&(a[i-1|0]=u),u}function mt(e,t,n){var r=0,s=0;e:if((0|e)!=(0|t)){if(t-(s=e+n|0)>>>0<=0-(n<<1)>>>0)return Je(e,t,n);if(r=3&(e^t),e>>>0<t>>>0){if(r)r=e;else{if(3&e)for(r=e;;){if(!n)break e;if(a[0|r]=o[0|t],t=t+1|0,n=n-1|0,!(3&(r=r+1|0)))break}else r=e;if(!(n>>>0<=3))for(;A[r>>2]=A[t>>2],t=t+4|0,r=r+4|0,(n=n-4|0)>>>0>3;);}if(n)for(;a[0|r]=o[0|t],r=r+1|0,t=t+1|0,n=n-1|0;);}else{if(!r){if(3&s)for(;;){if(!n)break e;if(a[0|(r=(n=n-1|0)+e|0)]=o[t+n|0],!(3&r))break}if(!(n>>>0<=3))for(;A[(n=n-4|0)+e>>2]=A[t+n>>2],n>>>0>3;);}if(!n)break e;for(;a[(n=n-1|0)+e|0]=o[t+n|0],n;);}}return e}function bt(e,t,n,r){e:switch(t-9|0){case 0:return t=A[n>>2],A[n>>2]=t+4,void(A[e>>2]=A[t>>2]);case 6:return t=A[n>>2],A[n>>2]=t+4,t=i[t>>1],A[e>>2]=t,void(A[e+4>>2]=t>>31);case 7:return t=A[n>>2],A[n>>2]=t+4,A[e>>2]=g[t>>1],void(A[e+4>>2]=0);case 8:return t=A[n>>2],A[n>>2]=t+4,t=a[0|t],A[e>>2]=t,void(A[e+4>>2]=t>>31);case 9:return t=A[n>>2],A[n>>2]=t+4,A[e>>2]=o[0|t],void(A[e+4>>2]=0);case 16:return t=A[n>>2]+7&-8,A[n>>2]=t+8,void(m[e>>3]=m[t>>3]);case 17:Ns[0|r](e,n);default:return;case 1:case 4:case 14:return t=A[n>>2],A[n>>2]=t+4,t=A[t>>2],A[e>>2]=t,void(A[e+4>>2]=t>>31);case 2:case 5:case 11:case 15:return t=A[n>>2],A[n>>2]=t+4,A[e>>2]=A[t>>2],void(A[e+4>>2]=0);case 3:case 10:case 12:case 13:}t=A[n>>2]+7&-8,A[n>>2]=t+8,n=A[t+4>>2],A[e>>2]=A[t>>2],A[e+4>>2]=n}function Ct(e,t,n,r,s,a){var i;U=i=U-80|0;e:if((0|a)>=16384){if(me(i+32|0,t,n,r,s,0,0,0,2147352576),r=A[i+40>>2],s=A[i+44>>2],t=A[i+32>>2],n=A[i+36>>2],a>>>0<32767){a=a-16383|0;break e}me(i+16|0,t,n,r,s,0,0,0,2147352576),a=((0|a)>=49149?49149:a)-32766|0,r=A[i+24>>2],s=A[i+28>>2],t=A[i+16>>2],n=A[i+20>>2]}else(0|a)>-16383||(me(i- -64|0,t,n,r,s,0,0,0,7471104),r=A[i+72>>2],s=A[i+76>>2],t=A[i+64>>2],n=A[i+68>>2],a>>>0>4294934644?a=a+16269|0:(me(i+48|0,t,n,r,s,0,0,0,7471104),a=((0|a)<=-48920?-48920:a)+32538|0,r=A[i+56>>2],s=A[i+60>>2],t=A[i+48>>2],n=A[i+52>>2]));me(i,t,n,r,s,0,0,0,a+16383<<16),t=A[i+12>>2],A[e+8>>2]=A[i+8>>2],A[e+12>>2]=t,t=A[i+4>>2],A[e>>2]=A[i>>2],A[e+4>>2]=t,U=i+80|0}function It(e,t){var n,r,s=0;U=n=U+-64|0,s=A[e>>2],r=A[s-4>>2],s=A[s-8>>2],A[n+32>>2]=0,A[n+36>>2]=0,A[n+40>>2]=0,A[n+44>>2]=0,A[n+48>>2]=0,A[n+52>>2]=0,a[n+55|0]=0,a[n+56|0]=0,a[n+57|0]=0,a[n+58|0]=0,a[n+59|0]=0,a[n+60|0]=0,a[n+61|0]=0,a[n+62|0]=0,A[n+24>>2]=0,A[n+28>>2]=0,A[n+20>>2]=0,A[n+16>>2]=125084,A[n+12>>2]=e,A[n+8>>2]=t,e=e+s|0,s=0;e:if(Wr(r,t,0))A[n+56>>2]=1,Ns[A[A[r>>2]+20>>2]](r,n+8|0,e,e,1,0),s=1==A[n+32>>2]?e:0;else{Ns[A[A[r>>2]+24>>2]](r,n+8|0,e,1,0);t:switch(A[n+44>>2]){case 0:s=1==A[n+48>>2]&&1==A[n+36>>2]&&1==A[n+40>>2]?A[n+28>>2]:0;break e;case 1:break t;default:break e}1!=A[n+32>>2]&&A[n+48>>2]|1!=A[n+36>>2]|1!=A[n+40>>2]||(s=A[n+24>>2])}return U=n- -64|0,s}function wt(e,t,n,r,s){var l,u,c=0;U=l=U-80|0,i[l+72>>1]=0,A[l+64>>2]=0,A[l+68>>2]=0,a[0|r]=0,c=Qn(t,u=2|(c=l- -64|0))+c|0,a[c+2|0]=32;e:if(-1!=(0|n))t>>>0>=33&&!tr(t)?(a[c+3|0]=32==(0|n)?32:31,a[l+65|0]=95,Mn(e,l- -64|1,l+16|0)||(a[l+65|0]=32,Mn(e,u,l+16|0)||be(e,u,l+16|0,40,0,268435456,0)),o[l+16|0]||it(e,t,l+16|0),t=rn(r,l+16|0),!(n=o[0|t])|21==(0|n)||(A[l+56>>2]=0,A[l+60>>2]=0,Ae(e,t,l+56|0,-1,1&s))):(A[l>>2]=t,En(t=l- -64|1,85485,l),Mn(e,t,r));else{if(Mn(e,u,r))break e;if(a[l+65|0]=95,Mn(e,l- -64|1,l+16|0)|25966==A[e+212>>2])break e;gs(85055),Mn(A[47194],u,l+16|0)&&(a[0|r]=21,a[r+1|0]=0),Zr(A[A[32972]+60>>2])}U=l+80|0}function kt(e,t,n){var r=0,s=0,i=0,o=0;if(n&&(a[0|e]=t,a[(r=e+n|0)-1|0]=t,!(n>>>0<3||(a[e+2|0]=t,a[e+1|0]=t,a[r-3|0]=t,a[r-2|0]=t,n>>>0<7||(a[e+3|0]=t,a[r-4|0]=t,n>>>0<9||(s=(r=0-e&3)+e|0,t=b(255&t,16843009),A[s>>2]=t,A[(n=(r=n-r&-4)+s|0)-4>>2]=t,r>>>0<9||(A[s+8>>2]=t,A[s+4>>2]=t,A[n-8>>2]=t,A[n-12>>2]=t,r>>>0<25||(A[s+24>>2]=t,A[s+20>>2]=t,A[s+16>>2]=t,A[s+12>>2]=t,A[n-16>>2]=t,A[n-20>>2]=t,A[n-24>>2]=t,A[n-28>>2]=t,(n=r-(o=4&s|24)|0)>>>0<32))))))))for(r=sr(t,0,1,1),i=K,t=s+o|0;A[t+24>>2]=r,A[t+28>>2]=i,A[t+16>>2]=r,A[t+20>>2]=i,A[t+8>>2]=r,A[t+12>>2]=i,A[t>>2]=r,A[t+4>>2]=i,t=t+32|0,(n=n-32|0)>>>0>31;);return e}function xt(){var e,t=0,n=0,r=0,s=0,a=0;if(U=e=U-208|0,(0|(r=A[50303]))>0)for(;(s=A[(n=201216+(t<<2)|0)>>2])&&(Ee(s),A[n>>2]=0),(0|r)!=(0|(t=t+1|0)););if(A[50303]=0,A[e+16>>2]=137584,A[e+20>>2]=47,En(t=e+32|0,87827,e+16|0),Pe(t,Hn(t)+1|0,0),A[e+4>>2]=47,A[e>>2]=137584,En(t,87933,e),Pe(t,Hn(t)+1|0,1),t=A[50303],A[201216+(n=t<<2)>>2]=0,n=Oe(r=A[50741],n+4|0)){if(A[50741]=n,tt(201216,t,7),r=A[50741],n=0,t=A[50304])for(s=0;a=A[t+4>>2],o[0|a]&&mr(a+1|0,86589)&&Sn(A[t+8>>2],88032,3)&&(A[(n<<2)+r>>2]=t,n=n+1|0),t=A[201216+((s=s+1|0)<<2)>>2];);A[(n<<2)+r>>2]=0}return U=e+208|0,r}function yt(e,t,n){var r=0,s=0,i=0,l=0;if(i=t-1|0,(0|t)>=2){t=e;e:{for(;;){t:{n:{if((0|(r=A[n+4>>2]))!=(0|(s=A[n+8>>2]))){if((l=Zt(r,10,s-r|0))?s=1+(l-(r=A[n+4>>2])|0)|0:(r=A[n+4>>2],s=A[n+8>>2]-r|0),Je(t,r,r=s>>>0<i>>>0?s:i),s=r+A[n+4>>2]|0,A[n+4>>2]=s,t=t+r|0,l)break t;if(!(i=i-r|0))break t;if((0|s)!=A[n+8>>2]){A[n+4>>2]=s+1,r=o[0|s];break n}}if(!((0|(r=Gr(n)))>=0)){if(r=0,(0|e)==(0|t))break e;if(16&o[0|n])break t;break e}}if(a[0|t]=r,t=t+1|0,10!=(255&r)&&(i=i-1|0))continue}break}e?(a[0|t]=0,r=e):r=0}}else if(t=A[n+72>>2],A[n+72>>2]=t-1|t,!i)return a[0|e]=0,e;return r}function vt(e){var t=0,n=0,r=0,s=0,a=0,i=0,l=0,u=0;if(t=b(e,44),(0|(e=A[t+137896>>2]))>0&&vt(e-1|0),e=A[36115],!((0|(t=A[36+(n=t+137856|0)>>2]))<=0)){if(s=A[n+32>>2],l=1&t,1!=(0|t))for(u=-2&t,n=0;t=o[10+(a=(r=n<<4)+s|0)|0],A[144464+(t<<2)>>2]=a,(0|e)>=(0|t)?t=e:kt(144464+((e=e+1|0)<<2)|0,0,t-e<<2),e=o[10+(r=(16|r)+s|0)|0],A[144464+(e<<2)>>2]=r,(0|e)<=(0|t)?e=t:kt(144464+((t=t+1|0)<<2)|0,0,e-t<<2),n=n+2|0,(0|u)!=(0|(i=i+2|0)););else n=0;l&&(t=o[10+(n=(n<<4)+s|0)|0],A[144464+(t<<2)>>2]=n,(0|e)>=(0|t)||(kt(144464+((e=e+1|0)<<2)|0,0,t-e<<2),e=t))}A[36115]=e}function Et(e,t,n,r,s){var i,l=0,u=0,c=0;U=i=U-16|0;e:if(1&a[e+106|0]&&(l=o[0|n],!(!(1&a[r+2|0])&46!=(0|l)||256&(c=A[r+12>>2])|!(!(2&c)||s)||(Ht(i+12|0,46!=(0|l)?n:n+2|0),!(l=o[0|n])|!o[n+1|0])))){if(!(!(c=A[i+12>>2])|2&o[r+2|0])){if(!fn(c))break e;l=o[0|n]}46==(0|l)&&(a[0|n]=32),u=2,26741!=A[e+212>>2]|s||(n=fn(A[i+12>>2])?ht(e,n+2|0,0,0):0,128&o[e+8233|0]&&(!(!(s=A[i+12>>2])|2&o[r+2|0])&s-48>>>0>=10||(u=0)),u=32768&n?0:u,131072&n&&(u=163840&A[e+8232>>2]?34:45!=o[t-2|0]?u:0))}return U=i+16|0,u}function Bt(e,t,n,r,s){var a,i=0,o=0;if(U=a=U-208|0,A[a+204>>2]=n,kt(n=a+160|0,0,40),A[a+200>>2]=A[a+204>>2],(0|pe(0,t,a+200|0,a+80|0,n,r,s))<0)s=-1;else{A[e+76>>2],i=A[e>>2],A[e+72>>2]<=0&&(A[e>>2]=-33&i);e:{t:{if(A[e+48>>2]){if(A[e+16>>2])break t}else A[e+48>>2]=80,A[e+28>>2]=0,A[e+16>>2]=0,A[e+20>>2]=0,o=A[e+44>>2],A[e+44>>2]=a;if(n=-1,fr(e))break e}n=pe(e,t,a+200|0,a+80|0,a+160|0,r,s)}o&&(Ns[A[e+36>>2]](e,0,0),A[e+48>>2]=0,A[e+44>>2]=o,A[e+28>>2]=0,t=A[e+20>>2],A[e+16>>2]=0,A[e+20>>2]=0,n=t?n:-1),t=e,e=A[e>>2],A[t>>2]=e|32&i,s=32&e?-1:n}return U=a+208|0,s}function Mt(e,t,n,r){var s,i=0,A=0,l=0,u=0,c=0,d=0,h=0;if(U=s=U-208|0,A=o[0|t])for(;a[i+s|0]=A,u=(6==(255&A)&21!=(0|l))+u|0,l=A<<24>>24,A=o[(i=i+1|0)+t|0];);if(a[i+s|0]=0,i=o[0|s])for(d=u-2|0,l=0,h=(0|r)<2,A=0;;){e:{t:if(6!=(255&i)|h|21==(0|A)){if(255==(0|(r=255&i))){if(!c|(0|n)<2)break e;r=n>>>0>2?11:(0|l)%3|0?23:11}A=r,r=l}else{if(i=l+1|0,o[e+169|0]){A=(0|i)>1?5:6,r=i;break t}if(A=6,r=u,(0|i)==(0|u))break t;A=(0|i)%3|0||(0|l)==(0|d)?5:6,r=i}l=r,a[0|t]=A,t=t+1|0}if(!(i=o[(c=c+1|0)+s|0]))break}(0|n)>=2&&(a[0|t]=11,t=t+1|0),a[0|t]=0,U=s+208|0}function Dt(e,t){var n=0;n=0,e&&(n=A[50754],n=(e=(e=(0|b(A[145712+(t?12:((0|e)>199)<<2)>>2],e))/256|0)>>>0>(t=A[36430])>>>0?e:t)>>>0<=89999?(b(e,n)>>>0)/1e3|0:(b(e,(0|n)/25|0)>>>0)/40|0),(0|(e=A[36440]))<=0||(0|(t=A[36424]))<0||(A[4+(t=216192+(t<<4)|0)>>2]||(A[t+4>>2]=e),A[36440]=0),A[36426]=0,A[36439]=-1,A[36455]=A[50758],he(),A[36427]=-1,e=216192+(A[50758]<<4)|0,A[e>>2]=5,A[e+4>>2]=n,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0,A[36426]=0,A[36438]&&(A[36438]=0,e=216192+(A[50758]<<4)|0,A[e>>2]=14,A[e+4>>2]=0,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0)}function Tt(e,t,n,r,s,a,i,A){var o,l=0,u=0,c=0;l=1,o=u=2147483647&r;e:if(!((c=2147418112==(0|u))&!n?e|t:c&!!(0|n)|u>>>0>2147418112)&&!((c=2147418112==(0|(u=2147483647&A)))&!i?s|a:c&!!(0|i)|u>>>0>2147418112)){if(!(e|s|n|i|t|a|u|o))return 0;if((0|(l=r&A))>0|(0|l)>=0){if(l=-1,(0|n)==(0|i)&(0|r)==(0|A)?(0|t)==(0|a)&e>>>0<s>>>0|t>>>0<a>>>0:n>>>0<i>>>0&(0|r)<=(0|A)|(0|r)<(0|A))break e;return!!(e^s|n^i|t^a|r^A)}l=-1,((0|n)==(0|i)&(0|r)==(0|A)?(0|t)==(0|a)&e>>>0>s>>>0|t>>>0>a>>>0:n>>>0>i>>>0&(0|r)>=(0|A)|(0|r)>(0|A))||(l=!!(e^s|n^i|t^a|r^A))}return l}function St(e,t){var n=0,r=0,s=0,i=0;for(n=o[85836]|o[85837]<<8,a[0|t]=n,a[t+1|0]=n>>>8,a[t+2|0]=o[85838];;)if(s=o[0|e],e=n=e+1|0,255!=(0|s)){if(!s)break;if(!(r=A[144464+(s<<2)>>2]))continue;if(1==o[r+11|0]&&(i=o[r+14|0],!(g[r+8>>1]|i>>>0>4))){if(i>>>0<2)continue;a[0|t]=o[i+93943|0],t=t+1|0;continue}if(255&(e=A[r>>2]))for(;a[0|t]=e,t=t+1|0,r=65280&e,e=e>>>8|0,r;);if(e=n,21!=(0|s))continue;if((32|(n=a[0|e]))-97>>>0>=26)continue;for(;a[0|t]=n,t=t+1|0,(32|(n=a[0|(e=e+1|0)]))-97>>>0<26;);}a[0|t]=0}function Nt(e,t){var n,r,s=0,a=0,i=0;U=n=U-112|0,e||(A[50303]||xt(),e=201216),fs(s=n+16|0,t,40),A[n>>2]=47,A[n+4>>2]=s,En(t=n- -64|0,87599,n),r=Hn(t),i=-1;e:{t:{n:{if(a=A[e>>2]){t=0,s=-1;r:{for(;;){if(In(n+16|0,A[a>>2])){if(In(n+16|0,a=A[a+8>>2])?i=In(n- -64|0,a+(Hn(a)-r|0)|0)?i:t:s=t,a=A[((t=t+1|0)<<2)+e>>2])continue;break r}break}if((0|t)>=0)break t;t=(0|s)<0?i:s;break n}if((0|(t=s))>=0)break n}t=i}if(s=0,(0|t)<0)break e}s=A[(t<<2)+e>>2]}return U=n+112|0,s}function Gt(e,t){var n,r,s=0,a=0,i=0,o=0,u=0;U=n=U-16|0,d(+t),r=0|l(1),a=0|l(0),2145386495==(0|(i=(s=2147483647&r)-1048576|0))|i>>>0<2145386495?(o=a<<28,i=s>>>4|0,s=(15&s)<<28|a>>>4,a=i+1006632960|0):2146435072==(0|s)|s>>>0>2146435072?(o=a<<28,s=(15&r)<<28|a>>>4,a=r>>>4|2147418112):s|a?(Ut(n,a,i=s,0,0,(s=s?w(s):w(a)+32|0)+49|0),u=A[n>>2],o=A[n+4>>2],i=15372-s<<16,s=A[n+8>>2],a=i|65536^A[n+12>>2]):(s=0,a=0),A[e>>2]=u,A[e+4>>2]=o,A[e+8>>2]=s,A[e+12>>2]=-2147483648&r|a,U=n+16|0}function Ft(e,t,n){var r=0,s=0;e:{t:{n:{if(!(3&((s=e)^t))){r=!!(0|n);r:if(!(!(3&t)|!n))for(;;){if(r=o[0|t],a[0|s]=r,!r)break e;if(s=s+1|0,r=!!(0|(n=n-1|0)),!(3&(t=t+1|0)))break r;if(!n)break}if(!r)break t;if(!o[0|t])break e;if(!(n>>>0<4))for(;;){if(~(r=A[t>>2])&r-16843009&-2139062144)break n;if(A[s>>2]=r,s=s+4|0,t=t+4|0,!((n=n-4|0)>>>0>3))break}}if(!n)break t}for(;;){if(r=o[0|t],a[0|s]=r,!r)break e;if(s=s+1|0,t=t+1|0,!(n=n-1|0))break}}n=0}return kt(s,0,n),e}function Pt(e,t,n,r,s,a){var i,o=0,l=0,u=0;U=i=U-240|0,o=A[n>>2],A[i+232>>2]=o,n=A[n+4>>2],A[i>>2]=e,A[i+236>>2]=n,u=1;e:{t:{n:{if(n|1!=(0|o)){for(o=e;;){if((0|ls(n=o-A[(l=(r<<2)+a|0)>>2]|0,e,t))<=0){n=o;break n}r:{if(!((0|r)<2|s)){if(s=A[l-8>>2],(0|ls(l=o-4|0,n,t))>=0)break r;if((0|ls(l-s|0,n,t))>=0)break r}if(A[(u<<2)+i>>2]=n,zr(o=i+232|0,s=vr(o)),u=u+1|0,r=r+s|0,s=0,o=n,A[i+236>>2]|1!=A[i+232>>2])continue;break t}break}n=o;break t}n=e}if(s)break e}Bn(i,u),vn(n,t,r,a)}U=i+240|0}function Qt(e,t){var n=0;A[4+(134912+(n=e<<2)|0)>>2]=t,A[n+136192>>2]=t,n=28;e:{t:{n:switch(e-1|0){case 0:A[50792]=t,A[50786]=t,Ke(3);break t;case 1:A[50787]=t,A[33037]=(0|b(o[A[50797]+105596|0],(0|b(A[50787],55))/100|0))/16;break t;case 2:e=(0|t)>=99?99:t,A[50785]=(0|e)>0?e:0;break t;case 3:A[50788]=(0|t)>=99?99:t;break t;case 12:A[47268]=t;break t;case 6:A[47205]=t;break t;case 9:break t;case 8:break n;default:break e}(e=255&t)&&(A[A[47192]+152>>2]=e),A[47196]=t}n=0}return n}function zt(e,t){var n=0,r=0,s=0;e:if(A[e>>2])for(;;){if(tr(A[e-4>>2])){if(r=0,(0|(n=a[0|t]))==A[e>>2])for(;(0|(n=a[(r=r+1|0)+t|0]))==A[(e=e+4|0)>>2];);if(!n){for(;t=e,e=e+4|0,tr(A[t>>2]););for(s=t+((61==A[t>>2])<<2)|0;s=(e=s)+4|0,tr(A[e>>2]););t:switch((t=A[e>>2])-34|0){case 0:case 5:break e}return tr(t)||47==A[e>>2]?102808:e}}if(!A[(e=e+4|0)>>2])break}return s}function Ot(e,t,n,r){var s,i,l=0,u=0,c=0;return!o[e+25|0]|m[e+8>>3]!=n|m[e+16>>3]!=r?(m[e+16>>3]=r,m[e+8>>3]=n,r=(l=$e(-3.141592653589793/(u=+A[e>>2])*r))*-l,m[e+48>>3]=r,l*=sn(-6.283185307179586/u*n),l+=l,m[e+40>>3]=l,u=1-l-r,m[e+32>>3]=u,!(c=o[e+24|0])|0==n||(u=1/u,m[e+32>>3]=u,r*=n=-u,m[e+48>>3]=r,l*=n,m[e+40>>3]=l,c=1)):(c=o[e+24|0],r=m[e+48>>3],l=m[e+40>>3],u=m[e+32>>3]),a[e+25|0]=1,n=m[e+64>>3],s=m[e+56>>3],m[e+64>>3]=s,i=t,t=r*n+(u*t+l*s),m[e+56>>3]=c?i:t,t}function Rt(e,t,n,r,s){var a,i=0,o=0,l=0,u=0;if((a=A[34388])&&!((0|(o=A[34436]))>=(A[34393]-2|0))){if(A[34436]=o+1,i=b(o,36)+a|0,A[i>>2]=e,A[i+4>>2]=A[34437],u=A[34438],A[i+12>>2]=t>>>24,A[i+8>>2]=16777215&t,A[i+24>>2]=u,t=A[50754],s=A[34439]+((s-A[34392]|0)/2|0)|0,A[i+20>>2]=s,t=I(l=1e3*+(0|s)/+(0|t))<2147483648?~~l:-2147483648,A[i+16>>2]=t,e-3>>>0<=1)return void(A[28+(b(o,36)+a|0)>>2]=A[33282]+n);t=28+(b(o,36)+a|0)|0,A[t>>2]=n,7==(0|e)&&(A[t+4>>2]=r)}}function Lt(e,t,n,r,s,a){var i=0,o=0,l=0,u=0;64&a?(t=31&(n=a+-64|0),(63&n)>>>0>=32?(n=0,t=s>>>t|0):(n=s>>>t|0,t=((1<<t)-1&s)<<32-t|r>>>t),r=0,s=0):a&&(l=r,i=31&(o=64-a|0),(63&o)>>>0>=32?(o=l<<i,u=0):(o=(1<<i)-1&l>>>32-i|s<<i,u=l<<i),l=t,t=31&a,(63&a)>>>0>=32?(i=0,t=n>>>t|0):(i=n>>>t|0,t=((1<<t)-1&n)<<32-t|l>>>t),t|=u,n=i|o,i=r,r=31&a,(63&a)>>>0>=32?(o=0,r=s>>>r|0):(o=s>>>r|0,r=((1<<r)-1&s)<<32-r|i>>>r),s=o),A[e>>2]=t,A[e+4>>2]=n,A[e+8>>2]=r,A[e+12>>2]=s}function Wt(e){var t=0,n=0;if(!e){if(A[33174]&&(t=Wt(A[33174])),A[33136]&&(t=Wt(A[33136])|t),e=A[56816])for(;A[e+20>>2]!=A[e+28>>2]&&(t=Wt(e)|t),e=A[e+56>>2];);return t}return A[e+76>>2],A[e+20>>2]==A[e+28>>2]||(Ns[A[e+36>>2]](e,0,0),A[e+20>>2])?((0|(t=A[e+8>>2]))!=(0|(n=A[e+4>>2]))&&(t=n-t|0,Ns[A[e+40>>2]](e,t,t>>31,1)),t=0,A[e+28>>2]=0,A[e+16>>2]=0,A[e+20>>2]=0,A[e+4>>2]=0,A[e+8>>2]=0):t=-1,t}function _t(e,t){var n=0,r=0,s=0,a=0,i=0;if(128==(192&(n=o[0|t])))for(;128==(192&(n=o[0|(t=t-1|0)])););e:if(128&(n=n<<24>>24)){if(r=1,192!=(0|(s=224&n)))if(224!=(240&n)){if(r=3,240!=(248&n)){n&=255,r=0;break e}}else r=2,i=1;n=o[r+93846|0]&n,(a=o[t+1|0])?(n=63&a|n<<6,192!=(0|s)&&((s=o[t+2|0])?(n=63&s|n<<6,i||((t=o[t+3|0])?n=63&t|n<<6:r=2)):r=1)):r=0}return A[e>>2]=n,r+1|0}function Vt(e,t,n,r){var s,a=0,i=0;return U=s=U-224|0,e?(A[s>>2]=137584,A[s+4>>2]=47,A[s+8>>2]=t,En(t=s+16|0,85430,s),(0|(a=Ar(t)))<0?t=ur(r,0-a|0,s+16|0):(t=et(s+16|0,85659))?((i=A[e>>2])&&Ee(i),a?(i=ie(a),A[e>>2]=i,i?(0|wn(i,a,t))==(0|a)?(cr(t),t=0,n&&(A[n>>2]=a)):(n=A[56798],cr(t),Ee(A[e>>2]),A[e>>2]=0,t=ur(r,n,s+16|0)):(cr(t),t=48)):(t=0,A[e>>2]=0)):t=ur(r,A[56798],s+16|0)):t=28,U=s+224|0,t}function Ht(e,t){var n=0,r=0,s=0,a=0,i=0;if(128==(192&(n=o[0|t])))for(;128==(192&(n=o[0|(t=t+1|0)])););e:if(128&(n=n<<24>>24)){if(r=1,192!=(0|(s=224&n)))if(224!=(240&n)){if(r=3,240!=(248&n)){n&=255,r=0;break e}}else r=2,i=1;n=o[r+93846|0]&n,(a=o[t+1|0])?(n=63&a|n<<6,192!=(0|s)&&((s=o[t+2|0])?(n=63&s|n<<6,i||((t=o[t+3|0])?n=63&t|n<<6:r=2)):r=1)):r=0}return A[e>>2]=n,r+1|0}function Ut(e,t,n,r,s,a){var i=0,o=0,l=0;64&a?(r=t,t=31&(s=a+-64|0),(63&s)>>>0>=32?(s=r<<t,r=0):(s=(1<<t)-1&r>>>32-t|n<<t,r<<=t),t=0,n=0):a&&(i=r,r=31&a,(63&a)>>>0>=32?(o=i<<r,l=0):(o=(1<<r)-1&i>>>32-r|s<<r,l=i<<r),i=t,r=31&(s=64-a|0),(63&s)>>>0>=32?(s=0,t=n>>>r|0):(s=n>>>r|0,t=((1<<r)-1&n)<<32-r|i>>>r),r=l|t,s|=o,t=31&a,(63&a)>>>0>=32?(o=i<<t,t=0):(o=(1<<t)-1&i>>>32-t|n<<t,t=i<<t),n=o),A[e>>2]=t,A[e+4>>2]=n,A[e+8>>2]=r,A[e+12>>2]=s}function jt(e){var t=0;return e>>>0<=55295?t=o[A[125552+(e>>>6&67108860)>>2]+(255&e)|0]:(t=4,e>>>0<57344||(e>>>0<63488?t=3:e>>>0<=195327?t=o[A[126416+(e-63488>>>6&67108860)>>2]+(255&e)|0]:(t=2,e>>>0<917504||(e>>>0<=918015?t=o[A[128476+(e-917504>>>6&67108860)>>2]+(255&e)|0]:e>>>0<983040||(e>>>0<1048574?t=3:e>>>0<1048576||(t=3,e>>>0<1114110||(t=e>>>0<1114112?2:5))))))),255&t}function Yt(e,t){var n=0,r=0,s=0,a=0,i=0,o=0,l=0,u=0,c=0;if(!((0|(n=A[33709]))<=0)){if(s=(0|e)>31?e-32|0:e,e=0,n>>>0>=4)for(c=-4&n;o=2|e,l=1|e,r=A[134912+((i=3|e)<<6)>>2]==(0|s)?i:A[134912+(o<<6)>>2]==(0|s)?o:A[134912+(l<<6)>>2]==(0|s)?l:A[134912+(e<<6)>>2]==(0|s)?e:r,e=e+4|0,(0|c)!=(0|(a=a+4|0)););if(a=3&n)for(;r=A[134912+(e<<6)>>2]==(0|s)?e:r,e=e+1|0,(0|a)!=(0|(u=u+1|0)););(0|r)<=0||(A[33709]=r,n=r)}_e(t,n)}function Kt(e){var t,n=0,r=0,s=0;for(U=t=U-96|0,fs(t,e,60),en(t,1);s=ar(a[0|(r=t+n|0)]),a[0|r]=s,n=n+1|0,255&s;);A[t+92>>2]=0,A[t+84>>2]=0,A[t+88>>2]=0,A[t+76>>2]=0,A[t+80>>2]=0,A[t+72>>2]=e;e:{t:{n:{if(se(t,1)){if(o[202976])break n;break t}if(A[50303]||xt(),n=268437247,!(e=Nt(201216,t)))break e;if(!se(A[e+8>>2],0))break e;if(!o[202976])break t}se(202976,2)}Sr(A[32972]),A[t+76>>2]=A[32972]+40,gn(t+72|0,202976),n=0}return U=t+96|0,n}function Xt(e,t){if(!e)return 0;e:{t:{if(e){if(t>>>0<=127)break t;if(A[A[56841]>>2]){if(t>>>0<=2047){a[e+1|0]=63&t|128,a[0|e]=t>>>6|192,e=2;break e}if(!(57344!=(-8192&t)&t>>>0>=55296)){a[e+2|0]=63&t|128,a[0|e]=t>>>12|224,a[e+1|0]=t>>>6&63|128,e=3;break e}if(t-65536>>>0<=1048575){a[e+3|0]=63&t|128,a[0|e]=t>>>18|240,a[e+2|0]=t>>>6&63|128,a[e+1|0]=t>>>12&63|128,e=4;break e}}else if(57216==(-128&t))break t;A[56798]=25,e=-1}else e=1;break e}a[0|e]=t,e=1}return e}function qt(e){var t=0,n=0,r=0,s=0;if(A[e+20>>2]=0,(r=(n=A[e+8>>2])-(t=A[e+4>>2])|0)>>>0>=9)for(;Ee(A[t>>2]),t=A[e+4>>2]+4|0,A[e+4>>2]=t,(r=(n=A[e+8>>2])-t|0)>>>0>8;);s=512;e:switch((r>>>2|0)-1|0){case 1:s=1024;case 0:A[e+16>>2]=s}if((0|t)!=(0|n)){for(;Ee(A[t>>2]),(0|n)!=(0|(t=t+4|0)););(0|(t=A[e+8>>2]))!=(0|(n=A[e+4>>2]))&&(A[e+8>>2]=t+(3+(n-t|0)&-4))}(e=A[e>>2])&&Ee(e)}function Zt(e,t,n){var r=0,s=0;r=!!(0|n);e:{t:{n:if(!(!(3&e)|!n))for(s=255&t;;){if((0|s)==o[0|e])break t;if(r=!!(0|(n=n-1|0)),!(3&(e=e+1|0)))break n;if(!n)break}if(!r)break e;if(!(o[0|e]==(255&t)|n>>>0<4))for(r=b(255&t,16843009);;){if(~(s=r^A[e>>2])&s-16843009&-2139062144)break t;if(e=e+4|0,!((n=n-4|0)>>>0>3))break}if(!n)break e}for(t&=255;;){if((0|t)==o[0|e])return e;if(e=e+1|0,!(n=n-1|0))break}}return 0}function Jt(e,t){var n=0,r=0;e:{if(r=255&t){if(3&e)for(;;){if(!(n=o[0|e])|(0|n)==(255&t))break e;if(!(3&(e=e+1|0)))break}t:if(!(~(n=A[e>>2])&n-16843009&-2139062144))for(r=b(r,16843009);;){if(~(n^=r)&n-16843009&-2139062144)break t;if(n=A[e+4>>2],e=e+4|0,n-16843009&~n&-2139062144)break}for(;(r=o[0|(n=e)])&&(e=n+1|0,(0|r)!=(255&t)););return n}return Hn(e)+e|0}return e}function $t(e,t,n,r,s){var a,i=0,A=0;A=-1;e:if(!(((i=2147418112==(0|(a=2147483647&r)))&!n?e|t:i&!!(0|n)|a>>>0>2147418112)||(i=2147483647&s)>>>0>2147418112&2147418112!=(0|i))){if(!(e|n|i|a|t))return 0;if((0|(i=r&s))>0|(0|i)>=0){if((!!(0|n)|(0|r)!=(0|s))&(0|r)<(0|s))break e;return!!(e|n|r^s|t)}(!n&(0|r)==(0|s)?e|t:!!(0|n)&(0|r)>=(0|s)|(0|r)>(0|s))||(A=!!(e|n|r^s|t))}return A}function en(e,t){var n,r=0;U=n=U+-64|0,a[202976]=0,A[n+48>>2]=47,En(n+59|0,91351,n+48|0),t||(a[n+59|0]=0);e:{t:{if(e&&(e=us(e,43))){if(a[0|e]=0,a[0|(e=e+1|0)]-48>>>0>=10)break t;r=kn(e)}if((0|r)<=0)break e;if(r>>>0<=9){A[n+4>>2]=r,A[n>>2]=n+59,En(202976,91378,n);break e}A[n+20>>2]=r-10,A[n+16>>2]=n+59,En(202976,91503,n+16|0);break e}A[n+36>>2]=e,A[n+32>>2]=n+59,En(202976,85425,n+32|0)}U=n- -64|0}function tn(e){var t,n=0,r=0,s=0;U=t=U-80|0,n=Ce(e,t+12|0),A[t+12>>2]?(fs(r=t+16|0,n,60),n=0,en(r,1),!se(r,0)|!o[202976]||se(202976,2),Sr(A[32972]),gn(e,86012)):n=268437247,U=t+80|0;e:{t:{n:{r:{if((0|n)<=268437502){if(!n)break e;if(268436479==(0|n))break t;if(268437247!=(0|n))break r;return 2}if(268437503==(0|n)|268437759==(0|n))break n;if(268439295==(0|n))break e}return-1}return 2}s=1}return s}function nn(e,t,n,r,s,a,i,o,l){var u,c,d;l=sr(t,n,o,l),o=K,s=sr(r,s,a,i),r=K+o|0,o=s>>>0>(l=s+l|0)>>>0?r+1|0:r,u=i,c=n,i=(n=sr(i,s=0,n,r=0))+l|0,l=K+o|0,d=i,n=n>>>0>i>>>0?l+1|0:l,i=sr(a,0,t,0),o=K,r=sr(a,l=0,c,r),a=K+l|0,a=r>>>0>(o=o+r|0)>>>0?a+1|0:a,r=n,a=a>>>0>(l=a+d|0)>>>0?r+1|0:r,n=sr(t,0,u,s)+o|0,s=K,o=(s=n>>>0<o>>>0?s+1|0:s)+l|0,l=a,A[e+8>>2]=o,A[e+12>>2]=s>>>0>o>>>0?l+1|0:l,A[e>>2]=i,A[e+4>>2]=n}function rn(e,t){var n=0,r=0;e:{if(3&((r=e)^t))n=o[0|t];else{if(3&t)for(;;){if(n=o[0|t],a[0|r]=n,!n)break e;if(r=r+1|0,!(3&(t=t+1|0)))break}if(!(~(n=A[t>>2])&n-16843009&-2139062144))for(;A[r>>2]=n,n=A[t+4>>2],r=r+4|0,t=t+4|0,!(n-16843009&~n&-2139062144););}if(a[0|r]=n,255&n)for(;n=o[t+1|0],a[r+1|0]=n,r=r+1|0,t=t+1|0,n;);}return e}function sn(e){var t,n=0,r=0;U=t=U-16|0,d(+e),r=0|l(1),l(0);e:if((r&=2147483647)>>>0<=1072243195){if(n=1,r>>>0<1044816030)break e;n=Yn(e,0)}else if(n=e-e,!(r>>>0>=2146435072)){t:switch(3&fe(e,t)){case 0:n=Yn(m[t>>3],m[t+8>>3]);break e;case 1:n=-Rn(m[t>>3],m[t+8>>3],1);break e;case 2:n=-Yn(m[t>>3],m[t+8>>3]);break e}n=Rn(m[t>>3],m[t+8>>3],1)}return U=t+16|0,n}function an(e,t,n,r){var s=0,a=0,i=0;if(!((Hn(r)+Hn(t)|0)>=(0|n))){for(i=A[36115],n=r;s=o[0|n];)if(n=n+1|0,!((0|s)>=(0|i))){e:{t:switch(s=A[144464+(s<<2)>>2],o[s+11|0]-1|0){case 1:break e;case 0:break t;default:continue}a=o[s+14|0]<4|a;continue}1&(o[s+4|0]>>>1|a)||(A[e+8212>>2]=A[e+8212>>2]+1),A[e+8208>>2]=A[e+8208>>2]+1,a=0}t&&Es(t,r)}}function An(e){var t,n=0;U=t=U-16|0,d(+e),n=0|l(1),l(0);e:if((n&=2147483647)>>>0<=1072243195){if(n>>>0<1045430272)break e;e=Rn(e,0,0)}else if(n>>>0>=2146435072)e-=e;else{t:switch(3&fe(e,t)){case 0:e=Rn(m[t>>3],m[t+8>>3],1);break e;case 1:e=Yn(m[t>>3],m[t+8>>3]);break e;case 2:e=-Rn(m[t>>3],m[t+8>>3],1);break e}e=-Yn(m[t>>3],m[t+8>>3])}return U=t+16|0,e}function on(e){var t=0;A[e+296>>2]=303173648,A[e+300>>2]=370677780,t=A[26341],A[e+304>>2]=A[26340],A[e+308>>2]=t,t=A[26343],A[e+312>>2]=A[26342],A[e+316>>2]=t,Ve(e),A[e+56>>2]=2,A[e+36>>2]=3,A[e+40>>2]=1074,a[e+168|0]=5,A[e+132>>2]=32,A[e+104>>2]=1032,A[e+108>>2]=66,A[e+8>>2]=5,A[e+12>>2]=32,a[e+365|0]=64|o[e+365|0],a[e+368|0]=64|o[e+368|0],a[e+396|0]=64|o[e+396|0],a[e+399|0]=64|o[e+399|0]}function ln(e,t,n){var r=0,s=0,a=0;e:{if(!(r=A[n+16>>2])){if(fr(n))break e;r=A[n+16>>2]}if(r-(a=A[n+20>>2])>>>0<t>>>0)return 0|Ns[A[n+36>>2]](n,e,t);t:if(A[n+80>>2]<0)r=0;else{for(s=t;;){if(!(r=s)){r=0;break t}if(10==o[(s=r-1|0)+e|0])break}if((s=0|Ns[A[n+36>>2]](n,e,r))>>>0<r>>>0)break e;e=e+r|0,t=t-r|0,a=A[n+20>>2]}Je(a,e,t),A[n+20>>2]=A[n+20>>2]+t,s=t+r|0}return s}function un(e){var t,n=0,r=0;e:{if((0|(t=A[34064]))>0)for(;;){if((r=A[136284+(n<<4)>>2])&&!mr(e,r)){if(A[136276+(n<<4)>>2])return n;if(r=-1,Qe(0,n))break e;return n}if((0|t)==(0|(n=n+1|0)))break}r=-1,Qe(e,t)||(n=Oe(A[12+(136272+(A[34064]<<4)|0)>>2],Hn(e)+1|0),r=A[34064],A[12+(136272+(r<<4)|0)>>2]=n,rn(n,e),A[34064]=r+1)}return r}function cn(e,t){var n,r=0,s=0,i=0,o=0;for(U=n=U-16|0,a[0|t]=0,(r=15&A[e>>2])&&(t=(s=Hn(t=rn(t,br(128496,64|r))))+t|0),r=8;;){e:{t:{if(r>>>0<=29){if(A[e>>2]>>>r&1)break t;break e}if(!(A[e+4>>2]>>>r-32&1)|r>>>0<32)break e}(0|(s=(o=Hn(i=br(128496,r))+1|0)+s|0))>=80||(A[n>>2]=i,En(t,84439,n),t=t+o|0)}if(64==(0|(r=r+1|0)))break}U=n+16|0}function dn(e,t,n){var r,s=0,i=0,l=0;if(U=r=U-16|0,o[0|e])for(l=A[30450];;)if(i=e,e=e+1|0,!(32==(0|(s=a[0|i]))|s-9>>>0<5)){for((0|(s=kn(i)))>0&&((0|s)<32?A[t>>2]=A[t>>2]|1<<s:(i=br(129568,n),A[r+4>>2]=s,A[r>>2]=i,ts(l,84902,r)),i=e);i=(e=i)+1|0,(s=a[0|e])-48>>>0<10|(32|s)-97>>>0<26;);if(!s)break}U=r+16|0}function hn(e,t,n){var r=0,s=0,i=0,o=0;e:if(t&&!((0|(s=n-4|0))<=0))for(i=34!=(0|(n=A[t-4>>2]))?39==(0|n)?n:0:n,n=0;;){if(o=n,!(n=A[t>>2]))break e;t:{if(!i){if(32==(0|n)|n-9>>>0<5)break e;if(47!=(0|n))break t;break e}if(92!=(0|o)&&(0|n)==(0|i))break e}if(t=t+4|0,!((0|s)>(0|(r=Qn(n,e+r|0)+r|0))))break}return a[e+r|0]=0,r}function fn(e){var t=0;e:if(!Br(e)){t=0;t:if(!(e>>>0<768)){if(e-2305>>>0<=1270){if((124&e)>>>0<100)break e;if(t=1,Pr(93850,e))break t;return e-3450>>>0<6}if(1541==(0|e)|e-1456>>>0<19|1648==(0|e))break e;if(10240==(0|(t=-256&e))|4352==(0|t)|e-3904>>>0<125|e>>>0<880)break e;t=1,e-1611>>>0<20||(t=e-12353>>>0<30400)}return t}return 1}function gn(e,t){var n=0;e?((n=A[e+4>>2])&&rn(133208,n),(n=A[e>>2])&&fs(133168,n,40),A[33289]=o[e+14|0],A[33291]=o[e+13|0],A[33290]=o[e+12|0],fs(134672,33!=o[0|t]|118!=o[t+1|0]?t:(47==o[t+2|0]?3:0)+t|0,40),e=A[50298],A[33678]=A[50297],A[33679]=e,e=A[50302],A[33682]=A[50301],A[33683]=e,e=A[50300],A[33680]=A[50299],A[33681]=e):kt(133152,0,76)}function pn(e,t,n,r){a[e+53|0]=1;e:if(A[e+4>>2]==(0|n)){a[e+52|0]=1;t:{if(!(n=A[e+16>>2])){if(A[e+36>>2]=1,A[e+24>>2]=r,A[e+16>>2]=t,1!=(0|r))break e;if(1==A[e+48>>2])break t;break e}if((0|t)==(0|n)){if(2==(0|(n=A[e+24>>2]))&&(A[e+24>>2]=r,n=r),1!=A[e+48>>2])break e;if(1==(0|n))break t;break e}A[e+36>>2]=A[e+36>>2]+1}a[e+54|0]=1}}function mn(e,t){var n=0,r=0,s=0,i=0,o=0;e:if(n=A[t>>2])for(;;){r=0;t:if(e){for(;o=a[r+n|0],(s=A[(r<<2)+e>>2])&&(r=r+1|0,(0|o)==(0|s)););n:switch(s-34|0){case 0:case 5:break n;default:break t}if(!o)break e}if(!(n=A[((i=i+1|0)<<3)+t>>2]))break}return A[4+((i<<3)+t|0)>>2]}function bn(e,t){e:if((0|t)>=1024){if(e*=898846567431158e293,t>>>0<2047){t=t-1023|0;break e}e*=898846567431158e293,t=((0|t)>=3069?3069:t)-2046|0}else(0|t)>-1023||(e*=2004168360008973e-307,t>>>0>4294965304?t=t+969|0:(e*=2004168360008973e-307,t=((0|t)<=-2960?-2960:t)+1938|0));return u(0,0),u(1,t+1023<<20),e*+c()}function Cn(e,t,n,r){var s,i,o,l=0;return U=i=U-16|0,A[i+12>>2]=r,U=s=U-160|0,o=t?e:s+158|0,A[s+144>>2]=o,l=-1,e=t-1|0,A[s+148>>2]=e>>>0<=t>>>0?e:0,e=kt(s,0,144),A[e+76>>2]=-1,A[e+36>>2]=17,A[e+80>>2]=-1,A[e+44>>2]=e+159,A[e+84>>2]=e+144,(0|t)<0?A[56798]=61:(a[0|o]=0,l=Bt(e,n,r,15,16)),U=e+160|0,U=i+16|0,l}function In(e,t){var n=0,r=0,s=0;e:if(n=o[0|e])for(;;){if(!(r=o[0|t])){s=n;break e}if((0|n)!=(0|r)&&(0|(r=n-65>>>0<26?32|n:n))!=(0|((n=o[0|t])-65>>>0<26?32|n:n))){s=o[0|e];break e}if(t=t+1|0,n=o[e+1|0],e=e+1|0,!n)break}return(s=(e=255&s)-65>>>0<26?32|e:e)-((e=o[0|t])-65>>>0<26?32|e:e)|0}function wn(e,t,n){var r=0,s=0;if(r=A[n+72>>2],A[n+72>>2]=r-1|r,(0|(r=A[n+4>>2]))==(0|(s=A[n+8>>2]))?r=t:(Je(e,r,r=t>>>0>(r=s-r|0)>>>0?r:t),A[n+4>>2]=r+A[n+4>>2],e=e+r|0,r=t-r|0),r)for(;;){if(_n(n)||!(s=0|Ns[A[n+32>>2]](n,e,r)))return t-r|0;if(e=e+s|0,!(r=r-s|0))break}return t}function kn(e){for(var t=0,n=0,r=0,s=0;e=(t=e)+1|0,32==(0|(n=a[0|t]))|n-9>>>0<5;);e:{t:{n:switch((n=a[0|t])-43|0){case 0:break t;case 2:break n;default:break e}s=1}n=a[0|e],t=e}if(n-48>>>0<10)for(;r=48+(b(r,10)-a[0|t]|0)|0,e=a[t+1|0],t=t+1|0,e-48>>>0<10;);return s?r:0-r|0}function xn(e,t){var n,r,s,a=0;return U=n=U-32|0,A[t>>2]=0,A[t+4>>2]=0,A[(a=r=t+24|0)>>2]=0,A[a+4>>2]=0,A[(a=s=t+16|0)>>2]=0,A[a+4>>2]=0,A[(a=t+8|0)>>2]=0,A[a+4>>2]=0,A[n+28>>2]=t+28,A[n+24>>2]=r,A[n+20>>2]=t+20,A[n+16>>2]=s,A[n+12>>2]=t+12,A[n+8>>2]=a,A[n+4>>2]=t+4,A[n>>2]=t,e=ae(e,84553,n),U=n+32|0,e}function yn(e){var t=0,n=0,r=0;if((t=o[0|e])&&((n=o[e+1|0])?(n=t|n<<8,(t=o[e+2|0])&&(n|=t<<16,(e=o[e+3|0])&&(n|=e<<24))):n=t),(0|(t=A[36115]))>0)for(e=0;;){if(!(!(r=A[144464+(e<<2)>>2])|A[r>>2]!=(0|n)))return o[r+10|0];if((0|t)==(0|(e=e+1|0)))break}return 0}function vn(e,t,n,r){var s,a=0,i=0,o=0,l=0,u=0;U=s=U-240|0,A[s>>2]=e,o=1;e:if(!((0|n)<2))for(a=e;;){if((0|ls(e,i=(a=a-4|0)-A[((l=n-2|0)<<2)+r>>2]|0,t))>=0&&(0|ls(e,a,t))>=0)break e;if(u=i,a=(i=(0|ls(i,a,t))>=0)?u:a,A[(o<<2)+s>>2]=a,o=o+1|0,!((0|(n=i?n-1|0:l))>1))break}Bn(s,o),U=s+240|0}function En(e,t,n){var r,s,i,o=0;return U=s=U-16|0,A[s+12>>2]=n,U=r=U-160|0,Je(i=r+8|0,124528,144),A[r+52>>2]=e,A[r+28>>2]=e,o=(o=-2-e|0)>>>0>2147483647?2147483647:o,A[r+56>>2]=o,e=e+o|0,A[r+36>>2]=e,A[r+24>>2]=e,e=ms(i,t,n),o&&(t=A[r+28>>2],a[t-((0|t)==A[r+24>>2])|0]=0),U=r+160|0,U=s+16|0,e}function Bn(e,t){var n,r=0,s=0,a=0,i=0,o=0;if(r=4,U=n=U-256|0,(0|t)>=2)for(A[(o=(t<<2)+e|0)>>2]=n;;){for(a=r>>>0>=256?256:r,Je(A[o>>2],A[e>>2],a),s=0;i=(s<<2)+e|0,s=s+1|0,Je(A[i>>2],A[(s<<2)+e>>2],a),A[i>>2]=A[i>>2]+a,(0|t)!=(0|s););if(!(r=r-a|0))break}U=n+256|0}function Mn(e,t,n){var r,s=0;return U=r=U-96|0,A[r+88>>2]=0,A[r+92>>2]=1073741824,A[r+84>>2]=t,t=He(e,r+84|0,n,r+88|0,2,0),536870912&(s=A[r+88>>2])?(t=A[47202],A[47202]=0,a[r+2|0]=32,i[r>>1]=8192,fs(s=3|r,A[r+84>>2],77),e=ht(e,s,0,0),rn(n,189088),A[47202]=t):e=t?s:0,U=r+96|0,e}function Dn(e,t,n){var r=0,s=0,i=0;s=Fn(e),r=A[t>>2];e:{t:if((0|s)>=0){if(r){if(!mr(e,n))break t;(i=A[r+688>>2])&&Ee(i),Ee(r),A[t>>2]=0}A[t>>2]=Z(e),e=rn(n,e),Ne(n=A[t>>2],n+228|0,0)&&(Zr(A[A[32972]+60>>2]),a[0|e]=0,s=-1),r=A[t>>2],A[r+292>>2]=s}else if(!r)break e;a[r+268|0]=0}return s}function Tn(e){var t=0,n=0;return(0|(t=A[e+76>>2]))>=0&(!t|A[56823]!=(-1073741825&t))?(n=A[(t=e+76|0)>>2],A[t>>2]=n||1073741823,(0|(n=A[e+4>>2]))==A[e+8>>2]?e=Gr(e):(A[e+4>>2]=n+1,e=o[0|n]),A[t>>2]=0,e):(0|(t=A[e+4>>2]))!=A[e+8>>2]?(A[e+4>>2]=t+1,o[0|t]):Gr(e)}function Sn(e,t,n){var r=0,s=0;e:{t:{if(n>>>0>=4){if(3&(e|t))break t;for(;;){if(A[e>>2]!=A[t>>2])break t;if(t=t+4|0,e=e+4|0,!((n=n-4|0)>>>0>3))break}}if(!n)break e}for(;;){if((0|(r=o[0|e]))==(0|(s=o[0|t]))){if(t=t+1|0,e=e+1|0,n=n-1|0)continue;break e}break}return r-s|0}return 0}function Nn(e,t){var n,r=0,s=0,a=0;U=n=U-16|0,t?(Ut(n,s=((r=t>>31)^t)-r|0,0,0,0,(r=w(s))+81|0),s=0+A[n+8>>2]|0,r=(65536^A[n+12>>2])+(16414-r<<16)|0,a=-2147483648&t|(r=s>>>0<a>>>0?r+1|0:r),r=A[n+4>>2],t=A[n>>2]):t=0,A[e>>2]=t,A[e+4>>2]=r,A[e+8>>2]=s,A[e+12>>2]=a,U=n+16|0}function Gn(e){var t,n=0,r=0,s=0;if((0|(n=Jt(e,61)))==(0|e))return 0;e:if(!o[(t=n-e|0)+e|0]&&(n=A[56800])&&(r=A[n>>2])){for(;;){if(Zn(e,r,t)||(r=A[n>>2]+t|0,61!=o[0|r])){if(r=A[n+4>>2],n=n+4|0,r)continue;break e}break}s=r+1|0}return s}function Fn(e){var t=0,n=0;e:if(!((0|(n=A[34461]))<=0)){for(;;){if(!mr(e,b(t,44)+137856|0)){A[34457]=t;break e}if((0|n)==(0|(t=t+1|0)))break}return-1}return(e=(0|t)==(0|n))?-1:((0|(e=e?-1:t))!=A[36114]&&(A[36115]=0,vt(e),A[36114]=e,A[36115]=A[36115]+1),t)}function Pn(e,t,n,r){var s=0,a=0;e:if(32!=(32|o[0|t])){if(s=((0|r)>2)<<1,a=we(e,t,n,s=(0|r)>1?4|s:s),21!=o[0|n])for(s|=1,t=t+a|0,a=1;;){if(32==(32|o[0|t]))break e;if(t=we(e,t,n,s)+t|0,a=a+1|0,21==o[0|n])break}return rn(189088,n),0}return Mt(e,n,r,a),t}function Qn(e,t){var n,r=0,s=0,i=0;if(e>>>0<=127)return a[0|t]=e,1;if(e>>>0>=1114112)return a[0|t]=32,1;for(r=b(n=e>>>0<2048?1:e>>>0<65536?2:3,6),a[0|t]=o[n+93842|0]|e>>>r;r=r-6|0,a[(s=s+1|0)+t|0]=e>>>r&63|128,(0|(i=i+1|0))!=(0|n););return n+1|0}function zn(e){var t=0,n=0;e:{if((0|(t=A[e+12>>2]))>=A[e+16>>2]){if(t=0,(0|(n=0|L(A[e+8>>2],e+24|0,2048)))<=0){if(!n|-44==(0|n))break e;return A[56798]=0-n,0}A[e+16>>2]=n}n=t,t=e+t|0,A[e+12>>2]=n+g[t+40>>1],n=A[t+36>>2],A[e>>2]=A[t+32>>2],A[e+4>>2]=n,t=t+24|0}return t}function On(e,t){var n,r=0;if(r=A[e+632>>2])return!!(0|Fr(r,t));e:{t:{if((0|(n=A[e+600>>2]))>0){if(r=0,(t=t-n|0)-1>>>0<255)break t;break e}if((r=t-192|0)>>>0<=413)return 128&o[344+(o[r+94240|0]+e|0)|0];if(r=0,t>>>0>255)break e}r=128&o[344+(e+t|0)|0]}return r}function Rn(e,t,n){var r,s,a;return a=(r=e*e)*(r*r)*(1.58969099521155e-10*r-2.5050760253406863e-8)+(r*(27557313707070068e-22*r-.0001984126982985795)+.00833333333332249),s=r*e,n?e-(r*(.5*t-a*s)-t+.16666666666666632*s):s*(r*a-.16666666666666632)+e}function Ln(e,t){var n,r=0,s=0,a=0;U=n=U-16|0,t?(Ut(n,r=t,0,0,0,(t=w(t))+81|0),r=0+A[n+8>>2]|0,t=(65536^A[n+12>>2])+(16414-t<<16)|0,a=s>>>0>r>>>0?t+1|0:t,s=A[n+4>>2],t=A[n>>2]):t=0,A[e>>2]=t,A[e+4>>2]=s,A[e+8>>2]=r,A[e+12>>2]=a,U=n+16|0}function Wn(e){var t,n=0;U=t=U-16|0,a[t+15|0]=10;e:{if(!(n=A[e+16>>2])){if(fr(e))break e;n=A[e+16>>2]}(0|n)==(0|(n=A[e+20>>2]))|10==A[e+80>>2]?Ns[A[e+36>>2]](e,t+15|0,1):(A[e+20>>2]=n+1,a[0|n]=10)}U=t+16|0}function _n(e){var t,n=0;return n=A[e+72>>2],A[e+72>>2]=n-1|n,A[e+20>>2]!=A[e+28>>2]&&Ns[A[e+36>>2]](e,0,0),A[e+28>>2]=0,A[e+16>>2]=0,A[e+20>>2]=0,4&(n=A[e>>2])?(A[e>>2]=32|n,-1):(t=A[e+44>>2]+A[e+48>>2]|0,A[e+8>>2]=t,A[e+4>>2]=t,n<<27>>31)}function Vn(e){var t=0;e:{t:{n:{r:{if((0|(e=Kt(e)))<=268437502){if(!e)break e;if(268436479==(0|e))break t;if(268437247!=(0|e))break r;return 2}if(268437503==(0|e)|268437759==(0|e))break n;if(268439295==(0|e))break e}return-1}return 2}t=1}return t}function Hn(e){var t=0,n=0,r=0;e:{if(3&(t=e))for(;;){if(!o[0|t])break e;if(!(3&(t=t+1|0)))break}for(;n=t,t=t+4|0,!(~(r=A[n>>2])&r-16843009&-2139062144););for(;n=(t=n)+1|0,o[0|t];);}return t-e|0}function Un(e,t,n){var r,s=0,a=0,i=0;A[e+112>>2]=t,A[e+116>>2]=n,r=A[e+4>>2],s=A[e+44>>2]-r|0,A[e+120>>2]=s,A[e+124>>2]=s>>31,s=A[e+8>>2],t|n&&((0|n)>=(0|(i=(a=s-r|0)>>31))&t>>>0>=a>>>0|(0|n)>(0|i)||(s=t+r|0)),A[e+104>>2]=s}function jn(e,t){var n,r,s=0;if(d(+e),n=0|l(1),r=0|l(0),2047!=(0|(s=n>>>20&2047))){if(!s)return 0==e?s=0:(e=jn(0x10000000000000000*e,t),s=A[t>>2]+-64|0),A[t>>2]=s,e;A[t>>2]=s-1022,u(0,0|r),u(1,-2146435073&n|1071644672),e=+c()}return e}function Yn(e,t){var n,r,s=0;return(r=1-(s=.5*(n=e*e)))+(1-r-s+(n*(n*(n*(2480158728947673e-20*n-.001388888888887411)+.0416666666666666)+(s=n*n)*s*(n*(-11359647557788195e-27*n+2.087572321298175e-9)-2.7557314351390663e-7))-e*t))}function Kn(e,t,n){var r=0,s=0;if(t)for(;n=n-1|0,s=e,e=ys(e,t,10),r=K,a[0|n]=s-sr(e,r,10,0)|48,s=t>>>0>9,t=r,s;);if(e)for(;t=(e>>>0)/10|0,a[0|(n=n-1|0)]=e-b(t,10)|48,r=e>>>0>9,e=t,r;);return n}function Xn(e,t){var n=0,r=0,s=0;e:if(e){for(;s=a[t+n|0],(r=A[(n<<2)+e>>2])&&(n=n+1|0,(0|s)==(0|r)););t:switch(r-34|0){case 0:case 5:break t;default:break e}if(!s)return 0}return 1}function qn(e,t,n){var r,s=0;return U=r=U-16|0,!(64&t)&&(s=0,4259840&~t)||(A[r+12>>2]=n+4,s=A[n>>2]),A[r>>2]=s,A[r+4>>2]=0,(e=0|M(-100,0|e,32768|t,0|r))>>>0>=4294963201&&(A[56798]=0-e,e=-1),U=r+16|0,e}function Zn(e,t,n){var r=0,s=0,a=0;if(!n)return 0;e:if(r=o[0|e]){for(;;){if((s=o[0|t])&&!(!(n=n-1|0)|(0|r)!=(0|s))){if(t=t+1|0,r=o[e+1|0],e=e+1|0,r)continue;break e}break}a=r}return(255&a)-o[0|t]|0}function Jn(e,t){var n,r=0;U=r=U-128|0,r=kt(r,0,128),a[r+98|0]=9,a[r+66|0]=9,a[r+34|0]=e,i[r+68>>1]=1,n=A[36125],A[r+104>>2]=n,A[r+72>>2]=n,A[r+40>>2]=A[144464+(e<<2)>>2],a[r+2|0]=9,A[r+8>>2]=n,le(0,0,r+32|0,t,0),U=r+128|0}function $n(e){var t=0,n=0,r=0;if(a[A[e>>2]]-48>>>0>=10)return 0;for(;r=A[e>>2],n=-1,t>>>0<=214748364&&(n=(0|(n=a[0|r]-48|0))>(2147483647^(t=b(t,10)))?-1:n+t|0),A[e>>2]=r+1,t=n,a[r+1|0]-48>>>0<10;);return t}function er(e,t){var n=0;if(!(!e|A[e>>2]-48>>>0>=10)){if(A[e>>2]-48>>>0<10)for(;n=(A[e>>2]+b(n,10)|0)-48|0,A[(e=e+4|0)>>2]-48>>>0<10;);1==(0|t)&&(n=115==(0|ar(A[e>>2]))?b(n,1e3):n)}return n}function tr(e){var t=0;t=1;e:{t:switch(0|jt(e)){case 30:if(t=0,160==(0|e)|8199==(0|e)|8239==(0|e))break e;return 1;case 0:if(e-9>>>0<5)return 1;if(133==(0|e))break e;break;case 28:case 29:break e}t=0}return t}function nr(e,t,n){var r,s=0;return U=r=U-16|0,a[r+6|0]=0,a[r+7|0]=95,s=Qn(s=t,t=r+8|0)+r|0,a[s+8|0]=32,a[s+9|0]=0,Mn(e,r+7|0,n)||(a[r+7|0]=32,Mn(e,t,n)||be(e,t,n,20,0,0,0)),U=r+16|0,a[0|n]}function rr(e){var t=0,n=0;n=170;e:if(!((0|e)<170))for(;;){if((0|e)==(0|n))return g[101616+(t<<1|2)>>1];if(124==(2147483646&(t=t+2|0)))break e;if(!((0|(n=g[101616+(t<<1)>>1]))<=(0|e)))break}return 0}function sr(e,t,n,r){var s,a,i,A,o=0,l=0;return A=b(o=n>>>16|0,l=e>>>16|0),o=(65535&(l=((i=b(s=65535&n,a=65535&e))>>>16|0)+b(l,s)|0))+b(o,a)|0,K=(b(t,n)+A|0)+b(e,r)+(l>>>16)+(o>>>16)|0,65535&i|o<<16}function ar(e){var t=0,n=0,r=0,s=0;for(t=2778;;){if((0|(n=A[1040+((r=(t+s|0)/2|0)<<4)>>2]))==(0|e))return(t=A[1048+(r<<4)>>2])||e;if(!((0|(s=(n=e>>>0>n>>>0)?r+1|0:s))<=(0|(t=n?t:r-1|0))))break}return e}function ir(e){var t=0,n=0,r=0,s=0;for(t=2778;;){if((0|(n=A[1040+((r=(t+s|0)/2|0)<<4)>>2]))==(0|e))return(t=A[1044+(r<<4)>>2])||e;if(!((0|(s=(n=e>>>0>n>>>0)?r+1|0:s))<=(0|(t=n?t:r-1|0))))break}return e}function Ar(e){var t,n=0;return U=t=U-112|0,(e=0|z(0|e,0|t))>>>0>=4294963201&&(A[56798]=0-e,e=-1),n=0-A[56798]|0,e||(n=-31,16384!=(61440&A[t+12>>2])&&(n=A[t+40>>2])),U=t+112|0,n}function or(e,t,n){var r;if(!(r=A[e+16>>2]))return A[e+36>>2]=1,A[e+24>>2]=n,void(A[e+16>>2]=t);e:{if((0|t)==(0|r)){if(2!=A[e+24>>2])break e;return void(A[e+24>>2]=n)}a[e+54|0]=1,A[e+24>>2]=2,A[e+36>>2]=A[e+36>>2]+1}}function lr(e,t,n,r,s){var a;if(U=a=U-256|0,!(73728&s|(0|n)<=(0|r))){if(kt(a,255&t,(n=(r=n-r|0)>>>0<256)?r:256),!n)for(;hs(e,a,256),(r=r-256|0)>>>0>255;);hs(e,a,r)}U=a+256|0}function ur(e,t,n){var r=0;e:{if(e){if(r=A[e>>2]){Ee(A[r+4>>2]),r=A[e>>2];break e}if(r=ie(16),A[e>>2]=r,r)break e;t=48}return t}return A[r>>2]=0,A[r+4>>2]=$r(n),e=A[e>>2],A[e+8>>2]=0,A[e+12>>2]=0,t}function cr(e){var t=0,n=0;Wt(e),Ns[A[e+12>>2]](e),1&a[0|e]||((t=A[e+52>>2])&&(A[t+56>>2]=A[e+56>>2]),(n=A[e+56>>2])&&(A[n+52>>2]=t),A[56816]==(0|e)&&(A[56816]=n),Ee(A[e+96>>2]),Ee(e))}function dr(e){var t=0,n=0;t=1;e:{t:{n:{r:switch((n=jt(e))-9|0){case 1:break e;case 6:case 18:break n;case 0:break r;default:break t}return(0|ar(e))!=(0|e)}return q(e,n)>>>15&1}t=0}return t}function hr(e){var t,n,r,s=0,a=0;if(r=Hn(e)+1|0,s=A[33282],(0|(n=(t=A[33287])+r|0))>=A[33286]){if(!(s=Oe(s,a=n+1e3|0)))return-1;A[33286]=a,A[33282]=s}return Je(s+t|0,e,r),A[33287]=n,t}function fr(e){var t=0;return t=A[e+72>>2],A[e+72>>2]=t-1|t,8&(t=A[e>>2])?(A[e>>2]=32|t,-1):(A[e+4>>2]=0,A[e+8>>2]=0,t=A[e+44>>2],A[e+28>>2]=t,A[e+20>>2]=t,A[e+16>>2]=t+A[e+48>>2],0)}function gr(e,t,n,r){e:if(e){t:switch(t+2|0){case 0:return void(a[0|e]=n);case 1:return void(i[e>>1]=n);case 2:case 3:return void(A[e>>2]=n);case 5:break t;default:break e}A[e>>2]=n,A[e+4>>2]=r}}function pr(e,t,n,r,s,a,i,o,l){var u;U=u=U-16|0,ve(u,t,n,r,s,a,i,o,-2147483648^l),r=A[u>>2],n=A[u+4>>2],t=A[u+12>>2],A[e+8>>2]=A[u+8>>2],A[e+12>>2]=t,A[e>>2]=r,A[e+4>>2]=n,U=u+16|0}function mr(e,t){var n=0,r=0;e:if(!(!(n=o[0|e])|(0|n)!=(0|(r=o[0|t]))))for(;;){if(r=o[t+1|0],!(n=o[e+1|0]))break e;if(t=t+1|0,e=e+1|0,(0|n)!=(0|r))break}return n-r|0}function br(e,t){var n=0,r=0,s=0;if(!(n=A[e>>2]))return 84399;if(A[e+4>>2]!=(0|t))for(;;){if(!(n=A[(r=e+8|0)>>2]))return 84399;if(s=e,e=r,A[s+12>>2]==(0|t))break}return n}function Cr(e,t,n){var r=0,s=0,a=0;e:if(n){for(;;){if(!(!(r=A[t>>2])|!(s=A[e>>2])|(0|r)!=(0|s))){if(t=t+4|0,e=e+4|0,n=n-1|0)continue;break e}break}a=s-r|0}return a}function Ir(e){var t,n=0,r=0;if((0|(t=A[36115]))>0)for(;;){if(!(!(r=A[144464+(n<<2)>>2])|A[r>>2]!=(0|e)))return o[r+10|0];if((0|t)==(0|(n=n+1|0)))break}return 0}function wr(e){var t,n;return(e=(t=A[33175])+(n=e+7&-8)|0)>>>0<=t>>>0&&n||e>>>0>r.byteLength/65536<<16>>>0&&!(0|Q(0|e))?(A[56798]=48,-1):(A[33175]=e,t)}function kr(e){var t=0;e:if(!((t=jt(e))>>>0>27)){if(!(1<<t&134259072)){if(6==(0|t))return 1;if(9!=(0|t))break e;return(0|ir(e))!=(0|e)}return q(e,t)>>>14&1}return 0}function xr(e,t){var n=0;return a[0|e]=t>>>24,a[0|(n=(t>>>0>16777215)+e|0)]=t>>>16,a[0|(n=n+!!(16711680&t)|0)]=t>>>8,a[0|(n=n+!!(65280&t)|0)]=t,a[n+!!(255&t)|0]=0,e}function yr(e,t){e:if((0|(e=Qt(e,t)))<=268437502){if(!e|268436479==(0|e)|268437247!=(0|e))break e;return}}function vr(e){var t=0;return t=A[e>>2]-1|0,(t=a[121600+(b(0-t&t,124511785)>>>27|0)|0])||(e=A[e+4>>2],t=(e=a[121600+(b(0-e&e,124511785)>>>27|0)|0])?e+32|0:0),t}function Er(e){var t=0,n=0,r=0;e:{if(!((t=jt(e))>>>0>27)){if(n=1,116672&(r=1<<t))break e;if(134227968&r)return q(e,t)>>>10&1}n=0}return n}function Br(e){var t=0,n=0,r=0;e:{if(!((t=jt(e))>>>0>27)){if(n=1,34752&(r=1<<t))break e;if(134227968&r)return q(e,t)>>>10&1}n=0}return n}function Mr(){var e,t=0;(e=A[56797])&&((t=A[e+8>>2])&&Ns[A[A[t>>2]+12>>2]](t),(t=A[e+4>>2])&&Ns[A[A[t>>2]+16>>2]](t),Ee(e)),A[56797]=0,A[56797]=Re()}function Dr(e,t){var n=0;return e&&(n=sr(e,0,t,0),(e|t)>>>0<65536||(n=K?-1:n)),!(e=ie(n))|!(3&o[e-4|0])||kt(e,0,n),e}function Tr(e,t){var n,r;r=A[130128+(t-b(n=(0|t)/100|0,100)<<2)>>2],A[e+100>>2]=r,A[e+96>>2]=r,t+99>>>0>=199&&(A[e+100>>2]=A[130128+(n<<2)>>2])}function Sr(e){var t=0;(t=ie(1344))&&(e=Je(t,e,1344),t=216192+(A[50758]<<4)|0,A[t>>2]=11,A[t+8>>2]=e,e=A[50758]+1|0,A[50758]=(0|e)<=169?e:0)}function Nr(e,t){var n=0;e:if(n=A[e>>2])for(;;){if(t&&!mr(t,n))break e;if(!(n=A[(e=e+8|0)>>2]))break}return A[e+4>>2]}function Gr(e){var t,n=0;return U=t=U-16|0,n=-1,_n(e)||1==(0|Ns[A[e+32>>2]](e,t+15|0,1))&&(n=o[t+15|0]),U=t+16|0,n}function Fr(e,t){var n=0,r=0;if(t){for(;r=e,(n=A[e>>2])&&(e=r+4|0,(0|t)!=(0|n)););return n?r:0}return(Yr(e)<<2)+e|0}function Pr(e,t){var n=0,r=0;if(n=g[e>>1])for(;;){if(r=r+1|0,(0|t)==(0|n))return r;if(!(n=g[(r<<1)+e>>1]))break}return 0}function Qr(e,t){var n=0,r=0;t>>>0<=31?(r=A[e>>2],n=e+4|0):(t=t-32|0,n=e),n=A[n>>2],A[e>>2]=r<<t,A[e+4>>2]=n<<t|r>>>32-t}function zr(e,t){var n=0,r=0;n=A[e+4>>2],t>>>0<=31?r=A[e>>2]:(t=t-32|0,r=n,n=0),A[e+4>>2]=n>>>t,A[e>>2]=n<<32-t|r>>>t}function Or(e){var t=0;e=e||1;e:{for(;;){if(t=ie(e))break e;if(!(t=A[57276]))break;Ns[0|t]()}P(),h()}return t}function Rr(e){return e>>>0<=131071?o[117424+(e>>>3&31|o[117424+(e>>>8|0)|0]<<5)|0]>>>(7&e)&1:e>>>0<196606}function Lr(e,t,n,r,s,a,i,o,l){A[e>>2]=t,A[e+4>>2]=n,A[e+8>>2]=r,A[e+12>>2]=65535&s|(l>>>16&32768|s>>>16&32767)<<16}function Wr(e,t,n){return n?(0|e)==(0|t)?1:!mr(A[e+4>>2],A[t+4>>2]):A[e+4>>2]==A[t+4>>2]}function _r(e){var t=0;-31==(0|(t=0|R(-100,0|e,0)))&&(t=0|O(0|e)),t>>>0>=4294963201&&(A[56798]=0-t)}function Vr(){var e;e=ie(84)+80|0,A[e>>2]=125420,A[e>>2]=125380,A[e>>2]=125400,H(0|e,125512,9),h()}function Hr(e){var t,n;return t=Tn(e),n=Tn(e),Tn(e)<<16&16711680|n<<8&65280|255&t|Tn(e)<<24}function Ur(e){var t=0;return e?(t=1,e-9472>>>0<160|e-65529>>>0<7||(t=tr(e)),t):0}function jr(e,t){var n;return n=t>>31,A[e+76>>2],function(e,t,n){return A[e+20>>2]!=A[e+28>>2]&&(Ns[A[e+36>>2]](e,0,0),!A[e+20>>2])||(A[e+28>>2]=0,A[e+16>>2]=0,A[e+20>>2]=0,Ns[A[e+40>>2]](e,t,n,0),(0|K)<0)?-1:(A[e+4>>2]=0,A[e+8>>2]=0,A[e>>2]=-17&A[e>>2],0)}(e,t,n)}function Yr(e){var t=0,n=0;for(n=e;n=(t=n)+4|0,A[t>>2];);return t-e>>2}function Kr(e,t){return a[0|e]=t,a[e+4|0]=0,a[e+3|0]=t>>>24,a[e+2|0]=t>>>16,a[e+1|0]=t>>>8,e}function Xr(e,t){var n=0;return(-1>>>(n=31&t)&e)<<n|((n=e)&-1<<(e=0-t&31))>>>e}function qr(e,t){var n=0;return 73==(0|e)&&(n=305,o[t+173|0])||(n=ar(e)),n}function Zr(e){A[36114]!=(0|e)&&(A[36115]=0,vt(e),A[36114]=e,A[36115]=A[36115]+1)}function Jr(e){return e?A[34460]+e|0:(ns(85328,20,A[30450]),A[32320])}function $r(e){var t,n;return(n=ie(t=Hn(e)+1|0))?Je(n,e,t):0}function es(){var e;A[33287]=0,(e=A[33282])&&(Ee(e),A[33286]=0,A[33282]=0)}function ts(e,t,n){var r;U=r=U-16|0,A[r+12>>2]=n,ms(e,t,n),U=r+16|0}function ns(e,t,n){A[n+76>>2],e=ln(e,t,n)}function rs(e,t){return t?e<<24|(65280&e)<<8|e>>>8&65280|e>>>24:e}function ss(e){return e-8212>>>0>=12?Pr(93856,e):1}function as(e){var t=0;e&&((t=A[e+688>>2])&&Ee(t),Ee(e))}function is(e){return(0|e)<=127?us(87712,e):0}function As(e){return!(e=o[0|e]?1:Sn(e,e+1|0,3))}function os(e){(e=27!=(0|(e=0|v(0|e)))?e:0)&&(A[56798]=e)}function ls(e,t,n){return e|=0,t|=0,0|Ns[0|(n|=0)](e,t)}function us(e,t){return e=Jt(e,t),o[0|e]==(255&t)?e:0}function cs(e,t){return lt(e,t,2147483647),K=Y,j}function ds(e){return e?31-w(e-1^e)|0:32}function hs(e,t,n){32&o[0|e]||ln(t,n,e)}function fs(e,t,n){a[(Ft(e,t,n)+n|0)-1|0]=0}function gs(e){return Dn(e,188776,189328)}function ps(e,t){t|=0,A[8+(e|=0)>>2]=t}function ms(e,t,n){return Bt(e,t,n,0,0)}function bs(e){return A[12+(e|=0)>>2]}function Cs(e){return A[16+(e|=0)>>2]}function Is(e){return A[20+(e|=0)>>2]}function ws(e){return A[8+(e|=0)>>2]}function ks(e){return A[4+(e|=0)>>2]}function xs(e){return A[(e|=0)>>2]}function ys(e,t,n){return lt(e,t,n)}function vs(e){(e|=0)&&Ee(e)}function Es(e,t){rn(Hn(e)+e|0,t)}function Bs(e){return 0|e}function Ms(e){return 0}function Ds(e){Ee(e|=0)}function Ts(e){}s(t=o,1024,"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"),s(t,45536,"HhYWFhgWFhYXExYaFhIWFg4ODg4ODg4ODg4WFhoaGhYWCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoXFhMZERkGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBhcaExo="),s(t,45664,"HhYYGBgYGxYZGwgVGgEbGRsaEBAZBhYWGRAIFBAQEBYKCgoKCgoKCgoKCgoKCgoKCgoKCgoKChoKCgoKCgoKBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGGgYGBgYGBgYGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYGCgYKBgoGCgYKBgoGCgYKBgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgoGCgYKBgYGCgoGCgYKCgYKCgoGBgoKCgoGCgoGCgoKBgYGCgoGCgoGCgYKBgoKBgoGBgoGCgoGCgoKBgoGCgoGBggKBgYGCAgICAoJBgoJBgoJBgoGCgYKBgoGCgYKBgoGCgYGCgYKBgoGCgYKBgoGCgYKBgoGBgoJBgoGCgoKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYGBgYGBgYKCgYKCgYGCgYKCgoKBgoGCgYKBgoGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYIBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBwcHBwcHBwcHBwcHBwcHBwcHGRkZGQcHBwcHBwcHBwcHBxkZGRkZGRkZGRkZGRkZBwcHBwcZGRkZGRkZBxkHGRkZGRkZGRkZGRkZGRkZGRkNDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NCgYKBgcZCgYCAgcGBgYWCgICAgIZGQoWCgoKAgoCCgoGCgoKCgoKCgoKCgoKCgoKCgoCCgoKCgoKCgoKBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYKBgYKCgoGBgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYGBgYGCgYaCgYKCgYGCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBhsNDQ0NDQwMCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgoGCgYKBgoGCgYKBgoGBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgIKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgICBxYWFhYWFgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGFhICAhsbGAINDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0SDRYNDRYNDRYNAgICAgICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICCAgICBYWAgICAgICAgICAgIBAQEBAQEaGhoWFhgWFhsbDQ0NDQ0NDQ0NDQ0WAQIWFggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIBwgICAgICAgICAgNDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0ODg4ODg4ODg4OFhYWFggIDQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBYIDQ0NDQ0NDQEbDQ0NDQ0NBwcNDRsNDQ0NCAgODg4ODg4ODg4OCAgIGxsIFhYWFhYWFhYWFhYWFhYCAQgNCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0NDQ0NDQ0NDQ0NCAICAgICAgICAgICAgICDg4ODg4ODg4ODggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0NDQ0NDQ0NDQcHGxYWFgcCAg0YGAgICAgICAgICAgICAgICAgICAgICAgNDQ0NBw0NDQ0NDQ0NDQcNDQ0HDQ0NDQ0CAhYWFhYWFhYWFhYWFhYWFgIICAgICAgICAgICAgICAgICAgICAgICAgIDQ0NAgIWAggICAgICAgICAgIAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIICAgICAgICAgICAgICAgICAgICAgCCAgICAgICAgCAgICAgICAgICAgICAgICAgICAgINDQ0NDQ0NDQ0NDQ0NDQ0BDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsNCAsLCw0NDQ0NDQ0NCwsLCw0LCwgNDQ0NDQ0NCAgICAgICAgICA0NFhYODg4ODg4ODg4OFgcICAgICAgICAgICAgICAgNCwsCCAgICAgICAgCAggIAgIICAgICAgICAgICAgICAgICAgICAgIAggICAgICAgCCAICAggICAgCAg0ICwsLDQ0NDQICCwsCAgsLDQgCAgICAgICAgsCAgICCAgCCAgIDQ0CAg4ODg4ODg4ODg4ICBgYEBAQEBAQGxgIFg0CAg0NCwIICAgICAgCAgICCAgCAggICAgICAgICAgICAgICAgICAgICAgCCAgICAgICAIICAIICAIICAICDQILCwsNDQICAgINDQICDQ0NAgICDQICAgICAgIICAgIAggCAgICAgICDg4ODg4ODg4ODg0NCAgIDRYCAgICAgICAgICDQ0LAggICAgICAgICAIICAgCCAgICAgICAgICAgICAgICAgICAgICAIICAgICAgIAggIAggICAgIAgINCAsLCw0NDQ0NAg0NCwILCw0CAggCAgICAgICAgICAgICAgIICA0NAgIODg4ODg4ODg4OFhgCAgICAgICCA0NDQ0NDQINCwsCCAgICAgICAgCAggIAgIICAgICAgICAgICAgICAgICAgICAgIAggICAgICAgCCAgCCAgICAgCAg0ICw0LDQ0NDQICCwsCAgsLDQICAgICAgICDQsCAgICCAgCCAgIDQ0CAg4ODg4ODg4ODg4bCBAQEBAQEAICAgICAgICAgINCAIICAgICAgCAgIICAgCCAgICAICAggIAggCCAgCAgIICAICAggICAICAggICAgICAgICAgICAICAgILCw0LCwICAgsLCwILCwsNAgIIAgICAgICCwICAgICAgICAgICAgICDg4ODg4ODg4ODhAQEBsbGxsbGxgbAgICAgINCwsLDQgICAgICAgIAggICAIICAgICAgICAgICAgICAgICAgICAgICAIICAgICAgICAgICAgICAgIAgICCA0NDQsLCwsCDQ0NAg0NDQ0CAgICAgICDQ0CCAgIAgICAgIICA0NAgIODg4ODg4ODg4OAgICAgICAgIQEBAQEBAQGwgNCwsWCAgICAgICAgCCAgIAggICAgICAgICAgICAgICAgICAgICAgIAggICAgICAgICAgCCAgICAgCAg0ICw0LCwsLCwINCwsCCwsNDQICAgICAgILCwICAgICAgIIAggIDQ0CAg4ODg4ODg4ODg4CCAgCAgICAgICAgICAgICDQ0LCwIICAgICAgICAIICAgCCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNDQgLCwsNDQ0NAgsLCwILCwsNCBsCAgICCAgICxAQEBAQEBAICAgNDQICDg4ODg4ODg4ODhAQEBAQEBAQEBsICAgICAgCAgsLAggICAgICAgICAgICAgICAgICAICAggICAgICAgICAgICAgICAgICAgICAgICAIICAgICAgICAgCCAICCAgICAgICAICAg0CAgICCwsLDQ0NAg0CCwsLCwsLCwsCAgICAgIODg4ODg4ODg4OAgILCxYCAgICAgICAgICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCAgNDQ0NDQ0NAgICAhgICAgICAgHDQ0NDQ0NDQ0WDg4ODg4ODg4ODhYWAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAggIAggCAggIAggCAggCAgICAgIICAgIAggICAgICAgCCAgIAggCCAICCAgCCAgICA0ICA0NDQ0NDQINDQgCAggICAgIAgcCDQ0NDQ0NAgIODg4ODg4ODg4OAgIICAgIAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIIGxsbFhYWFhYWFhYWFhYWFhYWGxYbGxsNDRsbGxsbGw4ODg4ODg4ODg4QEBAQEBAQEBAQGw0bDRsNFxMXEwsLCAgICAgICAgCCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICAg0NDQ0NDQ0NDQ0NDQ0NCw0NDQ0NFg0NCAgICAgNDQ0NDQ0NDQ0NDQINDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0CGxsbGxsbGxsNGxsbGxsbAhsbFhYWFhYbGxsbFhYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsLDQ0NDQsNDQ0NDQ0LDQ0LCw0NCA4ODg4ODg4ODg4WFhYWFhYICAgICAgLCw0NCAgICA0NDQgLCwsICAsLCwsLCwsICAgNDQ0NCAgICAgICAgICAgICA0LCw0NCwsLCwsLDQgLDg4ODg4ODg4ODgsLCw0bGwoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAgoCAgICAgoCAgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYWBwYGBggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAggICAgCAggICAgICAgCCAIICAgIAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAIICAgIAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCCAgICAICCAgICAgICAIIAggICAgCAggICAgICAgICAgICAgICAIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCCAgICAICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICDQ0NFhYWFhYWFhYWEBAQEBAQEBAQEBAQEBAQEBAQEBACAgIICAgICAgICAgICAgICAgIGxsbGxsbGxsbGwICAgICAgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAgIGBgYGBgYCAhIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFhYICAgICAgICAgICAgICAgICB4ICAgICAgICAgICAgICAgICAgICAgICAgICBcTAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFhYWDw8PCAgICAgICAgCAgICAgICCAgICAgICAgICAgICAIICAgIDQ0NAgICAgICAgICAgIICAgICAgICAgICAgICAgICAgNDQ0WFgICAgICAgICAggICAgICAgICAgICAgICAgICA0NAgICAgICAgICAgICCAgICAgICAgICAgICAIICAgCDQ0CAgICAgICAgICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQ0LDQ0NDQ0NDQsLCwsLCwsLDQsLDQ0NDQ0NDQ0NDQ0WFhYHFhYWGAgNAgIODg4ODg4ODg4OAgICAgICEBAQEBAQEBAQEAICAgICAhYWFhYWFhIWFhYWDQ0NAQIODg4ODg4ODg4OAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgHCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICAgICCAgICAgNDQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCAICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICAgICAgICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAg0NDQsLCwsNDQsLCwICAgILCw0LCwsLCwsNDQ0CAgICGwICAhYWDg4ODg4ODg4ODggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICCAgICAgCAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICAggICAgICAgICAgICAgICAgICAgICAgICAgIAgICAgICDg4ODg4ODg4ODhACAgIbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbCAgICAgICAgICAgICAgICAgICAgICAgNDQsLDQICFhYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsNCw0NDQ0NDQ0CDQsNCwsNDQ0NDQ0NDQsLCwsLCw0NDQ0NDQ0NDQ0CAg0ODg4ODg4ODg4OAgICAgICDg4ODg4ODg4ODgICAgICAhYWFhYWFhYHFhYWFhYWAgINDQ0NDQ0NDQ0NDQ0NDQwCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg0NDQ0LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCw0NDQ0NCw0LCwsLCw0LCwgICAgICAgCAgICDg4ODg4ODg4ODhYWFhYWFhYbGxsbGxsbGxsbDQ0NDQ0NDQ0NGxsbGxsbGxsbAgICDQ0LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICw0NDQ0LCw0NCw0NDQgIDg4ODg4ODg4ODggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsNDQsLCw0LDQ0NCwsCAgICAgICAhYWFhYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCwsLCwsLCw0NDQ0NDQ0NCwsNDQICAhYWFhYWDg4ODg4ODg4ODgICAggICA4ODg4ODg4ODg4ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgHBwcHBwcWFgYGBgYGBgYGBgICAgICAgIKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAgIKCgoWFhYWFhYWFgICAgICAgICDQ0NFg0NDQ0NDQ0NDQ0NDQ0LDQ0NDQ0NDQgICAgNCAgICAsLDQgICw0NAgICAgICBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcGBgYGBgYGBgYGBgYGBwYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQINDQ0NDQoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgYGBgYGBgYGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYGBgYGBgYGBgoKCgoKCgoKBgYGBgYGAgIKCgoKCgoCAgYGBgYGBgYGCgoKCgoKCgoGBgYGBgYGBgoKCgoKCgoKBgYGBgYGAgIKCgoKCgoCAgYGBgYGBgYGAgoCCgIKAgoGBgYGBgYGBgoKCgoKCgoKBgYGBgYGBgYGBgYGBgYCAgYGBgYGBgYGCQkJCQkJCQkGBgYGBgYGBgkJCQkJCQkJBgYGBgYGBgYJCQkJCQkJCQYGBgYGAgYGCgoKCgkZBhkZGQYGBgIGBgoKCgoJGRkZBgYGBgICBgYKCgoKAhkZGQYGBgYGBgYGCgoKCgoZGRkCAgYGBgIGBgoKCgoJGRkCHh4eHh4eHh4eHh4BAQEBARISEhISEhYWFRQXFRUUFxUWFhYWFhYWFhwdAQEBAQEeFhYWFhYWFhYWFRQWFhYWEREWFhYaFxMWFhYWFhYWFhYWFhoWERYWFhYWFhYWFhYeAQEBAQECAQEBAQEBAQEBARAHAgIQEBAQEBAaGhoXEwcQEBAQEBAQEBAQGhoaFxMCBwcHBwcHBwcHBwcHBwICAhgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYAgICAgICAgICAgICAgICAg0NDQ0NDQ0NDQ0NDQ0MDAwMDQwMDA0NDQ0NDQ0NDQ0NDQICAgICAgICAgICAgICAhsbChsbGxsKGxsGCgoKBgYKCgoGGwobGxoKCgoKChsbGxsbGwobChsKGwoKCgobBgoKCgoGCAgICAYbGwYGCgoaGhoaGgoGBgYGGxobGwYbEBAQEBAQEBAQEBAQEBAQEA8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PCgYPDw8PEBsbAgICAhoaGhoaGxsbGxsaGhsbGxsaGxsaGxsaGxsbGxsbGxobGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGhobGxobGhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGxsbGxsbGxsXExcTGxsbGxsbGxsbGxsbGxsbGxsbGxsaGhsbGxsbGxsXExsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxobGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxoaGhoaGhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGwICAgICAgICAgICAgICAgICAgICAgICAgIbGxsbGxsbGxsbGwICAgICAgICAgICAgICAgICAgICAhAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxAQEBAQEBAQEBAQEBAQEBAQEBAQEBAbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsaGxsbGxsbGxsbGhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxoaGhoaGhoaGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbFxMXExcTFxMXExcTFxMQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxoaGhoaFxMaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaFxMXExcTFxMXExoaGhoaGhoaGhoaGhoaGhobGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoXExcTFxMXExcTFxMXExcTFxMXExcTGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaFxMXExoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaFxMaGhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxoaGhoaGhoaGhoaGhoaGhoaGhoaGhsbGhoaGhoaGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbAgIbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGwICGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGwIbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGwIKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgIGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgIKBgoKCgYGCgYKBgoGCgoKCgYKBgYKBgYGBgYGBwcKCgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYGGxsbGxsbCgYKBg0NDQoGAgICAgIWFhYWEBYWBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYCBgICAgICBgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICAgICBxYCAgICAgICAgICAgICAg0ICAgICAgICAgICAgICAgICAgICAgICAICAgICAgICAggICAgICAgCCAgICAgICAIICAgICAgIAggICAgICAgCCAgICAgICAIICAgICAgIAggICAgICAgCCAgICAgICAINDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDRYWFRQVFBYWFhUUFhUUFhYWFhYWFhYWEhYWEhYVFBYWFRQXExcTFxMXExYWFhYWBxYWFhYWFhYWFhYSEhYWFhYSFhcWFhYWFhYWFhYWFhYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsCGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsCAgICAgICAgICAgIbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbAgICAgICAgICAgICAgICAgICAgICAgICAgIbGxsbGxsbGxsbGxsCAgICHhYWFhsHCA8XExcTFxMXExcTGxsXExcTFxMXExIXExMbDw8PDw8PDw8PDQ0NDQsLEgcHBwcHGxsPDw8HCBYbGwIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICDQ0ZGQcHCBIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWBwcHCAICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAhsbEBAQEBsbGxsbGxsbGxsICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICAhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGwICAgICAgICAgICAggICAgICAgICAgICAgICAgbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbAhAQEBAQEBAQEBAbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsQEBAQEBAQEBsQEBAQEBAQEBAQEBAQEBAbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxAQEBAQEBAQEBAbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsQEBAQEBAQEBAQEBAQEBAbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsCCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICAgICAgICGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICAgICAgICAgICAgICAgIICAgICAgICAgICAgICAgICAgICAgHCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGwICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgHBwcHBwcWFggICAgICAgICAgICAcWFhYICAgICAgICAgICAgICAgIDg4ODg4ODg4ODggIAgICAgICAgICAgICAgICAgICAgIKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCA0MDAwWDQ0NDQ0NDQ0NDRYHCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgcHDQ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw8PDw8PDw8PDw0NFhYWFhYWAgICAgICAgIZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGQcHBwcHBwcHBxkZCgYKBgoGCgYKBgoGCgYGBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGBwYGBgYGBgYGCgYKBgoKBgoGCgYKBgoGBxkZCgYKBggKBgoGBgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoKCgoKBgoKCgoKBgoGCgYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCAcHBggICAgICAgNCAgIDQgICAgNCAgICAgICAgICAgICAgICAgICAgICAgLCw0NCxsbGxsCAgICEBAQEBAQGxsYGwICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWFhYWAgICAgICAgILCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwsLCwsLCwsLCwsLCwsLCw0NAgICAgICAgIWFg4ODg4ODg4ODg4CAgICAgINDQ0NDQ0NDQ0NDQ0NDQ0NDQ0ICAgICAgWFhYIFggIDQ4ODg4ODg4ODg4ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQ0NDQ0NDQ0WFggICAgICAgICAgICAgICAgICAgICAgIDQ0NDQ0NDQ0NDQ0LCwICAgICAgICAgICFggICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICDQ0NCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsLDQ0NDQsLDQsLCwsWFhYWFhYWFhYWFhYWAgcODg4ODg4ODg4OAgICAhYWCAgICAgNBwgICAgICAgICA4ODg4ODg4ODg4ICAgICAIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0NDQ0NDQsLDQ0LCw0NAgICAgICAgICCAgIDQgICAgICAgIDQsCAg4ODg4ODg4ODg4CAhYWFhYICAgICAgICAgICAgICAgIBwgICAgICBsbGwgLDQsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IDQ0NCAgNDQgICAgIDQ0IDQgCAgICAgICAgICAgICAgICAgICAgICAgIICAcWFggICAgICAgICAgICw0NCwsWFggHBwsNAgICAgICAgICAggICAgICAICCAgICAgIAgIICAgICAgCAgICAgICAgIICAgICAgIAggICAgICAgCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBhkHBwcHBgYGBgYGAgICAgICAgICAgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCw0LCw0LCxYLDQICDg4ODg4ODg4ODgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICAgICAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgCAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICAgIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGBgYGBgYCAgICAgICAgICAgIGBgYGBgICAgICCA0ICAgICAgICAgIGggICAgICAgICAgICAgCCAgICAgCCAIICAIICAIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGRkZGRkZGRkZGRkZGRkZAgICAgICAgICAgICAgICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMXAgICAgICAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIICAgICAgICAgICAgYGwICDQ0NDQ0NDQ0NDQ0NDQ0NDRYWFhYWFhYXExYCAgICAgINDQ0NDQ0NDQ0NDQ0NDQ0NFhISEREXExcTFxMXExcTFxMXExcTFhYXExYWFhYREREWFhYCFhYWFhIXExcTFxMWFhYaEhoaGgIWGBYWAgICAggICAgIAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICAQIWFhYYFhYWFxMWGhYSFhYODg4ODg4ODg4OFhYaGhoWFgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKFxYTGREZBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYXGhMaFxMWFxMWFggICAgICAgICAgHCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIBwcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICCAgICAgIAgIICAgICAgCAggICAgICAICCAgIAgICGBgaGRsYGAIbGhoaGhsbAgICAgICAgICAgEBARsbAgIICAgICAgICAgICAgCCAgICAgICAgICAgICAgICAgICAgICAgICAgCCAgICAgICAgICAgICAgICAgICAIICAIICAgICAgICAgICAgICAgCAggICAgICAgICAgICAgIAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICAgICFhYWAgICAhAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAICAhsbGxsbGxsbGw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PEBAQEBsbGxsbGxsbGxsbGxsbGxsbEBAbGxsCGxsbGxsbGxsbGxsbAgICAhsCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGw0CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICAgICAgICAgICAgICDRAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAQEBACAgICAgICAgIICAgICAgICAgICAgICAgICAgICA8ICAgICAgICA8CAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQ0NDQ0CAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAIWCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICAggICAgICAgIFg8PDw8PAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAg4ODg4ODg4ODg4CAgICAgIKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoCAgICBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICAgICAgICAhYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICAgICAgICCAgICAgICAgICAgICAgICAgICAgICAICAgICAgICAgIICAgICAgICAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCAgICAgIAgIIAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAggIAgICCAICCAgICAgICAgICAgICAgICAgICAgICAgCFhAQEBAQEBAQCAgICAgICAgICAgICAgICAgICAgICAgbGxAQEBAQEBAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICAgICAgIQEBAQEBAQEBACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIICAgICAgICAgICAgICAgICAgIAggIAgICAgIQEBAQEAgICAgICAgICAgICAgICAgICAgICAgQEBAQEBACAgIWCAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICAhYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICEBAICBAQEBAQEBAQEBAQEBAQEBACAhAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAIDQ0NAg0NAgICAgINDQ0NCAgICAIICAgCCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAg0NDQICAgINEBAQEBAQEBAQAgICAgICAhYWFhYWFhYWFgICAgICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAQFggICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBAQAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIICAgICAgICBsICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQ0CAgICEBAQEBAWFhYWFhYWAgICAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICFhYWFhYWFggICAgICAgICAgICAgICAgICAgICAgCAhAQEBAQEBAQCAgICAgICAgICAgICAgICAgICAICAgICEBAQEBAQEBAICAgICAgICAgICAgICAgICAgCAgICAgICFhYWFgICAgICAgICAgICAhAQEBAQEBACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAgICAgICAgICAgICAgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgICAgICAgIQEBAQEBAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNDQ0NAgICAgICAgIODg4ODg4ODg4OAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBAQEBAQEBAQEAgCAgICAgICAggICAgICAgICAgICAgICAgICAgICAgNDQ0NDQ0NDQ0NDRAQEBAWFhYWFgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgILDQsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0NDQ0NDQ0NDQ0NDQ0NDRYWFhYWFhYCAgICEBAQEBAQEBAQEBAQEBAQEBAQEBAODg4ODg4ODg4OAgICAgICAgICAgICAgICDQ0NCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsLCw0NDQ0LCw0NFhYBFhYWFgICAgICAgICAgICAQICCAgICAgICAgICAgICAgICAgICAgICAgICAICAgICAgIODg4ODg4ODg4OAgICAgICDQ0NCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQ0NDQ0LDQ0NDQ0NDQ0CDg4ODg4ODg4ODhYWFhYICwsCAgICAgICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0WFggCAgICAgICAgINDQsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCwsNDQ0NDQ0NDQ0LCwgICAgWFhYWDQ0NDRYCAg4ODg4ODg4ODg4IFggWFhYCEBAQEBAQEBAQEBAQEBAQEBAQEBACAgICAgICAgICAggICAgICAgICAgICAgICAgICAIICAgICAgICAgICAgICAgICAgICAgICAgICwsLDQ0NCwsNCw0NFhYWFhYWDQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCAgICAgICAIIAggICAgCCAgICAgICAgICAgICAgIAggICAgICAgICAgWAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCwsLDQ0NDQ0NDQ0CAgICAg4ODg4ODg4ODg4CAgICAgINDQsLAggICAgICAgIAgIICAICCAgICAgICAgICAgICAgICAgICAgICAIICAgICAgIAggIAggICAgIAg0NCAsLDQsLCwsCAgsLAgILCwsCAggCAgICAgILAgICAgIICAgICAsLAgINDQ0NDQ0NAgICDQ0NDQ0CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCwsNDQ0NDQ0NDQsLDQ0NCw0ICAgIFhYWFhYODg4ODg4ODg4OAhYCFg0CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCwsNDQ0NDQ0LDQsLCwsNDQsNDQgIFggCAgICAgICAg4ODg4ODg4ODg4CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCwsNDQ0NAgILCwsLDQ0LDQ0WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFggICAgNDQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCwsNDQ0NDQ0NDQsLDQsNDRYWFggCAgICAgICAgICAg4ODg4ODg4ODg4CAgICAgIWFhYWFhYWFhYWFhYWAgICAgICAgICAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCw0LCw0NDQ0NDQsNAgICAgICAgIODg4ODg4ODg4OAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgIAgINDQ0LCw0NDQ0LDQ0NDQ0CAgICDg4ODg4ODg4ODhAQFhYWGwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwsLDQ0NDQ0NDQ0NCw0NFgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGDg4ODg4ODg4ODhAQEBAQEBAQEAICAgICAgICAgICAggCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCA0NDQ0NDQ0NDQ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQ0NDQ0NCwgNDQ0NFhYWFhYWFhYNAgICAgICAgIIDQ0NDQ0NCwsNDQ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgIICAgIDQ0NDQ0NDQ0NDQ0NDQsNDRYWFggWFhYWFgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICAgICAggICAgICAgICAIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICw0NDQ0NDQ0CDQ0NDQ0NCw0IFhYWFhYCAgICAgICAgICDg4ODg4ODg4ODhAQEBAQEBAQEBAQEBAQEBAQEBACAgIWFggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQILDQ0NDQ0NDQsNDQsNDQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIICAgICAgIAggIAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQ0NDQ0NAgICDQINDQINDQ0NDQ0NCA0CAgICAgICAg4ODg4ODg4ODg4CAgICAgIICAgICAgCCAgCCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCwsLCwINDQILCw0LDQgCAgICAgICDg4ODg4ODg4ODgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIICAgICAgICAgICAgICAgICAgIDQ0LCxYWAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIPDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8CFhYWFhYCAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCDg4ODg4ODg4ODgICAgIWFgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICDQ0NDQ0WAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0NDQ0NDQ0WFhYWFhsbGxsHBwcHFhsCAgICAgICAgICDg4ODg4ODg4ODgIQEBAQEBAQAggICAgICAgICAgICAgICAgICAgICAICAgICCAgICAgICAgICAgICAgICAgICAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBhAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFhYWFgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICAgICAgICAgIICwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwICAgICAgICAgICAgICAgINDQ0NBwcHBwcHBwcHBwcHBwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICAgICAgICAgICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICAgICAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICAgICCAgICAgICAgICAgICAICAggICAgICAgICAICAgICAgIICAgICAgICAgIAgIbDQ0WAQEBAQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbAgICAgICAgICAhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGwICGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbCwsNDQ0bGxsLCwsLCwsBAQEBAQEBAQ0NDQ0NDQ0NGxsNDQ0NDQ0NGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbDQ0NDRsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbAgICAgICAgICAgICAgICAgICAgICAgIbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsNDQ0bAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhAQEBAQEBAQEBAQEBAQEBAQEBAQAgICAgICAgICAgICGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbAgICAgICAgICEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgYGBgYGBgYCBgYGBgYGBgYGBgYGBgYGBgYGCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgoCCgoCAgoCAgoKAgIKCgoKAgoKCgoKCgoKBgYGBgIGAgYGBgYGBgYCBgYGBgYGBgYGBgYKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGCgoCCgoKCgICCgoKCgoKCgoCCgoKCgoKCgIGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgoKAgoKCgoCCgoKCgoCCgICAgoKCgoKCgoCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgICCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKChoGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGGgYGBgYGBgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoaBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBhoGBgYGBgYKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKGgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYaBgYGBgYGCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKChoGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGGgYGBgYGBgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoaBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBhoGBgYGBgYKBgICDg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NGxsbGw0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NGxsbGxsbGxsNGxsbGxsbGxsbGxsbGxsNGxsWFhYWFgICAgICAgICAgICAgICAg0NDQ0NAg0NDQ0NDQ0NDQ0NDQ0NDQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDQ0NDQ0NDQINDQ0NDQ0NDQ0NDQ0NDQ0NDQICDQ0NDQ0NDQINDQINDQ0NDQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgIQEBAQEBAQEBANDQ0NDQ0NAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBg0NDQ0NDQ0CAgICAg4ODg4ODg4ODg4CAgICFhYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBsQEBAYEBAQEAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAggICAgCCAgICAgICAgICAgICAgICAgICAgICAgICAgIAggIAggCAggCCAgICAgICAgICAIICAgIAggCCAICAgICAggCAgICCAIIAggCCAgIAggIAggCAggCCAIIAggCCAIICAIIAgIICAgIAggICAgICAgCCAgICAIICAgIAggCCAgICAgICAgICAIICAgICAgICAgICAgICAgICAICAgICCAgIAggICAgIAggICAgICAgICAgICAgICAgIAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhoaAgICAgICAgICAgICAgIbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGwICAgIbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbAgICAgICAgICAgICGxsbGxsbGxsbGxsbGxsbAgIbGxsbGxsbGxsbGxsbGxsCGxsbGxsbGxsbGxsbGxsbAhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsCAgICAgICAgICEBAQEBAQEBAQEBAQEAICAhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbAgICAhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGwICAgICAgICAgICAgIbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGwICAgIbGxsbGxsbGxsCAgICAgICGxsCAgICAgICAgICAgICAhsbGxsbGwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxkZGRkZGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbAgICAgICAgICAgIbGxsbGxsbGxsbGxsbAgICGxsbGxsbGxsbGwICAgICAhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbAgICAgICAgICAgICGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIbGxsbGxsbGxsbGxsCAgICGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsCAgICAgICAhsbGxsbGxsbGxsCAgICAgIbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbAgICAgICAgIbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICGxsbGxsbGxsbGxsbAgICAhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbAhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsCAhsbGxsCAgIbAhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGwICAgICAgICAgICAgIbGxsbGxsbGxsbAgICAgICGxsbAgICAgICAgICAgICAhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhsbGxsbGxsbGxsbGxsbAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCAgICAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NAgICAgICAgICAgICAgICAoAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAIA="),s(t,81428,"ggAAAAAAAAIAAAAAAAAAAgAAAAAAAAAC"),s(t,81475,"AgAAAAAAACAAAAAAAAAAIA=="),s(t,81506,"IA=="),s(t,81522,"IAAAAAAAAAAg"),s(t,81618,"IA=="),s(t,81634,"IA=="),s(t,81650,"IAAAAAAAAAAg"),s(t,81682,"IAAAAAAAAAAgAAAAAAAAACAAAAAAAIAAAAAAAAAAgA=="),s(t,81728,"gAAAAAAAAACAAAAAAAAAAIA="),s(t,81760,"gAAAAAAAAACA"),s(t,81904,"gAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAAAU"),s(t,81961,"FAAAAAAAAAAU"),s(t,81985,"FAAAAAAAAAAE"),s(t,82009,"BAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABA="),s(t,82097,"EAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABA="),s(t,82169,"EAAAAAAAAAAQAAAAAAAAABAAAAAAAACA"),s(t,82224,"gAAAAAAAAACA"),s(t,82272,"gAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABA=="),s(t,82353,"BAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABA=="),s(t,82393,"BAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAQAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAABAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABA=="),s(t,82625,"BAAAAAAAAAAE"),s(t,82649,"BAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAQAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABA=="),s(t,83033,"BAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABA=="),s(t,83097,"BAAAAAAAAAAE"),s(t,83121,"BAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAQAAAEAAAAAFAAAAQAAAAgEAAABAAAAAQQAAAAAAAACBAAAAAAAAAgEAAAAAAAAAAQAAAAAAAAABAAAAQAAAAgEAAAAAAAAAQQAAAAAAAAARAAAAAAAAAAEAAAAAAAAAAQA=="),s(t,83288,"QA=="),s(t,83303,"AkAAAAAAAAAQQAAAEAAAAIBAAAAAAAAACEA="),s(t,83352,"QAAAAAAAABBAAAAQAAAAgAAg"),s(t,83379,"gAAAAABAAACQggAAIEAAAJAAAAAAAAAAgAAAAABAAACQggAAIEAAAJCCAAAgAAAAgAAAAAAAAACAAAAAAAAAAIAAAAAAQAAAkIIAACBAAACQggAAIEAAAJCCAAAgQAAAkAAAAEBAAACQAAAAYEAAAJCCAABgQAAAkIIAACBAAACQggAAIEAAAJCCAAAgQAAAkIIAACBAAACQggAAIAAAAIAAAAAEAAAAAAAAAIAAAAAAAAAACAAAAAAAAAAEAAAAAAAAACAAAAAAAAAAQAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAAkAAAAAAAAAQQAAAEAAAAIBAAAAAAAAABEAAAAAAAAAIAAAAgIIAAAAAAACAgAAAAAAAAIAAAAAAAAAAgIYAAAAAAACAhgAAAAAAAICAAAAAAAAAgIAAAAAAAACAggAAAAAAAICAAAAAAAAAgIAAAAAAAACAgAAAAAAAAICAAAAAAAAAgJIAAACAAACAggAAAIAAAICCAAAAAAAAgIIAAAAAAACAggAAAIAAAICCAAAAAAAAgIIAAAAAAACAggAAAAAAAICAAAAAAAAAgIAAAAAAAACAggAAAAAAAICGAAAAAAAAgIIAAAAAAACAhgAAAAAAAICCAAAAAAAAgIIAAAAAAACAggAAAAAAAICCAAAAAAAAgIAAAAAAAACAggAAAAAAAICAAAAAAAAAgIIAAAAAAACAggAAAAAAAICCAAAAAAAAgIAAAAAAAACAggAAAAAAAICGAAAAAAAAgJIAAAAAAACAhgAAAAAAAICAAAAAAAAAgIAAAAAAAACAhg=="),s(t,83999,"IAAAAACCAAAgAAAAAIIAAAAAAAAAggAAAAAAAACGAAAAAAAAAIIAAAAAAAAAggAAAAAAAACCAAAAaW5maW5pdHkALSsgICAwWDB4AHN0ZDo6YmFkX2Nhc3QAJXMlYyVzX2RpY3QAJXMlYyVzJWMlcyVzACVzJWNzb3VuZGljb25zJWMlcwBDb21waWxlIGVycm9yAHN0ZDo6ZXhjZXB0aW9uAHRlcm1pbmF0aW5nAF8wbGFuZwB1bmV4cGVjdGVkX2hhbmRsZXIgdW5leHBlY3RlZGx5IHJldHVybmVkACVkICVkICVkICVkICVkICVkICVkICVkICVkICVkACVzJWMlYwByYgBwaG9udGFiAHJ3YQBYWFhYWFgAR01UAExDX0FMTABFU1BFQUtfREFUQV9QQVRIAEMAQU5TSV9YMy40LTE5NjgAMy4xLjMwACEtLQBQdXJlIHZpcnR1YWwgZnVuY3Rpb24gY2FsbGVkIQAlcwoAZXNwZWFrOiBCYWQgaW50b25hdGlvbiBkYXRhCgAAAQIEBwMGBQAAAABAAAAAAAAAAHBob25pbmRleAAlcyVjJWMlcwAgJXMAc3RkOjpiYWRfZXhjZXB0aW9uAEVtc2NyaXB0ZW4AbmFuAD94bWwAJXMvLi4vcGhzb3VyY2UAc3RkOjpiYWRfdHlwZWlkAHRlcm1pbmF0ZV9oYW5kbGVyIHVuZXhwZWN0ZWRseSByZXR1cm5lZAAlZCAlZCAlZCAlZCAlZCAlZCAlZCAlZAByYgBXcm9uZyB2ZXJzaW9uIG9mIGVzcGVhay1uZy1kYXRhAEkATEFORwBIT01FAEFOU0lfWDMuNC0xOTg2AChudWxsKQBGYWlsZWQgdG8gb3BlbjogJyVzJwBEZWxldGVkIHZpcnR1YWwgZnVuY3Rpb24gY2FsbGVkIQBudW1iZXJzOiBCYWQgb3B0aW9uIG51bWJlciAlZAoAX2NhcABlbXNjcmlwdGVuAFRoZSBGSUZPIGJ1ZmZlciBpcyBmdWxsAGVzcGVhawAlZCAlZCAlZABzdGQ6OmJhZF9hbGxvYwAlYyVzJWMlcyVjAHBob25kYXRhAC91c3Ivc2hhcmUvZXNwZWFrLW5nLWRhdGEAL3RtcC9lc3BlYWtYWFhYWFgATABQU0FSSFRJVllNVUJGAEFTTU8tNzA4AEMuVVRGLTgAICgAJXM6IEJhZCBvcHRpb24gbnVtYmVyICVkCgBVbnN1cHBvcnRlZCBzcGVjdHJhbCBmaWxlIGZvcm1hdC4KAENhbid0IHJlYWQgZGljdGlvbmFyeSBmaWxlOiAnJXMnCgAtMFgrMFggMFgtMHgrMHggMHgAaW50b25hdGlvbnMAcGhvbmVtZXMAJXMgJXMgJXMgJXMgJXMgJXMAZW4AYmFkX2FycmF5X25ld19sZW5ndGgAbm9uZQBUaGUgZXNwZWFrLW5nIGxpYnJhcnkgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkACVjJWQAUE9TSVgATQBDLlVURi04AEVDTUEtMTE0ACMxAEVtcHR5IF9kaWN0IGZpbGU6ICclcwoAUmVwbGFjZTogJXMgPiAlcwoAICBzdWZmaXggWyVzXQoKACVzL3Bob25lbWVzACVzJXMlcwBicABhbGwAaW5mAENhbm5vdCBpbml0aWFsaXplIHRoZSBhdWRpbyBkZXZpY2UAJXMlY3ZvaWNlcyVjAE4ATlVMTABFQ01BLTExOABVVEYtOAB3YXNtMzIAZXNwZWFrOiBObyBlbnZlbG9wZQoAQmFkIGRhdGE6ICclcycgKCV4IGxlbmd0aD0leCkKAFRoZSBzcGVjaWZpZWQgZXNwZWFrLW5nIHZvaWNlIGRvZXMgbm90IGV4aXN0ACVzJXMAJXMlYyVzAF9jYXAAYmhmAHNvbWUAWwIlc11dAFAASU5GAEVMT1RfOTI4AGVuX1VTLlVURi04AF8jJWQgAENvbXBpbGluZyBwaG9uZW1lIGRhdGE6ICVzCgBGdWxsIGRpY3Rpb25hcnkgaXMgbm90IGluc3RhbGxlZCBmb3IgJyVzJwoAVW5rbm93biB0dW5lICclcycKACU1ZDoJAGR0AG5vAGVuAG5hbgBfcm9tYW4AQ291bGQgbm90IGxvYWQgdGhlIG1icm9sYS5kbGwgZmlsZQAlZCAlZAAlcyVjbGFuZyVjAHJiAFsCX15fJXMgJXMgX15fJXNdXQBTAF8/QQBJQk0zNjcAPyVkIAAlcyVjJXMAJXMvJXMAcgBpY29uAGVuAENvdWxkIG5vdCBsb2FkIHRoZSBzcGVjaWZpZWQgbWJyb2xhIHZvaWNlIGZpbGUAZ2MAWgBOQU4AXz8/ADxzYXktYXMgaW50ZXJwcmV0LWFzPSJ0dHM6Y2hhciI+JiMlZDs8L3NheS1hcz4ASUJNODE5ACogACAgJWQgJXMgICAgAEludmFsaWQgaW5zdHJ1Y3Rpb24gJS40eCBmb3IgcGhvbmVtZSAnJXMnCgAAcGhvbmRhdGEtbWFuaWZlc3QAVGhlIGV2ZW50IGJ1ZmZlciBpcyBmdWxsAHNwZWxsaW5nAF9saWcAY29uZmlnACVzL2VzcGVhay1uZy1kYXRhACVzJXNfAElTQ0lJAGhBAGwnZXRAAC4ALQAoJXMpAAElZEkgACV4AHcAJXNydWxlcy50eHQAKyVzAHIAXy5wAHBpdGNoAFRoZSByZXF1ZXN0ZWQgZnVuY3Rpb25hbGl0eSBoYXMgbm90IGJlZW4gYnVpbHQgaW50byBlc3BlYWstbmcAX3NtYwBDYwBtYgBJU09fNjQ2LmlydjoxOTkxAHYgPD0gdm93ZWxfY291bnQAVGhlIHBob25lbWUgZmlsZSBpcyBub3QgaW4gYSBzdXBwb3J0ZWQgZm9ybWF0AGNoYXJhY3RlcnMAJWMlcyVzJXMAICVzAF90dXIAZW4AQ2YAbmQAJXMgJWQASVNPXzg4NTktMQAjIFRoaXMgZmlsZSBsaXN0cyB0aGUgdHlwZSBvZiBkYXRhIHRoYXQgaGFzIGJlZW4gY29tcGlsZWQgaW50byB0aGUKIyBwaG9uZGF0YSBmaWxlCiMKIyBUaGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgbGluZSBpbmRpY2F0ZXMgdGhlIHR5cGUgb2YgZGF0YToKIyAgIFMgLSBBIFNQRUNUX1NFUSBzdHJ1Y3R1cmUKIyAgIFcgLSBBIHdhdmVmaWxlIHNlZ21lbnQKIyAgIEUgLSBBbiBlbnZlbG9wZQojCiMgQWRkcmVzcyBpcyB0aGUgZGlzcGxhY2VtZW50IHdpdGhpbiBwaG9uZGF0YSBvZiB0aGlzIGl0ZW0KIwojICBBZGRyZXNzICBEYXRhIGZpbGUKIyAgLS0tLS0tLSAgLS0tLS0tLS0tCgBfcmV2AHZhcmlhbnQAJXNydWxlcwB0dHM6Y2hhcgBzb3VuZGljb24AQ24AX2VsAG5nAHNyYy9saWJlc3BlYWstbmcvZGljdGlvbmFyeS5jAF9zdWIAcGhvbmRhdGEAVGhlIHNwZWN0cmFsIGZpbGUgZG9lcyBub3QgY29udGFpbiBhbnkgZnJhbWUgZGF0YQABKzEwUwBJU09fODg1OS0xOjE5ODcAdHRzOmtleQAlcyVjJXNfZGljdAB0cwBUaGUgcGhvbmVtZSBtYW5pZmVzdCBmaWxlIGRvZXMgbm90IGNvbnRhaW4gYW55IHBob25lbWVzAF8lYyAlcwBfY3lyAF9zdXAAQ28AX2NybAB3YgAgAS0xMFMASVNPXzg4NTktMgAtAFVucHJvbm91bmNhYmxlPyAnJXMnCgBfaHkAcGhvbmluZGV4AF9hY3UAdHRzOmRpZ2l0cwBDcwAgJXMgJWQgJXMAJ2U6agBhcG9zdHJvcGhlAFRoZSBwaG9uZW1lIGZlYXR1cmUgaXMgbm90IHJlY29nbmlzZWQAdEEASVNPXzg4NTktMjoxOTg3AHdiKwBUcmFuc2xhdGUgJyVzJwoAX2JydgBicmFja2V0cwAlY2VuAElpAHRlbGVwaG9uZQBfaGUAVGhlIHRleHQgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZAAlZCAlZABwaG9udGFiAFsCKFgxKShYMSkoWDEpXV0AbkEAYidpOgBJU09fODg1OS0zAFVzaW5nIHBob25lbWV0YWJsZTogJyVzJwoAVW5zcGVjaWZpZWQgZXJyb3IgMHgleAByb290cwBnbHlwaHMAJWMlcwBfYXIATGwAJXMvY29tcGlsZV9wcm9nX2xvZwBicmFja2V0c0Fubm91bmNlZAAlZABfaGFjAF9eXwBzJ2k6AElTT184ODU5LTM6MTk4OABsaXN0AGRpY3RfbWluAGVuAExtAHgtd2VhawBiYXNlAF9jZWQAX3N5YwBkJ2k6AElTT184ODU5LTQAQmFkIHZvaWNlIGF0dHJpYnV0ZTogJXMKAEVycm9yIHByb2Nlc3NpbmcgZmlsZSAnJXMnOiAlcy4KAGxpc3R4AGRpY3RydWxlcwBfY2lyAExvAHdlYWsAX2hpACdpOgBJU09fODg1OS00OjE5ODgAJXMgAEludmFsaWQgcGhvbmVtZSBjb2RlICVkCgAKUmVmcyAlZCwgIFJldXNlZCAlZAoARXJyb3I6ICVzIGF0ICclcycgKGV4cGVjdGVkIDB4JXgsIGdvdCAweCV4KS4KAFVua25vd24gcGhvbmVtZSB0YWJsZTogJyVzJwoATHQAJWMlcwBpbnRvbmF0aW9uAF9ibgBtZWRpdW0AZW1vamkAJ2VmAF9kaWEASVNPXzg4NTktNQBSZXBsYWNlOiAlcyAgJXMKAENvbXBpbGVkIHBob25lbWVzOiAlZCBlcnJvcnMuCgBFcnJvcjogJXMuCgBoc3gATHUAJXMvLi4vcGhzb3VyY2UvaW50b25hdGlvbi50eHQAbF9kaWVyZXNpcwAlcyslcwBfZ3VyAGlvbgBzdHJvbmcAZXh0cmEASVNPXzg4NTktNToxOTg4AF9hYzIAbF9wcmVmaXgAX2d1AF9kb3QAJXMlY3ZvaWNlcwByAHgtc3Ryb25nAE1jAElTT184ODU5LTYAQ29tcGlsaW5nOiAnJXMnCgBfZ3J2AGxfcmVncmVzc2l2ZV92AHJzAF9vcgAlcy8uLi9waHNvdXJjZS9pbnRvbmF0aW9uACVzJWNsYW5nAE1lAHJlZHVjZWQASVNPXzg4NTktNjoxOTg3ACQxAGlyAF9tY24ATW4AbW9kZXJhdGUAdHVuZQBsX3VucHJvbm91bmNhYmxlAF90YQBJU09fODg1OS03ACQyAG1iLwAlcy9pbnRvbmF0aW9ucwB1cgBfb2dvAGxfc29ub3JhbnRfbWluAHJhdGUAX3RlAE5kAElTT184ODU5LTc6MTk4NwAkMwAvLwBfa24ATmwAYXRoAF9ybmcAdm9sdW1lAGFwb3N0cm9waGUAbG93ZXJjYXNlU2VudGVuY2UASVNPXzg4NTktOAAkNABEdXBsaWNhdGUgdHVuZSBuYW1lOiAnJXMnAGJyYWNrZXRzAG51bWJlcnMAbnMATm8AX21sAF9zdGsAcmFuZ2UAQmFkIHR1bmUgbmFtZTogJyVzOwBJU09fODg1OS04OjE5ODgAJDUAc3BlbGxpbmdTdHJlc3MAX3NpAF90bGQAZmllbGQAYnJhY2tldHNBbm5vdW5jZWQAUGMASVNPXzg4NTktOQAkNgBCYWQgZW52ZWxvcGUgbmFtZTogJyVzJwBfYmFyAGRpY3RfbWluAF90aABzcG9uZwBtb2RlAFR1bmUgJyVzJyBub3QgZm91bmQAc3RyZXNzQWRkAFBkAElTT184ODU5LTk6MTk4OQAkNwBfcmZ4ACR1AGRpY3RydWxlcwBzdHJlc3NBbXAAX2xvAHB1bmN0dWF0aW9uAHJhbmcAUGUASVNPXzg4NTktMTAAVW5leHBlY3RlZDogJyVzJwBjYXBpdGFsX2xldHRlcnMAaW50b25hdGlvbgBfaG9rAF90aQBzdHJlc3NMZW5ndGgAbGFyZwBQZgBUdW5lICclcycgbm90IGRlZmluZWQASVNPXzg4NTktMTA6MTk5MgAkdTEAX215AHN0cmVzc09wdABsX2RpZXJlc2lzAF8jJXMAbGV2ZWwAUGkASVNPXzg4NTktMTQAJHUyAGFkZCBlCgBDb21waWxlZCAlZCBpbnRvbmF0aW9uIHR1bmVzOiAlZCBlcnJvcnMuCgBsX3ByZWZpeABhbHBoYWJldABUb28gbWFueSBwaG9uZW1ldGFibGVzAF94IyVzAFBvAHN0cmVzc1J1bGUAX2thAElTT184ODU5LTE0OjE5OTgAJHUzAE91dCBvZiBtZW1vcnkAbF9yZWdyZXNzaXZlX3YAdHVuZXMAUHMAX2tvAHBoAElTT184ODU5LTE1AF8wACR1KwBfZHB0AHdvcmRzAGludGVycHJldC1hcwBfZXRoAGxfdW5wcm9ub3VuY2FibGUAU2MAXwBJU09fODg1OS0xNgAkdTErAEJhZCBydWxlcyBkYXRhIGluICclc19kaWN0JyBhdCAweCV4ICglYykKAGZvcm1hdABsX3Nvbm9yYW50X21pbgBTawBfYnJhaWxsZQBfME0lZABJU09fODg1OS0xNjoyMDAxACR1MisAQ2FuJ3QgZmluZCBiYXNlIHBob25lbWV0YWJsZSAnJXMnACUzZAklcyBbJXNdCgBDYW5ub3Qgc2V0ICVzOiBsYW5ndWFnZSBub3Qgc2V0LCBvciBpcyBpbnZhbGlkLgoAU20AZGV0YWlsAGxvd2VyY2FzZVNlbnRlbmNlAF9qYQBJU082NDYtVVMAXy4AJHUzKwBfAQBudW1iZXJzAFNvAF8lZG4AX3poACRwYXVzZQAlYyVkWQBwaG9uZW1lX2xlbiA8IE5fUEhPTkVNRV9CWVRFUwBJU08tMTA2NDYtVUNTLTIAJQBzcGVsbGluZ1N0cmVzcwBhbGlhcwBabAAkc3RyZW5kAElTTy04ODU5LTEAJSUARmxhZ3M6ICAlcyAgJXMKACVzJXMlYyVzJXMAWnAAbmFtZQBzdHJlc3NBZGQAJHN0cmVuZDIASVNPLTg4NTktMgAsAEZvdW5kOiAnJXMgJXMKAFpzACVzJXMlcyVjJXMARm91bmQ6ICclcwBzdHJlc3NBbXAAJHVuc3RyZXNzZW5kACVjJWRNAElTTy04ODU5LTMALCwAc3RyZXNzTGVuZ3RoACRhY2NlbnRfYmVmb3JlAF8wWiVkAHNyYwBJU08tODg1OS00AC0tACcAJyBbJXNdICAlcwoAJGFiYnJldgBzdHJlc3NPcHQAJXMvJXMAQWRsbQBfJWNkAElTTy04ODU5LTUAJycAJWMlcwBBZmFrAHN0cmVzc1J1bGUAJGRvdWJsZQAlYyVkSQA9AElTTy04ODU5LTYAJGFsdAB0dW5lcwBBZ2hiACVjJWRVAF86AElTTy04ODU5LTcAX2RwdDIA2Y4gINmPICDZkAB3b3JkcwBfJWRNJWRvAEFob20Ac3RyZW5ndGgASVNPLTg4NTktOAAkYWx0MQBfIQDYpyDZiCDZigBuYW1lAF8lZE0lZGUAQXJhYgAlYyVkQgA6AElTTy04ODU5LTkAJGFsdDIA2Kgg2b4g2Kog2Kkg2Ksg2Kwg2K0g2K4g2K8g2LAg2LEg2LIg2LMg2LQg2LUg2LYg2Lcg2Lgg2Lkg2Log2YEg2YIg2YMg2YQg2YUg2YYg2KYg2KQg2KEg2KMg2KIg2KUg2YcAXyVkTSVkeABBcm1pAHRpbWUAbGFuZ3VhZ2UAQAAkYWx0MwBJU08tODg1OS0xMADYtSDYtiDYtyDYuABnZW5kZXIAQXJtbgB4bWw6YmFzZQBfJWRNJWQAJGFsdDQASVNPLTg4NTktMTEAQC0AfHwAJXgAQXZzdAB2YXJpYW50cwBfMG9mACRhbHQ1AElTTy04ODU5LTEzACDZkSAAZm9ybWFudABfJXMlZG8AQmFsaQAlZAAkYWx0NgBJU08tODg1OS0xNAAxAEJhbXUAc3BlYWsAcGl0Y2gAXyVzJWRlACRhbHQ3AElTTy04ODU5LTE1ACNYMQBfJXMlZHgAQmFzcwBwaG9uZW1lcwAkY29tYmluZQB2b2ljZQA/AElTTy04ODU5LTE2AGRpY3Rpb25hcnkAcHJvc29keQAkZG90AEJhdGsAXyVzJWQAS09JOC1SAC0AJGhhc2RvdABzYXktYXMAQmVuZwByZXBsYWNlAF9eXwBMYXRpbi05AF8wTTIAQmhrcwBlY2hvAG1hcmsAJG1heDMAX1gxAF8lZE0xAFRJUy02MjAAX3wAQmxpcwBmbHV0dGVyACRicmsAVVMtQVNDSUkAXzBNMQAkdGV4dAByb3VnaG5lc3MAJXMlcwBwAEJvcG8AXzo6AFVURi04AGNsYXJpdHkAQnJhaAAkdmVyYmYAcGhvbmVtZQAxTUEAY3AzNjcAdCMAQnJhaQAkdmVyYnNmAHRvbmUAc3ViADBNQQBjcDgxOQAnIQBCdWdpAHZvaWNpbmcAJG5vdW5mAHR0czpzdHlsZQBfO18AY3NBU0NJSQAwTUIAYXVkaW8AYnJlYXRoACRwYXN0ZgBCdWhkADFNACNAAGNzSVNPODg1OTEzAGJyZWF0aHcAZW1waGFzaXMAQ2FrbQAkdmVyYgAjYQAwTQBjc0lTTzg4NTkxNABDYW5zAF8wQ28AJG5vdW4AYnJlYWsAI2UAbWJyb2xhAGNzSVNPODg1OTE1ACRwYXN0AGNvbnNvbmFudHMAQ2FyaQAjaQBtZXRhZGF0YQBjc0lTTzg4NTkxNgBfMEMwAGtsYXR0AGJyACNvAENoYW0AJHZlcmJleHRlbmQAXzBDAGNzSVNPTGF0aW4xACN1AENoZXIAJGNhcGl0YWwAbGkAJXMlYyVzJWMAZmFzdF90ZXN0MgBjc0lTT0xhdGluMgBDaXJ0ACRhbGxjYXBzAE1pc3NpbmcgZmlsZTogJXMAXzBhbmQAc3BlZWQAZGQAY3NJU09MYXRpbjMAQ29wdAAkYWNjZW50AG1haW50YWluZXIAXyVkQ28AcGhvbmVtZXRhYmxlIGlzIG1pc3NpbmcAaW1nAGNzSVNPTGF0aW40AENwcnQAc3RhdHVzACRzZW50ZW5jZQB0ZABLZXl3b3JkICdwaG9uZW1lJyBleHBlY3RlZABjc0lTT0xhdGluNQBfJWRDMAAkb25seQBUb28gbWFueSBwcm9jZWR1cmVzAEN5cmwAbWFsZQBfJWRDAGNzSVNPTGF0aW42AGgxACRvbmx5cwBDeXJzACVzJXMlcyVzAGZlbWFsZQBjc0lTT0xhdGluQXJhYmljACUuM2RQAGgyACVzJXMlYyVzACRzdGVtAE1pc3NpbmcgJ2VuZHBob25lbWUnIGJlZm9yZSBlbmQtb2YtZmlsZQAlZCAlZCAlZCAlZCAlZABjc0lTT0xhdGluQ3lyaWxsaWMARGV2YQBoMwBfJWRmeABNb3JlIHRoYW4gb25lIHBob25lbWUgdHlwZTogJXMARG9ncgBjc0lTT0xhdGluR3JlZWsAJGF0ZW5kAE5VTEwAaDQAY3NJU09MYXRpbkhlYnJldwBEc3J0ACRhdHN0YXJ0ACVkICVzICVzAGhyAF8lZGYATlVMTABfJWQlY3gAc2NyaXB0AER1cGwAJG5hdGl2ZQAhdiVjAGNzS09JOFIAJXgAc3R5bGUARWd5ZAAlc20lZABfJWQlYwAkPwBjc1RJUzYyMABmb250AEVneWgAYSBwaG9uZW1lIHR5cGUgb3IgbWFubmVyIG9mIGFydGljdWxhdGlvbiBtdXN0IGJlIHNwZWNpZmllZCBiZWZvcmUgc3RhcnR0eXBlACR0ZXh0bW9kZQBfJWRlACVzZiVkAGNzVVRGOAAlcy92b2ljZXMvJXMARWd5cABfJWRvAGEgcGhvbmVtZSB0eXBlIG9yIG1hbm5lciBvZiBhcnRpY3VsYXRpb24gbXVzdCBiZSBzcGVjaWZpZWQgYmVmb3JlIGVuZHR5cGUAJHBob25lbWVtb2RlAGNzVW5pY29kZQBiAGVuZHR5cGUgbXVzdCBlcXVhbCBzdGFydHR5cGUgZm9yIGNvbnNvbmFudHMAdW5wcgBhbGwAaQBhcmFiaWMAXyVkYQBFbGJhAG5vcHJlZml4AHZvaWNpbmdzd2l0Y2ggY2Fubm90IGJlIHVzZWQgb24gdm93ZWxzAGVtAEV0aGkAXyVkAGN5cmlsbGljAHN0cmVzcyBwaG9uZW1lcyBjYW4ndCBjb250YWluIHByb2dyYW0gaW5zdHJ1Y3Rpb25zAEdlb2sAZ3JlZWsAY29kZQBfJWRYJWMAd19hbHQxAFdhcm5pbmc6IG1heGltdW0gbnVtYmVyICVkIG9mIChOX1ZPSUNFU19MSVNUID0gJWQgLSAxKSByZWFjaGVkCgAlcyVjJXMAR2VvcgBfJWRYZgAlYyVkJWMAZ3JlZWs4AHdfYWx0MgBNaXNzaW5nICdlbmRwaG9uZW1lJyBiZWZvcmUgJyVzJwBoZWJyZXcAZGVmYXVsdABHbGFnAF8lZFgATWlzc2luZyBFTkRJRgB3X2FsdDMARXJyb3IgKCVzKTogZ2VuZGVyIGF0dHJpYnV0ZSBzcGVjaWZpZWQgb24gYSBsYW5ndWFnZSBmaWxlCgBzaWxlbnQAR29uZwAnZW5kcGhvbmVtZScgbm90IGV4cGVjdGVkIGhlcmUAaXNvLWNlbHRpYwB3X2FsdDQAX29yZDIwAHgtc29mdABHb25tAFBob25lbWUgdHlwZSBpcyBtaXNzaW5nAF9vcmQAaXNvLWlyLTYAd19hbHQ1AHNvZnQAR290aAB3X2FsdDYAaXNvLWlyLTEwMABCYWQgcGhvbmVtZSBuYW1lICclcycAd19hbHQAJXMlcyVzAEdyYW4AbG91ZABpc28taXItMTAxACVzOiAnJXMnLgBHcmVrAHgtbG91ZABpc28taXItMTA5AHBfYWx0MQB4LXNsb3cAR3VqcgBwX2FsdDIAaXNvLWlyLTExMABFeHBlY3RlZCAnKCcAc2xvdwBHdXJ1AGlzby1pci0xMjYAcF9hbHQzAEV4cGVjdGVkICcpJwBmYXN0AEhhbmcAVmFsdWUgJWQgaXMgZ3JlYXRlciB0aGFuIG1heGltdW0gJWQAaXNvLWlyLTEyNwBwX2FsdDQAeC1mYXN0AEhhbmkAaXNvLWlyLTEzOABwX2FsdDUAQ2Fubm90IGZpbmQgcGhvbmVtZSAnJXMnIHRvIGltcG9ydC4AeC1sb3cASGFubwBwX2FsdDYAaXNvLWlyLTE0NABQaG9uZW1lIGltcG9ydCB3aWxsIG92ZXJyaWRlIHNldCBwcm9wZXJ0aWVzLgBsb3cAcF9hbHQASGFucwBpc28taXItMTQ4AFBob25lbWUgcmVmZXJlbmNlIG5vdCBmb3VuZDogJyVzJwAlcyVzLnR4dABIYW50AGhpZ2gAaXNvLWlyLTE1NwBjb21waWxlOiB1bmtub3duIHBob25lbWUgdGFibGU6ICclcycAJXMlcwBIYXRyAHgtaGlnaABQaG9uZW1lIHByb2dyYW0gdG9vIGxhcmdlAGlzby1pci0xOTkASGVicgBpc28taXItMjI2AEV4cGVjdGVkIGEgY29uZGl0aW9uLCBub3QgJyVzJwBzcGFjZSAAQ2FuJ3QgYWxsb2NhdGUgbWVtb3J5CgBFeHBlY3RlZCBsaXN0IG9mIHN0cmVzcyBsZXZlbHMASGlyYQBsYXRpbjEAdGFiIAAJJWQgZW50cmllcwoASGx1dwBsYXRpbjIAVW5leHBlY3RlZCBrZXl3b3JkICclcycAdW5kZXJzY29yZSAAJTVkOiBVbmtub3duIGtleXdvcmQ6ICVzCgBIbW5nAHBob25lbWUAbGF0aW4zAGRvdWJsZS1xdW90ZSAAJTVkOiBNaXNzaW5nICcoJwoASHJrdABlbmRwaG9uZW1lAG1hbGUAbGF0aW40AEh1bmcAZmVtYWxlAEV4cGVjdGVkIEFORCwgT1IsIFRIRU4AbGF0aW41ACU1ZDogTmVlZCB0byBjb21waWxlIGRpY3Rpb25hcnkgYWdhaW4KAEluZHMAbmV1dHJhbABFTFNFIG5vdCBleHBlY3RlZABsYXRpbjYAJTVkOiBCYWQgcGhvbmVtZSBbJXNdIChVKyV4KSBpbjogJXMgICVzCgBVKyV4AEl0YWwASUYgYmxvY2sgaXMgdG9vIGxvbmcAeG1sOmxhbmcAbGF0aW44AHZhcmlhbnQARUxJRiBub3QgZXhwZWN0ZWQASmF2YQBsYXRpbjEwACU1ZDogRGljdGlvbmFyeSBsaW5lIGxlbmd0aCB3b3VsZCBvdmVyZmxvdyB0aGUgZGF0YSBidWZmZXI6ICVkCgBKcGFuAGFnZQBFTkRJRiBub3QgZXhwZWN0ZWQAbDEAJTVkOiBUd28gbWFueSBwYXJ0cyBpbiBhIG11bHRpLXdvcmQgZW50cnk6ICVkCgBnZW5kZXIASnVyYwBQYXJhbWV0ZXIgPiAxMjcAbDIALy8AJXMrJXMAS2FsaQAuTABQYXJhbWV0ZXIgPCAtMTI4AGwzAGd0AC5yZXBsYWNlAEthbmEAUGFyYW1ldGVyID4gMjU1AGw0AGx0AEtoYXIALmdyb3VwAERGVABsNQAweCV4ACVzLyVzLndhdgBLaG1yAGFtcABsNgBxdW90AENhbid0IHJlYWQgZmlsZTogJXMAS2hvagBsOAAlNWQ6IEdyb3VwIG5hbWUgbG9uZ2VyIHRoYW4gMiBieXRlcyAoVVRGOCkARmlsZSBub3QgU1BFQyBvciBSSUZGOiAlcwBuYnNwAEtuZGEAbDEwAApFeGNlZWRlZCBsaW1pdCBvZiBydWxlcyAoJWQpIGluIGdyb3VwICclcycKAHVzAGFwb3MAS29yZQAlYyAgMHglLjV4ICAlcwoAAMDg8P8fDwdwCnEKAAAoACkAWwBdAHsAfQA8AD4AIgAnAGAAqwC7AAowCzA84A=="),s(t,93904,"ICAgICAgICAgICYlKyNTRFpBTCEgQD9KTktWP1RYP1dBQkNIRkdZPT0sLCcqICAAIAAhACIAsAIkACUA5gDIAigAKQB+AisAzAItAC4ALwBSAjEAMgBcAjQANQA2ADcAdQI5ANACsgI8AD0APgCUAlkCUQKyA+cA8ABbAkYAYgInAWoCXwJLAGsCcQJLAVQCpgNjAoACgwK4A4oCjAJTAccD+ACSAioDXABdAF4AXwBgAGEAYgBjAGQAZQBmAGECaABpAGoAawBsAG0AbgBvAHAAcQByAHMAdAB1AHYAdwB4AHkAegB7AHwAfQADA38APT0sLCcnAAMCBAUGBxoAAAAAAQECAwMEBQYHBwgJCgsAAAEBAgIDAwQFBgcHCAkKAAABAgMDAwQFBgcHBwgJClNldFdvcmRTdHJlc3MA5ADrAO8A9gD8AP8AAAAAAAAAYWFhYWFhYWNlZWVlaWlpaWRub29vb28Ab3V1dXV5dHNhYWFhYWFhY2VlZWVpaWlpZG5vb29vbwBvdXV1dXl0eWFhYWFhYWNjY2NjY2NjZGRkZGVlZWVlZWVlZWVnZ2dnZ2dnZ2hoaGhpaWlpaWlpaWlpaWlqamtra2xsbGxsbGxsbGxubm5ubm5ubm5vb29vb29vb3JycnJycnNzc3Nzc3NzdHR0dHR0dXV1dXV1dXV1dXV1d3d5eXl6enp6enpzYmJiYgAAb2NjZGRkZGRlZWVmZmdnaGlpa2tsbG1ubm9vb29vcHB5AABzc3R0dHR1dXV2eXl6enp6enp6AAAAd3R0dGtkZGRsbGxubm5hYWlpb291dXV1dXV1dXV1ZWFhYWFhYWdnZ2dra29vb296empkZGRnZ3d3bm5hYWFhb29hYWFhZWVlZWlpaWlvb29vcnJycnV1dXVzc3R0eXloaG5kb296emFhZWVvb29vb29vb3l5bG50amRxYWNjbHRzegAAYnV2ZWVqanFxcnJ5eWFhYWJvY2RkZWVlZWVl"),s(t,94846,"TG9va3VwRGljdDIAAAAAAAAAgACBAIIAgwCEAIUAhgCHAIgAiQCKAIsAjACNAI4AjwCQAJEAkgCTAJQAlQCWAJcAmACZAJoAmwCcAJ0AngCfAKAAoQCiAKMApAClAKYApwCoAKkAqgCrAKwArQCuAK8AsACxALIAswC0ALUAtgC3ALgAuQC6ALsAvAC9AL4AvwDAAMEAwgDDAMQAxQDGAMcAyADJAMoAywDMAM0AzgDPANAA0QDSANMA1ADVANYA1wDYANkA2gDbANwA3QDeAN8A4ADhAOIA4wDkAOUA5gDnAOgA6QDqAOsA7ADtAO4A7wDwAPEA8gDzAPQA9QD2APcA+AD5APoA+wD8AP0A/gD/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAAQB2AJBAaQAPQFaAacAqABgAV4BZAF5Aa0AfQF7AbAABQHbAkIBtAA+AVsBxwK4AGEBXwFlAXoB3QJ+AXwBVAHBAMIAAgHEADkBBgHHAAwByQAYAcsAGgHNAM4ADgEQAUMBRwHTANQAUAHWANcAWAFuAdoAcAHcAN0AYgHfAFUB4QDiAAMB5AA6AQcB5wANAekAGQHrABsB7QDuAA8BEQFEAUgB8wD0AFEB9gD3AFkBbwH6AHEB/AD9AGMB2QKAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAAmAdgCowCkAP3/JAGnAKgAMAFeAR4BNAGtAP3/ewGwACcBsgCzALQAtQAlAbcAuAAxAV8BHwE1Ab0A/f98AcAAwQDCAP3/xAAKAQgBxwDIAMkAygDLAMwAzQDOAM8A/f/RANIA0wDUACAB1gDXABwB2QDaANsA3ABsAVwB3wDgAOEA4gD9/+QACwEJAecA6ADpAOoA6wDsAO0A7gDvAP3/8QDyAPMA9AAhAfYA9wAdAfkA+gD7APwAbQFdAdkCgACBAIIAgwCEAIUAhgCHAIgAiQCKAIsAjACNAI4AjwCQAJEAkgCTAJQAlQCWAJcAmACZAJoAmwCcAJ0AngCfAKAABAE4AVYBpAAoATsBpwCoAGABEgEiAWYBrQB9Aa8AsAAFAdsCVwG0ACkBPAHHArgAYQETASMBZwFKAX4BSwEAAcEAwgDDAMQAxQDGAC4BDAHJABgBywAWAc0AzgAqARABRQFMATYB1ADVANYA1wDYAHIB2gDbANwAaAFqAd8AAQHhAOIA4wDkAOUA5gAvAQ0B6QAZAesAFwHtAO4AKwERAUYBTQE3AfQA9QD2APcA+ABzAfoA+wD8AGkBawHZAoAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAAEEAgQDBAQEBQQGBAcECAQJBAoECwQMBK0ADgQPBBAEEQQSBBMEFAQVBBYEFwQYBBkEGgQbBBwEHQQeBB8EIAQhBCIEIwQkBCUEJgQnBCgEKQQqBCsELAQtBC4ELwQwBDEEMgQzBDQENQQ2BDcEOAQ5BDoEOwQ8BD0EPgQ/BEAEQQRCBEMERARFBEYERwRIBEkESgRLBEwETQROBE8EFiFRBFIEUwRUBFUEVgRXBFgEWQRaBFsEXASnAF4EXwSAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAD9//3//f+kAP3//f/9//3//f/9//3/DAatAP3//f/9//3//f/9//3//f/9//3//f/9//3/Gwb9//3//f8fBv3/IQYiBiMGJAYlBiYGJwYoBikGKgYrBiwGLQYuBi8GMAYxBjIGMwY0BjUGNgY3BjgGOQY6Bv3//f/9//3//f9ABkEGQgZDBkQGRQZGBkcGSAZJBkoGSwZMBk0GTgZPBlAGUQZSBv3//f/9//3//f/9//3//f/9//3//f/9//3/gACBAIIAgwCEAIUAhgCHAIgAiQCKAIsAjACNAI4AjwCQAJEAkgCTAJQAlQCWAJcAmACZAJoAmwCcAJ0AngCfAKAAGCAZIKMArCCvIKYApwCoAKkAegOrAKwArQD9/xUgsACxALIAswCEA4UDhgO3AIgDiQOKA7sAjAO9AI4DjwOQA5EDkgOTA5QDlQOWA5cDmAOZA5oDmwOcA50DngOfA6ADoQP9/6MDpAOlA6YDpwOoA6kDqgOrA6wDrQOuA68DsAOxA7IDswO0A7UDtgO3A7gDuQO6A7sDvAO9A74DvwPAA8EDwgPDA8QDxQPGA8cDyAPJA8oDywPMA80DzgP9/4AAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAP3/ogCjAKQApQCmAKcAqACpANcAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkA9wC7ALwAvQC+AP3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f8XINAF0QXSBdMF1AXVBdYF1wXYBdkF2gXbBdwF3QXeBd8F4AXhBeIF4wXkBeUF5gXnBegF6QXqBf3//f8OIA8g/f+AAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8AHgHRANIA0wDUANUA1gDXANgA2QDaANsA3AAwAV4B3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAB8B8QDyAPMA9AD1APYA9wD4APkA+gD7APwAMQFfAf8AgACBAIIAgwCEAIUAhgCHAIgAiQCKAIsAjACNAI4AjwCQAJEAkgCTAJQAlQCWAJcAmACZAJoAmwCcAJ0AngCfAKAABAESASIBKgEoATYBpwA7ARABYAFmAX0BrQBqAUoBsAAFARMBIwErASkBNwG3ADwBEQFhAWcBfgEVIGsBSwEAAcEAwgDDAMQAxQDGAC4BDAHJABgBywAWAc0AzgDPANAARQFMAdMA1ADVANYAaAHYAHIB2gDbANwA3QDeAN8AAQHhAOIA4wDkAOUA5gAvAQ0B6QAZAesAFwHtAO4A7wDwAEYBTQHzAPQA9QD2AGkB+ABzAfoA+wD8AP0A/gA4AYAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAAEOAg4DDgQOBQ4GDgcOCA4JDgoOCw4MDg0ODg4PDhAOEQ4SDhMOFA4VDhYOFw4YDhkOGg4bDhwOHQ4eDh8OIA4hDiIOIw4kDiUOJg4nDigOKQ4qDisOLA4tDi4OLw4wDjEOMg4zDjQONQ42DjcOOA45DjoO/f/9//3//f8/DkAOQQ5CDkMORA5FDkYORw5IDkkOSg5LDkwOTQ5ODk8OUA5RDlIOUw5UDlUOVg5XDlgOWQ5aDlsO/f/9//3//f+AAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAAdIKIAowCkAB4gpgCnANgAqQBWAasArACtAK4AxgCwALEAsgCzABwgtQC2ALcA+AC5AFcBuwC8AL0AvgDmAAQBLgEAAQYBxADFABgBEgEMAckAeQEWASIBNgEqATsBYAFDAUUB0wBMAdUA1gDXAHIBQQFaAWoB3AB7AX0B3wAFAS8BAQEHAeQA5QAZARMBDQHpAHoBFwEjATcBKwE8AWEBRAFGAfMATQH1APYA9wBzAUIBWwFrAfwAfAF+ARkggACBAIIAgwCEAIUAhgCHAIgAiQCKAIsAjACNAI4AjwCQAJEAkgCTAJQAlQCWAJcAmACZAJoAmwCcAJ0AngCfAKAAAh4DHqMACgELAQoepwCAHqkAgh4LHvIerQCuAHgBHh4fHiABIQFAHkEetgBWHoEeVx6DHmAe8x6EHoUeYR7AAMEAwgDDAMQAxQDGAMcAyADJAMoAywDMAM0AzgDPAHQB0QDSANMA1ADVANYAah7YANkA2gDbANwA3QB2Ad8A4ADhAOIA4wDkAOUA5gDnAOgA6QDqAOsA7ADtAO4A7wB1AfEA8gDzAPQA9QD2AGse+AD5APoA+wD8AP0AdwH/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKwgpQBgAacAYQGpAKoAqwCsAK0ArgCvALAAsQCyALMAfQG1ALYAtwB+AbkAugC7AFIBUwF4Ab8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAAEAQUBQQGsIB4gYAGnAGEBqQAYAqsAeQGtAHoBewGwALEADAFCAX0BHSC2ALcAfgENARkCuwBSAVMBeAF8AcAAwQDCAAIBxAAGAcYAxwDIAMkAygDLAMwAzQDOAM8AEAFDAdIA0wDUAFAB1gBaAXAB2QDaANsA3AAYARoC3wDgAOEA4gADAeQABwHmAOcA6ADpAOoA6wDsAO0A7gDvABEBRAHyAPMA9ABRAfYAWwFxAfkA+gD7APwAGQEbAv8AgACBAIIAgwCEAIUAhgCHAIgAiQCKAIsAjACNAI4AjwCQAJEAkgCTAJQAlQCWAJcAmACZAJoAmwCcAJ0AngCfAKAABAEFAUEBrCAeIGABpwBhAakAGAKrAHkBrQB6AXsBsACxAAwBQgF9AR0gtgC3AH4BDQEZArsAUgFTAXgBfAHAAMEAwgACAcQABgHGAMcAyADJAMoAywDMAM0AzgDPABABQwHSANMA1ABQAdYAWgFwAdkA2gDbANwAGAEaAt8A4ADhAOIAAwHkAAcB5gDnAOgA6QDqAOsA7ADtAO4A7wARAUQB8gDzAPQAUQH2AFsBcQH5APoA+wD8ABkBGwL/AP3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9/wEJAgkDCQUJBgkHCQgJCQkKCQsJDgkPCRAJDQkSCRMJFAkRCRUJFgkXCRgJGQkaCRsJHAkdCR4JHwkgCSEJIgkjCSQJJQkmCScJKAkpCSoJKwksCS0JLgkvCV8JMAkxCTIJMwk0CTUJNgk3CTgJOQkgAD4JPwlACUEJQglDCUYJRwlICUUJSglLCUwJSQlNCTwJZAn9//3//f/9//3/IAAwADEAMgAzADQANQA2ADcAOAA5AP3//f/9//3//f8CAAAAAAAAAAEAAAADAAAA//36+Pb08vDu7Oro5uTi4N7c2tjW1NLQzszKyMbEwsC+vLq4trSysK6sqqimpKKgnpyamJaUkpCOjIqIhoSCgH58enh2dHJwbmxqaGZkYmBeXFpYVlRSUE5MSkhGREJAPjw6ODY0MjAuLCooJiQiIB4cGhgWFBIQDgwKCAYEAgAAAgQGCAoMDhASFBYYGhweICIkJigqLC4wMjQ2ODo8PkBCREZISkxOUFJUVlhaXF5gYmRmaGpsbnBydHZ4enx+gIKEhoiKjI6QkpSWmJqcnqCipKaoqqyusLK0tri6vL7AwsTGyMrMztDS1NbY2tze4OLk5ujq7O7w8vT2+Pr9///06uDWzMO6saifl4+Hf3hxamNcVlBKRD85NC8rJiIeGhcTEA0LCAYEAgEAAAAAAAAAAQIDBAUHCAoMDhATFRcaHR8iJSgsLjAyNDY5Oz1AQkVHSkxPUVRXWl1fYmVoa25xdHh7foGFiIuPkpaZnaCkqKyvs7e7v8PHy8/T19vgz8zJxsPAvbm0sKunopyXkoyGgXt1b2ljXVdQSkQ+ODMtJyIcFxINCAQCAgEAAAAAAAEBAgMEBQcICgwNDxIUFhkbHiEkJyotMDQ2ODo8P0FDRkhLTVBSVVhaXWBjZmlsb3J1eHt+gYWIi4+SlpmdoKSorK+zt7u/w8fLz9PX2+D/+fTu6eTf2tXQy8bBvbizr6qmoZ2ZlZCMiISAfXl1cW5qZ2NgXVlWU1BNSkdEQT48OTc0Mi8tKygmJCIgHhwaGRcVFBIRDw4NDAoJCAcGBQUEAwICAQE="),s(t,99845,"AQECAgMEBAUGBwgJCgsMDg8QEhMVFxgaHB4g0M7NzMrIx8XDwcC9u7i1s7CtqqejoJ2ZlpKPi4eEgHx4dHBtaWVhXVlVUU1KRkI+Ozc0MS8tKigmJCIgHhwaGRcVFBIRDw4NDAoJCAcGBQUEAwICAQE="),s(t,99973,"AQECAgMEBAUGBwgJCgsMDg8QEhMVFxgaHB4gmJmZmpydn6Gkp6mssLO2ur7BxcnN0dTY3N/j5urt8PL19/n7/P3+/v////////79+/r49vPx7uzp5uTg3drX09DMyMTAvLi0sKyno5+alpGNiIR/e3ZybWllYFxYVFBMSERAPDk1Mi8rKCYjIB0aFxUSDw0KCAcFAwIBAAAAAAD+///////+/fz6+Pb08e7r6OXh3trW0s3JxL+6trCrpqGclpGLhoB7dW9qZF9ZVE9JRD86NTArJiIdGRURDQoHBAMBAAAAAAAAAAABAQIEBQcJCw0QEhUYGx4iJSktMTU6PkNITFFXW15iZWhrbnF0dnh7fH6AgYKDg4SEg4OCgXJycXFwb21samhmZGFfXFpXVFFOS0hFQj87ODUyLywpJiMgHRsYFhQSEA4MCwoJCAcHBwcHBgUFBQUFBQUFBQYHBwgJCgwNDxASFBYYGx0gIyYpLC8zNzs/Q0dMUVZbYGVqb3R5f4SJj5Wboaets7rAx87V3OPq8fX3+vz9/v///v79/fz7+/r6+fj49/f29vX09PPz8vLx8PDv7u7t7Ovq6uno5+bl5OPi4eDe3dzb2djW1dPS0M7My8nHxcPAvry5t7Wyr62qp6ShnpqXlJCNiYWBfXl1cW1oZGFeW1dUUU1KRkNAPDk1Mi4qJyMfHBgUEQ0LCQcFBAMCAQAAAAAAAAAAAQEBAgIDAwQEBQYGBwgICQoLDAwNDg8QERITFBYXGBkbHB0fICIjJSYoKSstLzAyNDY4Ojw+QEJER0lLTlBSVVdaXV9iZWdqbXBzdnl8f4KGiYyQk5aanaCjpqmsr7K1uLu+wcTHys3Q09bZ3N/i5Ofp7O7w8vT2+Pr7/X9/f4CBg4SHiYyPkpaZnaGlqq6yt7vAxcnN0tba3uLm6u3w8/X4+vv8/f7+/fz7+ff08Ozn4tzVzsa9tKmekoiCfXdybGZgWlROSUI8NzItKCQfGxgUEQ4MCQcGBQQEBAQFBggKDRAUGB0jKS83PkdQWmRwfIOFiIqMjo+RkpOTAEAIAEYSAAAAAAAAGAwAAARQEgZOFgAAAAAAACI0AAAEWBYGUhYAAAAAAAAiQAAAAFwIAFxQAAAAAAAATAgBAABWBABeQgAAAAAAACIKAAAAPgoAPhQAAAAAAAAcEAAABEQSBkQWAAAAAAAAHiwAAAZAEABCIAAAAAAAACASAAACRC4AKiAAAAAAAAAuOgAABE4YBkgWAAAAAAAAKjQAAARYIgBAIAAAAAAAAC5SAAAAOAwAOBQAAAAAAAAYDAAAAEYSAEYYAAAAAAAAIBQAAAkAAAAJAAAAEAAAABAAAAAQAAAAFwAAADcAAAAgAAAAACgYCAAKNCAUCgYmGA4EAAYAAAAHAAAACQAAAAkAAAAUAAAAFAAAABQAAAAZAAAA5iAUCA=="),s(t,101072,"ZgNmAWYCpgSmAiYEpoooAmoDagFqAqoCbgNuAW4CrgIpALMEdAN0AXQCtAS0AgAAdAR6A3oBegK6An4BOQC+AgAApgMAAKYBAADmAwAAaAEAAGgCAAAoAwAA6AEAAOkBAABpBAAAqgMAAKoBAAAqAwAA6gMAAOoBAABsAgAArAEAACwDAAAsAgAAbQIAAG0EAACuBAAArgMAAK4BAADuAwAALgAAAO6LAABvAgAAMAIwAAAAcQEAADECAADxAQAAMQMAAHEEAABzAQAAMwIAAPMBMwAAADMAAAC0AwAAtAEAAPQCAAC0igAAdwEAADcCAAD3AQAAeAEAAHgCAAA4AgAA+AEAADkCAAD5AQAAeQQAALoEAAC6AwAAugEAADoEAAD6AgAA+gMAAHwCAAB+AgAAAAB/AQAAPwMAAP8BOACmAAEAgQBnBQAAKAEpBWkF6gAAAEIFAADDAEMdAADvBGwFLABsAAQAAACtAG0FAADuBAUAbgCxBPEEMQXxj7IAAAByBQAAMwVzAPQEtJoAAAgAtwCOADcVAAA3BQAAzQB3ALcIOAUAAG8FyQAJAbkAOQX6BAoAewW7ALwAvgB+AD8FPwEAAAsBAADMAIwAAAAAAGcAAABsDW0ALwGwAHEAdgVMBEwc6Y8AAOnPOY4AADnO"),s(t,101586,"sQNZAlsCswO5A1MByQPGA4MCxQOSApQCfgJ8AgAAqgBhgLIAMoCzADOAuQAxgLoAb4CwAmiAsQJmgrICaoCzAnKAtAJ5grUCe4K2AoGCtwJ3gLgCeYDAApSCwQKVguACY4LhAmyA4gJzgOMCeIBwIDCAcSBpgHQgNIB1IDWAdiA2gHcgN4B4IDiAeSA5gHogK4B7IC2AfCA9gH0gKIB+ICmAfyBugIAgMECBIDFAgiAyQIMgM0CEIDRAhSA1QIYgNkCHIDdAiCA4QIkgOUCKICtAiyAtQIwgPUCNIChAjiApQJAgYUCRIGVAkiBvQJMgeECUIFlClSBoQJYga0CXIGxAmCBtQJkgbkCaIHBAmyBzQJwgdEAAAAAAaXhjbXZsZA=="),s(t,101888,"AQAAAAoAAABkAAAA6AMAAAUAAAAyAAAA9AEAAAAXCgkYExgY"),s(t,101936,"///////9+fXy7uvo5OHe2tjV0s/MycbEwb+8ure1s7CurKmopaOhn56bmZiWlJKRj42LiYiHhYOCgX9+fHt6eHd2dXNycXBvbm1ramloZ2ZlZGNiYWBfXl1cW1pZWVhXVlVUU1JSUVBQT05NTExLS0pJSEdHRkVFRENDQkJBQEA/Pj49PTw7Ozo6OTk4ODc2NjU1NDQ0MzIyMTEwMC8vLi4uLS0sLCwrKyopKCgoJycnJiYmJSUlJCQjIyMjIiIiISEhICAfHx8eHh4dHR0dHBwbGxsbGhoaGhkZGRgYGBgXFxcXFhYWFRUVFRQUFBQTExMSEhERERAQEBAQEA8PDw8ODg4NDQ0MDAwMCwsLCwoKCgkJCQgICAAAAAAAAAAAeHl4d3d2dnV0dHNycXBwb29ubWxrampoZ2dmZmZlZWNiYmFgYF9eXVtaW1pZWFZVVlVVVFJRUE9NTk5MTUtLSklHSEZFRUVDQUA/Pz89PTs7Ozo4OTo4NjU0NDU0NDIwLy8tLi0="),s(t,102336,"FhYWFhYWFhUVFRUUFBMTEhEQDw8PDw8PDwAAAAAAAABkeGRpZG5uZF9kaXhpbn2Ch3N9ZGl4S2RLaXhVS2RpeFVpX3N4ZF9kbnhfaWRzeGRkZGl4ZGlfc3huX2RpeGRpaXp9bmlkaXhkaWl6fW5pZGl4X2lkc3huZGRkeGRkZGRkZGRk"),s(t,102480,"ZJZkaW5zbm5uZGmWaW59h4xzh2RpllppWnqHZFpkaZZkaWR6h2RkZGmWZGlpc4duaWRplmRpaXqCeH1kaZZkaW56fXNuZGmWZGlpeod4aWRplmRpaXOHbmlkZGRkZGRkZGRkZA=="),s(t,102592,"bnhkbm5ubm5ubm54ZG5ubm5ubm5ueGRuZG5ubmRubnhkbm5ubm5ubm54ZG5ubm5ubm5ueGRubm5ubm5ubnhkbm5ubm5ubm54ZG5ubm5ubm5ueGRubm5ubm5ubnhkbm5ubm5ubg=="),s(t,102708,"rwAAAGQAAAAyAAAAMg=="),s(t,102744,"ZA=="),s(t,102764,"MjIoRlpkZGRGboeWZGRLZHiWAAAAAAAABwAAAA4AAAAVAAAAKAAAAFAAAAAAAAAAAFNBUFIAQwAAAAAARgAAAAAAAAABAAAAAgAAAAQAAAAPAAAAAAEAAAEBAAEBAgQAAAAAAPMAEAEAAQABAAEAAQAB8ADwAPA="),s(t,102898,"QABaAG4AgACPAJwAqQC1AMAAygDUAN0A5gDvAPcAAAEHAQ8BFgEeASUBLAEyATkBQAFGAUwBUgFYAV4BZAFqAW8BdQF6AYABhQGKAY8BlAGZAZ4BowGoAa0BsgG2AbsBwAHEAckBzQHRAdYB2gHeAeMB5wHrAe8B8wH3AfsBAAIDAgcCCwIPAhMCFwIbAh8CIgImAioCLQIxAjUCOAI8AkACQwJHAkoCTgJRAlQCWAJbAl8CYgJlAmkCbAJvAnMCdgJ5AnwCgAKDAoYCiQKMAo8CkgKWApkCnAKfAqICpQKoAqsCrgKxArQCtwK6Ar0CwALCAsUCyALLAs4C0QLUAtYC2QLcAt8C4gLkAucC6gLtAu8C8gL1AvcC+gL9AgADAgMFAwcDCgMNAw8DEgMVAxcDGgMcAx8DIQMkAycDKQMsAy4DMQMzAzYDOAM7Az0DQANCA0QDRwNJA0wDTgNRA1MDVQNYA1oDXQNfA2EDZANmA2gDawNtA28DcgN0A3YDeQN7A30DgAOCA4QDhgMAAAGqAqytAwQFsLGys7S0tgYHCLkJCrwMDQ4PEBESYWJjZGVmZ2hpamtsbW5vcHFyc3R1"),s(t,103360,"YAYAAPAGAABmCQAA5gkAAGYKAADmCgAAZgsAAOYLAABmDAAA5gwAAGYNAABQDgAA0A4AACAPAABAEAAAkBA="),s(t,103440,"5gDmAOYA5gAAAAAA5gDmAL4AqgC+AMgAAAAAAL4A8AC+AL4A0gDSAAAAAADSANIAyADIANIA0gAAAAAA5gDmAOYA5gDwAPAAAAAAAAQBBAGqAIwA3ADcAAAAAAD6AA4BoACMAMgAjAAAAAAA8ACgALQAtADSANIAAAAAAOYA8ACqANwAtAC0AAAAAAD6AA4BlgCCAMgAyAAAAAAADgEOAbYAjADcANwAAAAAAPgAEwGbALQA0gDSAAAAAAAOASwBwwMAAAAAAABsAAAAAAAAAKAAkQCbAJYAAAAAAMgA9QAnAAAAtwAAAAAAAADCugAAyADIAMgAyAAAAAAA0gDmAAABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGgAAAAAAABscHR4fICEiIyQlJicoKSorAAAs"),s(t,103790,"LQAAAAAAAAAu"),s(t,103816,"Lw=="),s(t,103833,"MAAAAAAAMQ=="),s(t,103856,"Mg=="),s(t,103868,"MwAAAK0AAQBABgEADCAtAAAAAAC+AL4A0gDSAAAAAADmAPoAoACWAMgAyAAAAAAA+gAEAbkAwwDDAL4AAAAAANIA3AD6AMgA+gD6AAAAAAD6APoAMjM0Njk6PD0+P0BBQkNERkdJSktMTU5PUFFSU1RWAACWAIwAtAC0AAAAAADIAMgAbA=="),s(t,104016,"oADIALQAtAAAAAAA3ADwALQAoADIAMgAAAAAAPAA+gBjAAAAZgAAAGgAAABrAAAAcAAAAHQAAAB4AAAA/g=="),s(t,104096,"oACMAJYApQAAAAAA2gAxAZEAkQCqAKAAAAAAAEoBXgEuAAAALAAAACcAAADIAg=="),s(t,104160,"MTIzNTY3OTo7PD4/QEFCREVGR0hJSktMTU5PUFFSU1RW"),s(t,104208,"vgC0AOYA5gAAAAAA+gD6ABESExQWFxkaGxwdHyAhIiQlJicoKSosc3uDmwAAAAAAtAC0AL4AtAAAAAAA5gDwALQAtAC0AKAAAAAAAOYAtABABAAAMAQAADUEAAA4BAAAOQQAAD4EAABDBAAASwQAAE0EAABOBAAATwQAAFAEAABRBAAAVgQAAFcEAABdBAAAXgQ="),s(t,104368,"tACgAMgAyAAAAAAA3ADmAKAAhwDSANIAAAAAAAQBGAGgAIwAyADIAAAAAADcAOYAyADIAMgAyAAAAAAAyADIAKAAvgCvAK8AAAAAAMgA0gCqAHMA0gDwAAAAAAAEARgBqgCqALQAtAAAAAAA8AAEAZYAtADIAMgAAAAAANIA+gCWAJYAtAC0AAAAAAAsASwBoACHANwA3AAAAAAA+gAYAaAAqgDIAMgAAAAAAEABVAG0AKAA8ADwAAAAAAAEAQQBvgC0AMgA5gAAAAAA8AD6AJYAlgC0ALQA0gDmAOYA8ABhAAAA4AAAAOEAAACjHgAA4wAAAKEeAAADAQAAsR4AAK8eAACzHgAAtR4AALceAADiAAAApx4AAKUeAACpHgAAqx4AAK0eAABlAAAA6AAAAOkAAAC7HgAAvR4AALkeAADqAAAAwR4AAL8eAADDHgAAxR4AAMceAABpAAAA7AAAAO0AAADJHgAAKQEAAMseAABvAAAA8gAAAPMAAADPHgAA9QAAAM0eAAD0AAAA0x4AANEeAADVHgAA1x4AANkeAAChAQAA3R4AANseAADfHgAA4R4AAOMeAAB1AAAA+QAAAPoAAADnHgAAaQEAAOUeAACwAQAA6x4AAOkeAADtHgAA7x4AAPEeAAB5AAAA8x4AAP0AAAD3HgAA+R4AAPUe"),s(t,104896,"5gCWAOYA5gDmAAAA8AD6AAAAAAAnAAAAAAAAAAABAgM="),s(t,104945,"AQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRo="),s(t,105072,"GxwdAAAeHyAhIiMkACUmAAAAACcAACgAKQAqACsAAAAAAAAsAC0ALgAAAAAALwAAADAAAAAAAAAAMQ=="),s(t,105170,"MgAz"),s(t,105195,"NAAAAAAANQA2"),s(t,105226,"NwA4ADkArQABAAwgAQ=="),s(t,105249,"AQIDAAQAAQIDAAQFBgIDAAQFBwEDAAQICQoDAAAICAoDAAALCwsLAAAMDAwMAAAMAQ4BEwEBAw8DDgYRBgMJAQsPCwEMCQwBDgYOCQ4ODg8OHA4DDxEPEg8PEBEQAREGEQkRDxETEiAS/38AAAAAlgCMANwA3AAAAAAABAEYAYKAeHRkZICAgIyAgKCrq4CAgA=="),s(t,105412,"yAAAAMgAAACQAQAAkAEAAJABAABYAgAAWAIAAFgC"),s(t,105456,"8AAAAKoAAACqAAAAqgAAAKoAAACqAAAAqgAAAKoAAACqAAAAAQIMAw0EDgULAAAAAQIDBAUGAAAAAAAACwwNDg=="),s(t,105540,"MgAAAK8AAABkAAAAMg=="),s(t,105568,"rw=="),s(t,105596,"EBAKEBY="),s(t,105620,"/38AANAHAAAsAQAAYwAAAGMAAABjAAAAAAAAANAH"),s(t,105668,"BA=="),s(t,105680,"QEFCQ0RFRkdISUpLTE1OT1BRUlNUVldYWVtcXV5gYWJkZWdoaWtsbm9xc3R2d3l7fH6AgoSFh4mLjY+Rk5WXmZueoKKkp6mrrrCztbi6vb/CxcfKzdDT1tnc3+Ll6Ozv8vb5/P7/"),s(t,105792,"//7+/v7+/v7+/v39/f38/Pz7+/v6+vn5+Pj39/b19fTz8/Lx7+3r6efl4+Hf3drY1dPQzcvIxcK/u7i1sq6rp6OgnJiUkIyIhH97d3JuaWRgXltYVlNRTkxKR0VCQD48OTc1MzEvLCooJiQiIB4dGxkXFRMSEA4MCwkHBgQDAQ=="),s(t,106064,"//7+/v7+/f38+/v6+fj39vX08vHv7uzq6efl4+Hf3NrY1dPRz83LycfFw8G/vbu5t7SysK2rqaakoZ+cmpeUko+MioeEgX57eHZzcGxpZmNgX11bWlhWVVNSUE9NTEpJSEZFRENCQD8+PTw7Ojk4Nzc2NTQ0MzIyMTAwLy8uLi4tLS0sLCwsLCwsKysrKywrKiopKCgnJiYlJCQjIyIhISAgHx4eHR0cHBsaGhkZGBgXFxYWFRUUFBMTEhISEREQEA8PDw4ODQ0NDAwLCwsKCgoJCQkICAgHBwcHBgYGBQUFBQQEBAQEAwMDAwICAgICAgEBAQEBAQ=="),s(t,106341,"RvIpAC8ALwBF8ikALwAuAEXyKAAuAC0ANPIoAC0tLAA08igAKysrADTyKAAqKioANPIoACkpKQA08igAAOf/zv+1/5z/g/9q/1H/N/8e/wX/7P7T/rr+of6I/m/+Vf48/iP+Cv7x/dj9v/2m/Y39dP1b/UL9Kf0Q/ff83vzF/Kz8k/x6/GH8SPwv/Bb8/fvk+8v7svuZ+4D7Z/tP+zb7HfsE++v60vq6+qH6iPpv+lf6Pvol+g369Pnb+cP5qvmR+Xn5YPlH+S/5Fvn++OX4zfi0+Jz4g/hr+FP4Ovgi+Ar48ffZ98H3qPeQ93j3YPdH9y/3F/f/9uf2z/a39p/2h/Zv9lf2P/Yn9g/29/Xf9cf1sPWY9YD1aPVR9Tn1IfUK9fL02/TD9Kz0lPR99GX0TvQ29B/0CPTw89nzwvOr85TzfPNl807zN/Mg8wnz8vLb8sTyrvKX8oDyafJS8jzyJfIO8vjx4fHL8bTxnvGH8XHxW/FE8S7xGPEB8evw1fC/8Knwk/B98GfwUfA78CXwEPD67+Tvzu+576Pvje9472LvTe847yLvDe/47uLuze647qPuju557mTuT+467iXuEO777eft0u297antlO2A7WvtV+1C7S7tGu0F7fHs3ezJ7LXsoeyN7HnsZexR7D3sKuwW7ALs7+vb68jrtOuh643reutn61TrQest6xrrB+v06uLqz+q86qnqluqE6nHqX+pM6jrqJ+oV6gPq8One6czpuumo6ZbphOly6WHpT+k96SzpGukI6ffo5ujU6MPosuig6I/ofuht6FzoS+g76CroGegI6Pjn5+fX58bntuel55Xnhed152XnVedF5zXnJecV5wXn9ubm5tfmx+a45qjmmeaK5nvma+Zc5k3mPuYw5iHmEuYD5vXl5uXY5cnlu+Wt5Z7lkOWC5XTlZuVY5UrlPOUv5SHlE+UG5fjk6+Te5NDkw+S25KnknOSP5ILkdeRo5FzkT+RD5DbkKuQd5BHkBeT54+3j4ePV48njveOx46XjmuOO44Pjd+Ns42HjVuNL4z/jNOMq4x/jFOMJ4//i9OLq4t/i1eLK4sDituKs4qLimOKO4oTie+Jx4mfiXuJU4kviQuI54i/iJuId4hTiDOID4vrh8eHp4eDh2OHQ4cfhv+G34a/hp+Gf4Zfhj+GI4YDheOFx4WrhYuFb4VThTeFG4T/hOOEx4SrhJOEd4RbhEOEK4QPh/eD34PHg6+Dl4N/g2eDU4M7gyeDD4L7guOCz4K7gqeCk4J/gmuCV4JHgjOCH4IPgfuB64HbgcuBu4GrgZuBi4F7gWuBX4FPgT+BM4EngReBC4D/gPOA54DbgM+Ax4C7gK+Ap4CfgJOAi4CDgHuAc4BrgGOAW4BTgEuAR4A/gDuAN4AvgCuAJ4AjgB+AG4AXgBeAE4APgA+AC4ALgAuAC4ALgAeAC4ALgAuAC4ALgA+AD4ATgBeAF4AbgB+AI4AngCuAL4A3gDuAP4BHgEuAU4BbgGOAa4BzgHuAg4CLgJOAn4CngK+Au4DHgM+A24DngPOA/4ELgReBJ4EzgT+BT4FfgWuBe4GLgZuBq4G7gcuB24HrgfuCD4IfgjOCR4JXgmuCf4KTgqeCu4LPguOC+4MPgyeDO4NTg2eDf4OXg6+Dx4Pfg/eAD4QrhEOEW4R3hJOEq4THhOOE/4UbhTeFU4VvhYuFq4XHheOGA4Yjhj+GX4Z/hp+Gv4bfhv+HH4dDh2OHg4enh8eH64QPiDOIU4h3iJuIv4jniQuJL4lTiXuJn4nHie+KE4o7imOKi4qzituLA4sri1eLf4uri9OL/4gnjFOMf4yrjNOM/40vjVuNh42zjd+OD447jmuOl47HjvePJ49Xj4ePt4/njBeQR5B3kKuQ25EPkT+Rc5GjkdeSC5I/knOSp5Lbkw+TQ5N7k6+T45AblE+Uh5S/lPOVK5VjlZuV05YLlkOWe5a3lu+XJ5djl5uX15QPmEuYh5jDmPuZN5lzma+Z75ormmeao5rjmx+bX5ubm9uYF5xXnJec150XnVedl53XnheeV56XntufG59fn5+f45wjoGegq6DvoS+hc6G3ofuiP6KDosujD6NTo5uj36AjpGuks6T3pT+lh6XLphOmW6ajpuunM6d7p8OkD6hXqJ+o66kzqX+px6oTqluqp6rzqz+ri6vTqB+sa6y3rQetU62freuuN66HrtOvI69vr7+sC7BbsKuw97FHsZex57I3soey17Mns3ezx7AXtGu0u7ULtV+1r7YDtlO2p7b3t0u3n7fvtEO4l7jruT+5k7nnuju6j7rjuze7i7vjuDe8i7zjvTe9i73jvje+j77nvzu/k7/rvEPAl8DvwUfBn8H3wk/Cp8L/w1fDr8AHxGPEu8UTxW/Fx8YfxnvG08cvx4fH48Q7yJfI88lLyafKA8pfyrvLE8tvy8vIJ8yDzN/NO82XzfPOU86vzwvPZ8/DzCPQf9Db0TvRl9H30lPSs9MP02/Ty9Ar1IfU59VH1aPWA9Zj1sPXH9d/19/UP9if2P/ZX9m/2h/af9rf2z/bn9v/2F/cv90f3YPd495D3qPfB99n38fcK+CL4OvhT+Gv4g/ic+LT4zfjl+P74Fvkv+Uf5YPl5+ZH5qvnD+dv59PkN+iX6PvpX+m/6iPqh+rr60vrr+gT7Hfs2+0/7Z/uA+5n7svvL++T7/fsW/C/8SPxh/Hr8k/ys/MX83vz3/BD9Kf1C/Vv9dP2N/ab9v/3Y/fH9Cv4j/jz+Vf5v/oj+of66/tP+7P4F/x7/N/9R/2r/g/+c/7X/zv/n/wAAGQAyAEsAZAB9AJYArwDJAOIA+wAUAS0BRgFfAXgBkQGrAcQB3QH2AQ8CKAJBAloCcwKMAqUCvgLXAvACCQMiAzsDVANtA4YDnwO4A9ED6gMDBBwENQROBGcEgASZBLEEygTjBPwEFQUuBUYFXwV4BZEFqQXCBdsF8wUMBiUGPQZWBm8GhwagBrkG0QbqBgIHGwczB0wHZAd9B5UHrQfGB94H9gcPCCcIPwhYCHAIiAigCLkI0QjpCAEJGQkxCUkJYQl5CZEJqQnBCdkJ8QkJCiEKOQpQCmgKgAqYCq8KxwrfCvYKDgslCz0LVAtsC4MLmwuyC8oL4Qv4CxAMJww+DFUMbAyEDJsMsgzJDOAM9wwODSUNPA1SDWkNgA2XDa4NxA3bDfINCA4fDjUOTA5iDnkOjw6lDrwO0g7oDv8OFQ8rD0EPVw9tD4MPmQ+vD8UP2w/wDwYQHBAyEEcQXRBzEIgQnhCzEMgQ3hDzEAgRHhEzEUgRXRFyEYcRnBGxEcYR2xHwEQUSGRIuEkMSVxJsEoASlRKpEr4S0hLmEvsSDxMjEzcTSxNfE3MThxObE68TwxPWE+oT/hMRFCUUOBRMFF8UcxSGFJkUrBS/FNMU5hT5FAwVHhUxFUQVVxVqFXwVjxWhFbQVxhXZFesV/RUQFiIWNBZGFlgWahZ8Fo4WnxaxFsMW1BbmFvgWCRcaFywXPRdOF2AXcReCF5MXpBe1F8UX1hfnF/gXCBgZGCkYOhhKGFsYaxh7GIsYmxirGLsYyxjbGOsY+xgKGRoZKRk5GUgZWBlnGXYZhRmVGaQZsxnCGdAZ3xnuGf0ZCxoaGigaNxpFGlMaYhpwGn4ajBqaGqgathrEGtEa3xrtGvoaCBsVGyIbMBs9G0obVxtkG3EbfhuLG5gbpBuxG70byhvWG+Mb7xv7GwccExwfHCscNxxDHE8cWxxmHHIcfRyJHJQcnxyqHLUcwRzMHNYc4RzsHPccAR0MHRYdIR0rHTYdQB1KHVQdXh1oHXIdfB2FHY8dmR2iHawdtR2+Hccd0R3aHeMd7B30Hf0dBh4PHhceIB4oHjAeOR5BHkkeUR5ZHmEeaR5xHngegB6IHo8elh6eHqUerB6zHroewR7IHs8e1h7cHuMe6h7wHvYe/R4DHwkfDx8VHxsfIR8nHywfMh83Hz0fQh9IH00fUh9XH1wfYR9mH2sfbx90H3kffR+CH4Yfih+OH5Iflh+aH54foh+mH6kfrR+xH7Qftx+7H74fwR/EH8cfyh/NH88f0h/VH9cf2R/cH94f4B/iH+Qf5h/oH+of7B/uH+8f8R/yH/Mf9R/2H/cf+B/5H/of+x/7H/wf/R/9H/4f/h/+H/4f/h//H/4f/h/+H/4f/h/9H/0f/B/7H/sf+h/5H/gf9x/2H/Uf8x/yH/Ef7x/uH+wf6h/oH+Yf5B/iH+Af3h/cH9kf1x/VH9Ifzx/NH8ofxx/EH8Efvh+7H7cftB+xH60fqR+mH6Ifnh+aH5Yfkh+OH4ofhh+CH30feR90H28fax9mH2EfXB9XH1IfTR9IH0IfPR83HzIfLB8nHyEfGx8VHw8fCR8DH/0e9h7wHuoe4x7cHtYezx7IHsEeuh6zHqwepR6eHpYejx6IHoAeeB5xHmkeYR5ZHlEeSR5BHjkeMB4oHiAeFx4PHgYe/R30Hewd4x3aHdEdxx2+HbUdrB2iHZkdjx2FHXwdch1oHV4dVB1KHUAdNh0rHSEdFh0MHQEd9xzsHOEc1hzMHMEctRyqHJ8clByJHH0cchxmHFscTxxDHDccKxwfHBMcBxz7G+8b4xvWG8obvRuxG6QbmBuLG34bcRtkG1cbShs9GzAbIhsVGwgb+hrtGt8a0RrEGrYaqBqaGowafhpwGmIaUxpFGjcaKBoaGgsa/RnuGd8Z0BnCGbMZpBmVGYUZdhlnGVgZSBk5GSkZGhkKGfsY6xjbGMsYuxirGJsYixh7GGsYWxhKGDoYKRgZGAgY+BfnF9YXxRe1F6QXkxeCF3EXYBdOFz0XLBcaFwkX+BbmFtQWwxaxFp8WjhZ8FmoWWBZGFjQWIhYQFv0V6xXZFcYVtBWhFY8VfBVqFVcVRBUxFR4VDBX5FOYU0xS/FKwUmRSGFHMUXxRMFDgUJRQRFP4T6hPWE8MTrxObE4cTcxNfE0sTNxMjEw8T+xLmEtISvhKpEpUSgBJsElcSQxIuEhkSBRLwEdsRxhGxEZwRhxFyEV0RSBEzER4RCBHzEN4QyBCzEJ4QiBBzEF0QRxAyEBwQBhDwD9sPxQ+vD5kPgw9tD1cPQQ8rDxUP/w7oDtIOvA6lDo8OeQ5iDkwONQ4fDggO8g3bDcQNrg2XDYANaQ1SDTwNJQ0ODfcM4AzJDLIMmwyEDGwMVQw+DCcMEAz4C+ELyguyC5sLgwtsC1QLPQslCw4L9grfCscKrwqYCoAKaApQCjkKIQoJCvEJ2QnBCakJkQl5CWEJSQkxCRkJAQnpCNEIuQigCIgIcAhYCD8IJwgPCPYH3gfGB60HlQd9B2QHTAczBxsHAgfqBtEGuQagBocGbwZWBj0GJQYMBvMF2wXCBakFkQV4BV8FRgUuBRUF/ATjBMoEsQSZBIAEZwROBDUEHAQDBOoD0QO4A58DhgNtA1QDOwMiAwkD8ALXAr4CpQKMAnMCWgJBAigCDwL2Ad0BxAGrAZEBeAFfAUYBLQEUAfsA4gDJAK8AlgB9AGQASwAyABkAMAAAADAAAABAAAAAUAAAAJAAAACgAAAAsAAAAMAAAACAm7XL3Ojt7Obczr+wo5iQjIuMj5KUlZKMg3hpWUk8MSopLTZEVml9j5+qsbKtpJaHeGlcU09PVV5reoiWoquwsa6ooJiRi4iJjZSdqLK7wMG9tKWSfGNKMh4OBQIFDx4wRFltf4yWnJ+fnZuZmZyhqbO/ytXc4N7YzLumj3dgSzouKCkvOkhZanqGkJSVkYmAdWtiXFpcYWl0gIqUmp6dmJCGfHFoYmBja3iIm6/C0t/m5+LXxrKchG9bS0A5Nzg9Q0pQVFZVUk1IQj8+QUlWZ3yTq8PZ6vb8+/Tn1cCqlIBxZF1aXGFocHd9f397dGthV05IRkhOWWZ1hJOfp6uqpJmLe2pbTkZDRU1aa3+SprjFz9PSzcS5raGWjomHh4qNkZKRjIR4aFVBLhwOBQEFDx80TWiBmrDBzdPT0Mi/taukn5ydoKWqrrGwq6OWh3ZjUUI2Ly0xOkhZa36OnKaqqaOYintsXVJKSEpQWmd1gi0AAAAmAAAALQAAAC0AAAA3AAAALQ=="),s(t,110928,"yv5w/hICZAHgAFkAFwD2/8b/8P/NAVcCGAK9AgIDXQLxAc0BMAKUAW4A4ACDAGgAn/+bABYBZv9z+6r94QJ9ALD9KQALAAn/9v9BAFwAUADQ/kcApwD//3oA6QChANX/FgHfAeUBlwEKAYoChgBQAOwARAAEAQ0BswA1AIwAEwElASgBaAABAZgANwG2AAcB9QB9ADoBjAAsAMsA5gAV/+L+FwBrAFwApf8mANABuwGwAGIA8Pxv9p346/vA+Ur6mPoT+0v8Jv0="),s(t,111162,"BgAHAAgACQAKAAsADQAOABAAEgAUABYAGQAcACAAIwAoAC0AMwA5AEAARwBQAFoAZQByAIAAjgCfALMAygDjAAABHAE+AWcBlQHHAQACOAJ+As8CcQOPAwAEcQT8BJ4FVgYfBwAI4Qj4CTsLrAw9DgAQwxHwE3cWWBl7HAAghSPfJ+4ssDL2OABArkekUIVbZmYzc/9/"),s(t,111324,"qMtoQQAAAACoy2jBAAAAAAAAAAAXCtQJkglQCQ8JzgiPCE8IEwjVB5oHYgcoB/MGvgaLBloGKwb9BdMFqQWBBVwFOAUWBfcE1wS7BKAEhgRuBFcEQQQtBBkEBwT1A+QD1APFA7YDqAOZA40DfwNxA2UDVwNLAz4DMgMkAxgDCwP+AvIC5ALYAssCvgKxAqQClwKLAn0CcgJkAlkCTAJAAjQCKAIcAhICBQL7AfAB5QHbAdABxgG7AbIBqAGeAZQBigGBAXcBbgFjAVsBUAFIAT0BNAErASABGAENAQQB+gDwAOcA3ADUAMgAwAC1AKwAoQCYAI4AhQB7AHEAaQBeAFYATABDADkAMQAnAB4AFgALAAQA+//y/+n/4P/X/87/xP+7/7L/qf+g/5X/jf+C/3r/cP9m/1z/Uv9J/z//Nf8r/yL/F/8O/wT/+v7x/uf+3f7T/sr+wP62/q3+o/6b/pD+h/59/nP+av5f/lb+TP5C/jj+Lf4j/hn+Df4D/vf97P3h/dX9yf29/bH9pf2Y/Yz9f/1z/Wb9Wf1M/T/9M/0k/Rn9Cv3//PH85fzY/Mz8vvyz/KT8mPyL/H78cfxi/FX8Rfw4/Cb8GfwG/Pb74vvQ+7r7pfuO+3b7XPtB+yT7Bvvl+sT6n/p5+lP6KPr++dD5oflw+Tz5CfnR+Jr4YPgm+Oj3q/ds9yz36/aq9mj2Jvbj9bAEdgRABA4E3wO0A4sDZQNBAx8DAAPiAsYCqwKSAnoCZAJOAjoCJwIVAgMC8wHjAdQBxgG4AasBnwGTAYcBfAFyAWgBXgFVAUwBQwE7ATMBLAEkAR0BFgEQAQkBAwH9APcA8gDtAOcA4gDdANkA1ADQAMwAxwDDAMAAvAC4ALQAsQCuAKoApwCkAKEAngCbAJkAlgCTAJEAjgCMAIkAhwCFAIMAgAB+AHwAegB4AHcAdQBzAHEAbwBuAGwAagBpAGcAZgBkAGMAYQBgAF8AXQBcAFsAWgBYAFcAVgBVAFQAUwBSAFAATwBOAE0ATABLAEsASgBJAEgARwBGAEUARABEAEMAQgBBAEAAQAA/AD4APQA9ADwAOwA7ADoAOQA5ADgAOAA3ADcANgA2ADUANQA0ADQAMwAzADIAMgAxADEAMAAwAC8ALwAuAC4ALQAtACwALAArACsAKgAqACkAKQApACkAKAAoACcAJwAmACYAJgAmACUAJQAkACQAJAAkACMAIwAjACMAIgAiACEAIQAhACEAIAAgACAAIAAfAB8AHwAfAB4AHgAeAB4AHQAdAB0AHQAcABwAHAAcABsAGwAxNkZyYW1lTWFuYWdlckltcGwAMTJGcmFtZU1hbmFnZXIAMjNTcGVlY2hXYXZlR2VuZXJhdG9ySW1wbAAxOVNwZWVjaFdhdmVHZW5lcmF0b3IAMTNXYXZlR2VuZXJhdG9y"),s(t,112416,"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"),s(t,115203,"QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNf6CK2VHFWdAAAAAAAAAOEMAAPr+Qi52vzo7nrya9wy9vf3/////3z88VFVVVVXFP5ErF89VVaU/F9CkZxERgT8AAAAAAADIQu85+v5CLuY/JMSC/72/zj+19AzXCGusP8xQRtKrsoM/hDpOm+DXVT8="),s(t,115390,"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gryYg8kW42DvP6ySwdVQWo48hTLbA+Zp7z9LawGsWTqEPGC0AfMhc+8/Hz60ByHVgrxfm3szl3zvP8kNRzu5Kom8KaH1FEaG7z/TiDpgBLZ0PPY/i+cukO8/cXKdUezFgzyDTMf7UZrvP/CR048S94+82pCkoq+k7z99dCPimK6NvPFnji1Ir+8/CCCqQbzDjjwnWmHuG7rvPzLrqcOUK4Q8l7prNyvF7z/uhdExqWSKPEBFblt20O8/7eM75Lo3jrwUvpyt/dvvP53NkU07iXc82JCegcHn7z+JzGBBwQVTPPFxjyvC8+8/EhETFBUWFxgZGhscHR4fICERIiMkESUmJygpKissES0uLxAQMBAQEBAQEBAxMjMQNDUQEBERERERERERERERERERERERERERERERERE2ERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERNxERERE4ETk6Ozw9PhERERERERERERERERERERERERERERERERERERERERERERERERERERERERE/EBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEUBBEUJDREVGR0hJShFLTE1OT1BREFJTVFVWV1hZWltcXRBeX2AQERERYWJjEBAQEBAQEBAQEBERERFkEBAQEBAQEBAQEBAQEBAQERFlEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQERFmZxAQaGkREREREREREREREREREREREREREREREWoREWsQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEWxtEBAQEBAQEBAQbhAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQb3BxchAQEBAQEBAQc3R1EBAQEBB2dxAQEBB4EBB5EBAQEBAQEBAQEBAQEBA="),s(t,117968,"//////////////////////////////////////////8AAAAAAAAAAP7//wf+//8HAAAAAAAEIAT//3////9//////////////////////////////////8P/AwAfUA=="),s(t,118072,"IAAAAAAA37xA1///+////////////7///////////////////////wP8///////////////////////////+////fwL//////wEAAAAA/7+2AP///4cHAAAA/wf//////////v/D////////////////7x/+4f+fAAD///////8A4P///////////////wMA//////8HMAT////8/x8AAP///wH/BwAAAAAAAP//3z8AAPD/+AP////////////v/9/h/8///v/vn/n///3F459ZgLDP/wMQ7of5///9bcOHGQJewP8/AO6/+////e3jvxsBAM//AB7un/n///3t458ZwLDP/wIA7Mc91hjH/8PHHYEAwP8AAO/f/f///f/j3x1gB8//AADv3/3///3v498dYEDP/wYA79/9/////+ffXfCAz/8A/Oz/f/z///svf4Bf/8D/DAD+/////3//Bz8g/wMAAAAA1vf//6///ztfIP/zAAAAAAEAAAD/AwAA//7///8f/v8D///+////HwAAAAAAAAAA////////f/n/A////////////z//////vyD///////f///////////89fz3//////z3/////PX89/3//////////Pf//////////BwAAAAD//wAA/////////////z8//v//////////////////////////////////////////////////////////n////v//B////////////8f/Af/fDwD//w8A//8PAP/fDQD////////P//8BgBD/AwAAAAD/A///////////////Af//////B///////////PwD///9//w//AcD/////Px8A//////8P////A/8DAAAAAP///w//////////f/7/HwD/A/8DgA=="),s(t,118768,"////////7//vD/8DAAAAAP//////8////////7//AwD///////9/AP/j//////8//wH//////+cAAAAAAN5vBP///////////////////////////////wAAAACA/x8A//8/P/////8/P/+q////P////////99f3B/PD/8f3B8="),s(t,118910,"AoAAAP8f"),s(t,118928,"hPwvPlC9//PgQwAA//////8B"),s(t,118982,"wP///////wMAAP//////f///////f/////////////////////8feAwA/////78g/////////4AAAP//fwB/f39/f39/f/////8AAAAAAIA="),s(t,119088,"4AAAAP4DPh/+////////////f+D+//////////////fg///////+/////////////38AAP///wcAAAAAAAD///////////////////////////////8/"),s(t,119184,"////////////////////////////////////////AAD//////////////////////x8AAAAAAAAAAP//////P/8f////DwAA//////9/8I///////////////////wAAAACA//z////////////////5////////fAAAAAAAgP+//////wAAAP///////w8A//////////8vAP8DAAD86P//////B/////8HAP///x/////////3/wCA/wP///9/////////fwD/P/8D//9//P////////9/BQAAOP//PAB+fn4Af3////////f/AP///////////////////wf/A///////////////////////////DwD//3/4//////8P/////////////////z//////////////////AwAAAAB/APjg//1/X9v/////////////////AwAAAPj///////////////8/AAD///////////z///////8AAAAAAP8P"),s(t,119582,"3/////////////////////8fAAD/A/7//wf+//8HwP////////////9//Pz8HAAAAAD/7///f///t/8//z8AAAAA////////////////////BwAAAAAAAAAA////////Hw=="),s(t,119712,"////H////////wEAAAAAAP////8A4P///wf//////wf///8//////w//PgAAAAAA/////////////////////////z//A/////8P/////w///////wD///////8P"),s(t,119824,"////////fwD//z8A/w=="),s(t,119856,"P/3/////v5H//z8A//9/AP///38AAAAAAAAAAP//NwD//z8A////AwAAAAAAAAAA/////////8AAAAAAAAAAAG/w7/7//z8AAAAAAP///x////8fAAAAAP/+//8fAAAA////////PwD//z8A//8HAP//Aw=="),s(t,119984,"////////////AQAAAAAAAP///////wcA////////BwD//////wD/Aw=="),s(t,120048,"////H4AA//8/"),s(t,120076,"//9/AP//////////PwAAAMD/AAD8////////AQAA////Af8D////////x/9wAP////9HAP//////////HgD/FwAAAAD///v///+fQAAAAAAAAAAAf73/v/8B/////////wH/A++f+f///e3jnxmB4A8="),s(t,120208,"//////////+7B/+DAAAAAP//////////swD/Aw=="),s(t,120256,"////////P38AAAA/AAAAAP////////9/EQD/AwAAAAD///////8/Af8DAAAAAAAA////5/8H/wM="),s(t,120336,"/////////wE="),s(t,120356,"////////////AwCA"),s(t,120388,"//z///////waAAAA////////538AAP///////////yAAAAAA/////////wH//f////9/fwEA/wMAAPz////8///+fw=="),s(t,120464,"f/v/////f7TLAP8Dv/3///9/ewH/Aw=="),s(t,120524,"//9/AP////////////////////////8D"),s(t,120560,"/////////////////38AAP///////////////////////////////w8="),s(t,120624,"//////9/"),s(t,120656,"//////////9/"),s(t,120688,"/////////wH///9//wM="),s(t,120714,"////PwAA////////AAAPAP8D+P//4P//"),s(t,120760,"//////////8="),s(t,120784,"////////////h/////////+A//8AAAAAAAAAAAsAAAD/////////////////////////////////////////AP///////////////////////////////////////wcA////fwAAAAAAAAcA8AD/////////////////////////////////////////////////////////////////D/////////////////8H/x//Af9D"),s(t,120976,"/////////////9///////////99k3v/r7/////////+/59/f////e1/8/f//////////////////////////////////////////////////////P/////3///f////3///f////3///f////3/////9/////f//98////////9////52wc="),s(t,121136,"//////8fgD//Qw=="),s(t,121192,"//////8P/wP///////////////////////////////8fAAAAAAAAAP//////////jwj/Aw=="),s(t,121264,"7////5b+9wqE6paqlvf3Xv/7/w/u+/8P"),s(t,121302,"////A////wP///8D"),s(t,121328,"/////////////////////////////////////////////////////////////////wABAgMEBQYHCAn/////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP///////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8="),s(t,121601,"ARcCHRgTAx4bGQsUCAQNHxYcEhoKBwwVEQkGEAUPDt4SBJUAAAAA////////////////INsBABQAAABDLlVURi04"),s(t,121696,"TENfQ1RZUEUAAAAATENfTlVNRVJJQwAATENfVElNRQAAAAAATENfQ09MTEFURQAATENfTU9ORVRBUlkATENfTUVTU0FHRVM="),s(t,121776,"Qy5VVEYtOA=="),s(t,121800,"MAUCAE5vIGVycm9yIGluZm9ybWF0aW9uAElsbGVnYWwgYnl0ZSBzZXF1ZW5jZQBEb21haW4gZXJyb3IAUmVzdWx0IG5vdCByZXByZXNlbnRhYmxlAE5vdCBhIHR0eQBQZXJtaXNzaW9uIGRlbmllZABPcGVyYXRpb24gbm90IHBlcm1pdHRlZABObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5AE5vIHN1Y2ggcHJvY2VzcwBGaWxlIGV4aXN0cwBWYWx1ZSB0b28gbGFyZ2UgZm9yIGRhdGEgdHlwZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBPdXQgb2YgbWVtb3J5AFJlc291cmNlIGJ1c3kASW50ZXJydXB0ZWQgc3lzdGVtIGNhbGwAUmVzb3VyY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUASW52YWxpZCBzZWVrAENyb3NzLWRldmljZSBsaW5rAFJlYWQtb25seSBmaWxlIHN5c3RlbQBEaXJlY3Rvcnkgbm90IGVtcHR5AENvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcgBPcGVyYXRpb24gdGltZWQgb3V0AENvbm5lY3Rpb24gcmVmdXNlZABIb3N0IGlzIGRvd24ASG9zdCBpcyB1bnJlYWNoYWJsZQBBZGRyZXNzIGluIHVzZQBCcm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBCbG9jayBkZXZpY2UgcmVxdWlyZWQATm8gc3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE11bHRpaG9wIGF0dGVtcHRlZABSZXF1aXJlZCBrZXkgbm90IGF2YWlsYWJsZQBLZXkgaGFzIGV4cGlyZWQAS2V5IGhhcyBiZWVuIHJldm9rZWQAS2V5IHdhcyByZWplY3RlZCBieSBzZXJ2aWNl"),s(t,123730,"pQJbAPABtQWMBSUBgwYdA5QE/wDHAzEDCwa8AY8BfwPKBCsA2gavAEIDTgPcAQ4EFQChBg0BlAILAjgGZAK8Av8CXQPnBAsHzwLLBe8F2wXhAh4GRQKFAIICbANvBPEA8wMYBdkA2gNMBlQCewGdA70EAABRABUCuwCzA20A/wGFBC8F+QQ4AGUBRgGfALcGqAFzAlMB"),s(t,123928,"IQQAAAAAAAAAAC8C"),s(t,123960,"NQRHBFYE"),s(t,123982,"oAQ="),s(t,124002,"RgVgBW4FYQYAAM8BAAAAAAAAAADJBukG+QYeBzkHSQdeBw=="),s(t,124048,"GQAKABkZGQAAAAAFAAAAAAAACQAAAAALAAAAAAAAAAAZABEKGRkZAwoHAAEACQsYAAAJBgsAAAsABhkAAAAZGRk="),s(t,124129,"DgAAAAAAAAAAGQAKDRkZGQANAAACAAkOAAAACQAOAAAO"),s(t,124187,"DA=="),s(t,124199,"EwAAAAATAAAAAAkMAAAAAAAMAAAM"),s(t,124245,"EA=="),s(t,124257,"DwAAAAQPAAAAAAkQAAAAAAAQAAAQ"),s(t,124303,"Eg=="),s(t,124315,"EQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoa"),s(t,124370,"GgAAABoaGgAAAAAAAAk="),s(t,124419,"FA=="),s(t,124431,"FwAAAAAXAAAAAAkUAAAAAAAUAAAU"),s(t,124477,"Fg=="),s(t,124489,"FQAAAAAVAAAAAAkWAAAAAAAWAAAWAAAwMTIzNDU2Nzg5QUJDREVG"),s(t,124564,"EQ=="),s(t,124604,"//////////8="),s(t,124672,"0XSeAFedvSqAcFIP//8+JwoAAABkAAAA6AMAABAnAACghgEAQEIPAICWmAAA4fUFGAAAADUAAABxAAAAa////877//+Sv///AAAAAAAAAAACAADAAwAAwAQAAMAFAADABgAAwAcAAMAIAADACQAAwAoAAMALAADADAAAwA0AAMAOAADADwAAwBAAAMARAADAEgAAwBMAAMAUAADAFQAAwBYAAMAXAADAGAAAwBkAAMAaAADAGwAAwBwAAMAdAADAHgAAwB8AAMAAAACzAQAAwwIAAMMDAADDBAAAwwUAAMMGAADDBwAAwwgAAMMJAADDCgAAwwsAAMMMAADDDQAA0w4AAMMPAADDAAAMuwEADMMCAAzDAwAMwwQADNsAAAAAIAAAAAkAAAAKAAAADQAAAAsAAAAMAAAAhQAAAAAgAAABIAAAAiAAAAMgAAAEIAAABSAAAAYgAAAIIAAACSAAAAogAAAoIAAAKSAAAF8gAAAAMAAAAAAAAE4xMF9fY3h4YWJpdjExNl9fc2hpbV90eXBlX2luZm9FAAAAAGjpAQB46AEAZOoBAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQAAAGjpAQCo6AEAnOgBAE4xMF9fY3h4YWJpdjExN19fcGJhc2VfdHlwZV9pbmZvRQAAAGjpAQDY6AEAnOgBAE4xMF9fY3h4YWJpdjExOV9fcG9pbnRlcl90eXBlX2luZm9FAGjpAQAI6QEA/OgBAAAAAADM6AEAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAAAAAAsOkBABQAAAAcAAAAFgAAABcAAAAYAAAAHQAAAB4AAAAfAAAATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAAAAAGjpAQCI6QEAzOgBAAAAAAAg6gEACQAAACAAAAAhAAAAAAAAAEjqAQAJAAAAIgAAACMAAAAAAAAACOoBAAkAAAAkAAAAJQAAAFN0OWV4Y2VwdGlvbgAAAABA6QEA+OkBAFN0OWJhZF9hbGxvYwAAAABo6QEAEOoBAAjqAQBTdDIwYmFkX2FycmF5X25ld19sZW5ndGgAAAAAaOkBACzqAQAg6gEAU3Q5dHlwZV9pbmZvAAAAAEDpAQBU6gE="),s(t,125552,"wLEAAMCyAADAswAAwLQAAMC1AADAtgAAwLcAAMC4AADAuQAAwLoAAMC7AADAvAAAwL0AAMC+AADAvwAAwMAAAMDBAADAwgAAwMMAAMDEAADAxQAAwMIAAMDGAADAxwAAwMgAAMDJAADAygAAwMsAAMDMAADAzQAAwM4AAMDPAADA0AAAwNEAAMDSAADA0wAAwNQAAMDVAADA1gAAwNcAAMDYAADA2QAAwNIAAMDaAADA2wAAwNwAAMDdAADA3gAAwN8AAMDgAADA4QAAwNgAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADA4gAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwOMAAMDkAADAwgAAwMIAAMDCAADA5QAAwMIAAMDmAADA5wAAwOgAAMDpAADA6gAAwOsAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADA7AAAwO0AAMDCAADA7gAAwO8AAMDCAADA8AAAwPEAAMDyAADA8wAAwPQAAMD1AADA9gAAwPcAAMD4AADAwgAAwPkAAMD6AADA+wAAwPwAAMD9AADA/gAAwP8AAMAAAQDAAQEAwAIBAMADAQDABAEAwAUBAMAGAQDABwEAwAgBAMAJAQDACgEAwAsBAMAMAQDACwEAwA0BAMAOAQDADwEAwAsBAMDCAADAwgAAwMIAAMAQAQDAEQEAwBIBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDAwgAAwMIAAMDCAADAwgAAwBMBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMDCAADAwgAAwBQBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMDCAADAwgAAwBUBAMAWAQDACwEAwAsBAMAXAQDAGAEAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAGQEAwMIAAMDCAADAGgEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMDCAADAGwEAwBwBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMAdAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwB4BAMAfAQDAIAEAwCEBAMAiAQDAIwEAwCQBAMAlAQDA2AAAwNgAAMAmAQDACwEAwAsBAMALAQDACwEAwAsBAMAnAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwCgBAMApAQDACwEAwAsBAMAqAQDACwEAwCsBAMALAQDALAEAwC0BAMAuAQDALwEAwNgAAMDYAADAMAEAwDEBAMAyAQDAMwEAwDQBAMALAQDACwEAwAsBAMALAQDACwEAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMA1AQDAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwDYBAMA3AQDAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAOAEAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMDCAADAwgAAwMIAAMA5AQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDACwEAwAsBAMALAQDAwgAAwMIAAMA6AQDAOwEAwDwB"),s(t,128496,"oVcBAEEAAADdVwEAQgAAACZYAQBDAAAAa1gBAEQAAADSWAEARQAAABNZAQBGAAAAfFkBAEcAAACEWQEASAAAADBaAQBJAAAAZ1oBAEoAAADuWgEASwAAAC5bAQBMAAAAcVsBAE0AAADZWwEATgAAAGtcAQBPAAAAh1wBAAgAAADcXAEACQAAAB9dAQAKAAAAZ10BAAsAAACVXQEADAAAAMpdAQANAAAAD14BAA4AAAAqXgEADwAAAIZeAQAPAAAAvV4BABAAAABDXwEAEQAAAH1fAQASAAAAq18BABMAAADZXwEAFAAAAAVgAQAVAAAAMGABABcAAABgYAEAGAAAAHlgAQAZAAAAtWABABsAAADdYAEAHAAAAPBgAQAdAAAAI2EBACAAAABEYQEAIQAAAG9hAQAiAAAAnWEBACMAAADRYQEAJAAAAPNhAQAlAAAAFWIBACYAAABZYgEAKAAAAH1iAQApAAAArmIBACoAAADoYgEAKwAAADVjAQAtAAAAb2MBAC4AAACnYwEALwAAAOZjAQAwAAAAeGQBADEAAACdZAEAMgAAAM9kAQAzAAAA/mQBAGQAAABgZQEAyAAAAN1lAQDJAAAAAAAAAP////8iZgEAAQAAAD5mAQACAAAABVUBAAMAAADNZgEAEQAAADRnAQASAAAAg2cBABMAAAD7ZwEAFAAAADtoAQAVAAAATGgBABYAAAB0aAEAEQAAALdoAQAhAAAAymgBACIAAAD+aAEAIwAAAEtpAQAkAAAAaWkBACUAAACfaQEAJgAAAOJpAQAhAAAAAAAAAP////8AAAAAAAAAACYAAAAAAAAAAQAAAJByAQABAAAAkHMBAAEAAACQdAEAAQAAAJB1AQABAAAAkHYBAAEAAACQdwEAAQAAAJB4AQABAAAAkHkBAAEAAACQegEAAQAAAJB7AQABAAAAkHwBAAEAAACQfQEAAQAAAJB+AQABAAAAkH8BAAEAAACQgAEAAQAAAJCBAQABAAAAkIIBAAUAAAAAAAAABg=="),s(t,129280,"oIMBAKCDAQAghAEAIIQBAKCEAQAghQEAoIUBACCGAQCghgEAoIYBACCHAQAghwEAoIcBAKCHAQAgiAEAIIgBAKCIAQCgiAEAIIkBACCJAQAuOU4ycIoBAAMHBQCQigEALjlOLnCKAQADBwUAkIoBAC45Ti5wigEAAwcFAJCKAQAuOVoycIoBAAMJBQCVigEALjlOMnCKAQADBwUAkIoBAC45SjdwigEABAcFAJqKAQAuOUo3cIoBAAQHBQCaigEALjlKN3CKAQAEBwUAmooBAC45TjJwigEAAwcFAJCKAQAuOU4ucIoBAAMHBQCQigEALjlOMnCKAQADBwUAkIoBACIpKSBwigEAAwcFAJqKAQAuOTcycIoBAAMHBQCaigEAo1MBABABAAAAVAEADAEAANJUAQARAQAAClUBACMAAAB/VQEAGwAAADRWAQAVAAAAxVYBAAABAAABVwEAAgEAAE1XAQADAQAAvVcBAAQBAAD7VwEABQEAAE5YAQATAAAAkVgBAB4AAADVWAEAFwAAAF9ZAQAaAAAAkVkBABkAAAD0WQEAGAAAADhaAQAdAAAAzloBABwAAAAPWwEAFgAAADdbAQAU"),s(t,129744,"Q1gBABABAACIWAEADAEAAPNYAQARAQAAM1kBACMAAACHWQEAGwAAAOBZAQAVAAAAQloBAAABAACcWgEAAgEAAABbAQADAQAAT1sBAAQBAACnWwEABQEAAEhcAQATAAAAc1wBAB4AAADEXAEAFwAAABVdAQAaAAAAXV0BABkAAACIXQEAGAAAANJdAQAdAAAABF4BABwAAAAvXgEAFgAAAF9eAQAU"),s(t,129920,"u08BAAEAAABcUAEAAAAAAM9QAQAAAAAAOFIBAAAAAABBUwEAAAAAAIFTAQAAAAAA+1MBAAAAAADnVAEAAAAAACVVAQAAAAAAiVUBAAAAAABUVgEAAAAAAPxWAQAAAAAADlcBAAAAAABIVwEAAAAAAKdXAQAAAAAA9lcBAAAAAAA3WAEAAAAAAKNYAQAAAAAA6FgBAAAAAAAuWQEAAAAAAH9ZAQAAAAAA61kBAAAAAAD/////g00BAIIAAAB5AAAAdg=="),s(t,130128,"4I8BAOCPAQBQkAEAwJABAMCQAQDAkAEAAQAAANQKAwCMCgMAROcC"),s(t,130176,"I0sBAAEAAAAAAAAA/////1dMAQABAAAA+0wBAAIAAADGTQEAAwAAAAAAAAD/////Vk4BAAAAAADSTgEAAQAAALJPAQACAAAAGFABABQAAAAAAAAA/////wAAAAAAAAAAt1ABABIAAABNUgEAFAAAAN5SAQAkAAAAhlMBAEAAAAARVAEAwQAAAAAAAAD/////q1QBAAEAAAAAAAAA/////1dMAQAAAAAAGVUBAAEAAACRVQEAAgAAAENWAQADAAAA31YBAAQAAAAgVwEABQAAAAAAAAD/////AAAAAAAAAABXTAEAAQAAAIlXAQACAAAAr1cBAAMAAADfVgEABAAAACBXAQAFAAAAAAAAAP////8AAAAAClgBADxYAQAYUAEAqFgB"),s(t,130480,"8l8BAAEAAAA5YAEAAgAAAFhgAQADAAAAgWABAAQAAACwYAEABQAAANNgAQAGAAAABWEBAAcAAAAqYQEACAAAAFFhAQAJAAAAdmEBAAoAAACQYQEACwAAAMNhAQAMAAAA+WEBAA0AAAAuYgEADgAAAE5iAQAPAAAAhmIBAA8AAADUYgEADwAAABljAQAPAAAAP2MBAA8AAACkYwEABwAAANpjAQAHAAAAO2QBAAcAAACEZAEABwAAAK9kAQAHAAAAw2QBAA4AAADnZAEADgAAAAplAQAQAAAA9GUBABAAAAArZgEAEAAAAN9WAQAQAAAAbmYBABAAAADBZgEAEA=="),s(t,130752,"f20BAD4AAACjbQEAPOAAAM1tAQAmAAAA1G0BACIAAAA6bgEAIAAAAHhuAQAnAAAAAAAAAP////8AAAAAAAAAAGNnAQBkAAAAxWcBAAAAAAAJaAEAHgAAAEJoAQBBAAAAQ1YBAGQAAACGaAEAlgAAAKVoAQDmAAAAAAAAAP////9jZwEAZAAAAL5oAQA8AAAA6WgBAFAAAABDVgEAZAAAABJpAQB9AAAAUmkBAKAAAAAAAAAA/////wAAAAAAAAAAY2cBAGQAAACUaQEARgAAAN5pAQBVAAAAQ1YBAGQAAAAoagEAbgAAAGdqAQB4AAAAAAAAAP////8AAAAAAAAAAGNnAQBkAAAAlGkBABQAAADeaQEAMgAAAENWAQBkAAAAKGoBAIwAAABnagEAtAAAAAAAAAD/////"),s(t,131076,"QP8BAAD/AQCA/wEAwP8B"),s(t,131104,"wmoBACDgAAALawEACeAAAEFrAQBf4AAAe2sBACI="),s(t,131152,"q2sBAAEAAAC8awEAAgAAAA1sAQAD"),s(t,131184,"+EwBAMJNAQBTTgEACU8BAOVPAQBkUAEA2lABAGdSAQDyUgEA1FMBAGFUAQ=="),s(t,131236,"iFIBADlTAQAAAAAAnlMBAGRUAQDwVAEAL1UBAJpVAQBQVgE="),s(t,131280,"Y1IBAIADAACAA/8DbGUAAAcAAAA0UwEAIAQAAAAELwUAAAAAAAAAAHNTAQAwBQAAMAWPBXloAAAEAAAAG1QBAJAFAACQBf8FAAAAAAAAAAC3VAEAAAYAAAAG/wYAAAAAAAAAACpVAQAABwAAAAdPBwAAAAAAAAAAllUBAAAJAAAACX8JaWgAAAQAAAA/VgEAgAkAAIAJ/wluYgAABAAAANZWAQAACgAAAAp/CmFwAAAEAAAAClcBAIAKAACACv8KdWcAAAQAAABfVwEAAAsAAAALfwsAAAAAAAAAAM5XAQCACwAAgAv/C2F0AAAEAAAAD1gBAAAMAAAADH8MZXQAAAAAAAAsWAEAgAwAAIAM/wxuawAABAAAAJ9YAQAADQAAAA1/DWxtAAAEAAAA5FgBAIANAACADf8NaXMAAAQAAAA8WQEAAA4AAAAOfw4AAAAAAAAAAJtZAQCADgAAgA7/DgAAAAAAAAAA8FkBAAAPAAAAD/8PAAAAAAAAAAA0WgEAABAAAAAQnxAAAAAAAAAAANlaAQCgEAAAoBD/EGFrAAAEAAAAGFsBAAARAAAAEf8Rb2sAAAQAAABKWwEAABIAAAASnxMAAAAAAAAAALlbAQAAKAAAACj/KAAAAAAQAAAAWlwBAEAwAABAMP8wAAAAAAgAAACDXAEAADEAAAAx/58AAAAACAAAABhbAQAApwAAAKf/129rAAAM"),s(t,131840,"WAIAAKoAAACwBAAAhwAAANAHAABuAAAAuAsAAG4AAAD/////"),s(t,131888,"qAsD"),s(t,131904,"mF4BAAEAAAA4XwEAAgAAAGFfAQADAAAAnV8BAAYAAADCXwEACQAAAPhfAQAKAAAAJ2ABAAQAAABNYAEABQAAAI1gAQAkAAAAq2ABAAsAAADVYAEADAAAAPZgAQANAAAAFmEBAA4AAABMYQEADwAAAGdhAQAQAAAAlmEBABEAAAC7YQEAEgAAAAJiAQAfAAAAG2IBACUAAABIYgEAIAAAAJJiAQAhAAAAzmIBACIAAADwYgEABwAAAC5jAQAI"),s(t,132112,"jmMBAAEAAAC8YwEAAgAAAAAAAAABAAAAFJwBACCcAQAsnAEAPAAAABo="),s(t,132163,"AgMFCAsOEhYbICUrMTc+RUxTWmJpcXmAiJCYn6autbzCyc/V2uDk6e3w9Pb5+/z9/f39/Pv59vTw7enk4NrVz8nCvLWupp+YkIiAeXFpYlpTTEU+NzErJSAbFhIOCwgFAwI="),s(t,132288,"QAAAAAABAAAAAAAA7AQCACcAAAAoAAAAKQAAACoAAAArAAAAQOkBAMO2AQBo6QEAsLYBAOQEAgAAAAAAJAUCACwAAAAtAAAALgAAAC8AAABA6QEAArcBAGjpAQDstgEAEAUCAGjpAQDStgEAGAUCAAU="),s(t,132412,"DQ=="),s(t,132436,"CwAAAAoAAADoeAM="),s(t,132460,"Ag=="),s(t,132476,"//////////8="),s(t,132544,"MAUCAAAAAAAF"),s(t,132564,"MA=="),s(t,132588,"CwAAADEAAAD4eAMAAAQ="),s(t,132612,"AQ=="),s(t,132628,"/////wo="),s(t,132696,"yAUCAAB/BA==");var Ss,Ns=(Ss=[null,function(e){var t,n=0;return n=A[(e|=0)>>2],A[e>>2]=n+1,n=255&(t=a[0|n]),(0|t)<0&&(n=g[(A[e+12>>2]+(n<<1)|0)-256>>1]),0|n},Ms,function(e){var t,n;return t=A[(e|=0)>>2],n=A[t>>2],A[e>>2]=t+4,0|n},function(e){var t=0,n=0;return t=A[(e|=0)>>2],65533==(0|(n=dt(e)))&&(A[e>>2]=t+1,A[e+8>>2]=1,n=255&(t=a[0|t]),(0|t)>=0||(n=g[(A[e+12>>2]+(n<<1)|0)-256>>1])),0|n},dt,function(e){var t,n,r=0;return(r=A[4+(e|=0)>>2])>>>0<=(n=(t=A[e>>2])+1|0)>>>0?(A[e>>2]=r,65533):(A[e>>2]=n,r=o[0|t],A[e>>2]=t+2,r|o[t+1|0]<<8)},function(e,t){var n,r,s;return t|=0,e=A[(e|=0)>>2],n=A[e+4>>2],r=A[t>>2],(t=mr(n+1|0,(s=A[r+4>>2])+1|0))||(t=a[0|n]-a[0|s]|0)||(t=mr(A[e>>2],A[r>>2])),0|t},function(e,t){var n;return e|=0,t=A[(t|=0)>>2],n=A[e>>2],(e=A[t+16>>2]-A[n+16>>2]|0)||(e=mr(A[n>>2],A[t>>2])),0|e},Bs,function(e,t,n,r){var s;return t|=0,n|=0,r|=0,U=s=U-16|0,(e=0|F(A[60+(e|=0)>>2],0|t,0|n,255&r,s+8|0))?(A[56798]=e,e=-1):e=0,U=s+16|0,K=e?-1:A[s+12>>2],0|(e?-1:A[s+8>>2])},function(e,t,n){t|=0,n|=0;var r,s=0,a=0,i=0,o=0,l=0,u=0;U=r=U-32|0,s=A[28+(e|=0)>>2],A[r+16>>2]=s,i=A[e+20>>2],A[r+28>>2]=n,A[r+24>>2]=t,t=i-s|0,A[r+20>>2]=t,i=t+n|0,l=2;e:{t:{t=r+16|0,(s=0|E(A[e+60>>2],0|t,2,r+12|0))?(A[56798]=s,s=-1):s=0;n:{if(s)s=t;else for(;;){if((0|(a=A[r+12>>2]))==(0|i))break n;if((0|a)<0){s=t;break t}if(o=a-((u=(o=A[t+4>>2])>>>0<a>>>0)?o:0)|0,A[(s=(u<<3)+t|0)>>2]=o+A[s>>2],A[(t=(u?12:4)+t|0)>>2]=A[t>>2]-o,i=i-a|0,t=s,l=l-u|0,(a=0|E(A[e+60>>2],0|t,0|l,r+12|0))?(A[56798]=a,a=-1):a=0,a)break}if(-1!=(0|i))break t}t=A[e+44>>2],A[e+28>>2]=t,A[e+20>>2]=t,A[e+16>>2]=t+A[e+48>>2],e=n;break e}A[e+28>>2]=0,A[e+16>>2]=0,A[e+20>>2]=0,A[e>>2]=32|A[e>>2],e=0,2!=(0|l)&&(e=n-A[s+4>>2]|0)}return U=r+32|0,0|e},function(e,t,n){e|=0,t|=0,n|=0;var r,s=0,i=0,l=0;U=r=U-32|0,A[r+16>>2]=t,s=A[e+48>>2],A[r+20>>2]=n-!!(0|s),i=A[e+44>>2],A[r+28>>2]=s,A[r+24>>2]=i;e:{t:{if((s=0|V(A[e+60>>2],r+16|0,2,r+12|0))?(A[56798]=s,s=-1):s=0,s)t=32;else{if((0|(s=A[r+12>>2]))>0)break t;t=s?32:16}A[e>>2]=t|A[e>>2];break e}l=s,(i=A[r+20>>2])>>>0>=s>>>0||(s=A[e+44>>2],A[e+4>>2]=s,A[e+8>>2]=s+(l-i|0),A[e+48>>2]&&(A[e+4>>2]=s+1,a[(t+n|0)-1|0]=o[0|s]),l=n)}return U=r+32|0,0|l},function(e){return 0|v(A[60+(e|=0)>>2])},ls,function(e,t,n,r,s,i){e|=0,t=+t,n|=0,r|=0,s|=0,i|=0;var u,c=0,h=0,f=0,g=0,p=0,m=0,C=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,D=0,T=0,S=0;U=u=U-560|0,A[u+44>>2]=0,d(+t),c=0|l(1),l(0),(0|c)<0?(v=1,T=84997,d(+(t=-t)),c=0|l(1),l(0)):2048&s?(v=1,T=85e3):(T=(v=1&s)?85003:84998,S=!v);e:if(2146435072&~c){B=u+16|0;t:{n:{r:{if(t=jn(t,u+44|0),0!=(t+=t)){if(c=A[u+44>>2],A[u+44>>2]=c-1,97!=(0|(M=32|i)))break r;break t}if(97==(0|(M=32|i)))break t;p=A[u+44>>2],m=(0|r)<0?6:r;break n}p=c-29|0,A[u+44>>2]=p,t*=268435456,m=(0|r)<0?6:r}for(h=x=(u+48|0)+((0|p)>=0?288:0)|0;r=t<4294967296&t>=0?~~t>>>0:0,A[h>>2]=r,h=h+4|0,0!=(t=1e9*(t-+(r>>>0))););if((0|p)<=0)r=p,c=h,f=x;else for(f=x,r=p;;){if(w=(0|r)>=29?29:r,!(f>>>0>(c=h-4|0)>>>0)){for(r=0;g=A[c>>2],D=r,r=31&w,(63&w)>>>0>=32?(C=g<<r,r=0):(C=(1<<r)-1&g>>>32-r,r=g<<r),g=C+k|0,r=ys(D=D+r|0,r>>>0>D>>>0?g+1|0:g,1e9),A[c>>2]=D-sr(r,K,1e9,0),f>>>0<=(c=c-4|0)>>>0;);r&&(A[(f=f-4|0)>>2]=r)}for(;f>>>0<(c=h)>>>0&&!A[(h=c-4|0)>>2];);if(r=A[u+44>>2]-w|0,A[u+44>>2]=r,h=c,!((0|r)>0))break}if((0|r)<0)for(E=1+((m+25>>>0)/9|0)|0,k=102==(0|M);;){if(C=(0|(r=0-r|0))>=9?9:r,c>>>0<=f>>>0)h=A[f>>2];else{for(w=1e9>>>C|0,g=~(-1<<C),r=0,h=f;D=r,r=A[h>>2],A[h>>2]=D+(r>>>C|0),r=b(w,r&g),(h=h+4|0)>>>0<c>>>0;);h=A[f>>2],r&&(A[c>>2]=r,c=c+4|0)}if(r=C+A[u+44>>2]|0,A[u+44>>2]=r,f=(!h<<2)+f|0,c=c-(h=k?x:f)>>2>(0|E)?h+(E<<2)|0:c,!((0|r)<0))break}if(r=0,!(c>>>0<=f>>>0||(r=b(x-f>>2,9),h=10,(g=A[f>>2])>>>0<10)))for(;r=r+1|0,g>>>0>=(h=b(h,10))>>>0;);if((0|(h=(m-(102!=(0|M)?r:0)|0)-(103==(0|M)&!!(0|m))|0))<(b(c-x>>2,9)-9|0)){if(p=((((0|p)<0?4:292)+u|0)+((g=(0|(w=h+9216|0))/9|0)<<2)|0)-4048|0,h=10,(0|(C=w-b(g,9)|0))<=7)for(;h=b(h,10),8!=(0|(C=C+1|0)););if(!(!(k=(w=A[p>>2])-b(h,E=(w>>>0)/(h>>>0)|0)|0)&(0|(g=p+4|0))==(0|c))&&(!(1&E)&&(t=9007199254740992,!(1&a[p-4|0])|1e9!=(0|h)|f>>>0>=p>>>0)||(t=9007199254740994),y=(0|c)==(0|g)?1:1.5,y=(g=h>>>1|0)>>>0>k>>>0?.5:(0|g)==(0|k)?y:1.5,45!=o[0|T]|S||(y=-y,t=-t),g=w-k|0,A[p>>2]=g,t+y!=t)){if(r=h+g|0,A[p>>2]=r,r>>>0>=1e9)for(;A[p>>2]=0,(p=p-4|0)>>>0<f>>>0&&(A[(f=f-4|0)>>2]=0),r=A[p>>2]+1|0,A[p>>2]=r,r>>>0>999999999;);if(r=b(x-f>>2,9),h=10,!((g=A[f>>2])>>>0<10))for(;r=r+1|0,g>>>0>=(h=b(h,10))>>>0;);}c=c>>>0>(h=p+4|0)>>>0?h:c}for(;g=c,!(w=c>>>0<=f>>>0)&&!A[(c=g-4|0)>>2];);if(103==(0|M)){if(m=((c=(0|(h=m||1))>(0|r)&(0|r)>-5)?~r:-1)+h|0,i=(c?-1:-2)+i|0,!(p=8&s)){if(c=-9,!w&&(p=A[g-4>>2])&&(C=10,c=0,!((p>>>0)%10|0))){for(;h=c,c=c+1|0,!((p>>>0)%((C=b(C,10))>>>0)|0););c=~h}h=b(g-x>>2,9),70!=(-33&i)?(p=0,m=(0|(c=(0|(c=((r+h|0)+c|0)-9|0))>0?c:0))>(0|m)?m:c):(p=0,m=(0|(c=(0|(c=(c+h|0)-9|0))>0?c:0))>(0|m)?m:c)}}else p=8&s;if(C=-1,(0|((w=p|m)?2147483645:2147483646))<(0|m))break e;if(k=1+(!!(0|w)+m|0)|0,70!=(0|(h=-33&i))){if((B-(c=Kn(((c=r>>31)^r)-c|0,0,B))|0)<=1)for(;a[0|(c=c-1|0)]=48,(B-c|0)<2;);if(a[0|(E=c-2|0)]=i,a[c-1|0]=(0|r)<0?45:43,(0|(c=B-E|0))>(2147483647^k))break e}else{if((2147483647^k)<(0|r))break e;c=(0|r)>0?r:0}if((0|(r=c+k|0))>(2147483647^v))break e;lr(e,32,n,k=r+v|0,s),hs(e,T,v),lr(e,48,n,k,65536^s);n:{r:{s:{if(70==(0|h)){for(r=8|(i=u+16|0),p=9|i,f=h=f>>>0>x>>>0?x:f;;){c=Kn(A[f>>2],0,p);a:if((0|h)==(0|f))(0|c)==(0|p)&&(a[u+24|0]=48,c=r);else{if(u+16>>>0>=c>>>0)break a;for(;a[0|(c=c-1|0)]=48,u+16>>>0<c>>>0;);}if(hs(e,c,p-c|0),!(x>>>0>=(f=f+4|0)>>>0))break}if(w&&hs(e,85998,1),(0|m)<=0|f>>>0>=g>>>0)break s;for(;;){if((c=Kn(A[f>>2],0,p))>>>0>u+16>>>0)for(;a[0|(c=c-1|0)]=48,u+16>>>0<c>>>0;);if(hs(e,c,(0|m)>=9?9:m),c=m-9|0,g>>>0<=(f=f+4|0)>>>0)break r;if(r=(0|m)>9,m=c,!r)break}break r}a:if(!((0|m)<0))for(x=f>>>0<g>>>0?g:f+4|0,r=8|(i=u+16|0),g=9|i,h=f;;){(0|g)==(0|(c=Kn(A[h>>2],0,g)))&&(a[u+24|0]=48,c=r);i:if((0|h)==(0|f))hs(e,c,1),c=c+1|0,p|m&&hs(e,85998,1);else{if(u+16>>>0>=c>>>0)break i;for(;a[0|(c=c-1|0)]=48,u+16>>>0<c>>>0;);}if(hs(e,c,(0|(i=g-c|0))>(0|m)?m:i),m=m-i|0,x>>>0<=(h=h+4|0)>>>0)break a;if(!((0|m)>=0))break}lr(e,48,m+18|0,18,0),hs(e,E,B-E|0);break n}c=m}lr(e,48,c+9|0,9,0)}lr(e,32,n,k,8192^s),C=(0|n)<(0|k)?k:n;break e}if(p=(i<<26>>31&9)+T|0,!(r>>>0>11)){for(c=12-r|0,y=16;y*=16,c=c-1|0;);t=45!=o[0|p]?t+y-y:-(y+(-t-y))}for((0|B)==(0|(c=Kn(((c=A[u+44>>2])^(h=c>>31))-h|0,0,B)))&&(a[u+15|0]=48,c=u+15|0),x=2|v,f=32&i,h=A[u+44>>2],a[0|(m=c-2|0)]=i+15,a[c-1|0]=(0|h)<0?45:43,c=8&s,h=u+16|0;i=h,g=I(t)<2147483648?~~t:-2147483648,a[0|h]=f|o[g+124512|0],!((0|r)>0|c)&0==(t=16*(t-+(0|g)))|1!=((h=i+1|0)-(u+16|0)|0)||(a[i+1|0]=46,h=i+2|0),0!=t;);C=-1,(2147483645-(i=(c=B-m|0)+x|0)|0)<(0|r)||(lr(e,32,n,i=(r=!r||((f=h-(u+16|0)|0)-2|0)>=(0|r)?f=h-(u+16|0)|0:r+2|0)+i|0,s),hs(e,p,x),lr(e,48,n,i,65536^s),hs(e,u+16|0,f),lr(e,48,r-f|0,0,0),hs(e,m,c),lr(e,32,n,i,8192^s),C=(0|n)<(0|i)?i:n)}else lr(e,32,n,c=v+3|0,-65537&s),hs(e,T,v),r=32&i,hs(e,t!=t?r?85596:85774:r?85247:85460,3),lr(e,32,n,c,8192^s),C=(0|n)<(0|c)?c:n;return U=u+560|0,0|C},function(e,t){var n;e|=0,n=t|=0,t=A[t>>2]+7&-8,A[n>>2]=t+16,m[e>>3]=nt(A[t>>2],A[t+4>>2],A[t+8>>2],A[t+12>>2])},function(e,t,n){t|=0,n|=0;var r,s,i=0,o=0;return r=A[84+(e|=0)>>2],o=A[r+4>>2],s=A[e+28>>2],(i=(i=A[e+20>>2]-s|0)>>>0>o>>>0?o:i)&&(Je(A[r>>2],s,i),A[r>>2]=i+A[r>>2],o=A[r+4>>2]-i|0,A[r+4>>2]=o),i=A[r>>2],(o=n>>>0>o>>>0?o:n)&&(Je(i,t,o),i=o+A[r>>2]|0,A[r>>2]=i,A[r+4>>2]=A[r+4>>2]-o),a[0|i]=0,t=A[e+44>>2],A[e+28>>2]=t,A[e+20>>2]=t,0|n},function(e,t,n){n|=0;var r,s,a=0;return Je(t|=0,r=A[84+(e|=0)>>2],n=n>>>0>(a=(s=Zt(r,0,a=n+256|0))?s-r|0:a)>>>0?a:n),t=r+a|0,A[e+84>>2]=t,A[e+8>>2]=t,A[e+4>>2]=n+r,0|n},function(e,t,n){t|=0,n|=0;var r,s=0,i=0,l=0;s=A[84+(e|=0)>>2],r=A[s>>2]?s:84412,s=0;e:if(A[e+48>>2])for(;;){if(!(i=A[(s<<2)+r>>2]))break e;if(a[A[e+44>>2]+s|0]=(0|i)>=128?64:i,!((s=s+1|0)>>>0<p[e+48>>2]))break}return i=A[e+44>>2],A[e+4>>2]=i,A[e+84>>2]=(s<<2)+r,A[e+8>>2]=s+i,!n|!s||(A[e+4>>2]=i+1,a[0|t]=o[0|i],l=1),0|l},Bs,Ds,Ts,Ts,function(e,t,n){n|=0;var r,s=0;return U=r=U+-64|0,s=1,Wr(e|=0,t|=0,0)||(s=0,t&&(s=0,(t=It(t,125132))&&(kt(4|(s=r+8|0),0,52),A[r+56>>2]=1,A[r+20>>2]=-1,A[r+16>>2]=e,A[r+8>>2]=t,Ns[A[A[t>>2]+28>>2]](t,s,A[n>>2],1),1==(0|(e=A[r+32>>2]))&&(A[n>>2]=A[r+24>>2]),s=1==(0|e)))),U=r- -64|0,0|s},function(e,t,n,r,s,a){n|=0,r|=0,s|=0,a|=0,Wr(e|=0,A[8+(t|=0)>>2],a)&&pn(t,n,r,s)},function(e,t,n,r,s){if(n|=0,r|=0,s|=0,Wr(e|=0,A[8+(t|=0)>>2],s))1==A[t+28>>2]|A[t+4>>2]!=(0|n)||(A[t+28>>2]=r);else e:if(Wr(e,A[t>>2],s)){if(!(A[t+16>>2]!=(0|n)&A[t+20>>2]!=(0|n))){if(1!=(0|r))break e;return void(A[t+32>>2]=1)}A[t+20>>2]=n,A[t+32>>2]=r,A[t+40>>2]=A[t+40>>2]+1,1!=A[t+36>>2]|2!=A[t+24>>2]||(a[t+54|0]=1),A[t+44>>2]=4}},function(e,t,n,r){n|=0,r|=0,Wr(e|=0,A[8+(t|=0)>>2],0)&&or(t,n,r)},Ds,function(e,t,n,r,s,a){n|=0,r|=0,s|=0,a|=0,Wr(e|=0,A[8+(t|=0)>>2],a)?pn(t,n,r,s):(e=A[e+8>>2],Ns[A[A[e>>2]+20>>2]](e,t,n,r,s,a))},function(e,t,n,r,s){if(n|=0,r|=0,s|=0,Wr(e|=0,A[8+(t|=0)>>2],s))1==A[t+28>>2]|A[t+4>>2]!=(0|n)||(A[t+28>>2]=r);else e:{if(Wr(e,A[t>>2],s)){if(!(A[t+16>>2]!=(0|n)&A[t+20>>2]!=(0|n))){if(1!=(0|r))break e;return void(A[t+32>>2]=1)}A[t+32>>2]=r;t:if(4!=A[t+44>>2]){if(i[t+52>>1]=0,e=A[e+8>>2],Ns[A[A[e>>2]+20>>2]](e,t,n,n,1,s),o[t+53|0]){if(A[t+44>>2]=3,!o[t+52|0])break t;break e}A[t+44>>2]=4}if(A[t+20>>2]=n,A[t+40>>2]=A[t+40>>2]+1,1!=A[t+36>>2]|2!=A[t+24>>2])break e;return void(a[t+54|0]=1)}e=A[e+8>>2],Ns[A[A[e>>2]+24>>2]](e,t,n,r,s)}},function(e,t,n,r){n|=0,r|=0,Wr(e|=0,A[8+(t|=0)>>2],0)?or(t,n,r):(e=A[e+8>>2],Ns[A[A[e>>2]+28>>2]](e,t,n,r))},Ds,function(e){return 84787},Ds,function(e){return 85058},Ds,function(e){return 84147},function(e){var t;return t=e|=0,e=A[e>>2],A[t>>2]=e+1,0|((0|(e=a[0|e]))<0?65533:255&e)},function(e,t,n,r,s,i){e|=0,t|=0,n|=0,r|=0,s|=0,i|=0;var l,u=0,c=0,d=0,f=0,g=0,p=0,b=0,C=0;if(l=Or(408),A[l+4>>2]=r,A[l>>2]=n,t?(Je(l+16|0,t,376),m[l+392>>3]=(m[t+368>>3]-m[t>>3])/+(n>>>0),t=0):t=1,A[l+400>>2]=s,a[l+8|0]=t,i){if(n=A[e+24>>2])for(t=A[e+20>>2],r=A[e+8>>2];(s=A[A[(t>>>8&16777212)+r>>2]+((1023&t)<<2)>>2])&&(Ee(s),n=A[e+24>>2],r=A[e+8>>2],t=A[e+20>>2]),t=t+1|0,A[e+20>>2]=t,n=n-1|0,A[e+24>>2]=n,t>>>0>=2048&&(Ee(A[r>>2]),r=A[e+8>>2]+4|0,A[e+8>>2]=r,t=A[e+20>>2]-1024|0,A[e+20>>2]=t,n=A[e+24>>2]),n;);t=A[e+28>>2],A[e+420>>2]=A[t>>2],(n=A[e+32>>2])&&(a[t+8|0]=o[n+8|0],Je(t+16|0,e+40|0,376),(t=A[e+32>>2])&&Ee(t),A[e+32>>2]=0)}if(n=(r=A[e+24>>2])+A[e+20>>2]|0,s=A[e+12>>2],(0|n)==(0|((0|(t=A[e+8>>2]))!=(0|s)?(s-t<<8)-1:0))){U=u=U-32|0;e:{t:{n:{r:{if((t=A[16+(i=e+4|0)>>2])>>>0>=1024){if(A[i+16>>2]=t-1024,t=A[i+4>>2],p=A[t>>2],s=t+4|0,A[i+4>>2]=s,(0|(t=A[i+8>>2]))==A[i+12>>2])if((c=A[i>>2])>>>0<s>>>0)n=mt((r=(1+(s-c>>2)|0)/-2<<2)+s|0,s,t=t-s|0)+t|0,A[i+8>>2]=n,A[i+4>>2]=r+A[i+4>>2];else{if((n=(0|t)==(0|c)?1:t-c>>1)>>>0>=1073741824)break r;if(b=(r=n<<2)+(d=Or(r))|0,n=r=d+(-4&n)|0,(0|t)!=(0|s)){if(C=-4&(t=t-s|0),g=1+((f=t-4|0)>>>2|0)&7)for(n=0,t=r;A[t>>2]=A[s>>2],s=s+4|0,t=t+4|0,(0|g)!=(0|(n=n+1|0)););else t=r;if(n=r+C|0,!(f>>>0<28))for(;A[t>>2]=A[s>>2],A[t+4>>2]=A[s+4>>2],A[t+8>>2]=A[s+8>>2],A[t+12>>2]=A[s+12>>2],A[t+16>>2]=A[s+16>>2],A[t+20>>2]=A[s+20>>2],A[t+24>>2]=A[s+24>>2],A[t+28>>2]=A[s+28>>2],s=s+32|0,(0|n)!=(0|(t=t+32|0)););}A[i+12>>2]=b,A[i+8>>2]=n,A[i+4>>2]=r,A[i>>2]=d,c&&(Ee(c),n=A[i+8>>2])}else n=t;A[n>>2]=p,A[i+8>>2]=A[i+8>>2]+4;break e}if((c=(s=A[i+8>>2])-A[i+4>>2]>>2)>>>0<(r=(t=A[i+12>>2])-(n=A[i>>2])|0)>>2>>>0){if((0|t)!=(0|s)){A[u+8>>2]=Or(4096),ut(i,u+8|0);break e}if(A[u+8>>2]=Or(4096),ot(i,u+8|0),t=A[i+4>>2],p=A[t>>2],s=t+4|0,A[i+4>>2]=s,(0|(t=A[i+8>>2]))==A[i+12>>2])if((c=A[i>>2])>>>0<s>>>0)n=mt((r=(1+(s-c>>2)|0)/-2<<2)+s|0,s,t=t-s|0)+t|0,A[i+8>>2]=n,A[i+4>>2]=r+A[i+4>>2];else{if((n=(0|t)==(0|c)?1:t-c>>1)>>>0>=1073741824)break r;if(b=(r=n<<2)+(d=Or(r))|0,n=r=d+(-4&n)|0,(0|t)!=(0|s)){if(C=-4&(t=t-s|0),g=1+((f=t-4|0)>>>2|0)&7)for(n=0,t=r;A[t>>2]=A[s>>2],s=s+4|0,t=t+4|0,(0|g)!=(0|(n=n+1|0)););else t=r;if(n=r+C|0,!(f>>>0<28))for(;A[t>>2]=A[s>>2],A[t+4>>2]=A[s+4>>2],A[t+8>>2]=A[s+8>>2],A[t+12>>2]=A[s+12>>2],A[t+16>>2]=A[s+16>>2],A[t+20>>2]=A[s+20>>2],A[t+24>>2]=A[s+24>>2],A[t+28>>2]=A[s+28>>2],s=s+32|0,(0|n)!=(0|(t=t+32|0)););}A[i+12>>2]=b,A[i+8>>2]=n,A[i+4>>2]=r,A[i>>2]=d,c&&(Ee(c),n=A[i+8>>2])}else n=t;A[n>>2]=p,A[i+8>>2]=A[i+8>>2]+4;break e}if(A[u+24>>2]=i+12,!((t=(0|t)==(0|n)?1:r>>1)>>>0>=1073741824)){if(t=Or(n=t<<2),A[u+8>>2]=t,r=t+(c<<2)|0,A[u+16>>2]=r,A[u+20>>2]=t+n,A[u+12>>2]=r,A[u+4>>2]=Or(4096),ut(u+8|0,u+4|0),(0|(s=A[i+8>>2]))==A[i+4>>2]){t=s;break t}for(;ot(u+8|0,s=s-4|0),A[i+4>>2]!=(0|s););break n}}Vr(),h()}t=A[i+8>>2]}n=A[i>>2],A[i>>2]=A[u+8>>2],A[u+8>>2]=n,A[i+4>>2]=A[u+12>>2],A[u+12>>2]=s,A[i+8>>2]=A[u+16>>2],A[u+16>>2]=t,r=A[i+12>>2],A[i+12>>2]=A[u+20>>2],A[u+20>>2]=r,(0|t)!=(0|s)&&(A[u+16>>2]=t+(3+(s-t|0)&-4)),n&&Ee(n)}U=u+32|0,n=(r=A[e+24>>2])+A[e+20>>2]|0,t=A[e+8>>2]}A[A[t+(n>>>8&16777212)>>2]+((1023&n)<<2)>>2]=l,A[e+24>>2]=r+1},function(e){var t=0,n=0,r=0,s=0,i=0,l=0,u=0,c=0,d=0;n=A[420+(e|=0)>>2]+1|0,A[e+420>>2]=n;e:{if(t=A[e+32>>2]){if(n>>>0>(u=A[t+4>>2])>>>0){(n=A[e+28>>2])&&(Ee(n),t=A[e+32>>2]),A[e+32>>2]=0,A[e+28>>2]=t;break e}for(i=e+40|0,l=t+16|0,c=A[e+28>>2]+16|0,d=+(n>>>0)/+(u>>>0),t=0;;){if(r=m[(n=t<<3)+l>>3],s=m[n+c>>3],m[n+i>>3]=r==r?(r-s)*d+s:s,47==(0|(n=1|t)))break e;r=m[(n<<=3)+l>>3],s=m[n+c>>3],m[n+i>>3]=r==r?(r-s)*d+s:s,t=t+2|0}}if(t=A[e+28>>2],n>>>0>p[t>>2]){if(i=A[e+24>>2]){if(a[e+416|0]=0,l=A[e+8>>2],n=A[e+20>>2],t=A[A[l+(n>>>8&16777212)>>2]+((1023&n)<<2)>>2],A[e+32>>2]=t,A[e+24>>2]=i-1,n=n+1|0,A[e+20>>2]=n,n>>>0>=2048&&(Ee(A[l>>2]),A[e+8>>2]=A[e+8>>2]+4,A[e+20>>2]=A[e+20>>2]-1024,t=A[e+32>>2]),o[t+8|0])Je(t+16|0,A[e+28>>2]+16|0,376),t=A[e+32>>2],A[t+368>>2]=0,A[t+372>>2]=0,r=m[e+40>>3],A[t+392>>2]=0,A[t+396>>2]=0,m[t+16>>3]=r;else if(n=A[e+28>>2],o[n+8|0]&&(Je(n+16|0,t+16|0,376),t=A[e+28>>2],A[t+368>>2]=0,A[t+372>>2]=0,!(t=A[e+32>>2])))break e;-1!=(0|(n=A[t+400>>2]))&&(A[e+424>>2]=n),A[e+420>>2]=0,m[t+16>>3]=m[t+392>>3]*+p[t+4>>2]+m[t+16>>3];break e}a[e+416|0]=1}else r=m[t+392>>3]+m[e+40>>3],m[e+40>>3]=r,m[t+16>>3]=r}return 0|(o[e+416|0]?0:e+40)},function(e){return A[424+(e|=0)>>2]},function(e){var t=0;return A[(e|=0)>>2]=132304,(t=A[e+28>>2])&&Ee(t),(t=A[e+32>>2])&&Ee(t),qt(e+4|0),0|e},function(e){var t=0;A[(e|=0)>>2]=132304,(t=A[e+28>>2])&&Ee(t),(t=A[e+32>>2])&&Ee(t),qt(e+4|0),Ee(e)},function(e,t,n){t|=0,n|=0;var r=0,s=0,o=0,l=0,u=0,c=0,d=0,h=0,f=0,g=0,p=0,b=0,C=0,w=0,k=0,x=0,y=0,v=0,E=0;if(!A[1088+(e|=0)>>2])return 0;e:if(t){for(d=e+648|0,c=e- -64|0;;){if(r=A[e+1088>>2],!(r=0|Ns[A[A[r>>2]+4>>2]](r)))break e;if(s=rt(m[e+32>>3]+m[r+16>>3]/+A[e+24>>2]),m[e+32>>3]=s,s=An(6.283185307179586*s),s=rt(m[e+16>>3]+m[r>>3]*(.06*s*m[r+8>>3]+1)/+A[e+8>>2]),m[e+16>>3]=s,u=sr(A[56848],A[56849],1284865837,1481765933),o=K,o=(u=u+1|0)?o:o+1|0,A[56848]=u,A[56849]=o,l=.75*m[e+40>>3]+ +(o>>>1|0)/2147483647,m[e+40>>3]=l,h=m[r+24>>3],o=s>=m[r+32>>3],a[e+48|0]=o,l=(g=h)*(h=.2*l),l=Ot(c+512|0,Ot(c+440|0,s=m[r+352>>3]*(h*m[r+48>>3]+m[r+40>>3]*(s+s+-1+(o?l:.01*l)))*.5,m[r+104>>3],m[r+168>>3]),m[r+112>>3],m[r+176>>3]),l=Ot(c+8|0,Ot(c+80|0,Ot(c+152|0,Ot(c+224|0,Ot(c+296|0,Ot(c+368|0,l==l?(l-s)*m[r+184>>3]+s:s,m[r+96>>3],m[r+160>>3]),m[r+88>>3],m[r+152>>3]),m[r+80>>3],m[r+144>>3]),m[r+72>>3],m[r+136>>3]),m[r+64>>3],m[r+128>>3]),m[r+56>>3],m[r+120>>3]),u=sr(A[56848],A[56849],1284865837,1481765933),o=K,o=(u=u+1|0)?o:o+1|0,A[56848]=u,A[56849]=o,s=.75*m[e+56>>3]+ +(o>>>1|0)/2147483647,m[e+56>>3]=s,o=(f<<1)+n|0,h=Ot(d+8|0,s=m[r+352>>3]*(m[r+192>>3]*(.3*s))*.5,m[r+200>>3],m[r+248>>3]),p=m[r+296>>3],b=Ot(d+80|0,s,m[r+208>>3],m[r+256>>3]),C=m[r+304>>3],w=Ot(d+152|0,s,m[r+216>>3],m[r+264>>3]),k=m[r+312>>3],x=Ot(d+224|0,s,m[r+224>>3],m[r+272>>3]),y=m[r+320>>3],v=Ot(d+296|0,s,m[r+232>>3],m[r+280>>3]),E=m[r+328>>3],g=l,l=(Ot(d+368|0,s,m[r+240>>3],m[r+288>>3])-s)*m[r+336>>3]+(E*(v-s)+(y*(x-s)+(k*(w-s)+(C*(b-s)+(p*(h-s)+0))))),s=(g+(s==s?(s-l)*m[r+344>>3]+l:l))*m[r+360>>3]*4e3,r=(0|(r=I(s)<2147483648?~~s:-2147483648))>=32e3?32e3:r,i[o>>1]=(0|r)<=-32e3?-32e3:r,(0|(f=f+1|0))==(0|t))break}f=t}return 0|(t>>>0>f>>>0?f:t)},function(e,t){t|=0,A[1088+(e|=0)>>2]=t},Bs,Ds,Ms,function(e,t,n,r){return K=0,0}],Ss.grow=function(e){var t=this.length;return this.length=this.length+e,t},Ss.set=function(e,t){this[e]=t},Ss.get=function(e){return this[e]},Ss);return{v:function(){var e,t=0;U=e=U-16|0,0|_(e+12|0,e+8|0)||(t=ie(4+(A[e+12>>2]<<2)|0),A[56800]=t,t&&(!(t=ie(A[e+8>>2]))||(A[A[56800]+(A[e+12>>2]<<2)>>2]=0,0|W(A[56800],0|t)))&&(A[56800]=0)),U=e+16|0,A[56841]=227236,A[56823]=42},w:vs,x:xs,y:function(e,t){t|=0,A[(e|=0)>>2]=t},z:function(e,t){return t|=0,a[A[4+(e|=0)>>2]+t|0]},A:ws,B:ps,C:function(e){return o[12+(e|=0)|0]},D:function(e,t){t|=0,a[12+(e|=0)|0]=t},E:function(e){return o[13+(e|=0)|0]},F:function(e,t){t|=0,a[13+(e|=0)|0]=t},G:function(e){return o[14+(e|=0)|0]},H:function(e,t){t|=0,a[14+(e|=0)|0]=t},I:function(e){return o[15+(e|=0)|0]},J:function(e,t){t|=0,a[15+(e|=0)|0]=t},K:Cs,L:function(e,t){t|=0,A[16+(e|=0)>>2]=t},M:Is,N:function(e,t){t|=0,A[20+(e|=0)>>2]=t},O:vs,P:xs,Q:ks,R:ws,S:bs,T:Cs,U:Is,V:function(e){return A[24+(e|=0)>>2]},W:vs,X:function(){var e,t=0,n=0,r=0,s=0,l=0,u=0,c=0,d=0,h=0,f=0,C=0,w=0,k=0,x=0,y=0,v=0,E=0,B=0,M=0,T=0,S=0,N=0,G=0;if(e=Or(20),A[e+16>>2]=0,A[e+8>>2]=175,A[e+12>>2]=50,!(t=A[33208])){U=t=(U=M=U-16|0)-80|0;e:{if(n=Gn(84292)){if(A[t+32>>2]=n,Cn(137584,160,85959,t+32|0),-31==(0|Ar(137584)))break e;if(A[t+16>>2]=n,Cn(137584,160,86031,t+16|0),-31==(0|Ar(137584)))break e}(n=Gn(84619))&&(A[t>>2]=n,Cn(137584,160,85959,t),-31==(0|Ar(137584)))||(n=o[84826]|o[84827]<<8|o[84828]<<16|o[84829]<<24,A[34396]=o[84822]|o[84823]<<8|o[84824]<<16|o[84825]<<24,A[34397]=n,i[68804]=o[84846]|o[84847]<<8,n=o[84842]|o[84843]<<8|o[84844]<<16|o[84845]<<24,A[34400]=o[84838]|o[84839]<<8|o[84840]<<16|o[84841]<<24,A[34401]=n,n=o[84834]|o[84835]<<8|o[84836]<<16|o[84837]<<24,A[34398]=o[84830]|o[84831]<<8|o[84832]<<16|o[84833]<<24,A[34399]=n)}if(U=t+80|0,A[M+12>>2]=0,s=M+12|0,U=c=U-16|0,A[c+12>>2]=22050,gt(85144)||gt(85315)||gt(85473)||gt(85698),C=c+12|0,U=l=U-16|0,A[l+12>>2]=0,!((t=Vt(137832,84262,0,s))||(t=Vt(137836,84420,0,s))||(t=Vt(137840,84813,0,s))||(t=Vt(137820,85016,l+12|0,s))))if(A[34454]=p[l+12>>2]/68,n=A[34460],A[34456]=n,n&&83969==(0|(h=o[0|n]|o[n+1|0]<<8|o[n+2|0]<<16|o[n+3|0]<<24))){if(w=o[n+4|0]|o[n+5|0]<<8|o[n+6|0]<<16|o[n+7|0]<<24,n=A[34458],x=o[0|n],A[34461]=x,x)for(t=n+4|0,h=0;r=b(h,44)+137856|0,s=o[0|t],A[r+36>>2]=s,A[r+40>>2]=o[t+1|0],u=o[t+8|0]|o[t+9|0]<<8|o[t+10|0]<<16|o[t+11|0]<<24,n=o[t+4|0]|o[t+5|0]<<8|o[t+6|0]<<16|o[t+7|0]<<24,a[0|r]=n,a[r+1|0]=n>>>8,a[r+2|0]=n>>>16,a[r+3|0]=n>>>24,a[r+4|0]=u,a[r+5|0]=u>>>8,a[r+6|0]=u>>>16,a[r+7|0]=u>>>24,u=o[t+16|0]|o[t+17|0]<<8|o[t+18|0]<<16|o[t+19|0]<<24,n=o[t+12|0]|o[t+13|0]<<8|o[t+14|0]<<16|o[t+15|0]<<24,a[r+8|0]=n,a[r+9|0]=n>>>8,a[r+10|0]=n>>>16,a[r+11|0]=n>>>24,a[r+12|0]=u,a[r+13|0]=u>>>8,a[r+14|0]=u>>>16,a[r+15|0]=u>>>24,u=o[t+24|0]|o[t+25|0]<<8|o[t+26|0]<<16|o[t+27|0]<<24,n=o[t+20|0]|o[t+21|0]<<8|o[t+22|0]<<16|o[t+23|0]<<24,a[r+16|0]=n,a[r+17|0]=n>>>8,a[r+18|0]=n>>>16,a[r+19|0]=n>>>24,a[r+20|0]=u,a[r+21|0]=u>>>8,a[r+22|0]=u>>>16,a[r+23|0]=u>>>24,u=o[t+32|0]|o[t+33|0]<<8|o[t+34|0]<<16|o[t+35|0]<<24,n=o[t+28|0]|o[t+29|0]<<8|o[t+30|0]<<16|o[t+31|0]<<24,a[r+24|0]=n,a[r+25|0]=n>>>8,a[r+26|0]=n>>>16,a[r+27|0]=n>>>24,a[r+28|0]=u,a[r+29|0]=u>>>8,a[r+30|0]=u>>>16,a[r+31|0]=u>>>24,n=t+36|0,A[r+32>>2]=n,t=n+(s<<4)|0,(0|x)!=(0|(h=h+1|0)););(0|x)<=A[34457]&&(A[34457]=0),t=0,C&&(A[C>>2]=w)}else e:{t:{if(s){if(n=A[s>>2]){Ee(A[n+4>>2]),t=A[s>>2];break t}if(t=ie(16),A[s>>2]=t,t)break t;t=48}else t=268436223;break e}A[t>>2]=1,A[t+4>>2]=$r(137584),n=A[s>>2],A[n+12>>2]=83969,A[n+8>>2]=h,t=268436223}if(U=l+16|0,n=t,!t){if(C=A[c+12>>2],A[50754]=C,A[50759]=0,A[50760]=134217728/(0|C),A[50762]=0,A[50763]=0,A[50765]=2147483647,A[50781]=100,A[50779]=32,A[50761]=(C<<6)/(0|C),t=A[26385],A[50784]=A[26384],A[50785]=t,t=A[26387],A[50786]=A[26386],A[50787]=t,t=A[26389],A[50788]=A[26388],A[50789]=t,t=A[26391],A[50790]=A[26390],A[50791]=t,t=A[26393],A[50792]=A[26392],A[50793]=t,t=A[26395],A[50794]=A[26394],A[50795]=t,t=A[26397],A[50796]=A[26396],A[50797]=t,A[50798]=A[26398],w=(0|(t=(0|(s=b(C,60)))/12800|0))>=128?128:t,A[50799]=w,A[50800]=(0|w)/2,!(22050==(0|C)|(0|s)<12800)){if(C=1&(t=(0|w)<=1?1:w),E=+(0|w),h=0,(0|w)>=2)for(w=2147483646&t,t=0;y=h+132160|0,d=127*(1-sn(6.283185307179586*+(0|h)/E)),k=I(d)<2147483648?~~d:-2147483648,a[0|y]=k,y=132160+(s=1|h)|0,d=127*(1-sn(6.283185307179586*+(0|s)/E)),k=I(d)<2147483648?~~d:-2147483648,a[0|y]=k,h=h+2|0,(0|w)!=(0|(t=t+2|0)););C&&(t=h+132160|0,d=127*(1-sn(6.283185307179586*+(0|h)/E)),y=I(d)<2147483648?~~d:-2147483648,a[0|t]=y)}if(A[50801]=105792,A[56797]=Re(),A[55964]=38,A[55921]=1,A[55918]=22050,A[56606]=0,A[55960]=110928,A[55958]=0,A[55959]=1074266112,A[55956]=100,A[55922]=20,A[55923]=220,A[55916]=1,A[55917]=0,Mr(),A[56244]=0,A[56245]=0,A[55928]=0,A[55926]=0,A[55927]=0,A[55924]=0,A[56246]=0,A[56247]=0,A[56260]=0,A[56261]=0,A[56262]=0,A[56263]=0,A[56276]=0,A[56277]=0,A[56278]=0,A[56279]=0,A[55974]=0,A[55975]=0,A[55972]=0,A[55973]=0,E=-3.141592653589793/+(0|(t=A[55918])),m[27967]=E,s=(0|b(t,630))/1e4|0,A[55920]=s,t=(0|b(t,950))/1e4|0,A[55919]=t,d=-2*E,m[27968]=d,E=(N=$e(E*+(0|s)))*-N,m[28129]=E,d=N*sn(d*+(0|t)),d+=d,m[28128]=d,m[28127]=1-d-E,A[55990]=0,A[55991]=0,A[55988]=0,A[55989]=0,A[56006]=0,A[56007]=0,A[56004]=0,A[56005]=0,A[56022]=0,A[56023]=0,A[56020]=0,A[56021]=0,A[56038]=0,A[56039]=0,A[56036]=0,A[56037]=0,A[56054]=0,A[56055]=0,A[56052]=0,A[56053]=0,A[56070]=0,A[56071]=0,A[56068]=0,A[56069]=0,A[56086]=0,A[56087]=0,A[56084]=0,A[56085]=0,A[56102]=0,A[56103]=0,A[56100]=0,A[56101]=0,A[56118]=0,A[56119]=0,A[56116]=0,A[56117]=0,A[56134]=0,A[56135]=0,A[56132]=0,A[56133]=0,A[56150]=0,A[56151]=0,A[56148]=0,A[56149]=0,A[56166]=0,A[56167]=0,A[56164]=0,A[56165]=0,A[56182]=0,A[56183]=0,A[56180]=0,A[56181]=0,A[56198]=0,A[56199]=0,A[56196]=0,A[56197]=0,A[56214]=0,A[56215]=0,A[56212]=0,A[56213]=0,A[56230]=0,A[56231]=0,A[56228]=0,A[56229]=0,A[56639]=59,A[56640]=59,A[56629]=0,A[56630]=59,A[56619]=89,A[56620]=160,A[56609]=280,A[56610]=688,A[56611]=1064,A[56621]=70,A[56631]=59,A[56612]=2806,A[56613]=3260,A[56622]=160,A[56623]=200,A[56632]=59,A[56633]=59,A[56641]=89,A[56642]=149,A[56643]=200,A[56644]=200,A[56634]=59,A[56635]=59,A[56624]=200,A[56625]=500,A[56614]=3700,A[56615]=6500,A[56645]=500,A[56646]=0,A[56616]=7e3,A[56626]=500,A[56636]=0,A[56647]=0,A[56637]=0,A[56627]=500,A[56617]=8e3,A[56669]=89,A[56648]=0,A[56638]=0,A[56628]=89,A[56618]=280,A[56657]=62,A[56655]=0,A[56656]=0,A[56653]=50,A[56654]=0,A[56651]=0,A[56652]=0,A[56649]=0,A[56650]=40,A[56607]=1e3,A[56608]=59,U=l=U-416|0,A[l+16>>2]=137584,A[l+20>>2]=47,A[l+24>>2]=85952,En(t=l+240|0,85699,l+16|0),u=et(t,86034)){if(yt(l+240|0,170,u))for(C=5|(t=l+240|0),w=10|t;47!=o[l+240|0]&&(1701736308!=A[l+240>>2]?Sn(l+240|0,86614,9)||(A[l+4>>2]=l+32,A[l>>2]=l+239,2==(0|ae(w,86829,l))&&(s=A[34064],A[(x=136272+(s<<4)|0)>>2]=a[l+239|0],t=$r(l+32|0),A[34064]=s+1,A[x+12>>2]=t,A[x+4>>2]=0)):(U=t=U-48|0,A[32960]=-1,A[32961]=-1,A[32970]=-1,A[32971]=-1,A[32968]=-1,A[32969]=-1,A[32966]=-1,A[32967]=-1,A[32964]=-1,A[32965]=-1,A[32962]=-1,A[32963]=-1,A[t+36>>2]=131876,A[t+32>>2]=131872,A[t+28>>2]=131868,A[t+24>>2]=131864,A[t+20>>2]=131860,A[t+16>>2]=131856,A[t+12>>2]=131852,A[t+8>>2]=131848,A[t+4>>2]=131844,A[t>>2]=131840,ae(C,84222,t),U=t+48|0)),yt(l+240|0,170,u););cr(u)}U=l+416|0,A[50297]=0,A[50298]=0,A[50301]=0,A[50302]=0,A[50299]=0,A[50300]=0,gn(0,85698),A[36425]=0,A[36424]=0,A[36426]=0,A[36427]=-1,es(),Se(0),r=A[25690],A[34062]=r,f=A[25689],l=A[25688],A[34060]=l,A[34061]=f,v=A[25687],u=A[25686],A[34058]=u,A[34059]=v,B=A[25685],x=A[25684],A[34056]=x,A[34057]=B,T=A[25683],C=A[25682],A[34054]=C,A[34055]=T,S=A[25681],w=A[25680],A[34052]=w,A[34053]=S,k=A[25679],s=A[25678],A[34050]=s,A[34051]=k,y=A[25677],t=A[25676],A[34048]=t,A[34049]=y,A[33729]=t,A[33730]=y,A[33731]=s,A[33732]=k,A[33733]=w,A[33734]=S,A[33735]=C,A[33736]=T,A[33737]=x,A[33738]=B,A[33739]=u,A[33740]=v,A[33741]=l,A[33742]=f,A[33743]=r,Qt(1,175),Qt(2,100),Qt(6,A[47200]),Qt(5,A[47201]),Qt(7,0),A[47198]=0,A[47197]=0,d=+D()/1e3,s=sr(t=I(d)<0x8000000000000000?~~d>>>0:0,0,1103515245,0),t=K,t=(s=s+12345|0)>>>0<12345?t+1|0:t,A[33209]=cs(s,t)}if(U=c+16|0,n){y=A[30450],T=A[M+12>>2],c=48+(f=U-560|0)|0,U=r=(U=f)-16|0;e:{t:switch(0|Xr(n-268435967|0,24)){case 0:fs(c,84133,512);break e;case 1:fs(c,84580,512);break e;case 2:fs(c,84747,512);break e;case 3:fs(c,85084,512);break e;case 4:fs(c,85251,512);break e;case 5:fs(c,85380,512);break e;case 6:fs(c,85607,512);break e;case 7:fs(c,85722,512);break e;case 8:fs(c,85913,512);break e;case 9:fs(c,86046,512);break e;case 10:fs(c,86153,512);break e;case 11:fs(c,86678,512);break e;case 12:fs(c,86773,512);break e;case 14:fs(c,86958,512);break e;case 15:fs(c,87071,512);break e}if(1879048192&n)A[r>>2]=n,Cn(c,512,87182,r);else{if(h=0,l=g[123728+((n>>>0<=153?n:0)<<1)>>1]+121804|0,n=A[A[56841]+20>>2]){S=A[n+4>>2],v=A[n>>2],B=A[v>>2]+1794895138|0,k=rs(A[v+8>>2],B),s=rs(A[v+12>>2],B),t=rs(A[v+16>>2],B);t:if(!(S>>>2>>>0<=k>>>0||3&(t|s)|(n=S-(k<<2)|0)>>>0<=s>>>0|t>>>0>=n>>>0))for(C=t>>>2|0,w=s>>>2|0;;){if(x=rs(A[(n=((t=(s=(u=k>>>1|0)+G|0)<<1)+w<<2)+v|0)>>2],B),(n=rs(A[n+4>>2],B))>>>0>=S>>>0|x>>>0>=S-n>>>0|o[(n+x|0)+v|0])break t;if(!(n=mr(l,n+v|0))){if(t=rs(A[(n=(t+C<<2)+v|0)>>2],B),(n=rs(A[n+4>>2],B))>>>0>=S>>>0|t>>>0>=S-n>>>0)break t;h=o[(t+n|0)+v|0]?0:n+v|0;break t}if(1==(0|k))break t;k=(n=(0|n)<0)?u:k-u|0,G=n?G:s}}if((n=Hn(t=h||l))>>>0>=512){Je(c,t,511),a[c+511|0]=0;break e}Je(c,t,n+1|0)}}U=r+16|0;e:if(T){t:switch(A[T>>2]){case 0:A[f+16>>2]=A[T+4>>2],A[f+20>>2]=f+48,ts(y,87384,f+16|0);break e;case 1:break t;default:break e}t=A[T+12>>2],n=A[T+8>>2],A[f+36>>2]=A[T+4>>2],K=n,A[f+40>>2]=t,A[f+44>>2]=K,A[f+32>>2]=f+48,ts(y,87521,f+32|0)}else A[f>>2]=f+48,ts(y,87700,f);U=f+560|0,-12!=(0|M)&&(n=A[M+12>>2])&&(Ee(A[n+4>>2]),Ee(A[M+12>>2]),A[M+12>>2]=0)}n=A[24806],A[34389]=0,A[32538]=n,n=(1e3+((n=b(A[50754],100))-((0|n)%1e3|0)|0)|0)/500|0,A[34390]=n,n=Oe(A[34391],n),A[34392]=n,n&&(A[34391]=n,A[34393]=40,(n=Oe(A[34388],1440))&&(A[34388]=n)),A[47198]=0,U=M+16|0,t=A[50754],A[33208]=t}return A[e+4>>2]=t,A[e>>2]=xt(),0|e},Y:function(e,t,n){e|=0,t|=0,n|=0,A[34440]=n,yr(3,A[e+12>>2]),yr(1,A[e+8>>2]),(e=A[e+16>>2])?tn(e):Vn(1024),J(t),A[34440]=0},Z:function(e,t,n){return e|=0,t|=0,n|=0,A[34440]=0,(e=et(n,1032))?(A[47195]=e,A[47197]=130,e||(A[47195]=A[30450]),J(t),A[47195]=0,A[47197]=0,A[47195]=A[30450],cr(e),0):-1},_:function(e){return 36},$:function(e,t,n){var r;return e|=0,t|=0,U=r=U-32|0,(n|=0)?(A[r+24>>2]=0,A[r+28>>2]=0,A[r+16>>2]=0,A[r+20>>2]=0,A[r+12>>2]=n,A[r+8>>2]=t,a[r+21|0]=0,t=tn(r+8|0)):t=Vn(t),A[e+16>>2]=201188,U=r+32|0,0|t},aa:function(e,t,n,r){var s;return e|=0,t|=0,U=s=U-32|0,(n|=0)|(r|=0)?(A[s+24>>2]=0,A[s+28>>2]=0,A[s+16>>2]=0,A[s+20>>2]=0,A[s+12>>2]=n,A[s+8>>2]=t,a[s+22|0]=0,a[s+20|0]=r,t=tn(s+8|0)):t=Vn(t),A[e+16>>2]=201188,U=s+32|0,0|t},ba:function(e,t,n,r,s){var i;return e|=0,t|=0,U=i=U-32|0,(r|=0)|(s|=0)|(n|=0)?(A[i+24>>2]=0,A[i+28>>2]=0,A[i+16>>2]=0,A[i+20>>2]=0,A[i+12>>2]=n,A[i+8>>2]=t,a[i+21|0]=s,a[i+20|0]=r,t=tn(i+8|0)):t=Vn(t),A[e+16>>2]=201188,U=i+32|0,0|t},ca:function(e,t,n,r,s,i){var o;return e|=0,t|=0,U=o=U-32|0,(r|=0)|(s|=0)|(i|=0)|(n|=0)?(A[o+24>>2]=0,A[o+28>>2]=0,A[o+16>>2]=0,A[o+20>>2]=0,A[o+12>>2]=n,A[o+8>>2]=t,a[o+22|0]=i,a[o+21|0]=s,a[o+20|0]=r,t=tn(o+8|0)):t=Vn(t),A[e+16>>2]=201188,U=o+32|0,0|t},da:function(e,t){return t|=0,A[A[(e|=0)>>2]+(t<<2)>>2]},ea:function(e,t,n){t|=0,n|=0,A[A[(e|=0)>>2]+(t<<2)>>2]=n},fa:ks,ga:ws,ha:ps,ia:bs,ja:function(e,t){t|=0,A[12+(e|=0)>>2]=t},ka:vs,la:function(){return 0},ma:function(){return 1},na:function(){return 2},oa:function(){return 3},pa:function(){return 4},qa:function(){return 5},ra:function(){return 6},sa:function(){return 7},ta:function(){return 8},ua:Ns,va:function(){return 227192},wa:Ee,xa:ie,ya:function(e){return(e|=0)?0|!!(0|It(e,125228)):0}}}(e)}(t)},instantiate:function(e,t){return{then:function(n){var r=new td.Module(e);n({instance:new td.Instance(r,t)})}}},RuntimeError:Error};"object"!=typeof td&&Dd("no native wasm support detected");var nd=!1;function rd(e,t){e||Dd(t)}var sd,ad,id,Ad,od,ld,ud,cd="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function dd(e,t,n){for(var r=t+n,s=t;e[s]&&!(s>=r);)++s;if(s-t>16&&e.buffer&&cd)return cd.decode(e.subarray(t,s));for(var a="";t<s;){var i=e[t++];if(128&i){var A=63&e[t++];if(192!=(224&i)){var o=63&e[t++];if((i=224==(240&i)?(15&i)<<12|A<<6|o:(7&i)<<18|A<<12|o<<6|63&e[t++])<65536)a+=String.fromCharCode(i);else{var l=i-65536;a+=String.fromCharCode(55296|l>>10,56320|1023&l)}}else a+=String.fromCharCode((31&i)<<6|A)}else a+=String.fromCharCode(i)}return a}function hd(e,t){return e?dd(ad,e,t):""}function fd(e,t,n,r){if(!(r>0))return 0;for(var s=n,a=n+r-1,i=0;i<e.length;++i){var A=e.charCodeAt(i);if(A>=55296&&A<=57343&&(A=65536+((1023&A)<<10)|1023&e.charCodeAt(++i)),A<=127){if(n>=a)break;t[n++]=A}else if(A<=2047){if(n+1>=a)break;t[n++]=192|A>>6,t[n++]=128|63&A}else if(A<=65535){if(n+2>=a)break;t[n++]=224|A>>12,t[n++]=128|A>>6&63,t[n++]=128|63&A}else{if(n+3>=a)break;t[n++]=240|A>>18,t[n++]=128|A>>12&63,t[n++]=128|A>>6&63,t[n++]=128|63&A}}return t[n]=0,n-s}function gd(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);r<=127?t++:r<=2047?t+=2:r>=55296&&r<=57343?(t+=4,++n):t+=3}return t}var pd,md=jc.INITIAL_MEMORY||16777216;pd=(ed=jc.wasmMemory?jc.wasmMemory:new td.Memory({initial:md/65536,maximum:md/65536})).buffer,jc.HEAP8=sd=new Int8Array(pd),jc.HEAP16=id=new Int16Array(pd),jc.HEAP32=Ad=new Int32Array(pd),jc.HEAPU8=ad=new Uint8Array(pd),jc.HEAPU16=new Uint16Array(pd),jc.HEAPU32=od=new Uint32Array(pd),jc.HEAPF32=ld=new Float32Array(pd),jc.HEAPF64=ud=new Float64Array(pd),md=ed.buffer.byteLength;var bd=[],Cd=[],Id=[],wd=!1;function kd(e){Cd.unshift(e)}var xd,yd,vd=0,Ed=null;function Bd(e){vd++,jc.monitorRunDependencies&&jc.monitorRunDependencies(vd)}function Md(e){if(vd--,jc.monitorRunDependencies&&jc.monitorRunDependencies(vd),0==vd&&Ed){var t=Ed;Ed=null,t()}}function Dd(e){throw jc.onAbort&&jc.onAbort(e),$c(e="Aborted("+e+")"),nd=!0,e+=". Build with -sASSERTIONS for more info.",new td.RuntimeError(e)}function Td(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function Sd(e){for(;e.length>0;)e.shift()(jc)}function Nd(e,t="i8"){switch(t.endsWith("*")&&(t="*"),t){case"i1":case"i8":return sd[0|e];case"i16":return id[e>>1];case"i32":case"i64":return Ad[e>>2];case"float":return ld[e>>2];case"double":return ud[e>>3];case"*":return od[e>>2];default:Dd("invalid type for getValue: "+t)}return null}function Gd(e){this.excPtr=e,this.ptr=e-24,this.set_type=function(e){od[this.ptr+4>>2]=e},this.get_type=function(){return od[this.ptr+4>>2]},this.set_destructor=function(e){od[this.ptr+8>>2]=e},this.get_destructor=function(){return od[this.ptr+8>>2]},this.set_refcount=function(e){Ad[this.ptr>>2]=e},this.set_caught=function(e){e=e?1:0,sd[this.ptr+12|0]=e},this.get_caught=function(){return 0!=sd[this.ptr+12|0]},this.set_rethrown=function(e){e=e?1:0,sd[this.ptr+13|0]=e},this.get_rethrown=function(){return 0!=sd[this.ptr+13|0]},this.init=function(e,t){this.set_adjusted_ptr(0),this.set_type(e),this.set_destructor(t),this.set_refcount(0),this.set_caught(!1),this.set_rethrown(!1)},this.add_ref=function(){var e=Ad[this.ptr>>2];Ad[this.ptr>>2]=e+1},this.release_ref=function(){var e=Ad[this.ptr>>2];return Ad[this.ptr>>2]=e-1,1===e},this.set_adjusted_ptr=function(e){od[this.ptr+16>>2]=e},this.get_adjusted_ptr=function(){return od[this.ptr+16>>2]},this.get_exception_ptr=function(){if(jh(this.get_type()))return od[this.excPtr>>2];var e=this.get_adjusted_ptr();return 0!==e?e:this.excPtr}}var Fd={isAbs:e=>"/"===e.charAt(0),splitPath:e=>/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(e).slice(1),normalizeArray:(e,t)=>{for(var n=0,r=e.length-1;r>=0;r--){var s=e[r];"."===s?e.splice(r,1):".."===s?(e.splice(r,1),n++):n&&(e.splice(r,1),n--)}if(t)for(;n;n--)e.unshift("..");return e},normalize:e=>{var t=Fd.isAbs(e),n="/"===e.substr(-1);return(e=Fd.normalizeArray(e.split("/").filter((e=>!!e)),!t).join("/"))||t||(e="."),e&&n&&(e+="/"),(t?"/":"")+e},dirname:e=>{var t=Fd.splitPath(e),n=t[0],r=t[1];return n||r?(r&&(r=r.substr(0,r.length-1)),n+r):"."},basename:e=>{if("/"===e)return"/";var t=(e=(e=Fd.normalize(e)).replace(/\/$/,"")).lastIndexOf("/");return-1===t?e:e.substr(t+1)},join:function(){var e=Array.prototype.slice.call(arguments);return Fd.normalize(e.join("/"))},join2:(e,t)=>Fd.normalize(e+"/"+t)},Pd={resolve:function(){for(var e="",t=!1,n=arguments.length-1;n>=-1&&!t;n--){var r=n>=0?arguments[n]:Ld.cwd();if("string"!=typeof r)throw new TypeError("Arguments to path.resolve must be strings");if(!r)return"";e=r+"/"+e,t=Fd.isAbs(r)}return(t?"/":"")+(e=Fd.normalizeArray(e.split("/").filter((e=>!!e)),!t).join("/"))||"."},relative:(e,t)=>{function n(e){for(var t=0;t<e.length&&""===e[t];t++);for(var n=e.length-1;n>=0&&""===e[n];n--);return t>n?[]:e.slice(t,n-t+1)}e=Pd.resolve(e).substr(1),t=Pd.resolve(t).substr(1);for(var r=n(e.split("/")),s=n(t.split("/")),a=Math.min(r.length,s.length),i=a,A=0;A<a;A++)if(r[A]!==s[A]){i=A;break}var o=[];for(A=i;A<r.length;A++)o.push("..");return(o=o.concat(s.slice(i))).join("/")}};function Qd(e,t,n){var r=gd(e)+1,s=new Array(r),a=fd(e,s,0,s.length);return t&&(s.length=a),s}var zd={ttys:[],init:function(){},shutdown:function(){},register:function(e,t){zd.ttys[e]={input:[],output:[],ops:t},Ld.registerDevice(e,zd.stream_ops)},stream_ops:{open:function(e){var t=zd.ttys[e.node.rdev];if(!t)throw new Ld.ErrnoError(43);e.tty=t,e.seekable=!1},close:function(e){e.tty.ops.fsync(e.tty)},fsync:function(e){e.tty.ops.fsync(e.tty)},read:function(e,t,n,r,s){if(!e.tty||!e.tty.ops.get_char)throw new Ld.ErrnoError(60);for(var a=0,i=0;i<r;i++){var A;try{A=e.tty.ops.get_char(e.tty)}catch(e){throw new Ld.ErrnoError(29)}if(void 0===A&&0===a)throw new Ld.ErrnoError(6);if(null==A)break;a++,t[n+i]=A}return a&&(e.node.timestamp=Date.now()),a},write:function(e,t,n,r,s){if(!e.tty||!e.tty.ops.put_char)throw new Ld.ErrnoError(60);try{for(var a=0;a<r;a++)e.tty.ops.put_char(e.tty,t[n+a])}catch(e){throw new Ld.ErrnoError(29)}return r&&(e.node.timestamp=Date.now()),a}},default_tty_ops:{put_char:function(e,t){null===t||10===t?(Jc(dd(e.output,0)),e.output=[]):0!=t&&e.output.push(t)},fsync:function(e){e.output&&e.output.length>0&&(Jc(dd(e.output,0)),e.output=[])}},default_tty1_ops:{put_char:function(e,t){null===t||10===t?($c(dd(e.output,0)),e.output=[]):0!=t&&e.output.push(t)},fsync:function(e){e.output&&e.output.length>0&&($c(dd(e.output,0)),e.output=[])}}};function Od(e){Dd()}var Rd={ops_table:null,mount:function(e){return Rd.createNode(null,"/",16895,0)},createNode:function(e,t,n,r){if(Ld.isBlkdev(n)||Ld.isFIFO(n))throw new Ld.ErrnoError(63);Rd.ops_table||(Rd.ops_table={dir:{node:{getattr:Rd.node_ops.getattr,setattr:Rd.node_ops.setattr,lookup:Rd.node_ops.lookup,mknod:Rd.node_ops.mknod,rename:Rd.node_ops.rename,unlink:Rd.node_ops.unlink,rmdir:Rd.node_ops.rmdir,readdir:Rd.node_ops.readdir,symlink:Rd.node_ops.symlink},stream:{llseek:Rd.stream_ops.llseek}},file:{node:{getattr:Rd.node_ops.getattr,setattr:Rd.node_ops.setattr},stream:{llseek:Rd.stream_ops.llseek,read:Rd.stream_ops.read,write:Rd.stream_ops.write,allocate:Rd.stream_ops.allocate,mmap:Rd.stream_ops.mmap,msync:Rd.stream_ops.msync}},link:{node:{getattr:Rd.node_ops.getattr,setattr:Rd.node_ops.setattr,readlink:Rd.node_ops.readlink},stream:{}},chrdev:{node:{getattr:Rd.node_ops.getattr,setattr:Rd.node_ops.setattr},stream:Ld.chrdev_stream_ops}});var s=Ld.createNode(e,t,n,r);return Ld.isDir(s.mode)?(s.node_ops=Rd.ops_table.dir.node,s.stream_ops=Rd.ops_table.dir.stream,s.contents={}):Ld.isFile(s.mode)?(s.node_ops=Rd.ops_table.file.node,s.stream_ops=Rd.ops_table.file.stream,s.usedBytes=0,s.contents=null):Ld.isLink(s.mode)?(s.node_ops=Rd.ops_table.link.node,s.stream_ops=Rd.ops_table.link.stream):Ld.isChrdev(s.mode)&&(s.node_ops=Rd.ops_table.chrdev.node,s.stream_ops=Rd.ops_table.chrdev.stream),s.timestamp=Date.now(),e&&(e.contents[t]=s,e.timestamp=s.timestamp),s},getFileDataAsTypedArray:function(e){return e.contents?e.contents.subarray?e.contents.subarray(0,e.usedBytes):new Uint8Array(e.contents):new Uint8Array(0)},expandFileStorage:function(e,t){var n=e.contents?e.contents.length:0;if(!(n>=t)){t=Math.max(t,n*(n<1048576?2:1.125)>>>0),0!=n&&(t=Math.max(t,256));var r=e.contents;e.contents=new Uint8Array(t),e.usedBytes>0&&e.contents.set(r.subarray(0,e.usedBytes),0)}},resizeFileStorage:function(e,t){if(e.usedBytes!=t)if(0==t)e.contents=null,e.usedBytes=0;else{var n=e.contents;e.contents=new Uint8Array(t),n&&e.contents.set(n.subarray(0,Math.min(t,e.usedBytes))),e.usedBytes=t}},node_ops:{getattr:function(e){var t={};return t.dev=Ld.isChrdev(e.mode)?e.id:1,t.ino=e.id,t.mode=e.mode,t.nlink=1,t.uid=0,t.gid=0,t.rdev=e.rdev,Ld.isDir(e.mode)?t.size=4096:Ld.isFile(e.mode)?t.size=e.usedBytes:Ld.isLink(e.mode)?t.size=e.link.length:t.size=0,t.atime=new Date(e.timestamp),t.mtime=new Date(e.timestamp),t.ctime=new Date(e.timestamp),t.blksize=4096,t.blocks=Math.ceil(t.size/t.blksize),t},setattr:function(e,t){void 0!==t.mode&&(e.mode=t.mode),void 0!==t.timestamp&&(e.timestamp=t.timestamp),void 0!==t.size&&Rd.resizeFileStorage(e,t.size)},lookup:function(e,t){throw Ld.genericErrors[44]},mknod:function(e,t,n,r){return Rd.createNode(e,t,n,r)},rename:function(e,t,n){if(Ld.isDir(e.mode)){var r;try{r=Ld.lookupNode(t,n)}catch(e){}if(r)for(var s in r.contents)throw new Ld.ErrnoError(55)}delete e.parent.contents[e.name],e.parent.timestamp=Date.now(),e.name=n,t.contents[n]=e,t.timestamp=e.parent.timestamp,e.parent=t},unlink:function(e,t){delete e.contents[t],e.timestamp=Date.now()},rmdir:function(e,t){var n=Ld.lookupNode(e,t);for(var r in n.contents)throw new Ld.ErrnoError(55);delete e.contents[t],e.timestamp=Date.now()},readdir:function(e){var t=[".",".."];for(var n in e.contents)e.contents.hasOwnProperty(n)&&t.push(n);return t},symlink:function(e,t,n){var r=Rd.createNode(e,t,41471,0);return r.link=n,r},readlink:function(e){if(!Ld.isLink(e.mode))throw new Ld.ErrnoError(28);return e.link}},stream_ops:{read:function(e,t,n,r,s){var a=e.node.contents;if(s>=e.node.usedBytes)return 0;var i=Math.min(e.node.usedBytes-s,r);if(i>8&&a.subarray)t.set(a.subarray(s,s+i),n);else for(var A=0;A<i;A++)t[n+A]=a[s+A];return i},write:function(e,t,n,r,s,a){if(!r)return 0;var i=e.node;if(i.timestamp=Date.now(),t.subarray&&(!i.contents||i.contents.subarray)){if(a)return i.contents=t.subarray(n,n+r),i.usedBytes=r,r;if(0===i.usedBytes&&0===s)return i.contents=t.slice(n,n+r),i.usedBytes=r,r;if(s+r<=i.usedBytes)return i.contents.set(t.subarray(n,n+r),s),r}if(Rd.expandFileStorage(i,s+r),i.contents.subarray&&t.subarray)i.contents.set(t.subarray(n,n+r),s);else for(var A=0;A<r;A++)i.contents[s+A]=t[n+A];return i.usedBytes=Math.max(i.usedBytes,s+r),r},llseek:function(e,t,n){var r=t;if(1===n?r+=e.position:2===n&&Ld.isFile(e.node.mode)&&(r+=e.node.usedBytes),r<0)throw new Ld.ErrnoError(28);return r},allocate:function(e,t,n){Rd.expandFileStorage(e.node,t+n),e.node.usedBytes=Math.max(e.node.usedBytes,t+n)},mmap:function(e,t,n,r,s){if(!Ld.isFile(e.node.mode))throw new Ld.ErrnoError(43);var a,i,A=e.node.contents;if(2&s||A.buffer!==sd.buffer){if((n>0||n+t<A.length)&&(A=A.subarray?A.subarray(n,n+t):Array.prototype.slice.call(A,n,n+t)),i=!0,!(a=Od()))throw new Ld.ErrnoError(48);sd.set(A,a)}else i=!1,a=A.byteOffset;return{ptr:a,allocated:i}},msync:function(e,t,n,r,s){return Rd.stream_ops.write(e,t,0,r,n,!1),0}}},Ld={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:!1,ignorePermissions:!0,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(e,t={})=>{if(!(e=Pd.resolve(e)))return{path:"",node:null};if((t=Object.assign({follow_mount:!0,recurse_count:0},t)).recurse_count>8)throw new Ld.ErrnoError(32);for(var n=e.split("/").filter((e=>!!e)),r=Ld.root,s="/",a=0;a<n.length;a++){var i=a===n.length-1;if(i&&t.parent)break;if(r=Ld.lookupNode(r,n[a]),s=Fd.join2(s,n[a]),Ld.isMountpoint(r)&&(!i||i&&t.follow_mount)&&(r=r.mounted.root),!i||t.follow)for(var A=0;Ld.isLink(r.mode);){var o=Ld.readlink(s);if(s=Pd.resolve(Fd.dirname(s),o),r=Ld.lookupPath(s,{recurse_count:t.recurse_count+1}).node,A++>40)throw new Ld.ErrnoError(32)}}return{path:s,node:r}},getPath:e=>{for(var t;;){if(Ld.isRoot(e)){var n=e.mount.mountpoint;return t?"/"!==n[n.length-1]?n+"/"+t:n+t:n}t=t?e.name+"/"+t:e.name,e=e.parent}},hashName:(e,t)=>{for(var n=0,r=0;r<t.length;r++)n=(n<<5)-n+t.charCodeAt(r)|0;return(e+n>>>0)%Ld.nameTable.length},hashAddNode:e=>{var t=Ld.hashName(e.parent.id,e.name);e.name_next=Ld.nameTable[t],Ld.nameTable[t]=e},hashRemoveNode:e=>{var t=Ld.hashName(e.parent.id,e.name);if(Ld.nameTable[t]===e)Ld.nameTable[t]=e.name_next;else for(var n=Ld.nameTable[t];n;){if(n.name_next===e){n.name_next=e.name_next;break}n=n.name_next}},lookupNode:(e,t)=>{var n=Ld.mayLookup(e);if(n)throw new Ld.ErrnoError(n,e);for(var r=Ld.hashName(e.id,t),s=Ld.nameTable[r];s;s=s.name_next){var a=s.name;if(s.parent.id===e.id&&a===t)return s}return Ld.lookup(e,t)},createNode:(e,t,n,r)=>{var s=new Ld.FSNode(e,t,n,r);return Ld.hashAddNode(s),s},destroyNode:e=>{Ld.hashRemoveNode(e)},isRoot:e=>e===e.parent,isMountpoint:e=>!!e.mounted,isFile:e=>32768==(61440&e),isDir:e=>16384==(61440&e),isLink:e=>40960==(61440&e),isChrdev:e=>8192==(61440&e),isBlkdev:e=>24576==(61440&e),isFIFO:e=>4096==(61440&e),isSocket:e=>!(49152&~e),flagModes:{r:0,"r+":2,w:577,"w+":578,a:1089,"a+":1090},modeStringToFlags:e=>{var t=Ld.flagModes[e];if(void 0===t)throw new Error("Unknown file open mode: "+e);return t},flagsToPermissionString:e=>{var t=["r","w","rw"][3&e];return 512&e&&(t+="w"),t},nodePermissions:(e,t)=>Ld.ignorePermissions||(!t.includes("r")||292&e.mode)&&(!t.includes("w")||146&e.mode)&&(!t.includes("x")||73&e.mode)?0:2,mayLookup:e=>Ld.nodePermissions(e,"x")||(e.node_ops.lookup?0:2),mayCreate:(e,t)=>{try{return Ld.lookupNode(e,t),20}catch(e){}return Ld.nodePermissions(e,"wx")},mayDelete:(e,t,n)=>{var r;try{r=Ld.lookupNode(e,t)}catch(e){return e.errno}var s=Ld.nodePermissions(e,"wx");if(s)return s;if(n){if(!Ld.isDir(r.mode))return 54;if(Ld.isRoot(r)||Ld.getPath(r)===Ld.cwd())return 10}else if(Ld.isDir(r.mode))return 31;return 0},mayOpen:(e,t)=>e?Ld.isLink(e.mode)?32:Ld.isDir(e.mode)&&("r"!==Ld.flagsToPermissionString(t)||512&t)?31:Ld.nodePermissions(e,Ld.flagsToPermissionString(t)):44,MAX_OPEN_FDS:4096,nextfd:(e=0,t=Ld.MAX_OPEN_FDS)=>{for(var n=e;n<=t;n++)if(!Ld.streams[n])return n;throw new Ld.ErrnoError(33)},getStream:e=>Ld.streams[e],createStream:(e,t,n)=>{Ld.FSStream||(Ld.FSStream=function(){this.shared={}},Ld.FSStream.prototype={},Object.defineProperties(Ld.FSStream.prototype,{object:{get:function(){return this.node},set:function(e){this.node=e}},isRead:{get:function(){return 1!=(2097155&this.flags)}},isWrite:{get:function(){return!!(2097155&this.flags)}},isAppend:{get:function(){return 1024&this.flags}},flags:{get:function(){return this.shared.flags},set:function(e){this.shared.flags=e}},position:{get:function(){return this.shared.position},set:function(e){this.shared.position=e}}})),e=Object.assign(new Ld.FSStream,e);var r=Ld.nextfd(t,n);return e.fd=r,Ld.streams[r]=e,e},closeStream:e=>{Ld.streams[e]=null},chrdev_stream_ops:{open:e=>{var t=Ld.getDevice(e.node.rdev);e.stream_ops=t.stream_ops,e.stream_ops.open&&e.stream_ops.open(e)},llseek:()=>{throw new Ld.ErrnoError(70)}},major:e=>e>>8,minor:e=>255&e,makedev:(e,t)=>e<<8|t,registerDevice:(e,t)=>{Ld.devices[e]={stream_ops:t}},getDevice:e=>Ld.devices[e],getMounts:e=>{for(var t=[],n=[e];n.length;){var r=n.pop();t.push(r),n.push.apply(n,r.mounts)}return t},syncfs:(e,t)=>{"function"==typeof e&&(t=e,e=!1),Ld.syncFSRequests++,Ld.syncFSRequests>1&&$c("warning: "+Ld.syncFSRequests+" FS.syncfs operations in flight at once, probably just doing extra work");var n=Ld.getMounts(Ld.root.mount),r=0;function s(e){return Ld.syncFSRequests--,t(e)}function a(e){if(e)return a.errored?void 0:(a.errored=!0,s(e));++r>=n.length&&s(null)}n.forEach((t=>{if(!t.type.syncfs)return a(null);t.type.syncfs(t,e,a)}))},mount:(e,t,n)=>{var r,s="/"===n,a=!n;if(s&&Ld.root)throw new Ld.ErrnoError(10);if(!s&&!a){var i=Ld.lookupPath(n,{follow_mount:!1});if(n=i.path,r=i.node,Ld.isMountpoint(r))throw new Ld.ErrnoError(10);if(!Ld.isDir(r.mode))throw new Ld.ErrnoError(54)}var A={type:e,opts:t,mountpoint:n,mounts:[]},o=e.mount(A);return o.mount=A,A.root=o,s?Ld.root=o:r&&(r.mounted=A,r.mount&&r.mount.mounts.push(A)),o},unmount:e=>{var t=Ld.lookupPath(e,{follow_mount:!1});if(!Ld.isMountpoint(t.node))throw new Ld.ErrnoError(28);var n=t.node,r=n.mounted,s=Ld.getMounts(r);Object.keys(Ld.nameTable).forEach((e=>{for(var t=Ld.nameTable[e];t;){var n=t.name_next;s.includes(t.mount)&&Ld.destroyNode(t),t=n}})),n.mounted=null;var a=n.mount.mounts.indexOf(r);n.mount.mounts.splice(a,1)},lookup:(e,t)=>e.node_ops.lookup(e,t),mknod:(e,t,n)=>{var r=Ld.lookupPath(e,{parent:!0}).node,s=Fd.basename(e);if(!s||"."===s||".."===s)throw new Ld.ErrnoError(28);var a=Ld.mayCreate(r,s);if(a)throw new Ld.ErrnoError(a);if(!r.node_ops.mknod)throw new Ld.ErrnoError(63);return r.node_ops.mknod(r,s,t,n)},create:(e,t)=>(t=void 0!==t?t:438,t&=4095,t|=32768,Ld.mknod(e,t,0)),mkdir:(e,t)=>(t=void 0!==t?t:511,t&=1023,t|=16384,Ld.mknod(e,t,0)),mkdirTree:(e,t)=>{for(var n=e.split("/"),r="",s=0;s<n.length;++s)if(n[s]){r+="/"+n[s];try{Ld.mkdir(r,t)}catch(e){if(20!=e.errno)throw e}}},mkdev:(e,t,n)=>(void 0===n&&(n=t,t=438),t|=8192,Ld.mknod(e,t,n)),symlink:(e,t)=>{if(!Pd.resolve(e))throw new Ld.ErrnoError(44);var n=Ld.lookupPath(t,{parent:!0}).node;if(!n)throw new Ld.ErrnoError(44);var r=Fd.basename(t),s=Ld.mayCreate(n,r);if(s)throw new Ld.ErrnoError(s);if(!n.node_ops.symlink)throw new Ld.ErrnoError(63);return n.node_ops.symlink(n,r,e)},rename:(e,t)=>{var n,r,s=Fd.dirname(e),a=Fd.dirname(t),i=Fd.basename(e),A=Fd.basename(t);if(n=Ld.lookupPath(e,{parent:!0}).node,r=Ld.lookupPath(t,{parent:!0}).node,!n||!r)throw new Ld.ErrnoError(44);if(n.mount!==r.mount)throw new Ld.ErrnoError(75);var o,l=Ld.lookupNode(n,i),u=Pd.relative(e,a);if("."!==u.charAt(0))throw new Ld.ErrnoError(28);if("."!==(u=Pd.relative(t,s)).charAt(0))throw new Ld.ErrnoError(55);try{o=Ld.lookupNode(r,A)}catch(e){}if(l!==o){var c=Ld.isDir(l.mode),d=Ld.mayDelete(n,i,c);if(d)throw new Ld.ErrnoError(d);if(d=o?Ld.mayDelete(r,A,c):Ld.mayCreate(r,A))throw new Ld.ErrnoError(d);if(!n.node_ops.rename)throw new Ld.ErrnoError(63);if(Ld.isMountpoint(l)||o&&Ld.isMountpoint(o))throw new Ld.ErrnoError(10);if(r!==n&&(d=Ld.nodePermissions(n,"w")))throw new Ld.ErrnoError(d);Ld.hashRemoveNode(l);try{n.node_ops.rename(l,r,A)}catch(e){throw e}finally{Ld.hashAddNode(l)}}},rmdir:e=>{var t=Ld.lookupPath(e,{parent:!0}).node,n=Fd.basename(e),r=Ld.lookupNode(t,n),s=Ld.mayDelete(t,n,!0);if(s)throw new Ld.ErrnoError(s);if(!t.node_ops.rmdir)throw new Ld.ErrnoError(63);if(Ld.isMountpoint(r))throw new Ld.ErrnoError(10);t.node_ops.rmdir(t,n),Ld.destroyNode(r)},readdir:e=>{var t=Ld.lookupPath(e,{follow:!0}).node;if(!t.node_ops.readdir)throw new Ld.ErrnoError(54);return t.node_ops.readdir(t)},unlink:e=>{var t=Ld.lookupPath(e,{parent:!0}).node;if(!t)throw new Ld.ErrnoError(44);var n=Fd.basename(e),r=Ld.lookupNode(t,n),s=Ld.mayDelete(t,n,!1);if(s)throw new Ld.ErrnoError(s);if(!t.node_ops.unlink)throw new Ld.ErrnoError(63);if(Ld.isMountpoint(r))throw new Ld.ErrnoError(10);t.node_ops.unlink(t,n),Ld.destroyNode(r)},readlink:e=>{var t=Ld.lookupPath(e).node;if(!t)throw new Ld.ErrnoError(44);if(!t.node_ops.readlink)throw new Ld.ErrnoError(28);return Pd.resolve(Ld.getPath(t.parent),t.node_ops.readlink(t))},stat:(e,t)=>{var n=Ld.lookupPath(e,{follow:!t}).node;if(!n)throw new Ld.ErrnoError(44);if(!n.node_ops.getattr)throw new Ld.ErrnoError(63);return n.node_ops.getattr(n)},lstat:e=>Ld.stat(e,!0),chmod:(e,t,n)=>{var r;if(!(r="string"==typeof e?Ld.lookupPath(e,{follow:!n}).node:e).node_ops.setattr)throw new Ld.ErrnoError(63);r.node_ops.setattr(r,{mode:4095&t|-4096&r.mode,timestamp:Date.now()})},lchmod:(e,t)=>{Ld.chmod(e,t,!0)},fchmod:(e,t)=>{var n=Ld.getStream(e);if(!n)throw new Ld.ErrnoError(8);Ld.chmod(n.node,t)},chown:(e,t,n,r)=>{var s;if(!(s="string"==typeof e?Ld.lookupPath(e,{follow:!r}).node:e).node_ops.setattr)throw new Ld.ErrnoError(63);s.node_ops.setattr(s,{timestamp:Date.now()})},lchown:(e,t,n)=>{Ld.chown(e,t,n,!0)},fchown:(e,t,n)=>{var r=Ld.getStream(e);if(!r)throw new Ld.ErrnoError(8);Ld.chown(r.node,t,n)},truncate:(e,t)=>{if(t<0)throw new Ld.ErrnoError(28);var n;if(!(n="string"==typeof e?Ld.lookupPath(e,{follow:!0}).node:e).node_ops.setattr)throw new Ld.ErrnoError(63);if(Ld.isDir(n.mode))throw new Ld.ErrnoError(31);if(!Ld.isFile(n.mode))throw new Ld.ErrnoError(28);var r=Ld.nodePermissions(n,"w");if(r)throw new Ld.ErrnoError(r);n.node_ops.setattr(n,{size:t,timestamp:Date.now()})},ftruncate:(e,t)=>{var n=Ld.getStream(e);if(!n)throw new Ld.ErrnoError(8);if(!(2097155&n.flags))throw new Ld.ErrnoError(28);Ld.truncate(n.node,t)},utime:(e,t,n)=>{var r=Ld.lookupPath(e,{follow:!0}).node;r.node_ops.setattr(r,{timestamp:Math.max(t,n)})},open:(e,t,n)=>{if(""===e)throw new Ld.ErrnoError(44);var r;if(n=void 0===n?438:n,n=64&(t="string"==typeof t?Ld.modeStringToFlags(t):t)?4095&n|32768:0,"object"==typeof e)r=e;else{e=Fd.normalize(e);try{r=Ld.lookupPath(e,{follow:!(131072&t)}).node}catch(e){}}var s=!1;if(64&t)if(r){if(128&t)throw new Ld.ErrnoError(20)}else r=Ld.mknod(e,n,0),s=!0;if(!r)throw new Ld.ErrnoError(44);if(Ld.isChrdev(r.mode)&&(t&=-513),65536&t&&!Ld.isDir(r.mode))throw new Ld.ErrnoError(54);if(!s){var a=Ld.mayOpen(r,t);if(a)throw new Ld.ErrnoError(a)}512&t&&!s&&Ld.truncate(r,0),t&=-131713;var i=Ld.createStream({node:r,path:Ld.getPath(r),flags:t,seekable:!0,position:0,stream_ops:r.stream_ops,ungotten:[],error:!1});return i.stream_ops.open&&i.stream_ops.open(i),!jc.logReadFiles||1&t||(Ld.readFiles||(Ld.readFiles={}),e in Ld.readFiles||(Ld.readFiles[e]=1)),i},close:e=>{if(Ld.isClosed(e))throw new Ld.ErrnoError(8);e.getdents&&(e.getdents=null);try{e.stream_ops.close&&e.stream_ops.close(e)}catch(e){throw e}finally{Ld.closeStream(e.fd)}e.fd=null},isClosed:e=>null===e.fd,llseek:(e,t,n)=>{if(Ld.isClosed(e))throw new Ld.ErrnoError(8);if(!e.seekable||!e.stream_ops.llseek)throw new Ld.ErrnoError(70);if(0!=n&&1!=n&&2!=n)throw new Ld.ErrnoError(28);return e.position=e.stream_ops.llseek(e,t,n),e.ungotten=[],e.position},read:(e,t,n,r,s)=>{if(r<0||s<0)throw new Ld.ErrnoError(28);if(Ld.isClosed(e))throw new Ld.ErrnoError(8);if(1==(2097155&e.flags))throw new Ld.ErrnoError(8);if(Ld.isDir(e.node.mode))throw new Ld.ErrnoError(31);if(!e.stream_ops.read)throw new Ld.ErrnoError(28);var a=void 0!==s;if(a){if(!e.seekable)throw new Ld.ErrnoError(70)}else s=e.position;var i=e.stream_ops.read(e,t,n,r,s);return a||(e.position+=i),i},write:(e,t,n,r,s,a)=>{if(r<0||s<0)throw new Ld.ErrnoError(28);if(Ld.isClosed(e))throw new Ld.ErrnoError(8);if(!(2097155&e.flags))throw new Ld.ErrnoError(8);if(Ld.isDir(e.node.mode))throw new Ld.ErrnoError(31);if(!e.stream_ops.write)throw new Ld.ErrnoError(28);e.seekable&&1024&e.flags&&Ld.llseek(e,0,2);var i=void 0!==s;if(i){if(!e.seekable)throw new Ld.ErrnoError(70)}else s=e.position;var A=e.stream_ops.write(e,t,n,r,s,a);return i||(e.position+=A),A},allocate:(e,t,n)=>{if(Ld.isClosed(e))throw new Ld.ErrnoError(8);if(t<0||n<=0)throw new Ld.ErrnoError(28);if(!(2097155&e.flags))throw new Ld.ErrnoError(8);if(!Ld.isFile(e.node.mode)&&!Ld.isDir(e.node.mode))throw new Ld.ErrnoError(43);if(!e.stream_ops.allocate)throw new Ld.ErrnoError(138);e.stream_ops.allocate(e,t,n)},mmap:(e,t,n,r,s)=>{if(2&r&&!(2&s)&&2!=(2097155&e.flags))throw new Ld.ErrnoError(2);if(1==(2097155&e.flags))throw new Ld.ErrnoError(2);if(!e.stream_ops.mmap)throw new Ld.ErrnoError(43);return e.stream_ops.mmap(e,t,n,r,s)},msync:(e,t,n,r,s)=>e.stream_ops.msync?e.stream_ops.msync(e,t,n,r,s):0,munmap:e=>0,ioctl:(e,t,n)=>{if(!e.stream_ops.ioctl)throw new Ld.ErrnoError(59);return e.stream_ops.ioctl(e,t,n)},readFile:(e,t={})=>{if(t.flags=t.flags||0,t.encoding=t.encoding||"binary","utf8"!==t.encoding&&"binary"!==t.encoding)throw new Error('Invalid encoding type "'+t.encoding+'"');var n,r=Ld.open(e,t.flags),s=Ld.stat(e).size,a=new Uint8Array(s);return Ld.read(r,a,0,s,0),"utf8"===t.encoding?n=dd(a,0):"binary"===t.encoding&&(n=a),Ld.close(r),n},writeFile:(e,t,n={})=>{n.flags=n.flags||577;var r=Ld.open(e,n.flags,n.mode);if("string"==typeof t){var s=new Uint8Array(gd(t)+1),a=fd(t,s,0,s.length);Ld.write(r,s,0,a,void 0,n.canOwn)}else{if(!ArrayBuffer.isView(t))throw new Error("Unsupported data type");Ld.write(r,t,0,t.byteLength,void 0,n.canOwn)}Ld.close(r)},cwd:()=>Ld.currentPath,chdir:e=>{var t=Ld.lookupPath(e,{follow:!0});if(null===t.node)throw new Ld.ErrnoError(44);if(!Ld.isDir(t.node.mode))throw new Ld.ErrnoError(54);var n=Ld.nodePermissions(t.node,"x");if(n)throw new Ld.ErrnoError(n);Ld.currentPath=t.path},createDefaultDirectories:()=>{Ld.mkdir("/tmp"),Ld.mkdir("/home"),Ld.mkdir("/home/web_user")},createDefaultDevices:()=>{Ld.mkdir("/dev"),Ld.registerDevice(Ld.makedev(1,3),{read:()=>0,write:(e,t,n,r,s)=>r}),Ld.mkdev("/dev/null",Ld.makedev(1,3)),zd.register(Ld.makedev(5,0),zd.default_tty_ops),zd.register(Ld.makedev(6,0),zd.default_tty1_ops),Ld.mkdev("/dev/tty",Ld.makedev(5,0)),Ld.mkdev("/dev/tty1",Ld.makedev(6,0)),Ld.mkdir("/dev/shm"),Ld.mkdir("/dev/shm/tmp")},createSpecialDirectories:()=>{Ld.mkdir("/proc");var e=Ld.mkdir("/proc/self");Ld.mkdir("/proc/self/fd"),Ld.mount({mount:()=>{var t=Ld.createNode(e,"fd",16895,73);return t.node_ops={lookup:(e,t)=>{var n=+t,r=Ld.getStream(n);if(!r)throw new Ld.ErrnoError(8);var s={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:()=>r.path}};return s.parent=s,s}},t}},{},"/proc/self/fd")},createStandardStreams:()=>{jc.stdin?Ld.createDevice("/dev","stdin",jc.stdin):Ld.symlink("/dev/tty","/dev/stdin"),jc.stdout?Ld.createDevice("/dev","stdout",null,jc.stdout):Ld.symlink("/dev/tty","/dev/stdout"),jc.stderr?Ld.createDevice("/dev","stderr",null,jc.stderr):Ld.symlink("/dev/tty1","/dev/stderr"),Ld.open("/dev/stdin",0),Ld.open("/dev/stdout",1),Ld.open("/dev/stderr",1)},ensureErrnoError:()=>{Ld.ErrnoError||(Ld.ErrnoError=function(e,t){this.node=t,this.setErrno=function(e){this.errno=e},this.setErrno(e),this.message="FS error"},Ld.ErrnoError.prototype=new Error,Ld.ErrnoError.prototype.constructor=Ld.ErrnoError,[44].forEach((e=>{Ld.genericErrors[e]=new Ld.ErrnoError(e),Ld.genericErrors[e].stack="<generic error, no stack>"})))},staticInit:()=>{Ld.ensureErrnoError(),Ld.nameTable=new Array(4096),Ld.mount(Rd,{},"/"),Ld.createDefaultDirectories(),Ld.createDefaultDevices(),Ld.createSpecialDirectories(),Ld.filesystems={MEMFS:Rd}},init:(e,t,n)=>{Ld.init.initialized=!0,Ld.ensureErrnoError(),jc.stdin=e||jc.stdin,jc.stdout=t||jc.stdout,jc.stderr=n||jc.stderr,Ld.createStandardStreams()},quit:()=>{Ld.init.initialized=!1;for(var e=0;e<Ld.streams.length;e++){var t=Ld.streams[e];t&&Ld.close(t)}},getMode:(e,t)=>{var n=0;return e&&(n|=365),t&&(n|=146),n},findObject:(e,t)=>{var n=Ld.analyzePath(e,t);return n.exists?n.object:null},analyzePath:(e,t)=>{try{e=(r=Ld.lookupPath(e,{follow:!t})).path}catch(e){}var n={isRoot:!1,exists:!1,error:0,name:null,path:null,object:null,parentExists:!1,parentPath:null,parentObject:null};try{var r=Ld.lookupPath(e,{parent:!0});n.parentExists=!0,n.parentPath=r.path,n.parentObject=r.node,n.name=Fd.basename(e),r=Ld.lookupPath(e,{follow:!t}),n.exists=!0,n.path=r.path,n.object=r.node,n.name=r.node.name,n.isRoot="/"===r.path}catch(e){n.error=e.errno}return n},createPath:(e,t,n,r)=>{e="string"==typeof e?e:Ld.getPath(e);for(var s=t.split("/").reverse();s.length;){var a=s.pop();if(a){var i=Fd.join2(e,a);try{Ld.mkdir(i)}catch(e){}e=i}}return i},createFile:(e,t,n,r,s)=>{var a=Fd.join2("string"==typeof e?e:Ld.getPath(e),t),i=Ld.getMode(r,s);return Ld.create(a,i)},createDataFile:(e,t,n,r,s,a)=>{var i=t;e&&(e="string"==typeof e?e:Ld.getPath(e),i=t?Fd.join2(e,t):e);var A=Ld.getMode(r,s),o=Ld.create(i,A);if(n){if("string"==typeof n){for(var l=new Array(n.length),u=0,c=n.length;u<c;++u)l[u]=n.charCodeAt(u);n=l}Ld.chmod(o,146|A);var d=Ld.open(o,577);Ld.write(d,n,0,n.length,0,a),Ld.close(d),Ld.chmod(o,A)}return o},createDevice:(e,t,n,r)=>{var s=Fd.join2("string"==typeof e?e:Ld.getPath(e),t),a=Ld.getMode(!!n,!!r);Ld.createDevice.major||(Ld.createDevice.major=64);var i=Ld.makedev(Ld.createDevice.major++,0);return Ld.registerDevice(i,{open:e=>{e.seekable=!1},close:e=>{r&&r.buffer&&r.buffer.length&&r(10)},read:(e,t,r,s,a)=>{for(var i=0,A=0;A<s;A++){var o;try{o=n()}catch(e){throw new Ld.ErrnoError(29)}if(void 0===o&&0===i)throw new Ld.ErrnoError(6);if(null==o)break;i++,t[r+A]=o}return i&&(e.node.timestamp=Date.now()),i},write:(e,t,n,s,a)=>{for(var i=0;i<s;i++)try{r(t[n+i])}catch(e){throw new Ld.ErrnoError(29)}return s&&(e.node.timestamp=Date.now()),i}}),Ld.mkdev(s,a,i)},forceLoadFile:e=>{if(e.isDevice||e.isFolder||e.link||e.contents)return!0;throw"undefined"!=typeof XMLHttpRequest?new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."):new Error("Cannot load without read() or XMLHttpRequest.")},createLazyFile:(e,t,n,r,s)=>{function a(){this.lengthKnown=!1,this.chunks=[]}if(a.prototype.get=function(e){if(!(e>this.length-1||e<0)){var t=e%this.chunkSize,n=e/this.chunkSize|0;return this.getter(n)[t]}},a.prototype.setDataGetter=function(e){this.getter=e},a.prototype.cacheLength=function(){var e=new XMLHttpRequest;if(e.open("HEAD",n,!1),e.send(null),!(e.status>=200&&e.status<300||304===e.status))throw new Error("Couldn't load "+n+". Status: "+e.status);var t,r=Number(e.getResponseHeader("Content-length")),s=(t=e.getResponseHeader("Accept-Ranges"))&&"bytes"===t,a=(t=e.getResponseHeader("Content-Encoding"))&&"gzip"===t,i=1048576;s||(i=r);var A=this;A.setDataGetter((e=>{var t=e*i,s=(e+1)*i-1;if(s=Math.min(s,r-1),void 0===A.chunks[e]&&(A.chunks[e]=((e,t)=>{if(e>t)throw new Error("invalid range ("+e+", "+t+") or no bytes requested!");if(t>r-1)throw new Error("only "+r+" bytes available! programmer error!");var s=new XMLHttpRequest;if(s.open("GET",n,!1),r!==i&&s.setRequestHeader("Range","bytes="+e+"-"+t),s.responseType="arraybuffer",s.overrideMimeType&&s.overrideMimeType("text/plain; charset=x-user-defined"),s.send(null),!(s.status>=200&&s.status<300||304===s.status))throw new Error("Couldn't load "+n+". Status: "+s.status);return void 0!==s.response?new Uint8Array(s.response||[]):Qd(s.responseText||"",!0)})(t,s)),void 0===A.chunks[e])throw new Error("doXHR failed!");return A.chunks[e]})),!a&&r||(i=r=1,r=this.getter(0).length,i=r,Jc("LazyFiles on gzip forces download of the whole file when length is accessed")),this._length=r,this._chunkSize=i,this.lengthKnown=!0},"undefined"!=typeof XMLHttpRequest){if(!Yc)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var i=new a;Object.defineProperties(i,{length:{get:function(){return this.lengthKnown||this.cacheLength(),this._length}},chunkSize:{get:function(){return this.lengthKnown||this.cacheLength(),this._chunkSize}}});var A={isDevice:!1,contents:i}}else A={isDevice:!1,url:n};var o=Ld.createFile(e,t,A,r,s);A.contents?o.contents=A.contents:A.url&&(o.contents=null,o.url=A.url),Object.defineProperties(o,{usedBytes:{get:function(){return this.contents.length}}});var l={};function u(e,t,n,r,s){var a=e.node.contents;if(s>=a.length)return 0;var i=Math.min(a.length-s,r);if(a.slice)for(var A=0;A<i;A++)t[n+A]=a[s+A];else for(A=0;A<i;A++)t[n+A]=a.get(s+A);return i}return Object.keys(o.stream_ops).forEach((e=>{var t=o.stream_ops[e];l[e]=function(){return Ld.forceLoadFile(o),t.apply(null,arguments)}})),l.read=(e,t,n,r,s)=>(Ld.forceLoadFile(o),u(e,t,n,r,s)),l.mmap=(e,t,n,r,s)=>{Ld.forceLoadFile(o);var a=Od();if(!a)throw new Ld.ErrnoError(48);return u(e,sd,a,t,n),{ptr:a,allocated:!0}},o.stream_ops=l,o},indexedDB:()=>window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB,DB_NAME:()=>"EM_FS_"+window.location.pathname,DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(e,t,n)=>{t=t||(()=>{}),n=n||(()=>{});var r=Ld.indexedDB();try{var s=r.open(Ld.DB_NAME(),Ld.DB_VERSION)}catch(e){return n(e)}s.onupgradeneeded=()=>{Jc("creating db"),s.result.createObjectStore(Ld.DB_STORE_NAME)},s.onsuccess=()=>{var r=s.result.transaction([Ld.DB_STORE_NAME],"readwrite"),a=r.objectStore(Ld.DB_STORE_NAME),i=0,A=0,o=e.length;function l(){0==A?t():n()}e.forEach((e=>{var t=a.put(Ld.analyzePath(e).object.contents,e);t.onsuccess=()=>{++i+A==o&&l()},t.onerror=()=>{A++,i+A==o&&l()}})),r.onerror=n},s.onerror=n},loadFilesFromDB:(e,t,n)=>{t=t||(()=>{}),n=n||(()=>{});var r=Ld.indexedDB();try{var s=r.open(Ld.DB_NAME(),Ld.DB_VERSION)}catch(e){return n(e)}s.onupgradeneeded=n,s.onsuccess=()=>{var r=s.result;try{var a=r.transaction([Ld.DB_STORE_NAME],"readonly")}catch(e){return void n(e)}var i=a.objectStore(Ld.DB_STORE_NAME),A=0,o=0,l=e.length;function u(){0==o?t():n()}e.forEach((e=>{var t=i.get(e);t.onsuccess=()=>{Ld.analyzePath(e).exists&&Ld.unlink(e),Ld.createDataFile(Fd.dirname(e),Fd.basename(e),t.result,!0,!0,!0),++A+o==l&&u()},t.onerror=()=>{o++,A+o==l&&u()}})),a.onerror=n},s.onerror=n}},Wd={DEFAULT_POLLMASK:5,calculateAt:function(e,t,n){if(Fd.isAbs(t))return t;var r;if(r=-100===e?Ld.cwd():Wd.getStreamFromFD(e).path,0==t.length){if(!n)throw new Ld.ErrnoError(44);return r}return Fd.join2(r,t)},doStat:function(e,t,n){try{var r=e(t)}catch(e){if(e&&e.node&&Fd.normalize(t)!==Fd.normalize(Ld.getPath(e.node)))return-54;throw e}Ad[n>>2]=r.dev,Ad[n+8>>2]=r.ino,Ad[n+12>>2]=r.mode,od[n+16>>2]=r.nlink,Ad[n+20>>2]=r.uid,Ad[n+24>>2]=r.gid,Ad[n+28>>2]=r.rdev,yd=[r.size>>>0,(xd=r.size,+Math.abs(xd)>=1?xd>0?(0|Math.min(+Math.floor(xd/4294967296),4294967295))>>>0:~~+Math.ceil((xd-+(~~xd>>>0))/4294967296)>>>0:0)],Ad[n+40>>2]=yd[0],Ad[n+44>>2]=yd[1],Ad[n+48>>2]=4096,Ad[n+52>>2]=r.blocks;var s=r.atime.getTime(),a=r.mtime.getTime(),i=r.ctime.getTime();return yd=[Math.floor(s/1e3)>>>0,(xd=Math.floor(s/1e3),+Math.abs(xd)>=1?xd>0?(0|Math.min(+Math.floor(xd/4294967296),4294967295))>>>0:~~+Math.ceil((xd-+(~~xd>>>0))/4294967296)>>>0:0)],Ad[n+56>>2]=yd[0],Ad[n+60>>2]=yd[1],od[n+64>>2]=s%1e3*1e3,yd=[Math.floor(a/1e3)>>>0,(xd=Math.floor(a/1e3),+Math.abs(xd)>=1?xd>0?(0|Math.min(+Math.floor(xd/4294967296),4294967295))>>>0:~~+Math.ceil((xd-+(~~xd>>>0))/4294967296)>>>0:0)],Ad[n+72>>2]=yd[0],Ad[n+76>>2]=yd[1],od[n+80>>2]=a%1e3*1e3,yd=[Math.floor(i/1e3)>>>0,(xd=Math.floor(i/1e3),+Math.abs(xd)>=1?xd>0?(0|Math.min(+Math.floor(xd/4294967296),4294967295))>>>0:~~+Math.ceil((xd-+(~~xd>>>0))/4294967296)>>>0:0)],Ad[n+88>>2]=yd[0],Ad[n+92>>2]=yd[1],od[n+96>>2]=i%1e3*1e3,yd=[r.ino>>>0,(xd=r.ino,+Math.abs(xd)>=1?xd>0?(0|Math.min(+Math.floor(xd/4294967296),4294967295))>>>0:~~+Math.ceil((xd-+(~~xd>>>0))/4294967296)>>>0:0)],Ad[n+104>>2]=yd[0],Ad[n+108>>2]=yd[1],0},doMsync:function(e,t,n,r,s){if(!Ld.isFile(t.node.mode))throw new Ld.ErrnoError(43);if(2&r)return 0;var a=ad.slice(e,e+n);Ld.msync(t,a,s,n,r)},varargs:void 0,get:function(){return Wd.varargs+=4,Ad[Wd.varargs-4>>2]},getStr:function(e){return hd(e)},getStreamFromFD:function(e){var t=Ld.getStream(e);if(!t)throw new Ld.ErrnoError(8);return t}},_d={};function Vd(){if(!Vd.strings){var e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:Zc||"./this.program"};for(var t in _d)void 0===_d[t]?delete e[t]:e[t]=_d[t];var n=[];for(var t in e)n.push(t+"="+e[t]);Vd.strings=n}return Vd.strings}var Hd=function(e,t,n,r){e||(e=this),this.parent=e,this.mount=e.mount,this.mounted=null,this.id=Ld.nextInode++,this.name=t,this.mode=n,this.node_ops={},this.stream_ops={},this.rdev=r};Object.defineProperties(Hd.prototype,{read:{get:function(){return!(365&~this.mode)},set:function(e){e?this.mode|=365:this.mode&=-366}},write:{get:function(){return!(146&~this.mode)},set:function(e){e?this.mode|=146:this.mode&=-147}},isFolder:{get:function(){return Ld.isDir(this.mode)}},isDevice:{get:function(){return Ld.isChrdev(this.mode)}}}),Ld.FSNode=Hd,Ld.staticInit(),jc.FS_createPath=Ld.createPath,jc.FS_createDataFile=Ld.createDataFile,jc.FS_unlink=Ld.unlink,jc.FS_createLazyFile=Ld.createLazyFile,jc.FS_createDevice=Ld.createDevice;var Ud={g:function(e,t,n,r){Dd("Assertion failed: "+hd(e)+", at: "+[t?hd(t):"unknown filename",n,r?hd(r):"unknown function"])},u:function(e,t,n){throw new Gd(e).init(t,n),e},d:function(e,t,n){Wd.varargs=n;try{var r=Wd.getStreamFromFD(e);switch(t){case 0:return(s=Wd.get())<0?-28:Ld.createStream(r,s).fd;case 1:case 2:case 6:case 7:return 0;case 3:return r.flags;case 4:var s=Wd.get();return r.flags|=s,0;case 5:return s=Wd.get(),id[s+0>>1]=2,0;case 16:case 8:default:return-28;case 9:return Ad[Hh()>>2]=28,-1}}catch(e){if(void 0===Ld||!(e instanceof Ld.ErrnoError))throw e;return-e.errno}},q:function(e,t,n){try{var r=Wd.getStreamFromFD(e);r.getdents||(r.getdents=Ld.readdir(r.path));for(var s=280,a=0,i=Ld.llseek(r,0,1),A=Math.floor(i/s);A<r.getdents.length&&a+s<=n;){var o,l,u=r.getdents[A];if("."===u)o=r.node.id,l=4;else if(".."===u)o=Ld.lookupPath(r.path,{parent:!0}).node.id,l=4;else{var c=Ld.lookupNode(r.node,u);o=c.id,l=Ld.isChrdev(c.mode)?2:Ld.isDir(c.mode)?4:Ld.isLink(c.mode)?10:8}yd=[o>>>0,(xd=o,+Math.abs(xd)>=1?xd>0?(0|Math.min(+Math.floor(xd/4294967296),4294967295))>>>0:~~+Math.ceil((xd-+(~~xd>>>0))/4294967296)>>>0:0)],Ad[t+a>>2]=yd[0],Ad[t+a+4>>2]=yd[1],yd=[(A+1)*s>>>0,(xd=(A+1)*s,+Math.abs(xd)>=1?xd>0?(0|Math.min(+Math.floor(xd/4294967296),4294967295))>>>0:~~+Math.ceil((xd-+(~~xd>>>0))/4294967296)>>>0:0)],Ad[t+a+8>>2]=yd[0],Ad[t+a+12>>2]=yd[1],id[t+a+16>>1]=280,sd[t+a+18|0]=l,fd(u,ad,t+a+19,256),a+=s,A+=1}return Ld.llseek(r,A*s,0),a}catch(e){if(void 0===Ld||!(e instanceof Ld.ErrnoError))throw e;return-e.errno}},h:function(e,t,n){Wd.varargs=n;try{var r=Wd.getStreamFromFD(e);switch(t){case 21509:case 21505:case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:case 21523:case 21524:return r.tty?0:-59;case 21519:if(!r.tty)return-59;var s=Wd.get();return Ad[s>>2]=0,0;case 21520:return r.tty?-28:-59;case 21531:return s=Wd.get(),Ld.ioctl(r,t,s);default:return-28}}catch(e){if(void 0===Ld||!(e instanceof Ld.ErrnoError))throw e;return-e.errno}},e:function(e,t,n,r){Wd.varargs=r;try{t=Wd.getStr(t),t=Wd.calculateAt(e,t);var s=r?Wd.get():0;return Ld.open(t,n,s).fd}catch(e){if(void 0===Ld||!(e instanceof Ld.ErrnoError))throw e;return-e.errno}},o:function(e){try{return e=Wd.getStr(e),Ld.rmdir(e),0}catch(e){if(void 0===Ld||!(e instanceof Ld.ErrnoError))throw e;return-e.errno}},n:function(e,t){try{return e=Wd.getStr(e),Wd.doStat(Ld.stat,e,t)}catch(e){if(void 0===Ld||!(e instanceof Ld.ErrnoError))throw e;return-e.errno}},p:function(e,t,n){try{return t=Wd.getStr(t),t=Wd.calculateAt(e,t),0===n?Ld.unlink(t):512===n?Ld.rmdir(t):Dd("Invalid flags passed to unlinkat"),0}catch(e){if(void 0===Ld||!(e instanceof Ld.ErrnoError))throw e;return-e.errno}},i:function(){return!0},l:function(){Dd("")},f:function(){return Date.now()},j:function(e,t,n){ad.copyWithin(e,t,t+n)},m:function(e){ad.length,Dd("OOM")},r:function(e,t){var n=0;return Vd().forEach((function(r,s){var a=t+n;od[e+4*s>>2]=a,function(e,t){for(var n=0;n<e.length;++n)sd[0|t++]=e.charCodeAt(n);sd[0|t]=0}(r,a),n+=r.length+1})),0},s:function(e,t){var n=Vd();od[e>>2]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),od[t>>2]=r,0},b:function(e){try{var t=Wd.getStreamFromFD(e);return Ld.close(t),0}catch(e){if(void 0===Ld||!(e instanceof Ld.ErrnoError))throw e;return e.errno}},t:function(e,t,n,r){try{var s=function(e,t,n){for(var r=0,s=0;s<n;s++){var a=od[t>>2],i=od[t+4>>2];t+=8;var A=Ld.read(e,sd,a,i,undefined);if(A<0)return-1;if(r+=A,A<i)break}return r}(Wd.getStreamFromFD(e),t,n);return od[r>>2]=s,0}catch(e){if(void 0===Ld||!(e instanceof Ld.ErrnoError))throw e;return e.errno}},k:function(e,t,n,r,s){try{var a=(o=n)+2097152>>>0<4194305-!!(A=t)?(A>>>0)+4294967296*o:NaN;if(isNaN(a))return 61;var i=Wd.getStreamFromFD(e);return Ld.llseek(i,a,r),yd=[i.position>>>0,(xd=i.position,+Math.abs(xd)>=1?xd>0?(0|Math.min(+Math.floor(xd/4294967296),4294967295))>>>0:~~+Math.ceil((xd-+(~~xd>>>0))/4294967296)>>>0:0)],Ad[s>>2]=yd[0],Ad[s+4>>2]=yd[1],i.getdents&&0===a&&0===r&&(i.getdents=null),0}catch(e){if(void 0===Ld||!(e instanceof Ld.ErrnoError))throw e;return e.errno}var A,o},c:function(e,t,n,r){try{var s=function(e,t,n){for(var r=0,s=0;s<n;s++){var a=od[t>>2],i=od[t+4>>2];t+=8;var A=Ld.write(e,sd,a,i,undefined);if(A<0)return-1;r+=A}return r}(Wd.getStreamFromFD(e),t,n);return od[r>>2]=s,0}catch(e){if(void 0===Ld||!(e instanceof Ld.ErrnoError))throw e;return e.errno}},a:ed};!function(){var e,t={a:Ud};function n(e,t){var n=e.exports;jc.asm=n,jc.asm.ua,kd(jc.asm.v),Md()}if(Bd(),jc.instantiateWasm)try{return jc.instantiateWasm(t,n)}catch(e){return $c("Module.instantiateWasm callback failed with error: "+e),!1}e=function(e){n(e.instance)},async function(){return[]}().then((function(e){return td.instantiate(e,t)})).then((function(e){return e})).then(e,(function(e){$c("failed to asynchronously prepare wasm: "+e),Dd(e)}))}(),jc.___wasm_call_ctors=function(){return(jc.___wasm_call_ctors=jc.asm.v).apply(null,arguments)};var jd=jc._emscripten_bind_VoidPtr___destroy___0=function(){return(jd=jc._emscripten_bind_VoidPtr___destroy___0=jc.asm.w).apply(null,arguments)},Yd=jc._emscripten_bind_espeak_VOICE_get_name_0=function(){return(Yd=jc._emscripten_bind_espeak_VOICE_get_name_0=jc.asm.x).apply(null,arguments)},Kd=jc._emscripten_bind_espeak_VOICE_set_name_1=function(){return(Kd=jc._emscripten_bind_espeak_VOICE_set_name_1=jc.asm.y).apply(null,arguments)},Xd=jc._emscripten_bind_espeak_VOICE_get_languages_1=function(){return(Xd=jc._emscripten_bind_espeak_VOICE_get_languages_1=jc.asm.z).apply(null,arguments)},qd=jc._emscripten_bind_espeak_VOICE_get_identifier_0=function(){return(qd=jc._emscripten_bind_espeak_VOICE_get_identifier_0=jc.asm.A).apply(null,arguments)},Zd=jc._emscripten_bind_espeak_VOICE_set_identifier_1=function(){return(Zd=jc._emscripten_bind_espeak_VOICE_set_identifier_1=jc.asm.B).apply(null,arguments)},Jd=jc._emscripten_bind_espeak_VOICE_get_gender_0=function(){return(Jd=jc._emscripten_bind_espeak_VOICE_get_gender_0=jc.asm.C).apply(null,arguments)},$d=jc._emscripten_bind_espeak_VOICE_set_gender_1=function(){return($d=jc._emscripten_bind_espeak_VOICE_set_gender_1=jc.asm.D).apply(null,arguments)},eh=jc._emscripten_bind_espeak_VOICE_get_age_0=function(){return(eh=jc._emscripten_bind_espeak_VOICE_get_age_0=jc.asm.E).apply(null,arguments)},th=jc._emscripten_bind_espeak_VOICE_set_age_1=function(){return(th=jc._emscripten_bind_espeak_VOICE_set_age_1=jc.asm.F).apply(null,arguments)},nh=jc._emscripten_bind_espeak_VOICE_get_variant_0=function(){return(nh=jc._emscripten_bind_espeak_VOICE_get_variant_0=jc.asm.G).apply(null,arguments)},rh=jc._emscripten_bind_espeak_VOICE_set_variant_1=function(){return(rh=jc._emscripten_bind_espeak_VOICE_set_variant_1=jc.asm.H).apply(null,arguments)},sh=jc._emscripten_bind_espeak_VOICE_get_xx1_0=function(){return(sh=jc._emscripten_bind_espeak_VOICE_get_xx1_0=jc.asm.I).apply(null,arguments)},ah=jc._emscripten_bind_espeak_VOICE_set_xx1_1=function(){return(ah=jc._emscripten_bind_espeak_VOICE_set_xx1_1=jc.asm.J).apply(null,arguments)},ih=jc._emscripten_bind_espeak_VOICE_get_score_0=function(){return(ih=jc._emscripten_bind_espeak_VOICE_get_score_0=jc.asm.K).apply(null,arguments)},Ah=jc._emscripten_bind_espeak_VOICE_set_score_1=function(){return(Ah=jc._emscripten_bind_espeak_VOICE_set_score_1=jc.asm.L).apply(null,arguments)},oh=jc._emscripten_bind_espeak_VOICE_get_spare_0=function(){return(oh=jc._emscripten_bind_espeak_VOICE_get_spare_0=jc.asm.M).apply(null,arguments)},lh=jc._emscripten_bind_espeak_VOICE_set_spare_1=function(){return(lh=jc._emscripten_bind_espeak_VOICE_set_spare_1=jc.asm.N).apply(null,arguments)},uh=jc._emscripten_bind_espeak_VOICE___destroy___0=function(){return(uh=jc._emscripten_bind_espeak_VOICE___destroy___0=jc.asm.O).apply(null,arguments)},ch=jc._emscripten_bind_espeak_EVENT_get_type_0=function(){return(ch=jc._emscripten_bind_espeak_EVENT_get_type_0=jc.asm.P).apply(null,arguments)},dh=jc._emscripten_bind_espeak_EVENT_get_unique_identifier_0=function(){return(dh=jc._emscripten_bind_espeak_EVENT_get_unique_identifier_0=jc.asm.Q).apply(null,arguments)},hh=jc._emscripten_bind_espeak_EVENT_get_text_position_0=function(){return(hh=jc._emscripten_bind_espeak_EVENT_get_text_position_0=jc.asm.R).apply(null,arguments)},fh=jc._emscripten_bind_espeak_EVENT_get_length_0=function(){return(fh=jc._emscripten_bind_espeak_EVENT_get_length_0=jc.asm.S).apply(null,arguments)},gh=jc._emscripten_bind_espeak_EVENT_get_audio_position_0=function(){return(gh=jc._emscripten_bind_espeak_EVENT_get_audio_position_0=jc.asm.T).apply(null,arguments)},ph=jc._emscripten_bind_espeak_EVENT_get_sample_0=function(){return(ph=jc._emscripten_bind_espeak_EVENT_get_sample_0=jc.asm.U).apply(null,arguments)},mh=jc._emscripten_bind_espeak_EVENT_get_user_data_0=function(){return(mh=jc._emscripten_bind_espeak_EVENT_get_user_data_0=jc.asm.V).apply(null,arguments)},bh=jc._emscripten_bind_espeak_EVENT___destroy___0=function(){return(bh=jc._emscripten_bind_espeak_EVENT___destroy___0=jc.asm.W).apply(null,arguments)},Ch=jc._emscripten_bind_eSpeakNGWorker_eSpeakNGWorker_0=function(){return(Ch=jc._emscripten_bind_eSpeakNGWorker_eSpeakNGWorker_0=jc.asm.X).apply(null,arguments)},Ih=jc._emscripten_bind_eSpeakNGWorker_synth__2=function(){return(Ih=jc._emscripten_bind_eSpeakNGWorker_synth__2=jc.asm.Y).apply(null,arguments)},wh=jc._emscripten_bind_eSpeakNGWorker_synth_ipa__2=function(){return(wh=jc._emscripten_bind_eSpeakNGWorker_synth_ipa__2=jc.asm.Z).apply(null,arguments)},kh=jc._emscripten_bind_eSpeakNGWorker_getSizeOfEventStruct__0=function(){return(kh=jc._emscripten_bind_eSpeakNGWorker_getSizeOfEventStruct__0=jc.asm._).apply(null,arguments)},xh=jc._emscripten_bind_eSpeakNGWorker_set_voice_2=function(){return(xh=jc._emscripten_bind_eSpeakNGWorker_set_voice_2=jc.asm.$).apply(null,arguments)},yh=jc._emscripten_bind_eSpeakNGWorker_set_voice_3=function(){return(yh=jc._emscripten_bind_eSpeakNGWorker_set_voice_3=jc.asm.aa).apply(null,arguments)},vh=jc._emscripten_bind_eSpeakNGWorker_set_voice_4=function(){return(vh=jc._emscripten_bind_eSpeakNGWorker_set_voice_4=jc.asm.ba).apply(null,arguments)},Eh=jc._emscripten_bind_eSpeakNGWorker_set_voice_5=function(){return(Eh=jc._emscripten_bind_eSpeakNGWorker_set_voice_5=jc.asm.ca).apply(null,arguments)},Bh=jc._emscripten_bind_eSpeakNGWorker_get_voices_1=function(){return(Bh=jc._emscripten_bind_eSpeakNGWorker_get_voices_1=jc.asm.da).apply(null,arguments)},Mh=jc._emscripten_bind_eSpeakNGWorker_set_voices_2=function(){return(Mh=jc._emscripten_bind_eSpeakNGWorker_set_voices_2=jc.asm.ea).apply(null,arguments)},Dh=jc._emscripten_bind_eSpeakNGWorker_get_samplerate_0=function(){return(Dh=jc._emscripten_bind_eSpeakNGWorker_get_samplerate_0=jc.asm.fa).apply(null,arguments)},Th=jc._emscripten_bind_eSpeakNGWorker_get_rate_0=function(){return(Th=jc._emscripten_bind_eSpeakNGWorker_get_rate_0=jc.asm.ga).apply(null,arguments)},Sh=jc._emscripten_bind_eSpeakNGWorker_set_rate_1=function(){return(Sh=jc._emscripten_bind_eSpeakNGWorker_set_rate_1=jc.asm.ha).apply(null,arguments)},Nh=jc._emscripten_bind_eSpeakNGWorker_get_pitch_0=function(){return(Nh=jc._emscripten_bind_eSpeakNGWorker_get_pitch_0=jc.asm.ia).apply(null,arguments)},Gh=jc._emscripten_bind_eSpeakNGWorker_set_pitch_1=function(){return(Gh=jc._emscripten_bind_eSpeakNGWorker_set_pitch_1=jc.asm.ja).apply(null,arguments)},Fh=jc._emscripten_bind_eSpeakNGWorker___destroy___0=function(){return(Fh=jc._emscripten_bind_eSpeakNGWorker___destroy___0=jc.asm.ka).apply(null,arguments)},Ph=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_LIST_TERMINATED=function(){return(Ph=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_LIST_TERMINATED=jc.asm.la).apply(null,arguments)},Qh=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_WORD=function(){return(Qh=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_WORD=jc.asm.ma).apply(null,arguments)},zh=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_SENTENCE=function(){return(zh=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_SENTENCE=jc.asm.na).apply(null,arguments)},Oh=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_MARK=function(){return(Oh=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_MARK=jc.asm.oa).apply(null,arguments)},Rh=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_PLAY=function(){return(Rh=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_PLAY=jc.asm.pa).apply(null,arguments)},Lh=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_END=function(){return(Lh=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_END=jc.asm.qa).apply(null,arguments)},Wh=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_MSG_TERMINATED=function(){return(Wh=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_MSG_TERMINATED=jc.asm.ra).apply(null,arguments)},_h=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_PHONEME=function(){return(_h=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_PHONEME=jc.asm.sa).apply(null,arguments)},Vh=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_SAMPLERATE=function(){return(Vh=jc._emscripten_enum_espeak_EVENT_TYPE_espeakEVENT_SAMPLERATE=jc.asm.ta).apply(null,arguments)},Hh=jc.___errno_location=function(){return(Hh=jc.___errno_location=jc.asm.va).apply(null,arguments)};jc._free=function(){return(jc._free=jc.asm.wa).apply(null,arguments)},jc._malloc=function(){return(jc._malloc=jc.asm.xa).apply(null,arguments)};var Uh,jh=jc.___cxa_is_pointer_type=function(){return(jh=jc.___cxa_is_pointer_type=jc.asm.ya).apply(null,arguments)};function Yh(e){function t(){Uh||(Uh=!0,jc.calledRun=!0,nd||(wd=!0,jc.noFSInit||Ld.init.initialized||Ld.init(),Ld.ignorePermissions=!1,Sd(Cd),jc.onRuntimeInitialized&&jc.onRuntimeInitialized(),function(){if(jc.postRun)for("function"==typeof jc.postRun&&(jc.postRun=[jc.postRun]);jc.postRun.length;)e=jc.postRun.shift(),Id.unshift(e);var e;Sd(Id)}()))}vd>0||(function(){if(jc.preRun)for("function"==typeof jc.preRun&&(jc.preRun=[jc.preRun]);jc.preRun.length;)e=jc.preRun.shift(),bd.unshift(e);var e;Sd(bd)}(),vd>0||(jc.setStatus?(jc.setStatus("Running..."),setTimeout((function(){setTimeout((function(){jc.setStatus("")}),1),t()}),1)):t()))}if(jc.___start_em_js=132724,jc.___stop_em_js=132822,jc.addRunDependency=Bd,jc.removeRunDependency=Md,jc.FS_createPath=Ld.createPath,jc.FS_createDataFile=Ld.createDataFile,jc.FS_createLazyFile=Ld.createLazyFile,jc.FS_createDevice=Ld.createDevice,jc.FS_unlink=Ld.unlink,Ed=function e(){Uh||Yh(),Uh||(Ed=e)},jc.preInit)for("function"==typeof jc.preInit&&(jc.preInit=[jc.preInit]);jc.preInit.length>0;)jc.preInit.pop()();function Kh(){}function Xh(e){return(e||Kh).__cache__}function qh(e,t){var n=Xh(t),r=n[e];return r||((r=Object.create((t||Kh).prototype)).ptr=e,n[e]=r)}Yh(),Kh.prototype=Object.create(Kh.prototype),Kh.prototype.constructor=Kh,Kh.prototype.__class__=Kh,Kh.__cache__={},jc.WrapperObject=Kh,jc.getCache=Xh,jc.wrapPointer=qh,jc.castObject=function(e,t){return qh(e.ptr,t)},jc.NULL=qh(0),jc.destroy=function(e){if(!e.__destroy__)throw"Error: Cannot destroy object. (Did you create it yourself?)";e.__destroy__(),delete Xh(e.__class__)[e.ptr]},jc.compare=function(e,t){return e.ptr===t.ptr},jc.getPointer=function(e){return e.ptr},jc.getClass=function(e){return e.__class__};var Zh={buffer:0,size:0,pos:0,temps:[],needed:0,prepare:function(){if(Zh.needed){for(var e=0;e<Zh.temps.length;e++)jc._free(Zh.temps[e]);Zh.temps.length=0,jc._free(Zh.buffer),Zh.buffer=0,Zh.size+=Zh.needed,Zh.needed=0}Zh.buffer||(Zh.size+=128,Zh.buffer=jc._malloc(Zh.size),rd(Zh.buffer)),Zh.pos=0},alloc:function(e,t){rd(Zh.buffer);var n,r=t.BYTES_PER_ELEMENT,s=e.length*r;return s=s+7&-8,Zh.pos+s>=Zh.size?(rd(s>0),Zh.needed+=s,n=jc._malloc(s),Zh.temps.push(n)):(n=Zh.buffer+Zh.pos,Zh.pos+=s),n},copy:function(e,t,n){switch(n>>>=0,t.BYTES_PER_ELEMENT){case 2:n>>>=1;break;case 4:n>>>=2;break;case 8:n>>>=3}for(var r=0;r<e.length;r++)t[n+r]=e[r]}};function Jh(e){if("string"==typeof e){var t=Qd(e),n=Zh.alloc(t,sd);return Zh.copy(t,sd,n),n}return e}function $h(){throw"cannot construct a VoidPtr, no constructor in IDL"}function ef(){throw"cannot construct a espeak_VOICE, no constructor in IDL"}function tf(){throw"cannot construct a espeak_EVENT, no constructor in IDL"}function nf(){this.ptr=Ch(),Xh(nf)[this.ptr]=this}$h.prototype=Object.create(Kh.prototype),$h.prototype.constructor=$h,$h.prototype.__class__=$h,$h.__cache__={},jc.VoidPtr=$h,$h.prototype.__destroy__=$h.prototype.__destroy__=function(){var e=this.ptr;jd(e)},ef.prototype=Object.create(Kh.prototype),ef.prototype.constructor=ef,ef.prototype.__class__=ef,ef.__cache__={},jc.espeak_VOICE=ef,ef.prototype.get_name=ef.prototype.get_name=function(){var e=this.ptr;return hd(Yd(e))},ef.prototype.set_name=ef.prototype.set_name=function(e){var t=this.ptr;Zh.prepare(),e=e&&"object"==typeof e?e.ptr:Jh(e),Kd(t,e)},Object.defineProperty(ef.prototype,"name",{get:ef.prototype.get_name,set:ef.prototype.set_name}),ef.prototype.get_languages=ef.prototype.get_languages=function(e){var t=this.ptr;return e&&"object"==typeof e&&(e=e.ptr),Xd(t,e)},Object.defineProperty(ef.prototype,"languages",{get:ef.prototype.get_languages}),ef.prototype.get_identifier=ef.prototype.get_identifier=function(){var e=this.ptr;return hd(qd(e))},ef.prototype.set_identifier=ef.prototype.set_identifier=function(e){var t=this.ptr;Zh.prepare(),e=e&&"object"==typeof e?e.ptr:Jh(e),Zd(t,e)},Object.defineProperty(ef.prototype,"identifier",{get:ef.prototype.get_identifier,set:ef.prototype.set_identifier}),ef.prototype.get_gender=ef.prototype.get_gender=function(){var e=this.ptr;return Jd(e)},ef.prototype.set_gender=ef.prototype.set_gender=function(e){var t=this.ptr;e&&"object"==typeof e&&(e=e.ptr),$d(t,e)},Object.defineProperty(ef.prototype,"gender",{get:ef.prototype.get_gender,set:ef.prototype.set_gender}),ef.prototype.get_age=ef.prototype.get_age=function(){var e=this.ptr;return eh(e)},ef.prototype.set_age=ef.prototype.set_age=function(e){var t=this.ptr;e&&"object"==typeof e&&(e=e.ptr),th(t,e)},Object.defineProperty(ef.prototype,"age",{get:ef.prototype.get_age,set:ef.prototype.set_age}),ef.prototype.get_variant=ef.prototype.get_variant=function(){var e=this.ptr;return nh(e)},ef.prototype.set_variant=ef.prototype.set_variant=function(e){var t=this.ptr;e&&"object"==typeof e&&(e=e.ptr),rh(t,e)},Object.defineProperty(ef.prototype,"variant",{get:ef.prototype.get_variant,set:ef.prototype.set_variant}),ef.prototype.get_xx1=ef.prototype.get_xx1=function(){var e=this.ptr;return sh(e)},ef.prototype.set_xx1=ef.prototype.set_xx1=function(e){var t=this.ptr;e&&"object"==typeof e&&(e=e.ptr),ah(t,e)},Object.defineProperty(ef.prototype,"xx1",{get:ef.prototype.get_xx1,set:ef.prototype.set_xx1}),ef.prototype.get_score=ef.prototype.get_score=function(){var e=this.ptr;return ih(e)},ef.prototype.set_score=ef.prototype.set_score=function(e){var t=this.ptr;e&&"object"==typeof e&&(e=e.ptr),Ah(t,e)},Object.defineProperty(ef.prototype,"score",{get:ef.prototype.get_score,set:ef.prototype.set_score}),ef.prototype.get_spare=ef.prototype.get_spare=function(){var e=this.ptr;return oh(e)},ef.prototype.set_spare=ef.prototype.set_spare=function(e){var t=this.ptr;e&&"object"==typeof e&&(e=e.ptr),lh(t,e)},Object.defineProperty(ef.prototype,"spare",{get:ef.prototype.get_spare,set:ef.prototype.set_spare}),ef.prototype.__destroy__=ef.prototype.__destroy__=function(){var e=this.ptr;uh(e)},tf.prototype=Object.create(Kh.prototype),tf.prototype.constructor=tf,tf.prototype.__class__=tf,tf.__cache__={},jc.espeak_EVENT=tf,tf.prototype.get_type=tf.prototype.get_type=function(){var e=this.ptr;return ch(e)},Object.defineProperty(tf.prototype,"type",{get:tf.prototype.get_type}),tf.prototype.get_unique_identifier=tf.prototype.get_unique_identifier=function(){var e=this.ptr;return dh(e)},Object.defineProperty(tf.prototype,"unique_identifier",{get:tf.prototype.get_unique_identifier}),tf.prototype.get_text_position=tf.prototype.get_text_position=function(){var e=this.ptr;return hh(e)},Object.defineProperty(tf.prototype,"text_position",{get:tf.prototype.get_text_position}),tf.prototype.get_length=tf.prototype.get_length=function(){var e=this.ptr;return fh(e)},Object.defineProperty(tf.prototype,"length",{get:tf.prototype.get_length}),tf.prototype.get_audio_position=tf.prototype.get_audio_position=function(){var e=this.ptr;return gh(e)},Object.defineProperty(tf.prototype,"audio_position",{get:tf.prototype.get_audio_position}),tf.prototype.get_sample=tf.prototype.get_sample=function(){var e=this.ptr;return ph(e)},Object.defineProperty(tf.prototype,"sample",{get:tf.prototype.get_sample}),tf.prototype.get_user_data=tf.prototype.get_user_data=function(){var e=this.ptr;return mh(e)},Object.defineProperty(tf.prototype,"user_data",{get:tf.prototype.get_user_data}),tf.prototype.__destroy__=tf.prototype.__destroy__=function(){var e=this.ptr;bh(e)},nf.prototype=Object.create(Kh.prototype),nf.prototype.constructor=nf,nf.prototype.__class__=nf,nf.__cache__={},jc.eSpeakNGWorker=nf,nf.prototype.synth_=nf.prototype.synth_=function(e,t){var n=this.ptr;Zh.prepare(),e=e&&"object"==typeof e?e.ptr:Jh(e),t&&"object"==typeof t&&(t=t.ptr),Ih(n,e,t)},nf.prototype.synth_ipa_=nf.prototype.synth_ipa_=function(e,t){var n=this.ptr;return Zh.prepare(),e=e&&"object"==typeof e?e.ptr:Jh(e),t=t&&"object"==typeof t?t.ptr:Jh(t),wh(n,e,t)},nf.prototype.getSizeOfEventStruct_=nf.prototype.getSizeOfEventStruct_=function(){var e=this.ptr;return kh(e)},nf.prototype.set_voice=nf.prototype.set_voice=function(e,t,n,r,s){var a=this.ptr;return Zh.prepare(),e=e&&"object"==typeof e?e.ptr:Jh(e),t=t&&"object"==typeof t?t.ptr:Jh(t),n&&"object"==typeof n&&(n=n.ptr),r&&"object"==typeof r&&(r=r.ptr),s&&"object"==typeof s&&(s=s.ptr),void 0===n?xh(a,e,t):void 0===r?yh(a,e,t,n):void 0===s?vh(a,e,t,n,r):Eh(a,e,t,n,r,s)},nf.prototype.get_voices=nf.prototype.get_voices=function(e){var t=this.ptr;return e&&"object"==typeof e&&(e=e.ptr),qh(Bh(t,e),ef)},nf.prototype.set_voices=nf.prototype.set_voices=function(e,t){var n=this.ptr;Zh.prepare(),e&&"object"==typeof e&&(e=e.ptr),t&&"object"==typeof t&&(t=t.ptr),Mh(n,e,t)},Object.defineProperty(nf.prototype,"voices",{get:nf.prototype.get_voices,set:nf.prototype.set_voices}),nf.prototype.get_samplerate=nf.prototype.get_samplerate=function(){var e=this.ptr;return Dh(e)},Object.defineProperty(nf.prototype,"samplerate",{get:nf.prototype.get_samplerate}),nf.prototype.get_rate=nf.prototype.get_rate=function(){var e=this.ptr;return Th(e)},nf.prototype.set_rate=nf.prototype.set_rate=function(e){var t=this.ptr;e&&"object"==typeof e&&(e=e.ptr),Sh(t,e)},Object.defineProperty(nf.prototype,"rate",{get:nf.prototype.get_rate,set:nf.prototype.set_rate}),nf.prototype.get_pitch=nf.prototype.get_pitch=function(){var e=this.ptr;return Nh(e)},nf.prototype.set_pitch=nf.prototype.set_pitch=function(e){var t=this.ptr;e&&"object"==typeof e&&(e=e.ptr),Gh(t,e)},Object.defineProperty(nf.prototype,"pitch",{get:nf.prototype.get_pitch,set:nf.prototype.set_pitch}),nf.prototype.__destroy__=nf.prototype.__destroy__=function(){var e=this.ptr;Fh(e)},function(){function e(){jc.espeakEVENT_LIST_TERMINATED=Ph(),jc.espeakEVENT_WORD=Qh(),jc.espeakEVENT_SENTENCE=zh(),jc.espeakEVENT_MARK=Oh(),jc.espeakEVENT_PLAY=Rh(),jc.espeakEVENT_END=Lh(),jc.espeakEVENT_MSG_TERMINATED=Wh(),jc.espeakEVENT_PHONEME=_h(),jc.espeakEVENT_SAMPLERATE=Vh()}wd?e():kd(e)}(),nf.prototype.list_voices=function(){for(var e,t=[],n=this.get_voices(e=0);0!=n.ptr;n=this.get_voices(++e)){var r={name:n.get_name(),identifier:n.get_identifier(),languages:[]},s=0,a=n.get_languages(s);function A(e){for(var t="",r=e,s=n.get_languages(r++);0!=s;)t+=String.fromCharCode(s),s=n.get_languages(r++);return t}for(;0!=a;){var i={priority:a,name:A(++s)};r.languages.push(i),s+=i.name.length+1,a=n.get_languages(s)}t.push(r)}return t};var rf=["list_terminated","word","sentence","mark","play","end","msg_terminated","phoneme","samplerate"];nf.prototype.synthesize=function(e,t){var n=this.getSizeOfEventStruct_(),r=addFunction((function(e,r,s){for(var a=new Float32Array(2*r),i=0;i<r;i++)a[2*i]=Math.max(-1,Math.min(1,Nd(e+2*i,"i16")/32768)),a[2*i+1]=a[2*i];var A=[];for(e=s,ev=qh(e,tf);ev.get_type()!=jc.espeakEVENT_LIST_TERMINATED;ev=qh(e+=n,tf))A.push({type:rf[ev.get_type()],text_position:ev.get_text_position(),word_length:ev.get_length(),audio_position:ev.get_audio_position()});return t(a,A)?1:0}));this.synth_(e,r),removeFunction(r)},nf.prototype.synthesize_ipa=function(e,t){var n="espeak-ng-ipa-tmp-"+Math.random().toString().substring(2),r="",s=this.synth_ipa_(e,n);return 0==s&&(r=Ld.readFile(n,{encoding:"utf8"})),Ld.unlink(n),{code:s,ipa:r}};const sf=new Promise((e=>{jc.calledRun?e(new jc.eSpeakNGWorker):jc.onRuntimeInitialized=()=>e(new jc.eSpeakNGWorker)})),af=["en"],Af=sf.then((e=>{const t=e.list_voices().map((({name:e,identifier:t,languages:n})=>({name:e,identifier:t,languages:n.filter((e=>af.includes(e.name.split("-")[0])))}))).filter((e=>e.languages.length>0)),n=new Set;for(const e of t){n.add(e.identifier);for(const t of e.languages)n.add(t.name)}return{voices:t,identifiers:n}}));function of(e){if(e.includes("."))return e;if(e.includes(":")){let[t,n]=e.split(":").map(Number);return 0===n?`${t} o'clock`:n<10?`${t} oh ${n}`:`${t} ${n}`}let t=parseInt(e.slice(0,4),10);if(t<1100||t%1e3<10)return e;let n=e.slice(0,2),r=parseInt(e.slice(2,4),10),s=e.endsWith("s")?"s":"";if(t%1e3>=100&&t%1e3<=999){if(0===r)return`${n} hundred${s}`;if(r<10)return`${n} oh ${r}${s}`}return`${n} ${r}${s}`}function lf(e){const t="$"===e[0]?"dollar":"pound";if(isNaN(Number(e.slice(1))))return`${e.slice(1)} ${t}s`;if(!e.includes(".")){let n="1"===e.slice(1)?"":"s";return`${e.slice(1)} ${t}${n}`}const[n,r]=e.slice(1).split("."),s=parseInt(r.padEnd(2,"0"),10);return`${n} ${t}${"1"===n?"":"s"} and ${s} ${"$"===e[0]?1===s?"cent":"cents":1===s?"penny":"pence"}`}function uf(e){let[t,n]=e.split(".");return`${t} point ${n.split("").join(" ")}`}const cf=new RegExp(`(\\s*[${df=';:,.!?"(){}[]',df.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}]+\\s*)+`,"g");var df;async function hf(e,t="a",n=!0){n&&(e=function(e){return e.replace(/[]/g,"'").replace(//g,"").replace(//g,"").replace(/[]/g,'"').replace(/\(/g,"").replace(/\)/g,"").replace(//g,", ").replace(//g,". ").replace(//g,"! ").replace(//g,", ").replace(//g,": ").replace(//g,"; ").replace(//g,"? ").replace(/[^\S \n]/g," ").replace(/  +/," ").replace(/(?<=\n) +(?=\n)/g,"").replace(/\bD[Rr]\.(?= [A-Z])/g,"Doctor").replace(/\b(?:Mr\.|MR\.(?= [A-Z]))/g,"Mister").replace(/\b(?:Ms\.|MS\.(?= [A-Z]))/g,"Miss").replace(/\b(?:Mrs\.|MRS\.(?= [A-Z]))/g,"Mrs").replace(/\betc\.(?! [A-Z])/gi,"etc").replace(/\b(y)eah?\b/gi,"$1e'a").replace(/\d*\.\d+|\b\d{4}s?\b|(?<!:)\b(?:[1-9]|1[0-2]):[0-5]\d\b(?!:)/g,of).replace(/(?<=\d),(?=\d)/g,"").replace(/[$]\d+(?:\.\d+)?(?: hundred| thousand| (?:[bm]|tr)illion)*\b|[$]\d+\.\d\d?\b/gi,lf).replace(/\d*\.\d+/g,uf).replace(/(?<=\d)-(?=\d)/g," to ").replace(/(?<=\d)S/g," S").replace(/(?<=[BCDFGHJ-NP-TV-Z])'?s\b/g,"'S").replace(/(?<=X')S\b/g,"s").replace(/(?:[A-Za-z]\.){2,} [a-z]/g,(e=>e.replace(/\./g,"-"))).replace(/(?<=[A-Z])\.(?=[A-Z])/gi,"-").trim()}(e));const r=function(e,t){const n=[];let r=0;for(const s of e.matchAll(t)){const t=s[0];r<s.index&&n.push({match:!1,text:e.slice(r,s.index)}),t.length>0&&n.push({match:!0,text:t}),r=s.index+t.length}return r<e.length&&n.push({match:!1,text:e.slice(r)}),n}(e,cf),s="a"===t?"en-us":"en",a=(await Promise.all(r.map((async({match:e,text:t})=>e?t:(await(async(e,t="en-us")=>{const n=await sf,{identifiers:r}=await Af;if(!r.has(t))throw new Error(`Invalid language identifier: "${t}". Should be one of: ${Array.from(r).toSorted().join(", ")}.`);return n.set_voice(t),n.synthesize_ipa(e).ipa?.split("\n").filter((e=>e.length>0))??[]})(t,s)).join(" "))))).join("");let i=a.replace(/kkoo/g,"koko").replace(/kk/g,"kk").replace(//g,"j").replace(/r/g,"").replace(/x/g,"k").replace(//g,"l").replace(/(?<=[a-z])(?=hndd)/g," ").replace(/ z(?=[;:,.!?" ]|$)/g,"z");return"a"===t&&(i=i.replace(/(?<=nan)ti(?!)/g,"di")),i.trim()}function ff(e,t=!0){return".!?".includes(e)||t&&"\n"===e}function gf(e){return"\"')]}".includes(e)}function pf(e,t){let n=t;for(;n<e.length&&!/\s/.test(e[n]);)++n;return e.substring(t,n)}const mf=new Set(["mr","mrs","ms","dr","prof","sr","jr","sgt","col","gen","rep","sen","gov","lt","maj","capt","st","mt","etc","co","inc","ltd","dept","vs","p","pg","jan","feb","mar","apr","jun","jul","aug","sep","sept","oct","nov","dec","sun","mon","tu","tue","tues","wed","th","thu","thur","thurs","fri","sat"]);function bf(e){return e=e.replace(/[']s$/i,"").replace(/\.+$/,""),mf.has(e.toLowerCase())}const Cf=new Map([[")","("],["]","["],["}","{"],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""]]),If=new Set(Cf.values());function wf(e,t,n,r){if('"'===e||"'"===e){if("'"===e&&n>0&&n<r.length-1&&/[A-Za-z]/.test(r[n-1])&&/[A-Za-z]/.test(r[n+1]))return;return void(t.length&&t.at(-1)===e?t.pop():t.push(e))}if(If.has(e))return void t.push(e);const s=Cf.get(e);s&&t.length&&t.at(-1)===s&&t.pop()}class kf{constructor(){this._buffer="",this._sentences=[],this._resolver=null,this._closed=!1}push(...e){for(const t of e)this._buffer+=t,this._process()}close(){if(this._closed)throw new Error("Stream is already closed.");this._closed=!0,this.flush()}flush(){const e=this._buffer.trim();e.length>0&&this._sentences.push(e),this._buffer="",this._resolve()}_resolve(){this._resolver&&(this._resolver(),this._resolver=null)}_process(){let e=0;const t=this._buffer,n=t.length;let r=0,s=[];const a=e=>{let r=e;for(;r+1<n&&ff(t[r+1],!1);)++r;for(;r+1<n&&gf(t[r+1]);)++r;let s=r+1;for(;s<n&&/\s/.test(t[s]);)++s;return{end:r,nextNonSpace:s}};for(;r<n;){const i=t[r];if(wf(i,s,r,t),0===s.length&&ff(i)){const s=t.slice(e,r);if(/(^|\n)\d+$/.test(s)){++r;continue}const{end:A,nextNonSpace:o}=a(r);if(r===o-1&&"\n"!==i){++r;continue}if(o===n)break;let l=r-1;for(;l>=0&&/\S/.test(t[l]);)l--;l=Math.max(e,l+1);const u=pf(t,l);if(!u){++r;continue}if((/https?[,:]\/\//.test(u)||u.includes("@"))&&!ff(u.at(-1))){r=l+u.length;continue}if(bf(u)){++r;continue}if(/^([A-Za-z]\.)+$/.test(u)&&o<n&&/[A-Z]/.test(t[o])){++r;continue}if("."===i&&o<n&&/[a-z]/.test(t[o])){++r;continue}const c=t.substring(e,A+1).trim();if("..."===c||""===c){++r;continue}c&&this._sentences.push(c),r=e=A+1}else++r}this._buffer=t.substring(e),this._sentences.length>0&&this._resolve()}async*[Symbol.asyncIterator](){if(this._resolver)throw new Error("Another iterator is already active.");for(;;)if(this._sentences.length>0)yield this._sentences.shift();else{if(this._closed)break;await new Promise((e=>{this._resolver=e}))}}[Symbol.iterator](){this.flush();const e=this._sentences[Symbol.iterator]();return this._sentences=[],e}get sentences(){return this._sentences}}var xf={},yf=Object.freeze({__proto__:null,default:xf});const vf=Object.freeze({af_heart:{name:"Heart",language:"en-us",gender:"Female",traits:"",targetQuality:"A",overallGrade:"A"},af_alloy:{name:"Alloy",language:"en-us",gender:"Female",targetQuality:"B",overallGrade:"C"},af_aoede:{name:"Aoede",language:"en-us",gender:"Female",targetQuality:"B",overallGrade:"C+"},af_bella:{name:"Bella",language:"en-us",gender:"Female",traits:"",targetQuality:"A",overallGrade:"A-"},af_jessica:{name:"Jessica",language:"en-us",gender:"Female",targetQuality:"C",overallGrade:"D"},af_kore:{name:"Kore",language:"en-us",gender:"Female",targetQuality:"B",overallGrade:"C+"},af_nicole:{name:"Nicole",language:"en-us",gender:"Female",traits:"",targetQuality:"B",overallGrade:"B-"},af_nova:{name:"Nova",language:"en-us",gender:"Female",targetQuality:"B",overallGrade:"C"},af_river:{name:"River",language:"en-us",gender:"Female",targetQuality:"C",overallGrade:"D"},af_sarah:{name:"Sarah",language:"en-us",gender:"Female",targetQuality:"B",overallGrade:"C+"},af_sky:{name:"Sky",language:"en-us",gender:"Female",targetQuality:"B",overallGrade:"C-"},am_adam:{name:"Adam",language:"en-us",gender:"Male",targetQuality:"D",overallGrade:"F+"},am_echo:{name:"Echo",language:"en-us",gender:"Male",targetQuality:"C",overallGrade:"D"},am_eric:{name:"Eric",language:"en-us",gender:"Male",targetQuality:"C",overallGrade:"D"},am_fenrir:{name:"Fenrir",language:"en-us",gender:"Male",targetQuality:"B",overallGrade:"C+"},am_liam:{name:"Liam",language:"en-us",gender:"Male",targetQuality:"C",overallGrade:"D"},am_michael:{name:"Michael",language:"en-us",gender:"Male",targetQuality:"B",overallGrade:"C+"},am_onyx:{name:"Onyx",language:"en-us",gender:"Male",targetQuality:"C",overallGrade:"D"},am_puck:{name:"Puck",language:"en-us",gender:"Male",targetQuality:"B",overallGrade:"C+"},am_santa:{name:"Santa",language:"en-us",gender:"Male",targetQuality:"C",overallGrade:"D-"},bf_emma:{name:"Emma",language:"en-gb",gender:"Female",traits:"",targetQuality:"B",overallGrade:"B-"},bf_isabella:{name:"Isabella",language:"en-gb",gender:"Female",targetQuality:"B",overallGrade:"C"},bm_george:{name:"George",language:"en-gb",gender:"Male",targetQuality:"B",overallGrade:"C"},bm_lewis:{name:"Lewis",language:"en-gb",gender:"Male",targetQuality:"C",overallGrade:"D+"},bf_alice:{name:"Alice",language:"en-gb",gender:"Female",traits:"",targetQuality:"C",overallGrade:"D"},bf_lily:{name:"Lily",language:"en-gb",gender:"Female",traits:"",targetQuality:"C",overallGrade:"D"},bm_daniel:{name:"Daniel",language:"en-gb",gender:"Male",traits:"",targetQuality:"C",overallGrade:"D"},bm_fable:{name:"Fable",language:"en-gb",gender:"Male",traits:"",targetQuality:"B",overallGrade:"C"}});const Ef=new Map;async function Bf(e){if(Ef.has(e))return Ef.get(e);const t=new Float32Array(await async function(e){if(xf&&Object.hasOwn(xf,"readFile")){const t="undefined"!=typeof __dirname?__dirname:import.meta.dirname,n=xf.resolve(t,`../build/voices/${e}.bin`),{buffer:r}=await xf.readFile(n);return r}const t=`https://huggingface.co/onnx-community/Kokoro-82M-v1.0-ONNX/resolve/main/voices/${e}.bin`;let n;try{n=await caches.open("kokoro-voices");const e=await n.match(t);if(e)return await e.arrayBuffer()}catch(e){console.warn("Unable to open cache",e)}const r=await fetch(t),s=await r.arrayBuffer();if(n)try{await n.put(t,new Response(s,{headers:r.headers}))}catch(e){console.warn("Unable to cache file",e)}return s}(e));return Ef.set(e,t),t}class Mf{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Df{refCount(e){return Tf("refCount")}incRef(e){return Tf("incRef")}timerAvailable(){return!0}time(e){return Tf("time")}read(e){return Tf("read")}readSync(e){return Tf("readSync")}readToGPU(e,t){return Tf("readToGPU")}numDataIds(){return Tf("numDataIds")}disposeData(e,t){return Tf("disposeData")}write(e,t,n){return Tf("write")}move(e,t,n,r,s){return Tf("move")}createTensorFromGPUData(e,t,n){return Tf("createTensorFromGPUData")}memory(){return Tf("memory")}floatPrecision(){return Tf("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Tf("dispose")}}function Tf(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Sf(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Ff(e,t,n)}function Nf(e,t,n){return Math.max(e,Math.min(t,n))}function Gf(e){return e%2==0?e:e+1}function Ff(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function Pf(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function Qf(e,t,n=""){Pf(Rf(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function zf(e){Pf(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Of(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Rf(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Lf(e){return e%1==0}function Wf(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function _f(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Vf(e,t=e=>0,n,r){return new Promise(((s,a)=>{let i=0;const A=()=>{if(e())return void s();i++;const o=t(i);null!=n&&i>=n?a():null!=r?r(A,o):setTimeout(A,o)};A()}))}function Hf(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function Uf(e,t){const n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),Pf(e.every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),Pf(e.every((e=>Lf(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function jf(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:Uf(t,e).sort();let i=0;for(let t=0;t<e.length;++t){if(null!=a){if(a[i]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==a[i]||a[i]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),a[i]<=t&&i++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function Yf(e,t){return Kf(e,t)}function Kf(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function Xf(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function qf(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function Zf(e){return"string"==typeof e||e instanceof String}function Jf(e){return"number"==typeof e}function $f(e){return Array.isArray(e)?$f(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Jf(e)?"float32":Zf(e)?"string":"boolean"==typeof e?"bool":"float32"}function eg(e){return!!(e&&e.constructor&&e.call&&e.apply)}function tg(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function ng(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function rg(e,t,n,r=!1){const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),A=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<a;t++)s[t]=rg(e+t*A,i,n,r)}return s}function sg(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return rg(0,e,t,n)}function ag(e,t){const n=ig(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function ig(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Ag(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return sg(e,new Float32Array(n));if("int32"===t)return sg(e,new Int32Array(n));if("bool"===t)return sg(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function og(e){e.forEach((t=>{Pf(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function lg(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function ug(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function cg(e){return e&&e.then&&"function"==typeof e.then}const dg="tfjsflags";class hg{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=fg,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(gg().getBool("IS_TEST")||gg().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];gg().getBool("IS_TEST")||gg().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(cg(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(dg in e){e[dg].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}}function fg(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}function gg(){return mg}let pg,mg=null;function bg(){if(null==pg){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof global)e=global;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}pg=e}return pg}function Cg(e,t){const n=function(){const e=bg();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const Ig="Abs",wg="Acos",kg="Acosh",xg="Add",yg="AddN",vg="All",Eg="Any",Bg="ArgMax",Mg="ArgMin",Dg="Asin",Tg="Asinh",Sg="Atan",Ng="Atanh",Gg="Atan2",Fg="AvgPool",Pg="AvgPoolGrad",Qg="AvgPool3D",zg="AvgPool3DGrad",Og="BatchMatMul",Rg="BatchToSpaceND",Lg="Bincount",Wg="BitwiseAnd",_g="BroadcastArgs",Vg="Cast",Hg="Ceil",Ug="ClipByValue",jg="Complex",Yg="ComplexAbs",Kg="Concat",Xg="Conv2D",qg="Conv2DBackpropFilter",Zg="Conv2DBackpropInput",Jg="Conv3D",$g="Conv3DBackpropFilterV2",ep="Conv3DBackpropInputV2",tp="Cos",np="Cosh",rp="Cumprod",sp="Cumsum",ap="CropAndResize",ip="DenseBincount",Ap="DepthToSpace",op="DepthwiseConv2dNative",lp="DepthwiseConv2dNativeBackpropFilter",up="DepthwiseConv2dNativeBackpropInput",cp="Diag",dp="Dilation2D",hp="Dilation2DBackpropInput",fp="Dilation2DBackpropFilter",gp="RealDiv",pp="Einsum",mp="Elu",bp="EluGrad",Cp="Erf",Ip="Equal",wp="Exp",kp="ExpandDims",xp="Expm1",yp="FFT",vp="Fill",Ep="FlipLeftRight",Bp="Floor",Mp="FloorDiv",Dp="FusedBatchNorm",Tp="GatherV2",Sp="GatherNd",Np="Greater",Gp="GreaterEqual",Fp="Identity",Pp="IFFT",Qp="Imag",zp="IsFinite",Op="IsInf",Rp="IsNan",Lp="LeakyRelu",Wp="Less",_p="LessEqual",Vp="LinSpace",Hp="Log",Up="Log1p",jp="LogicalAnd",Yp="LogicalNot",Kp="LogicalOr",Xp="LRN",qp="LRNGrad",Zp="Max",Jp="Maximum",$p="MaxPool",em="MaxPoolGrad",tm="MaxPool3D",nm="MaxPool3DGrad",rm="MaxPoolWithArgmax",sm="Mean",am="Min",im="Minimum",Am="MirrorPad",om="Mod",lm="Multinomial",um="Multiply",cm="Neg",dm="NotEqual",hm="NonMaxSuppressionV3",fm="NonMaxSuppressionV4",gm="NonMaxSuppressionV5",pm="OnesLike",mm="OneHot",bm="Pack",Cm="PadV2",Im="Pow",wm="Prelu",km="Prod",xm="RaggedGather",ym="RaggedRange",vm="RaggedTensorToTensor",Em="Range",Bm="Real",Mm="Reciprocal",Dm="Relu",Tm="Reshape",Sm="ResizeNearestNeighbor",Nm="ResizeNearestNeighborGrad",Gm="ResizeBilinear",Fm="ResizeBilinearGrad",Pm="Relu6",Qm="Reverse",zm="Round",Om="Rsqrt",Rm="ScatterNd",Lm="TensorScatterUpdate",Wm="SearchSorted",_m="Select",Vm="Selu",Hm="Slice",Um="Sin",jm="Sinh",Ym="Sign",Km="Sigmoid",Xm="Softplus",qm="Sqrt",Zm="Sum",Jm="SpaceToBatchND",$m="SplitV",eb="Softmax",tb="SparseFillEmptyRows",nb="SparseReshape",rb="SparseSegmentMean",sb="SparseSegmentSum",ab="SparseToDense",ib="SquaredDifference",Ab="Square",ob="StaticRegexReplace",lb="StridedSlice",ub="StringNGrams",cb="StringSplit",db="StringToHashBucketFast",hb="Sub",fb="Tan",gb="Tanh",pb="Tile",mb="TopK",bb="Transform",Cb="Transpose",Ib="Unique",wb="Unpack",kb="UnsortedSegmentSum",xb="ZerosLike",yb="Step",vb="RotateWithOffset",Eb="_FusedMatMul",Bb="FusedConv2D",Mb="FusedDepthwiseConv2D";function Db(...e){gg().getBool("IS_TEST")||gg().getBool("PROD")||console.warn(...e)}const Tb=Cg("kernelRegistry",(()=>new Map)),Sb=Cg("gradRegistry",(()=>new Map));function Nb(e,t){const n=zb(e,t);return Tb.get(n)}function Gb(e){return Sb.get(e)}function Fb(e){const t=Tb.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[A]=a.split("_");A===e&&n.push(i)}return n}function Pb(e){const{kernelName:t,backendName:n}=e,r=zb(t,n);Tb.has(r)&&Db(`The kernel '${t}' for backend '${n}' is already registered`),Tb.set(r,e)}function Qb(e){const{kernelName:t}=e;Sb.has(t)&&gg().getBool("DEBUG")&&Db(`Overriding the gradient for '${t}'`),Sb.set(t,e)}function zb(e,t){return`${t}_${e}`}function Ob(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function Rb(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function Lb(e){if(Object.prototype.hasOwnProperty.call(e,"__esModule"))return e;var t=e.default;if("function"==typeof t){var n=function e(){return this instanceof e?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};n.prototype=t.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(e).forEach((function(t){var r=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(n,t,r.get?r:{enumerable:!0,get:function(){return e[t]}})})),n}var Wb,_b;var Vb=function(){if(_b)return Wb;_b=1,Wb=t;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function t(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function n(e){return!0===(e&&e.__isLong__)}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0}),t.isLong=n;var r={},s={};function a(e,t){var n,a,i;return t?(i=0<=(e>>>=0)&&e<256)&&(a=s[e])?a:(n=A(e,(0|e)<0?-1:0,!0),i&&(s[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(a=r[e])?a:(n=A(e,e<0?-1:0,!1),i&&(r[e]=n),n)}function i(e,t){if(isNaN(e))return t?p:g;if(t){if(e<0)return p;if(e>=d)return w}else{if(e<=-0x8000000000000000)return k;if(e+1>=h)return I}return e<0?i(-e,t).neg():A(e%c|0,e/c|0,t)}function A(e,n,r){return new t(e,n,r)}t.fromInt=a,t.fromNumber=i,t.fromBits=A;var o=Math.pow;function l(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return l(e.substring(1),t,n).neg();for(var s=i(o(n,8)),a=g,A=0;A<e.length;A+=8){var u=Math.min(8,e.length-A),c=parseInt(e.substring(A,A+u),n);if(u<8){var d=i(o(n,u));a=a.mul(d).add(i(c))}else a=(a=a.mul(s)).add(i(c))}return a.unsigned=t,a}function u(e,t){return"number"==typeof e?i(e,t):"string"==typeof e?l(e,t):A(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}t.fromString=l,t.fromValue=u;var c=4294967296,d=c*c,h=d/2,f=a(1<<24),g=a(0);t.ZERO=g;var p=a(0,!0);t.UZERO=p;var m=a(1);t.ONE=m;var b=a(1,!0);t.UONE=b;var C=a(-1);t.NEG_ONE=C;var I=A(-1,2147483647,!1);t.MAX_VALUE=I;var w=A(-1,-1,!0);t.MAX_UNSIGNED_VALUE=w;var k=A(0,-2147483648,!1);t.MIN_VALUE=k;var x=t.prototype;return x.toInt=function(){return this.unsigned?this.low>>>0:this.low},x.toNumber=function(){return this.unsigned?(this.high>>>0)*c+(this.low>>>0):this.high*c+(this.low>>>0)},x.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(k)){var t=i(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=i(o(e,6),this.unsigned),a=this,A="";;){var l=a.div(s),u=(a.sub(l.mul(s)).toInt()>>>0).toString(e);if((a=l).isZero())return u+A;for(;u.length<6;)u="0"+u;A=""+u+A}},x.getHighBits=function(){return this.high},x.getHighBitsUnsigned=function(){return this.high>>>0},x.getLowBits=function(){return this.low},x.getLowBitsUnsigned=function(){return this.low>>>0},x.getNumBitsAbs=function(){if(this.isNegative())return this.eq(k)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},x.isZero=function(){return 0===this.high&&0===this.low},x.eqz=x.isZero,x.isNegative=function(){return!this.unsigned&&this.high<0},x.isPositive=function(){return this.unsigned||this.high>=0},x.isOdd=function(){return!(1&~this.low)},x.isEven=function(){return!(1&this.low)},x.equals=function(e){return n(e)||(e=u(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&(this.high===e.high&&this.low===e.low)},x.eq=x.equals,x.notEquals=function(e){return!this.eq(e)},x.neq=x.notEquals,x.ne=x.notEquals,x.lessThan=function(e){return this.comp(e)<0},x.lt=x.lessThan,x.lessThanOrEqual=function(e){return this.comp(e)<=0},x.lte=x.lessThanOrEqual,x.le=x.lessThanOrEqual,x.greaterThan=function(e){return this.comp(e)>0},x.gt=x.greaterThan,x.greaterThanOrEqual=function(e){return this.comp(e)>=0},x.gte=x.greaterThanOrEqual,x.ge=x.greaterThanOrEqual,x.compare=function(e){if(n(e)||(e=u(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},x.comp=x.compare,x.negate=function(){return!this.unsigned&&this.eq(k)?k:this.not().add(m)},x.neg=x.negate,x.add=function(e){n(e)||(e=u(e));var t=this.high>>>16,r=65535&this.high,s=this.low>>>16,a=65535&this.low,i=e.high>>>16,o=65535&e.high,l=e.low>>>16,c=0,d=0,h=0,f=0;return h+=(f+=a+(65535&e.low))>>>16,d+=(h+=s+l)>>>16,c+=(d+=r+o)>>>16,c+=t+i,A((h&=65535)<<16|(f&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},x.subtract=function(e){return n(e)||(e=u(e)),this.add(e.neg())},x.sub=x.subtract,x.multiply=function(t){if(this.isZero())return g;if(n(t)||(t=u(t)),e)return A(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return g;if(this.eq(k))return t.isOdd()?k:g;if(t.eq(k))return this.isOdd()?k:g;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(f)&&t.lt(f))return i(this.toNumber()*t.toNumber(),this.unsigned);var r=this.high>>>16,s=65535&this.high,a=this.low>>>16,o=65535&this.low,l=t.high>>>16,c=65535&t.high,d=t.low>>>16,h=65535&t.low,p=0,m=0,b=0,C=0;return b+=(C+=o*h)>>>16,m+=(b+=a*h)>>>16,b&=65535,m+=(b+=o*d)>>>16,p+=(m+=s*h)>>>16,m&=65535,p+=(m+=a*d)>>>16,m&=65535,p+=(m+=o*c)>>>16,p+=r*h+s*d+a*c+o*l,A((b&=65535)<<16|(C&=65535),(p&=65535)<<16|(m&=65535),this.unsigned)},x.mul=x.multiply,x.divide=function(t){if(n(t)||(t=u(t)),t.isZero())throw Error("division by zero");var r,s,a;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?A((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?p:g;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return p;if(t.gt(this.shru(1)))return b;a=p}else{if(this.eq(k))return t.eq(m)||t.eq(C)?k:t.eq(k)?m:(r=this.shr(1).div(t).shl(1)).eq(g)?t.isNegative()?m:C:(s=this.sub(t.mul(r)),a=r.add(s.div(t)));if(t.eq(k))return this.unsigned?p:g;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();a=g}for(s=this;s.gte(t);){r=Math.max(1,Math.floor(s.toNumber()/t.toNumber()));for(var l=Math.ceil(Math.log(r)/Math.LN2),c=l<=48?1:o(2,l-48),d=i(r),h=d.mul(t);h.isNegative()||h.gt(s);)h=(d=i(r-=c,this.unsigned)).mul(t);d.isZero()&&(d=m),a=a.add(d),s=s.sub(h)}return a},x.div=x.divide,x.modulo=function(t){return n(t)||(t=u(t)),e?A((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},x.mod=x.modulo,x.rem=x.modulo,x.not=function(){return A(~this.low,~this.high,this.unsigned)},x.and=function(e){return n(e)||(e=u(e)),A(this.low&e.low,this.high&e.high,this.unsigned)},x.or=function(e){return n(e)||(e=u(e)),A(this.low|e.low,this.high|e.high,this.unsigned)},x.xor=function(e){return n(e)||(e=u(e)),A(this.low^e.low,this.high^e.high,this.unsigned)},x.shiftLeft=function(e){return n(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?A(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):A(0,this.low<<e-32,this.unsigned)},x.shl=x.shiftLeft,x.shiftRight=function(e){return n(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?A(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):A(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},x.shr=x.shiftRight,x.shiftRightUnsigned=function(e){if(n(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?A(this.low>>>e|t<<32-e,t>>>e,this.unsigned):A(32===e?t:t>>>e-32,0,this.unsigned)},x.shru=x.shiftRightUnsigned,x.shr_u=x.shiftRightUnsigned,x.toSigned=function(){return this.unsigned?A(this.low,this.high,!1):this},x.toUnsigned=function(){return this.unsigned?this:A(this.low,this.high,!0)},x.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},x.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},x.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},t.fromBytes=function(e,n,r){return r?t.fromBytesLE(e,n):t.fromBytesBE(e,n)},t.fromBytesLE=function(e,n){return new t(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)},t.fromBytesBE=function(e,n){return new t(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)},Wb}(),Hb=Rb(Vb);const Ub=Hb||e({__proto__:null,default:Hb},[Vb]);function jb(e){return Ub.fromString(e,!0,16)}const Yb=jb("c3a5c85c97cb3127"),Kb=jb("b492b66fbe98f273"),Xb=jb("9ae16a3b2f90404f");function qb(e){return e.xor(e.shru(47))}function Zb(e,t,n){const r=e.slice(t,t+n);return Ub.fromBytes(Array.from(r),!0,!0)}function Jb(e,t){return Zb(e,t,8)}function $b(e,t){return Zb(e,t,4)}function eC(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function tC(e,t,n=jb("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function nC(e,t,n,r){return function(e,t,n,r,s,a){s=s.add(e),a=eC(a.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(n),a=a.add(eC(s,44)),[s.add(r),a.add(i)]}(Jb(e,t),Jb(e,t+8),Jb(e,t+16),Jb(e,t+24),n,r)}function rC(e,t=e.length){const n=Ub.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){const n=Xb.add(2*t),r=Jb(e,0).add(Xb),s=Jb(e,t-8);return tC(eC(s,37).mul(n).add(r),eC(r,25).add(s).mul(n),n)}if(t>=4){const n=Xb.add(2*t);return tC($b(e,0).shl(3).add(t),$b(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return qb(Xb.mul(n).xor(Yb.mul(r))).mul(Xb)}return Xb}(e,t):function(e,t=e.length){const n=Xb.add(2*t),r=Jb(e,0).mul(Kb),s=Jb(e,8),a=Jb(e,t-8).mul(n),i=Jb(e,t-16).mul(Xb);return tC(eC(r.add(s),43).add(eC(a,30)).add(i),r.add(eC(s.add(Xb),18)).add(a),n)}(e,t);if(t<=64)return function(e,t=e.length){const n=Xb.add(2*t),r=Jb(e,0).mul(Xb),s=Jb(e,8),a=Jb(e,t-8).mul(n),i=Jb(e,t-16).mul(Xb),A=eC(r.add(s),43).add(eC(a,30)).add(i),o=tC(A,r.add(eC(s.add(Xb),18)).add(a),n),l=Jb(e,16).mul(n),u=Jb(e,24),c=A.add(Jb(e,t-32)).mul(n),d=o.add(Jb(e,t-24)).mul(n);return tC(eC(l.add(u),43).add(eC(c,30)).add(d),l.add(eC(u.add(r),18)).add(c),n)}(e,t);let r=n,s=n.mul(Kb).add(113),a=qb(s.mul(Xb).add(113)).mul(Xb),i=[Ub.UZERO,Ub.UZERO],A=[Ub.UZERO,Ub.UZERO];r=r.mul(Xb).add(Jb(e,0));let o=0;const l=64*(t-1>>6),u=l+(t-1&63)-63;do{r=eC(r.add(s).add(i[0]).add(Jb(e,o+8)),37).mul(Kb),s=eC(s.add(i[1]).add(Jb(e,o+48)),42).mul(Kb),r=r.xor(A[1]),s=s.add(i[0]).add(Jb(e,o+40)),a=eC(a.add(A[0]),33).mul(Kb),i=nC(e,o,i[1].mul(Kb),r.add(A[0])),A=nC(e,o+32,a.add(A[1]),s.add(Jb(e,o+16))),[a,r]=[r,a],o+=64}while(o!==l);const c=Kb.add(a.and(255).shl(1));return o=u,A[0]=A[0].add(t-1&63),i[0]=i[0].add(A[0]),A[0]=A[0].add(i[0]),r=eC(r.add(s).add(i[0]).add(Jb(e,o+8)),37).mul(c),s=eC(s.add(i[1]).add(Jb(e,o+48)),42).mul(c),r=r.xor(A[1].mul(9)),s=s.add(i[0].mul(9).add(Jb(e,o+40))),a=eC(a.add(A[0]),33).mul(c),i=nC(e,o,i[1].mul(c),r.add(A[0])),A=nC(e,o+32,a.add(A[1]),s.add(Jb(e,o+16))),[a,r]=[r,a],tC(tC(i[0],A[0],c).add(qb(s).mul(Yb)).add(a),tC(i[1],A[1],c).add(r),c)}function sC(e,t){return"string"===t?AC(e):aC([e],t)}function aC(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=uC(e)),gg().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function iC(){return gg().platform.now()}function AC(e,t="utf-8"){return t=t||"utf-8",gg().platform.encode(e,t)}function oC(e,t="utf-8"){return t=t||"utf-8",gg().platform.decode(e,t)}function lC(e){return null!=gg().platform.isTypedArray?gg().platform.isTypedArray(e):Ob(e)}function uC(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||cg(e)||null==e||lC(e)&&n)t.push(e);else if(Array.isArray(e)||lC(e))for(let r=0;r<e.length;++r)uC(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let s=0;s<=r;s++)uC(e[s],t,n)}return t}class cC{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new hC)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let a;const i=iC();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();a=Promise.resolve({kernelMs:iC()-i})}if(gg().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<r.length;t++){const n=r[t];n.data().then((t=>{dC(t,n.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])}))}))}}function dC(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class hC{logKernelProfile(e,t,n,r,s,a){const i="number"==typeof r?_f(`${r}ms`,9):r.error,A=_f(e,25),o=t.rank,l=t.size,u=_f(t.shape.toString(),14);let c="";for(const e in s){const n=s[e];if(null!=n){const r=n.shape||t.shape,s=r.length;c+=`${e}: ${s}D ${s>0?r:""} `}}console.log(`%c${A}\t%c${i}\t%c${o}D ${u}\t%c${l}\t%c${c}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function fC(e,t,n,r){const s=ng(t),a=function(e,t,n,r){const s=Of(t),a=r[r.length-1],i=new Array(a).fill(0),A=t.length,o="complex64"===n?bC(e):e;if(A>1)for(let e=0;e<s/a;e++){const t=e*a;for(let e=0;e<a;e++)i[e]=Math.max(i[e],gC(o[t+e],0,n).length)}return i}(e,t,n,s),i=t.length,A=mC(e,t,n,s,a),o=["Tensor"];return r&&(o.push(`  dtype: ${n}`),o.push(`  rank: ${i}`),o.push(`  shape: [${t}]`),o.push("  values:")),o.push(A.map((e=>"    "+e)).join("\n")),o.join("\n")}function gC(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Zf(e)?`'${e}'`:"bool"===n?pC(e):parseFloat(e.toFixed(7)).toString(),_f(r,t)}function pC(e){return 0===e?"false":"true"}function mC(e,t,n,r,s,a=!0){const i="complex64"===n?2:1,A=t[0],o=t.length;if(0===o){if("complex64"===n){return[gC(bC(e)[0],0,n)]}return"bool"===n?[pC(e[0])]:[e[0].toString()]}if(1===o){if(A>20){const t=3*i;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((A-3)*i,A*i));return"complex64"===n&&(r=bC(r),a=bC(a)),["["+r.map(((e,t)=>gC(e,s[t],n))).join(", ")+", ..., "+a.map(((e,t)=>gC(e,s[A-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?bC(e):Array.from(e)).map(((e,t)=>gC(e,s[t],n))).join(", ")+"]"]}const l=t.slice(1),u=r.slice(1),c=r[0]*i,d=[];if(A>20){for(let t=0;t<3;t++){const r=t*c,a=r+c;d.push(...mC(e.slice(r,a),l,n,u,s,!1))}d.push("...");for(let t=A-3;t<A;t++){const r=t*c,a=r+c;d.push(...mC(e.slice(r,a),l,n,u,s,t===A-1))}}else for(let t=0;t<A;t++){const r=t*c,a=r+c;d.push(...mC(e.slice(r,a),l,n,u,s,t===A-1))}const h=2===o?",":"";d[0]="["+(A>0?d[0]+h:"");for(let e=1;e<d.length-1;e++)d[e]=" "+d[e]+h;let f=",\n";for(let e=2;e<o;e++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(a?"":f),d}function bC(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class CC{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Of(e),null!=n){const e=n.length;Pf(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Kf(t,this.size),this.strides=ng(e)}set(e,...t){0===t.length&&(t=[0]),Pf(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return IC().makeTensor(this.values,this.shape,this.dtype)}}let IC=null,wC=null;class kC{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Of(e),this.strides=ng(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return wC.buffer(this.shape,this.dtype,e)}bufferSync(){return wC.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return sg(this.shape,e,"complex64"===this.dtype)}arraySync(){return sg(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=IC().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>oC(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),IC().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=IC().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>oC(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await IC().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),IC().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return wC.print(this,e)}clone(){return this.throwIfDisposed(),wC.clone(this)}toString(e=!1){return fC(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),wC.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),IC().makeVariable(this,e,t,n)}}function xC(){return Cg("Tensor",(()=>kC))}Object.defineProperty(kC,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),xC();class yC extends kC{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Rf(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);IC().disposeTensor(this),this.dataId=e.dataId,IC().incRef(this,null)}dispose(){IC().disposeVariable(this),this.isDisposedInternal=!0}}var vC,EC,BC,MC,DC;Object.defineProperty(yC,Symbol.hasInstance,{value:e=>e instanceof kC&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(vC||(vC={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(EC||(EC={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(BC||(BC={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(MC||(MC={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(DC||(DC={}));const TC={float32:MC,int32:EC,bool:BC,complex64:DC};function SC(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return TC[e][t]}function NC(e){return SC(e,"int32")}function GC(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function FC(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function PC(e,t){if(e.dtype===t.dtype)return[e,t];const n=SC(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function QC(e){const t=[];return zC(e,t,new Set),t}function zC(e,t,n){if(null==e)return;if(e instanceof kC)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!=typeof r)return;var r;const s=e;for(const e in s){const r=s[e];n.has(r)||(n.add(r),zC(r,t,n))}}function OC(e){return null!=e.kernelName}class RC{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class LC{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new RC}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(Db(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new cC(this.backendInstance),!0}setupRegisteredKernels(){Fb(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){Fb(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof Df||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,Db(`Initialization of backend ${e} failed`),Db(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return Db(`Initialization of backend ${e} failed`),Db(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return LC.nextTensorId++}nextVariableId(){return LC.nextVariableId++}clone(e){const t=_C.runKernel(Fp,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return _C.runKernel(Vg,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=Nb(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach((e=>{s+="complex64"===e.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;let i,A;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const o=OC(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(OC(e)){const{kernelName:t,inputs:s,attrs:a}=e;null==this.backendName&&this.backend;const o=Nb(t,this.backendName);Pf(null!=o,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),i=()=>{const e=this.backend.numDataIds();A=o.kernelFunc({inputs:s,attrs:a,backend:this.backend});const i=Array.isArray(A)?A:[A];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const l=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,s,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();A=this.tidy((()=>t(this.backend,s)));const n=Array.isArray(A)?A:[A];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(o,e,n),n}}const{inputs:l,attrs:u}=e,c=OC(e)?null:e.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(o,l,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=i()})),r&&this.addTapeNode(o,l,t,c,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:o,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(A)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=Gb(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let a;r.saveAllInputs?(Pf(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),a=Object.keys(t).map((e=>t[e]))):a=e.map((e=>t[e]));const i=n.filter(((e,t)=>s[t]));return a.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;"string"===n&&Zf(e[0])&&(s=e.map((e=>AC(e))));const a=r.write(s,t,n),i=new kC(t,n,a,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:s}=e,a=new kC(r,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new yC(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*qf(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof yC||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*qf(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},A=Gb(e);null!=A&&(r=A.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=ig(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=QC(e),n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n,r=!1){if(Pf(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Pf(s instanceof kC,(()=>"The result y returned by f() must be a tensor."));const a=function(e,t,n){const r={},s={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const a=e[n],i=a.inputs;for(const e in i){const n=i[e];let A=!1;for(let e=0;e<t.length;e++)if(r[n.id]){a.outputs.forEach((e=>r[e.id]=!0)),A=!0,s[a.id]=!0;break}if(A)break}}const a={};a[n.id]=!0;const i={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(a[n.outputs[e].id]){for(const e in r)a[r[e].id]=!0,i[n.id]=!0;break}}const A=[];for(let t=0;t<e.length;t++){const n=e[t];if(s[n.id]&&i[n.id]){const e={};for(const t in n.inputs){const s=n.inputs[t];r[s.id]&&(e[t]=s)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,A.push(t)}}return A}(this.state.activeTape,t,s);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[s.id]=null==n?function(e){const t=ag(Of(e),"float32");return _C.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const A=a.gradient(i);for(const t in a.inputs){if(!(t in A))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(A)}.`);const s=n((()=>A[t]()));if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=a.inputs[t];if(!Rf(s.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}(e,a,(e=>this.tidy(e)),VC);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:s,grads:r}}))}customGrad(e){return Pf(eg(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;Pf(t.every((e=>e instanceof kC)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};t.forEach(((e,t)=>{r[t]=e}));return this.runKernelFunc({forwardFunc:(r,s)=>(n=e(...t,s),Pf(n.value instanceof kC,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Pf(eg(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,r)=>{const s=n.gradFunc(e,r),a=Array.isArray(s)?s:[s];Pf(a.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Pf(a.every((e=>e instanceof kC)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=iC(),n=await this.backend.time(e);return n.wallMs=iC()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new RC;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function WC(){const e=bg();if(null==e._tfengine){const t=new hg(e);e._tfengine=new LC(t)}var t;return t=e._tfengine.ENV,mg=t,IC=()=>e._tfengine,e._tfengine}LC.nextTensorId=0,LC.nextVariableId=0;const _C=WC();function VC(e,t){const n={a:e,b:t};return _C.runKernel(xg,n)}function HC(e){if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function UC(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const jC=gg();function YC(e,t){let n=e;if(lC(e))return"string"===t?[]:[e.length];if(GC(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(FC(e))return[e.buffer.size/(null==t?4:qf(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||lC(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&gg().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&KC(e,r,[]),r}function KC(e,t,n){if(n=n||[],!Array.isArray(e)&&!lC(e))return void Pf(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));Pf(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),Pf(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let t=0;t<e.length;++t)KC(e[t],r,n.concat(t))}function XC(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function qC(e,t,n,r="numeric"){if(e instanceof xC())return XC(r,e.dtype,t,n),e;let s=$f(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),XC(r,s,t,n),null==e||!lC(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=YC(e,s);lC(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?aC(e,s):uC(e,[],!0);return _C.makeTensor(i,a,s)}function ZC(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,s)=>qC(e,`${t}[${s}]`,n,r)))}jC.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),jC.registerFlag("IS_BROWSER",(()=>UC())),jC.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),jC.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),jC.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),jC.registerFlag("PROD",(()=>!1)),jC.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>jC.getBool("DEBUG"))),jC.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),jC.registerFlag("IS_TEST",(()=>!1)),jC.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>jC.getBool("DEBUG"))),jC.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),jC.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),jC.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function JC(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const s=(...e)=>{_C.startScope(n);try{const t=r(...e);return cg(t)&&console.error("Cannot return a Promise inside of tidy."),_C.endScope(t),t}catch(e){throw _C.endScope(null),e}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}const $C=JC({complex_:function(e,t){const n=qC(e,"real","complex"),r=qC(t,"imag","complex");Qf(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return _C.runKernel(jg,s)}});function eI(e,t,n,r){if(null==r)r=$f(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(FC(e)||GC(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return _C.backend.createTensorFromGPUData(e,t||n,r)}if(!lC(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){og(t);const e=Of(t),r=Of(n);Pf(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let e=0;e<n.length;++e){const r=n[e],s=e!==n.length-1||r!==Of(t.slice(e));Pf(n[e]===t[e]||!s,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return lC(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?aC(e,r):uC(e,[],!0),_C.makeTensor(e,t,r)}function tI(e,t,n){return eI(e,t,YC(e,n),n)}class nI{static join(e){return new nI(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>lC(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+r.byteLength;this.shards.push({buffer:r,start:t,end:s}),t=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),s=new Uint8Array(r);let a=0;for(let r=n;r<this.shards.length;r++){const n=this.shards[r],i=e+a-n.start,A=a,o=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,i,o-i);if(s.set(l,A),a+=l.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(0===a)return s;a<0?r=s:n=s+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function rI(){return _C}function sI(){return _C.memory()}function aI(e,t){return _C.tidy(e,t)}function iI(e){QC(e).forEach((e=>e.dispose()))}function AI(e){return _C.keep(e)}function oI(e,t,n=1){return _C.registerBackend(e,t,n)}async function lI(e,t){const n=[],r=[],s=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let a=0;a<s.length;++a){const i=s[a],A=Array.isArray(e)?e[a].tensor:e[i];if("float32"!==A.dtype&&"int32"!==A.dtype&&"bool"!==A.dtype&&"string"!==A.dtype&&"complex64"!==A.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${A.dtype}`);const o={name:i,shape:A.shape,dtype:A.dtype};if("string"===A.dtype){const e=new Promise((async e=>{const t=await A.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+4*t.length,r=new Uint8Array(n);let s=0;for(let e=0;e<t.length;e++){const n=t[e],a=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(a,s),s+=4,r.set(n,s),s+=n.length}e(r)}));r.push(e)}else r.push(A.data());null!=t&&(o.group=t),n.push(o)}return{data:uI(await Promise.all(r)),specs:n}}function uI(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let s=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),s),s+=e.byteLength})),r.buffer}const cI="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function dI(e){return cI?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function hI(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:dI(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:dI(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new nI(e.weightData).byteLength}}class fI{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==fI.instance&&(fI.instance=new fI),fI.instance}static registerSaveRouter(e){fI.getInstance().saveRouters.push(e)}static registerLoadRouter(e){fI.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return fI.getHandlers(e,"save")}static getLoadHandlers(e,t){return fI.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?fI.getInstance().loadRouters:fI.getInstance().saveRouters).forEach((t=>{const s=t(e,n);null!==s&&r.push(s)})),r}}const gI="tensorflowjs",pI="models_store",mI="model_info_store";function bI(){if(!gg().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function CI(e){const t=e.result;t.createObjectStore(pI,{keyPath:"modelPath"}),t.createObjectStore(mI,{keyPath:"modelPath"})}class II{constructor(e){if(this.indexedDB=bI(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(gI,1);r.onupgradeneeded=()=>CI(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(pI,"readonly"),r=t.objectStore(pI).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{t.weightData=nI.join(t.weightData);const r=hI(t),a=s.transaction(mI,"readwrite");let i,A,o=a.objectStore(mI);try{i=o.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(e){return n(e)}i.onsuccess=()=>{A=s.transaction(pI,"readwrite");const i=A.objectStore(pI);let l;try{l=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(e){return n(e)}l.onsuccess=()=>e({modelArtifactsInfo:r}),l.onerror=e=>{o=a.objectStore(mI);const t=o.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(l.error)),t.onerror=e=>(s.close(),n(l.error))}},i.onerror=e=>(s.close(),n(i.error)),a.oncomplete=()=>{null==A?s.close():A.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)}))}}II.URL_SCHEME="indexeddb://";const wI=e=>{return gg().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(II.URL_SCHEME)?(t=e.slice(II.URL_SCHEME.length),new II(t)):null;var t};fI.registerSaveRouter(wI),fI.registerLoadRouter(wI);class kI{constructor(){this.indexedDB=bI()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(gI,1);n.onupgradeneeded=()=>CI(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(mI,"readonly"),a=s.objectStore(mI).getAll();a.onsuccess=()=>{const t={};for(const e of a.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},a.onerror=e=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(II.URL_SCHEME)?t.slice(II.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(gI,1);r.onupgradeneeded=()=>CI(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(mI,"readwrite"),i=a.objectStore(mI),A=i.get(e);let o;A.onsuccess=()=>{if(null==A.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),a=()=>{o=s.transaction(pI,"readwrite");const r=o.objectStore(pI).delete(e);r.onsuccess=()=>t(A.result.modelArtifactsInfo),r.onerror=e=>n(A.error)};r.onsuccess=a,r.onerror=e=>(a(),s.close(),n(A.error))}},A.onerror=e=>(s.close(),n(A.error)),a.oncomplete=()=>{null==o?s.close():o.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}}const xI="/",yI="tensorflowjs_models",vI="info",EI="model_topology",BI="weight_specs",MI="weight_data",DI="model_metadata";function TI(e){return{info:[yI,e,vI].join(xI),topology:[yI,e,EI].join(xI),weightSpecs:[yI,e,BI].join(xI),weightData:[yI,e,MI].join(xI),modelMetadata:[yI,e,DI].join(xI)}}function SI(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function NI(e){const t=e.split(xI);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(xI)}class GI{constructor(e){if(!gg().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=TI(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=hI(e),s=nI.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(cI)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}(s));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch(e){throw SI(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(cI){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}(a),t}}GI.URL_SCHEME="localstorage://";const FI=e=>{return gg().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(GI.URL_SCHEME)?(t=e.slice(GI.URL_SCHEME.length),new GI(t)):null;var t};fI.registerSaveRouter(FI),fI.registerLoadRouter(FI);class PI{constructor(){Pf(gg().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Pf("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=yI+xI,n=xI+vI;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){e[NI(s)]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){var t;const n=TI(e=(t=e).startsWith(GI.URL_SCHEME)?t.slice(GI.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return SI(n),r}}class QI{constructor(){this.managers={}}static getInstance(){return null==QI.instance&&(QI.instance=new QI),QI.instance}static registerManager(e,t){Pf(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),Pf(e.length>0,(()=>"scheme must not be an empty string."));const n=QI.getInstance();Pf(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=QI.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(QI.getInstance().managers)}}class zI{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&gg().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return Ob(e)}}if(gg().get("IS_BROWSER")){gg().setPlatform("browser",new zI);try{QI.registerManager(GI.URL_SCHEME,new PI)}catch(e){}try{QI.registerManager(II.URL_SCHEME,new kI)}catch(e){}}const OI=()=>require("node-fetch");let RI;class LI{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=gg().global.fetch?gg().global.fetch(e,t):(null==RI&&(RI=OI()),RI(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function WI(e,t="float32",n){return t=t||"float32",og(e),new CC(e,t,n)}gg().get("IS_NODE")&&!gg().get("IS_BROWSER")&&gg().setPlatform("node",new LI);const _I=JC({cast_:function(e,t){const n=qC(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return _C.runKernel(Vg,r,s)}});const VI=JC({clone_:function(e){const t={x:qC(e,"x","clone","string_or_numeric")};return _C.runKernel(Fp,t)}});WC();const HI={buffer:WI,cast:_I,clone:VI,print:function(e,t=!1){console.log(e.toString(t))}};wC=HI;const UI=JC({add_:function(e,t){let n=qC(e,"a","add"),r=qC(t,"b","add");[n,r]=PC(n,r);const s={a:n,b:r};return _C.runKernel(xg,s)}});const jI=JC({floorDiv_:function(e,t){let n=qC(e,"a","floorDiv"),r=qC(t,"b","floorDiv");[n,r]=PC(n,r);const s={a:n,b:r};return _C.runKernel(Mp,s)}});const YI=JC({div_:function(e,t){let n=qC(e,"a","div"),r=qC(t,"b","div");if([n,r]=PC(n,r),"int32"===n.dtype&&"int32"===r.dtype)return jI(n,r);const s={a:n,b:r};return _C.runKernel(gp,s,{})}});const KI=JC({mul_:function(e,t){let n=qC(e,"a","mul"),r=qC(t,"b","mul");[n,r]=PC(n,r);const s={a:n,b:r};return _C.runKernel(um,s)}});const XI=JC({abs_:function(e){const t=qC(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return _C.runKernel(Yg,e)}{const e={x:t};return _C.runKernel(Ig,e)}}});const qI=JC({acos_:function(e){const t={x:qC(e,"x","acos")};return _C.runKernel(wg,t)}});const ZI=JC({acosh_:function(e){const t={x:qC(e,"x","acosh")};return _C.runKernel(kg,t)}});const JI=JC({all_:function(e,t=null,n=!1){const r={x:qC(e,"x","all","bool")},s={axis:t,keepDims:n};return _C.runKernel(vg,r,s)}});const $I=JC({any_:function(e,t=null,n=!1){const r={x:qC(e,"x","any","bool")},s={axis:t,keepDims:n};return _C.runKernel(Eg,r,s)}});const ew=JC({argMax_:function(e,t=0){const n={x:qC(e,"x","argMax")},r={axis:t};return _C.runKernel(Bg,n,r)}});const tw=JC({argMin_:function(e,t=0){const n={x:qC(e,"x","argMin")},r={axis:t};return _C.runKernel(Mg,n,r)}});const nw=JC({asin_:function(e){const t={x:qC(e,"x","asin")};return _C.runKernel(Dg,t)}});const rw=JC({asinh_:function(e){const t={x:qC(e,"x","asinh")};return _C.runKernel(Tg,t)}});const sw=JC({atan_:function(e){const t={x:qC(e,"x","atan")};return _C.runKernel(Sg,t)}});const aw=JC({atan2_:function(e,t){let n=qC(e,"a","atan2"),r=qC(t,"b","atan2");[n,r]=PC(n,r);const s={a:n,b:r};return _C.runKernel(Gg,s)}});const iw=JC({atanh_:function(e){const t={x:qC(e,"x","atanh")};return _C.runKernel(Ng,t)}});function Aw(e,t,n,r,s="NHWC",a){return uw(e,[...t,e[3]],n,a,r,null,null,Iw(s))}function ow(e,t,n,r,s,a,i="channelsLast"){const[A,o]=hw(t);let l;if("channelsLast"===i)l=[A,o,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);l=[A,o,e[1],e[1]]}return uw(e,l,n,r,s,a,!1,i)}function lw(e,t,n,r,s,a,i="NDHWC"){const[A,o,l]=fw(t);let u,c;if("NDHWC"===i)c="channelsLast",u=[A,o,l,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);c="channelsFirst",u=[A,o,l,e[1],e[1]]}return cw(e,u,n,r,s,!1,c,a)}function uw(e,t,n,r,s,a,i=!1,A="channelsLast"){let[o,l,u,c]=[-1,-1,-1,-1];if("channelsLast"===A)[o,l,u,c]=e;else{if("channelsFirst"!==A)throw new Error(`Unknown dataFormat ${A}`);[o,c,l,u]=e}const[d,h,,f]=t,[g,p]=hw(n),[m,b]=hw(r),C=gw(d,m),I=gw(h,b),{padInfo:w,outHeight:k,outWidth:x}=function(e,t,n,r,s,a,i,A,o){let l,u,c;if("number"==typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=dw(e,t,n));const a=e[0],i=e[1],A=pw((a-t+2*r)/n+1,s),o=pw((i-t+2*r)/n+1,s);return[A,o]}([t,n],a,r,e,A);u=s[0],c=s[1]}else if("same"===e){u=Math.ceil(t/r),c=Math.ceil(n/s);const e=Math.max(0,(u-1)*r+a-t),A=Math.max(0,(c-1)*s+i-n),o=Math.floor(e/2),d=e-o,h=Math.floor(A/2);l={top:o,bottom:d,left:h,right:A-h,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-a+1)/r),c=Math.ceil((n-i+1)/s);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const d="channelsLast"===o?e[1][0]:e[2][0],h="channelsLast"===o?e[1][1]:e[2][1],f="channelsLast"===o?e[2][0]:e[3][0],g="channelsLast"===o?e[2][1]:e[3][1];l={top:d,bottom:h,left:f,right:g,type:0===d&&0===h&&0===f&&0===g?"VALID":"EXPLICIT"},u=pw((t-a+d+h)/r+1,A),c=pw((n-i+f+g)/s+1,A)}}return{padInfo:l,outHeight:u,outWidth:c}}(s,l,u,g,p,C,I,a,A),y=i?f*c:f;let v;return"channelsFirst"===A?v=[o,y,k,x]:"channelsLast"===A&&(v=[o,k,x,y]),{batchSize:o,dataFormat:A,inHeight:l,inWidth:u,inChannels:c,outHeight:k,outWidth:x,outChannels:y,padInfo:w,strideHeight:g,strideWidth:p,filterHeight:d,filterWidth:h,effectiveFilterHeight:C,effectiveFilterWidth:I,dilationHeight:m,dilationWidth:b,inShape:e,outShape:v,filterShape:t}}function cw(e,t,n,r,s,a=!1,i="channelsLast",A){let[o,l,u,c,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[o,l,u,c,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[o,d,l,u,c]=e}const[h,f,g,,p]=t,[m,b,C]=fw(n),[I,w,k]=fw(r),x=gw(h,I),y=gw(f,w),v=gw(g,k),{padInfo:E,outDepth:B,outHeight:M,outWidth:D}=function(e,t,n,r,s,a,i,A,o,l,u){let c,d,h,f;"valid"===e&&(e=0);if("number"==typeof e){c={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const g=function(e,t,n,r,s,a){null==s&&(s=dw(e,t[0],r[0]));const i=[0,0,0,n];for(let n=0;n<3;n++)e[n]+2*s>=t[n]&&(i[n]=pw((e[n]-t[n]+2*s)/r[n]+1,a));return i}([t,n,r,1],[A,o,l],1,[s,a,i],e,u);d=g[0],h=g[1],f=g[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{d=Math.ceil(t/s),h=Math.ceil(n/a),f=Math.ceil(r/i);const e=(d-1)*s+A-t,u=(h-1)*a+o-n,g=(f-1)*i+l-r,p=Math.floor(e/2),m=e-p,b=Math.floor(u/2),C=u-b,I=Math.floor(g/2);c={top:b,bottom:C,left:I,right:g-I,front:p,back:m,type:"SAME"}}}return{padInfo:c,outDepth:d,outHeight:h,outWidth:f}}(s,l,u,c,m,b,C,x,y,v,A),T=a?p*d:p;let S;return"channelsFirst"===i?S=[o,T,B,M,D]:"channelsLast"===i&&(S=[o,B,M,D,T]),{batchSize:o,dataFormat:i,inDepth:l,inHeight:u,inWidth:c,inChannels:d,outDepth:B,outHeight:M,outWidth:D,outChannels:T,padInfo:E,strideDepth:m,strideHeight:b,strideWidth:C,filterDepth:h,filterHeight:f,filterWidth:g,effectiveFilterDepth:x,effectiveFilterHeight:y,effectiveFilterWidth:v,dilationDepth:I,dilationHeight:w,dilationWidth:k,inShape:e,outShape:S,filterShape:t}}function dw(e,t,n,r=1){const s=gw(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function hw(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function fw(e){return"number"==typeof e?[e,e,e]:e}function gw(e,t){return t<=1?e:e+(e-1)*(t-1)}function pw(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function mw(e){const[t,n,r]=hw(e);return 1===t&&1===n&&1===r}function bw(e,t){return mw(e)||mw(t)}function Cw(e){return hw(e).every((e=>e>0))}function Iw(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function ww(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)Pf(Lf(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{Pf(Lf(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}const kw=JC({reshape_:function(e,t){const n={x:qC(e,"x","reshape","string_or_numeric")},r={shape:t};return _C.runKernel(Tm,n,r)}});const xw=JC({avgPool_:function(e,t,n,r,s){const a=qC(e,"x","avgPool","float32");Pf(bw(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=a,A=!1;3===a.rank&&(A=!0,i=kw(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Pf(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),ww("avgPool",r,s);const o={x:i},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let u=_C.runKernel(Fg,o,l);return u=_I(u,a.dtype),A?kw(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const yw=JC({avgPool3d_:function(e,t,n,r,s,a="NDHWC"){const i=qC(e,"x","avgPool3d","float32");let A=i,o=!1;4===i.rank&&(o=!0,A=kw(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Pf(5===A.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${A.rank}.`)),Pf("NDHWC"===a,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),Pf("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),ww("avgPool3d",r,s);const l={x:A},u={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let c=_C.runKernel(Qg,l,u);return c=_I(c,A.dtype),o?kw(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}});const vw=JC({concat_:function(e,t=0){Pf(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=ZC(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return VI(n[0]);const r=n,s={axis:t};return _C.runKernel(Kg,r,s)}});const Ew=JC({matMul_:function(e,t,n=!1,r=!1){let s=qC(e,"a","matMul"),a=qC(t,"b","matMul");[s,a]=PC(s,a);const i={a:s,b:a},A={transposeA:n,transposeB:r};return _C.runKernel(Og,i,A)}});const Bw=JC({sigmoid_:function(e){const t={x:qC(e,"x","sigmoid","float32")};return _C.runKernel(Km,t)}});const Mw=JC({slice_:function(e,t,n){const r=qC(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return _C.runKernel(Hm,s,a)}});const Dw=JC({tanh_:function(e){const t={x:qC(e,"x","tanh","float32")};return _C.runKernel(gb,t)}});const Tw=JC({batchToSpaceND_:function(e,t,n){const r=qC(e,"x","batchToSpaceND"),s=t.reduce(((e,t)=>e*t));Pf(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),Pf(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),Pf(r.shape[0]%s===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`));const a={x:r},i={blockShape:t,crops:n};return _C.runKernel(Rg,a,i)}});const Sw=JC({batchNorm_:function(e,t,n,r,s,a){null==a&&(a=.001);const i=qC(e,"x","batchNorm"),A=qC(t,"mean","batchNorm"),o=qC(n,"variance","batchNorm");let l,u;null!=s&&(l=qC(s,"scale","batchNorm")),null!=r&&(u=qC(r,"offset","batchNorm")),Pf(A.rank===o.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Pf(null==u||A.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Pf(null==l||A.rank===l.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const c=function(e){let t;return t=0===e.rank||1===e.rank?kw(e,[1,1,1,e.size]):2===e.rank?kw(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?kw(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),d={x:c,scale:l,offset:u,mean:A,variance:o},h={varianceEpsilon:a},f=_C.runKernel(Dp,d,h);return kw(f,i.shape)}});const Nw=JC({batchNorm2d_:function(e,t,n,r,s,a){const i=qC(e,"x","batchNorm"),A=qC(t,"mean","batchNorm"),o=qC(n,"variance","batchNorm");let l,u;return null!=s&&(l=qC(s,"scale","batchNorm")),null!=r&&(u=qC(r,"offset","batchNorm")),Pf(2===i.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),Pf(2===A.rank||1===A.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${A.rank}.`)),Pf(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${o.rank}.`)),null!=l&&Pf(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&Pf(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`)),Sw(i,A,o,u,l,a)}});const Gw=JC({batchNorm3d_:function(e,t,n,r,s,a){const i=qC(e,"x","batchNorm"),A=qC(t,"mean","batchNorm"),o=qC(n,"variance","batchNorm");let l,u;return null!=s&&(l=qC(s,"scale","batchNorm")),null!=r&&(u=qC(r,"offset","batchNorm")),Pf(3===i.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),Pf(3===A.rank||1===A.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${A.rank}.`)),Pf(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${o.rank}.`)),null!=l&&Pf(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&Pf(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`)),Sw(i,A,o,u,l,a)}});const Fw=JC({batchNorm4d_:function(e,t,n,r,s,a){const i=qC(e,"x","batchNorm"),A=qC(t,"mean","batchNorm"),o=qC(n,"variance","batchNorm");let l,u;return null!=s&&(l=qC(s,"scale","batchNorm")),null!=r&&(u=qC(r,"offset","batchNorm")),Pf(4===i.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),Pf(4===A.rank||1===A.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${A.rank}.`)),Pf(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${o.rank}.`)),null!=l&&Pf(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&Pf(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`)),Sw(i,A,o,u,l,a)}});const Pw=JC({bincount_:function(e,t,n){const r=qC(e,"x","bincount"),s=qC(t,"weights","bincount");Pf("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),Pf(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Pf(s.size===r.size||0===s.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`));const a={x:r,weights:s},i={size:n};return _C.runKernel(Lg,a,i)}});const Qw=JC({broadcastTo_:function(e,t){let n=qC(e,"broadcastTo","x");const r=n.shape;if(og(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=kw(n,e)}const s=n.shape,a=Array.from(t);for(let e=t.length-1;e>=0;e--)if(s[e]===t[e])a[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);const i=a.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0));if(0===i.length)return VI(n);const A={x:n},o={reps:a};return _C.runKernel(pb,A,o)}});const zw=JC({ceil_:function(e){const t={x:qC(e,"x","ceil","float32")};return _C.runKernel(Hg,t)}});function Ow(e,t,n){og(e);const r={shape:e,value:t,dtype:n=n||$f(t)};return _C.runKernel(vp,{},r)}const Rw=JC({clipByValue_:function(e,t,n){const r=qC(e,"x","clipByValue");if(Pf(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return Ow(r.shape,t,r.dtype);const s={x:r},a={clipValueMin:t,clipValueMax:n};return _C.runKernel(Ug,s,a)}});const Lw=JC({concat1d_:function(e){return vw(e,0)}});const Ww=JC({concat2d_:function(e,t){return vw(e,t)}});const _w=JC({concat3d_:function(e,t){return vw(e,t)}});const Vw=JC({concat4d_:function(e,t){return vw(e,t)}});const Hw=JC({conv2d_:function(e,t,n,r,s="NHWC",a=[1,1],i){const A=qC(e,"x","conv2d","float32"),o=qC(t,"filter","conv2d","float32");let l=A,u=!1;3===A.rank&&(u=!0,l=kw(A,[1,A.shape[0],A.shape[1],A.shape[2]])),Pf(4===l.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`)),Pf(4===o.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${o.rank}.`)),ww("conv2d",r,i);const c="NHWC"===s?l.shape[3]:l.shape[1];Pf(c===o.shape[2],(()=>`Error in conv2d: depth of input (${c}) must match input depth for filter ${o.shape[2]}.`)),Pf(bw(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),Pf(Cw(a),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Pf(Cw(n),(()=>"Error in conv2D: Strides should be larger than 0."));const d={x:l,filter:o},h={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=_C.runKernel(Xg,d,h);return u?kw(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Uw=JC({conv1d_:function(e,t,n,r,s="NWC",a=1,i){const A=qC(e,"x","conv1d"),o=qC(t,"filter","conv1d");let l=A,u=!1;2===A.rank&&(u=!0,l=kw(A,[1,A.shape[0],A.shape[1]])),Pf(3===l.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`)),Pf(3===o.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${o.rank}.`)),ww("conv1d",r,i),Pf(l.shape[2]===o.shape[1],(()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${o.shape[1]}.`)),Pf(bw(n,a),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`)),Pf(Cw(a),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Pf(Cw(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Pf("NWC"===s,(()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`));const c=kw(o,[1,o.shape[0],o.shape[1],o.shape[2]]),d=kw(l,[l.shape[0],1,l.shape[1],l.shape[2]]),h=Hw(d,c,[1,n],r,"NHWC",[1,a],i);return kw(h,u?[h.shape[2],h.shape[3]]:[h.shape[0],h.shape[2],h.shape[3]])}});const jw=JC({conv2DBackpropInput_:function(e,t,n,r,s,a="NHWC",i){Pf(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let A=e,o=t,l=!1;3===t.rank&&(l=!0,o=kw(t,[1,t.shape[0],t.shape[1],t.shape[2]]),A=[1,e[0],e[1],e[2]]),Pf(4===A.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${A.length}.`)),Pf(4===o.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${o.rank}`)),Pf(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const u="NHWC"===a?A[3]:A[1],c="NHWC"===a?o.shape[3]:o.shape[1];Pf(u===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`)),Pf(c===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[3]}.`)),ww("conv2dDerInput",s,i);const d={dy:o,filter:n},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:A},f=_C.runKernel(Zg,d,h);return l?kw(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Yw=JC({conv2dTranspose_:function(e,t,n,r,s,a){const i=qC(e,"x","conv2dTranspose"),A=qC(t,"filter","conv2dTranspose");return jw(n,i,A,r,s,"NHWC",a)}});const Kw=JC({conv3d_:function(e,t,n,r,s="NDHWC",a=[1,1,1]){const i=qC(e,"x","conv3d"),A=qC(t,"filter","conv3d");let o=i,l=!1;4===i.rank&&(l=!0,o=kw(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Pf(5===o.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${o.rank}.`)),Pf(5===A.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${A.rank}.`)),Pf(o.shape[4]===A.shape[3],(()=>`Error in conv3d: depth of input (${o.shape[4]}) must match input depth for filter ${A.shape[3]}.`)),Pf(bw(n,a),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),Pf("NDHWC"===s,(()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`)),Pf(Cw(a),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Pf(Cw(n),(()=>"Error in conv3D: Strides should be larger than 0."));const u={x:o,filter:A},c={strides:n,pad:r,dataFormat:s,dilations:a},d=_C.runKernel(Jg,u,c);return l?kw(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Xw=JC({conv3DBackpropInput_:function(e,t,n,r,s){Pf(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let a=e,i=t,A=!1;4===t.rank&&(A=!0,i=kw(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const o=a[4],l=i.shape[4];Pf(5===a.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`)),Pf(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),Pf(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),Pf(o===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${o}) must match input depth for filter ${n.shape[3]}.`)),Pf(l===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`));const u={dy:i,filter:n},c={pad:s,strides:r,inputShape:a},d=_C.runKernel(ep,u,c);return A?kw(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const qw=JC({conv3dTranspose_:function(e,t,n,r,s){const a=qC(e,"x","conv3dTranspose"),i=qC(t,"filter","conv3dTranspose");return Xw(n,a,i,r,s)}});const Zw=JC({cos_:function(e){const t={x:qC(e,"x","cos","float32")};return _C.runKernel(tp,t)}});const Jw=JC({cosh_:function(e){const t={x:qC(e,"x","cosh","float32")};return _C.runKernel(np,t)}});const $w=JC({cumprod_:function(e,t=0,n=!1,r=!1){const s={x:qC(e,"x","cumprod")},a={axis:t,exclusive:n,reverse:r};return _C.runKernel(rp,s,a)}});const ek=JC({cumsum_:function(e,t=0,n=!1,r=!1){const s={x:qC(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return _C.runKernel(sp,s,a)}});const tk=JC({denseBincount_:function(e,t,n,r=!1){const s=qC(e,"x","denseBincount"),a=qC(t,"weights","denseBincount");Pf("int32"===s.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`)),Pf(s.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`)),Pf(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Pf(a.size===s.size||0===a.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`));const i={x:s,weights:a},A={size:n,binaryOutput:r};return _C.runKernel(ip,i,A)}});const nk=JC({depthToSpace_:function(e,t,n="NHWC"){const r=qC(e,"x","depthToSpace","float32"),s="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];Pf(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),Pf(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),Pf(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),Pf(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));const A={x:r},o={blockSize:t,dataFormat:n};return _C.runKernel(Ap,A,o)}});const rk=JC({depthwiseConv2d_:function(e,t,n,r,s="NHWC",a=[1,1],i){const A=qC(e,"x","depthwiseConv2d","float32"),o=qC(t,"filter","depthwiseConv2d","float32");let l=A,u=!1;3===A.rank&&(u=!0,l=kw(A,[1,A.shape[0],A.shape[1],A.shape[2]])),Pf(4===l.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`)),Pf(4===o.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${o.rank}.`));const c="NHWC"===s?l.shape[3]:l.shape[1];Pf(c===o.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${c}) must match the inChannels dimension in filter ${o.shape[2]}.`)),ww("depthwiseConv2d",r,i);const d={x:l,filter:o},h={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=_C.runKernel(op,d,h);return u?kw(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const sk=JC({dilation2d_:function(e,t,n,r,s=[1,1],a="NHWC"){const i=qC(e,"x","dilation2d"),A=qC(t,"filter","dilation2d");Pf(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),Pf(3===A.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${A.rank}.`)),Pf("NHWC"===a,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`));let o=i,l=!1;3===i.rank&&(o=kw(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),Pf(o.shape[3]===A.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${o.shape[3]} vs ${A.shape[2]}`));const u={x:o,filter:A},c={strides:n,pad:r,dilations:s},d=_C.runKernel(dp,u,c);return l?kw(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});function ak(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}function ik(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(null==s||1===s&&i>1)&&n.unshift(a)}return n}function Ak(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];null==a&&(a=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===a)r[n-s-1]=i;else if(1===i)r[n-s-1]=a;else{if(a!==i){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-s-1]=a}}return r}const ok=JC({equal_:function(e,t){let n=qC(e,"a","equal","string_or_numeric"),r=qC(t,"b","equal","string_or_numeric");[n,r]=PC(n,r),Ak(n.shape,r.shape);const s={a:n,b:r};return _C.runKernel(Ip,s)}});const lk=JC({where_:function(e,t,n){const r=qC(t,"a","where"),s=qC(n,"b","where"),a=qC(e,"condition","where","bool"),i=Ak(Ak(a.shape,r.shape),s.shape),A={condition:Qw(a,i),t:Qw(r,i),e:Qw(s,i)};return _C.runKernel(_m,A)}});const uk=JC({zerosLike_:function(e){const t={x:qC(e,"x","zerosLike")};return _C.runKernel(xb,t)}});const ck=JC({divNoNan_:function(e,t){let n=qC(e,"a","div"),r=qC(t,"b","div");[n,r]=PC(n,r);const s=YI(n,r),a=uk(s),i=ok(r,a);return lk(i,a,s)}});const dk=JC({dot_:function(e,t){const n=qC(e,"t1","dot"),r=qC(t,"t2","dot");Pf(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const s=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];if(Pf(s===a,(()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`)),1===n.rank&&1===r.rank){const e=kw(n,[1,-1]),t=kw(r,[-1,1]),s=Ew(e,t);return kw(s,[])}if(1===n.rank&&2===r.rank){const e=kw(n,[1,-1]),t=kw(r,[r.shape[0],r.shape[1]]),s=Ew(e,t);return kw(s,[s.size])}if(2===n.rank&&1===r.rank){const e=kw(r,[-1,1]),t=Ew(n,e);return kw(t,[t.size])}{const e=kw(r,[r.shape[0],r.shape[1]]);return Ew(n,e)}}});const hk=JC({einsum_:function(e,...t){const n=t.map(((e,t)=>qC(e,`tensors${t}`,"einsum"))),r={equation:e};return _C.runKernel(pp,n,r)}});const fk=JC({elu_:function(e){const t={x:qC(e,"x","elu","float32")};return _C.runKernel(mp,t)}});const gk=JC({erf_:function(e){let t=qC(e,"x","erf");Pf("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=_I(t,"float32"));const n={x:t};return _C.runKernel(Cp,n)}});function pk(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function mk(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let A=0;A<r;A++)-1===n.indexOf(A)?s.push(e[a++]):s.push(t[i++]);return s}function bk(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map((t=>e[t]))]}function Ck(e,t){return mk(e,t.map((e=>1)),t)}function Ik(e,t,n){Pf(pk(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function wk(e,t){if(pk(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function kk(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function xk(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const yk=JC({max_:function(e,t=null,n=!1){const r={x:qC(e,"x","max")},s={reductionIndices:t,keepDims:n};return _C.runKernel(Zp,r,s)}});const vk=JC({min_:function(e,t=null,n=!1){const r={x:qC(e,"x","min")},s={axis:t,keepDims:n};return _C.runKernel(am,r,s)}});const Ek=JC({pow_:function(e,t){let n=qC(e,"base","pow"),r=qC(t,"exp","pow");[n,r]=PC(n,r);const s={a:n,b:r};return _C.runKernel(Im,s)}});function Bk(e,t){if((lC(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&lC(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return eI(e,[],[],t)}const Mk=JC({sqrt_:function(e){const t={x:qC(e,"x","sqrt","float32")};return _C.runKernel(qm,t)}});const Dk=JC({square_:function(e){const t=qC(e,"x","square");return _C.runKernel("Square",{x:t},{})}});const Tk=JC({sum_:function(e,t=null,n=!1){let r=qC(e,"x","sum");"bool"===r.dtype&&(r=_I(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return _C.runKernel(Zm,s,a)}});function Sk(e,t,n=null){if(0===e.rank)return XI(e);if(1!==e.rank&&null===n)return Sk(kw(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Tk(XI(e),n);if(t===1/0)return yk(XI(e),n);if(t===-1/0)return vk(XI(e),n);if("euclidean"===t||2===t)return Mk(Tk(Ek(XI(e),Bk(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return yk(Tk(XI(e),n[0]),n[1]-1);if(t===1/0)return yk(Tk(XI(e),n[1]),n[0]);if(t===-1/0)return vk(Tk(XI(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Mk(Tk(Dk(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Nk=JC({norm_:function(e,t="euclidean",n=null,r=!1){const s=Sk(e=qC(e,"x","norm"),t,n);let a=s.shape;if(r){const t=Uf(n,e.shape);a=Ck(s.shape,t)}return kw(s,a)}});const Gk=JC({euclideanNorm_:function(e,t=null,n=!1){return Nk(e,"euclidean",t,n)}});const Fk=JC({exp_:function(e){const t={x:qC(e,"x","exp")};return _C.runKernel(wp,t)}});const Pk=JC({expandDims_:function(e,t=0){const n=qC(e,"x","expandDims","string_or_numeric");Pf(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},s={dim:t};return _C.runKernel(kp,r,s)}});const Qk=JC({expm1_:function(e){const t={x:qC(e,"x","expm1")};return _C.runKernel(xp,t)}});const zk=JC({tile_:function(e,t){const n=qC(e,"x","tile","string_or_numeric");Pf(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},s={reps:t};return _C.runKernel(pb,r,s)}});const Ok=JC({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const s=WI([e,t],r),a=e<=t?e:t;for(let e=0;e<a;++e)s.set(1,e,e);const i=kw(s.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return zk(Pk(i,0),[n[0],1,1]);if(2===n.length)return zk(Pk(Pk(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return zk(Pk(Pk(Pk(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});const Rk=JC({floor_:function(e){const t={x:qC(e,"x","floor","float32")};return _C.runKernel(Bp,t)}});const Lk=JC({gather_:function(e,t,n=0,r=0){const s={x:qC(e,"x","gather"),indices:qC(t,"indices","gather","int32")},a={axis:n,batchDims:r};return _C.runKernel(Tp,s,a)}});const Wk=JC({greater_:function(e,t){let n=qC(e,"a","greater","string_or_numeric"),r=qC(t,"b","greater","string_or_numeric");[n,r]=PC(n,r),Ak(n.shape,r.shape);const s={a:n,b:r};return _C.runKernel(Np,s)}});const _k=JC({greaterEqual_:function(e,t){let n=qC(e,"a","greaterEqual","string_or_numeric"),r=qC(t,"b","greaterEqual","string_or_numeric");[n,r]=PC(n,r),Ak(n.shape,r.shape);const s={a:n,b:r};return _C.runKernel(Gp,s)}});const Vk=JC({imag_:function(e){const t={input:qC(e,"input","imag")};return _C.runKernel(Qp,t)}});const Hk=JC({isFinite_:function(e){const t={x:qC(e,"x","isFinite")};return _C.runKernel(zp,t)}});const Uk=JC({isInf_:function(e){const t={x:qC(e,"x","isInf")};return _C.runKernel(Op,t)}});const jk=JC({isNaN_:function(e){const t={x:qC(e,"x","isNaN")};return _C.runKernel(Rp,t)}});const Yk=JC({leakyRelu_:function(e,t=.2){const n={x:qC(e,"x","leakyRelu")},r={alpha:t};return _C.runKernel(Lp,n,r)}});const Kk=JC({less_:function(e,t){let n=qC(e,"a","less","string_or_numeric"),r=qC(t,"b","less","string_or_numeric");[n,r]=PC(n,r),Ak(n.shape,r.shape);const s={a:n,b:r};return _C.runKernel(Wp,s)}});const Xk=JC({lessEqual_:function(e,t){let n=qC(e,"a","lessEqual","string_or_numeric"),r=qC(t,"b","lessEqual","string_or_numeric");[n,r]=PC(n,r),Ak(n.shape,r.shape);const s={a:n,b:r};return _C.runKernel(_p,s)}});const qk=JC({localResponseNormalization_:function(e,t=5,n=1,r=1,s=.5){const a=qC(e,"x","localResponseNormalization");Pf(4===a.rank||3===a.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`)),Pf(Lf(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=a,A=!1;3===a.rank&&(A=!0,i=kw(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const o={x:i},l={depthRadius:t,bias:n,alpha:r,beta:s},u=_C.runKernel(Xp,o,l);return A?kw(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Zk=JC({log_:function(e){const t={x:qC(e,"x","log","float32")};return _C.runKernel(Hp,t)}});const Jk=JC({log1p_:function(e){const t={x:qC(e,"x","log1p")};return _C.runKernel(Up,t)}});function $k(e){return _C.customGrad(e)}const ex=JC({neg_:function(e){const t={x:qC(e,"x","neg")};return _C.runKernel(cm,t)}});const tx=JC({softplus_:function(e){const t={x:qC(e,"x","softplus")};return _C.runKernel(Xm,t)}});const nx=JC({logSigmoid_:function(e){const t=qC(e,"x","logSigmoid"),n=$k((e=>({value:ex(tx(ex(e))),gradFunc:t=>KI(t,Bw(ex(e)))})));return n(t)}});const rx=JC({sub_:function(e,t){let n=qC(e,"a","sub"),r=qC(t,"b","sub");[n,r]=PC(n,r);const s={a:n,b:r};return _C.runKernel(hb,s)}});const sx=JC({logSoftmax_:function(e,t=-1){const n=qC(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const r=$k(((e,n)=>{const r=yk(e,t,!0),s=rx(e,r),a=rx(_I(s,"float32"),Zk(Tk(Fk(s),t,!0)));n([a]);return{value:a,gradFunc:(e,n)=>{const[r]=n,s=Fk(r);return rx(e,KI(Tk(e,t,!0),s))}}}));return r(n)}});const ax=JC({logSumExp_:function(e,t=null,n=!1){const r=qC(e,"x","logSumExp"),s=Uf(t,r.shape),a=yk(r,s,!0),i=rx(r,a),A=Fk(i),o=Tk(A,s),l=Zk(o),u=UI(kw(a,l.shape),l);if(n){const e=Ck(u.shape,s);return kw(u,e)}return u}});const ix=JC({logicalAnd_:function(e,t){const n=qC(e,"a","logicalAnd","bool"),r=qC(t,"b","logicalAnd","bool");Ak(n.shape,r.shape);const s={a:n,b:r};return _C.runKernel(jp,s)}});const Ax=JC({logicalNot_:function(e){const t={x:qC(e,"x","logicalNot","bool")};return _C.runKernel(Yp,t)}});const ox=JC({logicalOr_:function(e,t){const n=qC(e,"a","logicalOr","bool"),r=qC(t,"b","logicalOr","bool");Ak(n.shape,r.shape);const s={a:n,b:r};return _C.runKernel(Kp,s)}});const lx=JC({logicalXor_:function(e,t){const n=qC(e,"a","logicalXor","bool"),r=qC(t,"b","logicalXor","bool");return Ak(n.shape,r.shape),ix(ox(e,t),Ax(ix(e,t)))}});const ux=JC({maxPool_:function(e,t,n,r,s){const a=qC(e,"x","maxPool");let i=a,A=!1;3===a.rank&&(A=!0,i=kw(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Pf(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),Pf(bw(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),ww("maxPool",r,s);const o={x:i},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s},u=_C.runKernel($p,o,l);return A?kw(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const cx=JC({maxPool3d_:function(e,t=[1,1,1],n,r,s,a="NDHWC"){const i=qC(e,"x","maxPool3d");let A=i,o=!1;4===i.rank&&(o=!0,A=kw(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Pf(5===A.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${A.rank}.`)),Pf("NDHWC"===a,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),ww("maxPool3d",r,s);const l={x:A},u={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},c=_C.runKernel(tm,l,u);return o?kw(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}});const dx=JC({maximum_:function(e,t){let n=qC(e,"a","maximum"),r=qC(t,"b","maximum");[n,r]=PC(n,r),"bool"===n.dtype&&(n=_I(n,"int32"),r=_I(r,"int32")),Ak(n.shape,r.shape);const s={a:n,b:r};return _C.runKernel(Jp,s)}});const hx=JC({mean_:function(e,t=null,n=!1){const r={x:qC(e,"x","mean")},s={axis:t,keepDims:n};return _C.runKernel(sm,r,s)}});function fx(e,t="float32"){if(og(e),"complex64"===t){const t=fx(e,"float32"),n=fx(e,"float32");return $C(t,n)}const n=ig(Of(e),t);return _C.makeTensor(n,e,t)}function gx(e,t="float32"){if(og(e),"complex64"===t){const t=gx(e,"float32"),n=fx(e,"float32");return $C(t,n)}const n=ag(Of(e),t);return _C.makeTensor(n,e,t)}const px=JC({minimum_:function(e,t){let n=qC(e,"a","minimum"),r=qC(t,"b","minimum");[n,r]=PC(n,r),"bool"===n.dtype&&(n=_I(n,"int32"),r=_I(r,"int32")),Ak(n.shape,r.shape);const s={a:n,b:r};return _C.runKernel(im,s)}});const mx=JC({mirrorPad_:function(e,t,n){Pf("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=qC(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Pf(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const s="reflect"===n?1:0;for(let e=0;e<r.rank;e++)Pf(2===t[e].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Pf(t[e][0]>=0&&t[e][0]<=r.shape[e]-s&&t[e][1]>=0&&t[e][1]<=r.shape[e]-s,(()=>`Padding in dimension ${e} cannot be greater than or equal to ${r.shape[e]-s} or less than 0 for input of shape ${r.shape}`));const a={paddings:t,mode:n},i={x:r};return _C.runKernel(Am,i,a)}});const bx=JC({mod_:function(e,t){let n=qC(e,"a","mod"),r=qC(t,"b","mod");[n,r]=PC(n,r);const s={a:n,b:r};return _C.runKernel(om,s)}});const Cx=JC({moments_:function(e,t=null,n=!1){const r=Uf(t,(e=qC(e,"x","moments")).shape),s=hx(e,r,n);let a=s.shape;n||(a=Ck(s.shape,r));const i=Dk(rx(_I(e,"float32"),kw(s,a)));return{mean:s,variance:hx(i,r,n)}}});const Ix=JC({notEqual_:function(e,t){let n=qC(e,"a","notEqual","string_or_numeric"),r=qC(t,"b","notEqual","string_or_numeric");[n,r]=PC(n,r),Ak(n.shape,r.shape);const s={a:n,b:r};return _C.runKernel(dm,s)}});const wx=JC({oneHot_:function(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:qC(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return _C.runKernel(mm,a,i)}});const kx=JC({onesLike_:function(e){const t={x:qC(e,"x","onesLike")};return _C.runKernel(pm,t)}});const xx=JC({pad_:function(e,t,n=0){const r=qC(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return _C.runKernel(Cm,a,s)}});const yx=JC({spaceToBatchND_:function(e,t,n){const r=qC(e,"x","spaceToBatchND");Pf(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),Pf(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),Pf(r.shape.reduce(((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const s={x:r},a={blockShape:t,paddings:n};return _C.runKernel(Jm,s,a)}});const vx=JC({pool_:function(e,t,n,r,s,a,i){null==s&&(s=[1,1]),null==a&&(a=1),0===r&&(r="valid");const A=qC(e,"x","maxPool");let o=A,l=!1;3===A.rank&&(l=!0,o=kw(A,[1,A.shape[0],A.shape[1],A.shape[2]])),Pf(bw(a,s),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`));const u=ow(o.shape,t,a,s,r),c=[u.dilationHeight,u.dilationWidth];let d;d="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),r=n.map((e=>e-1)),s=r.map((e=>Math.floor(e/2))),a=r.map(((e,t)=>e-s[t]));return r.map(((e,t)=>[s[t],a[t]]))}([u.filterHeight,u.filterWidth],c):[[0,0],[0,0]];const h=1===c[0]&&1===c[1],[f,g]=function(e,t,n){const r=n.map((e=>e[0])),s=n.map((e=>e[1])),a=e.concat(r,s),i=t.map(((e,t)=>(e-a[t]%e)%e)),A=s.map(((e,t)=>e+i[t])),o=t.map(((e,t)=>[r[t],A[t]])),l=t.map(((e,t)=>[0,i[t]]));return[o,l]}([u.inHeight,u.inWidth],c,d),p=h?r:"valid",m=h?o:yx(o,c,f),b=("avg"===n?()=>xw(m,t,a,p,i):()=>ux(m,t,a,p,i))(),C=h?b:Tw(b,c,g);return l?kw(C,[C.shape[1],C.shape[2],C.shape[3]]):C}});const Ex=JC({prelu_:function(e,t){const n={x:qC(e,"x","prelu"),alpha:qC(t,"alpha","prelu")};return _C.runKernel(wm,n)}});const Bx=JC({prod_:function(e,t=null,n=!1){let r=qC(e,"x","prod");"bool"===r.dtype&&(r=_I(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return _C.runKernel(km,s,a)}});var Mx,Dx={exports:{}};function Tx(){return Mx||(Mx=1,function(e,t){function n(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function r(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var s=new n(e),a=t&&t.state,i=s.next;return i.int32=function(){return 4294967296*s.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,a&&("object"==typeof a&&r(a,s),i.state=function(){return r(s,{})}),i}t&&t.exports?t.exports=s:this.alea=s}(0,Dx)),Dx.exports}var Sx,Nx={exports:{}};function Gx(){return Sx||(Sx=1,function(e,t){function n(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function r(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var s=new n(e),a=t&&t.state,i=function(){return(s.next()>>>0)/4294967296};return i.double=function(){do{var e=((s.next()>>>11)+(s.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=s.next,i.quick=i,a&&("object"==typeof a&&r(a,s),i.state=function(){return r(s,{})}),i}t&&t.exports?t.exports=s:this.xor128=s}(0,Nx)),Nx.exports}var Fx,Px={exports:{}};function Qx(){return Fx||(Fx=1,function(e,t){function n(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function r(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var s=new n(e),a=t&&t.state,i=function(){return(s.next()>>>0)/4294967296};return i.double=function(){do{var e=((s.next()>>>11)+(s.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=s.next,i.quick=i,a&&("object"==typeof a&&r(a,s),i.state=function(){return r(s,{})}),i}t&&t.exports?t.exports=s:this.xorwow=s}(0,Px)),Px.exports}var zx,Ox={exports:{}};function Rx(){return zx||(zx=1,function(e,t){function n(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],n^=(e^=e<<13)^e<<9,r[s]=n,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function r(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var s=new n(e),a=t&&t.state,i=function(){return(s.next()>>>0)/4294967296};return i.double=function(){do{var e=((s.next()>>>11)+(s.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=s.next,i.quick=i,a&&(a.x&&r(a,s),i.state=function(){return r(s,{})}),i}t&&t.exports?t.exports=s:this.xorshift7=s}(0,Ox)),Ox.exports}var Lx,Wx={exports:{}};function _x(){return Lx||(Lx=1,function(e,t){function n(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,a=t.i;return t.w=r=r+1640531527|0,n=s[a+34&127],e=s[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,s,a,i,A=[],o=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,o=Math.max(o,t.length)),s=0,a=-32;a<o;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,s=0==(n=A[127&a]^=r+i)?s+1:0);for(s>=128&&(A[127&(t&&t.length||0)]=-1),s=127,a=512;a>0;--a)r=A[s+34&127],n=A[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,A[s]=r^n;e.w=i,e.X=A,e.i=s}(t,e)}function r(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var s=new n(e),a=t&&t.state,i=function(){return(s.next()>>>0)/4294967296};return i.double=function(){do{var e=((s.next()>>>11)+(s.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=s.next,i.quick=i,a&&(a.X&&r(a,s),i.state=function(){return r(s,{})}),i}t&&t.exports?t.exports=s:this.xor4096=s}(0,Wx)),Wx.exports}var Vx,Hx={exports:{}};function Ux(){return Vx||(Vx=1,function(e,t){function n(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function r(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var s=new n(e),a=t&&t.state,i=function(){return(s.next()>>>0)/4294967296};return i.double=function(){do{var e=((s.next()>>>11)+(s.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=s.next,i.quick=i,a&&("object"==typeof a&&r(a,s),i.state=function(){return r(s,{})}),i}t&&t.exports?t.exports=s:this.tychei=s}(0,Hx)),Hx.exports}var jx,Yx,Kx,Xx={exports:{}},qx=Lb(yf),Zx=Xx.exports;function Jx(){return jx||(jx=1,e=Xx,function(t,n,r){var s,a=256,i="random",A=r.pow(a,6),o=r.pow(2,52),l=2*o,u=255;function c(e,u,c){var m=[],b=g(f((u=1==u?{entropy:!0}:u||{}).entropy?[e,p(n)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(a):(e=new Uint8Array(a),(t.crypto||t.msCrypto).getRandomValues(e)),p(e)}catch(e){var r=t.navigator,i=r&&r.plugins;return[+new Date,t,i,t.screen,p(n)]}}():e,3),m),C=new d(m),I=function(){for(var e=C.g(6),t=A,n=0;e<o;)e=(e+n)*a,t*=a,n=C.g(1);for(;e>=l;)e/=2,t/=2,n>>>=1;return(e+n)/t};return I.int32=function(){return 0|C.g(4)},I.quick=function(){return C.g(4)/4294967296},I.double=I,g(p(C.S),n),(u.pass||c||function(e,t,n,s){return s&&(s.S&&h(s,C),e.state=function(){return h(C,{})}),n?(r[i]=e,t):e})(I,b,"global"in u?u.global:this==r,u.state)}function d(e){var t,n=e.length,r=this,s=0,i=r.i=r.j=0,A=r.S=[];for(n||(e=[n++]);s<a;)A[s]=s++;for(s=0;s<a;s++)A[s]=A[i=u&i+e[s%n]+(t=A[s])],A[i]=t;(r.g=function(e){for(var t,n=0,s=r.i,i=r.j,A=r.S;e--;)t=A[s=u&s+1],n=n*a+A[u&(A[s]=A[i=u&i+t])+(A[i]=t)];return r.i=s,r.j=i,n})(a)}function h(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function f(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(f(e[n],t-1))}catch(e){}return r.length?r:"string"==s?e:e+"\0"}function g(e,t){for(var n,r=e+"",s=0;s<r.length;)t[u&s]=u&(n^=19*t[u&s])+r.charCodeAt(s++);return p(t)}function p(e){return String.fromCharCode.apply(0,e)}if(g(r.random(),n),e.exports){e.exports=c;try{s=qx}catch(e){}}else r["seed"+i]=c}("undefined"!=typeof self?self:Zx,[],Math)),Xx.exports;var e}var $x=function(){if(Kx)return Yx;Kx=1;var e=Tx(),t=Gx(),n=Qx(),r=Rx(),s=_x(),a=Ux(),i=Jx();return i.alea=e,i.xor128=t,i.xorwow=n,i.xorshift7=r,i.xor4096=s,i.tychei=a,Yx=i}();class ey{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=$x.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class ty{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=$x.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const ny=JC({randomNormal_:function(e,t=0,n=1,r,s){if(og(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new ey(t,n,r,!1,s),i=WI(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}});const ry=JC({randomUniform_:function(e,t=0,n=1,r="float32",s){og(e);const a=WI(e,r),i=new ty(t,n,null,s);for(let e=0;e<a.values.length;e++)a.values[e]=i.nextValue();return a.toTensor()}});function sy(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return _C.runKernel(Em,{},s)}const ay=JC({real_:function(e){const t={input:qC(e,"input","real")};return _C.runKernel(Bm,t)}});const iy=JC({reciprocal_:function(e){const t={x:qC(e,"x","reciprocal")};return _C.runKernel(Mm,t)}});const Ay=JC({relu_:function(e){const t={x:qC(e,"x","relu")};return _C.runKernel(Dm,t)}});const oy=JC({relu6_:function(e){const t={x:qC(e,"x","relu6")};return _C.runKernel(Pm,t)}});const ly=JC({reverse_:function(e,t){const n={x:qC(e,"x","reverse")},r={dims:t};return _C.runKernel(Qm,n,r)}});const uy=JC({round_:function(e){const t={x:qC(e,"x","round")};return _C.runKernel(zm,t)}});const cy=JC({rsqrt_:function(e){const t={x:qC(e,"x","rsqrt","float32")};return _C.runKernel(Om,t)}});const dy=JC({selu_:function(e){const t={x:qC(e,"x","selu")};return _C.runKernel(Vm,t)}});const hy=JC({separableConv2d_:function(e,t,n,r,s,a=[1,1],i="NHWC"){const A=qC(e,"x","separableConv2d"),o=qC(t,"depthwiseFilter","separableConv2d"),l=qC(n,"pointwiseFilter","separableConv2d");let u=A,c=!1;if(3===A.rank&&(c=!0,u=kw(A,[1,A.shape[0],A.shape[1],A.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Pf(4===u.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`)),Pf(4===o.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${o.rank}.`)),Pf(4===l.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${o.rank}.`)),Pf(1===l.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`)),Pf(1===l.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`));const d=o.shape[2],h=o.shape[3];Pf(l.shape[2]===d*h,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*h}, but got ${l.shape[2]}.`));const f=rk(u,o,r,s,i,a),g=Hw(f,l,1,"valid",i);return c?kw(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});const fy=JC({sign_:function(e){const t={x:qC(e,"x","sign")};return _C.runKernel(Ym,t)}});const gy=JC({sin_:function(e){const t={x:qC(e,"x","sin","float32")};return _C.runKernel(Um,t)}});const py=JC({sinh_:function(e){const t={x:qC(e,"x","sinh")};return _C.runKernel(jm,t)}});const my=JC({slice1d_:function(e,t,n){const r=qC(e,"x","slice1d");return Pf(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),Mw(r,[t],[n])}});const by=JC({slice2d_:function(e,t,n){const r=qC(e,"x","slice2d");return Pf(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),Mw(r,t,n)}});const Cy=JC({slice3d_:function(e,t,n){const r=qC(e,"x","slice3d");return Pf(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),Mw(r,t,n)}});const Iy=JC({slice4d_:function(e,t,n){const r=qC(e,"x","slice4d");return Pf(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),Mw(r,t,n)}});const wy=JC({softmax_:function(e,t=-1){const n=qC(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return _C.runKernel(eb,r,s)}});const ky=JC({fft_:function(e){Pf("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return _C.runKernel(yp,t)}});const xy=JC({ifft_:function(e){Pf("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return _C.runKernel(Pp,t)}});const yy=JC({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=kw(e,[n,t]);r=xy(s)}else{const s=[n,2*(t-1)],a=kw(ay(e),[n,t]),i=kw(Vk(e),[n,t]),A=ly(Mw(a,[0,1],[n,t-2]),1),o=KI(ly(Mw(i,[0,1],[n,t-2]),1),Bk(-1)),l=vw([a,A],1),u=vw([i,o],1),c=kw($C(l,u),[s[0],s[1]]);r=xy(c)}if(r=ay(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=kw(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});const vy=JC({split_:function(e,t,n=0){const r={x:qC(e,"x","split")},s={numOrSizeSplits:t,axis:n};return _C.runKernel($m,r,s)}});const Ey=JC({rfft_:function(e,t){Pf("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map((e=>0)),a=e.shape.map((e=>e));a[e.shape.length-1]=t,s=Mw(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,s=vw([e,fx(r)],e.shape.length-1),n=t}else s=e;const a=uk(s),i=kw($C(s,a),[r,n]),A=ky(i),o=Math.floor(n/2)+1,l=ay(A),u=Vk(A),c=vy(l,[o,n-o],l.shape.length-1),d=vy(u,[o,n-o],u.shape.length-1),h=s.shape.slice();return h[s.shape.length-1]=o,kw($C(c[0],d[0]),h)}});const By=JC({squaredDifference_:function(e,t){let n=qC(e,"a","squaredDifference"),r=qC(t,"b","squaredDifference");[n,r]=PC(n,r),Ak(n.shape,r.shape);const s={a:n,b:r};return _C.runKernel(ib,s,{})}});const My=JC({squeeze_:function(e,t){const n=qC(e,"x","squeeze","string_or_numeric");return kw(n,jf(n.shape,t).newShape)}});const Dy=JC({stack_:function(e,t=0){const n=ZC(e,"tensors","stack","string_or_numeric");Pf(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Pf(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,s={axis:t};return _C.runKernel(bm,r,s)}});const Ty=JC({step_:function(e,t=0){const n={x:qC(e,"x","step")},r={alpha:t};return _C.runKernel(yb,n,r)}});const Sy=JC({stridedSlice_:function(e,t,n,r,s=0,a=0,i=0,A=0,o=0){const l={x:qC(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:A,shrinkAxisMask:o};return _C.runKernel(lb,l,u)}});const Ny=JC({tan_:function(e){const t={x:qC(e,"x","tan","float32")};return _C.runKernel(fb,t)}});function Gy(e,t){zf(e);const n=YC(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return eI(e,null,n,t)}function Fy(e,t,n){if(zf(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=YC(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return eI(e,t,r,n)}function Py(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let e=0;e<s;++e)if(n.shape[e]!==t.shape[e])throw new Error(a+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-s;++t)if(n.shape[t+s]!==e[t+r])throw new Error(a+` updates.shape[${t+s}] (${n.shape[t+s]}) != shape[${t+s}] (${e[t+s]})`)}function Qy(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let e=s;e<a;++e)i*=n[e];const A=s<1?1:s;return{sliceRank:s,numUpdates:Of(t.shape)/A,sliceSize:i,strides:[...ng(n.slice(0,s)),1],outputSize:Of(n)}}const zy=JC({topk_:function(e,t=1,n=!0){const r=qC(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[A,o]=_C.runKernel(mb,a,i);return{values:A,indices:o}}});const Oy=JC({truncatedNormal_:function(e,t=0,n=1,r,s){if(og(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new ey(t,n,r,!0,s),i=WI(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}});const Ry=JC({unique_:function(e,t=0){const n=qC(e,"x","unique","string_or_numeric");Pf(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},s={axis:t},[a,i]=_C.runKernel(Ib,r,s);return{values:a,indices:i}}});const Ly=JC({unsortedSegmentSum_:function(e,t,n){const r=qC(e,"x","unsortedSegmentSum"),s=qC(t,"segmentIds","unsortedSegmentSum","int32");Pf(Lf(n),(()=>"numSegments must be of dtype int"));const a={x:r,segmentIds:s},i={numSegments:n};return _C.runKernel(kb,a,i)}});const Wy=JC({unstack_:function(e,t=0){const n=qC(e,"x","unstack","string_or_numeric");Pf(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},s={axis:t};return _C.runKernel(wb,r,s)}});function _y(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const r=WI(e,"int32"),s=WI([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const a=r.indexToLoc(n[t]),i=t*e.length;s.values.set(a,i)}return s.toTensor()}const Vy=JC({transpose_:function(e,t,n){const r=qC(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),Pf(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{Pf(e>=0&&e<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${t}`))})),r.rank<=1)return r.clone();const s={x:r},a={perm:t};return"complex64"===r.dtype?aI((()=>{let e=ay(r),t=Vk(r);return e=_C.runKernel(Cb,{x:e},a),t=_C.runKernel(Cb,{x:t},a),n&&(t=ex(t)),$C(e,t)})):_C.runKernel(Cb,s,a)}});const Hy=JC({dropout_:function(e,t,n,r){const s=qC(e,"x","dropout");if(Pf("float32"===s.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`)),Pf(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof kC?s.clone():s;const a=function(e,t){if(null==t)return e.shape.slice();if(Rf(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(s,n),i=1-t,A=YI(Rk(UI(ry(a,0,1,"float32",r),i)),i);return KI(s,A)}});const Uy=JC({conv2DBackpropFilter_:function(e,t,n,r,s,a="NHWC",i){let A=e;3===e.rank&&(A=kw(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let o=t;3===o.rank&&(o=kw(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Pf(4===A.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${A.shape}.`)),Pf(4===o.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${o.shape}.`)),Pf(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const l="NHWC"===a?A.shape[3]:A.shape[1],u="NHWC"===a?o.shape[3]:o.shape[1];Pf(l===n[2],(()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`)),Pf(u===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`)),ww("conv2dDerFilter",s,i);const c={x:A,dy:o},d={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return _C.runKernel(qg,c,d)}});function jy(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return KI(e,Ty(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Yy(e,t){let n=t;const r=ik(e.shape,t.shape);return r.length>0&&(n=Tk(n,r)),kw(n,e.shape)}function Ky(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Ay(e);if("elu"===t)return fk(e);if("relu6"===t)return oy(e);if("prelu"===t)return Ex(e,n);if("leakyrelu"===t)return Yk(e,r);if("sigmoid"===t)return Bw(e);throw new Error(`Unknown fused activation ${t}.`)}const Xy=(e,t)=>!(e>0)||"linear"===t;const qy=JC({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:A,activation:o="linear",preluActivationWeights:l,leakyreluAlpha:u}){if(o=o||"linear",!1===Xy(_C.state.gradientDepth,o)){Pf("NHWC"===s,(()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let c=Hw(e,t,n,r,s,a,i);return null!=A&&(c=UI(c,A)),Ky(c,o,l,u)}const c=qC(e,"x","conv2d","float32"),d=qC(t,"filter","conv2d","float32");let h=c,f=!1;3===c.rank&&(f=!0,h=kw(c,[1,c.shape[0],c.shape[1],c.shape[2]])),Pf(4===h.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`)),Pf(4===d.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`)),ww("fused conv2d",r,i);const g="NHWC"===s?h.shape[3]:h.shape[1];Pf(d.shape[2]===g,(()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${d.shape[2]}.`)),Pf(bw(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`));const p=uw(h.shape,d.shape,n,a,r,i);let m,b;if(null!=A&&(m=qC(A,"bias","fused conv2d"),[m]=PC(m,c),"NHWC"===s?Ak(p.outShape,m.shape):(Pf(m.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${m.shape.length}.`)),Pf(0===m.shape.length||m.shape[0]===p.outChannels||1===m.shape[0],(()=>`Error in fused conv2d: bias shape (${m.shape}) is not compatible with the number of output channels (${p.outChannels})`)))),null!=l){const e=l.shape;if(Pf(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)Pf(1===e[0]||e[0]===p.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${p.outChannels}).`));else if(3===e.length)try{Ak(e,p.outShape)}catch(t){const n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${p.outShape}).`;throw Error(n)}b=qC(l,"prelu weights","fused conv2d")}const C=(e,t)=>{Pf("NHWC"===s,(()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`));const[i,A,l,u]=t,c=jy(e,l,o);Pf(mw(a),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`));const d=[jw(A.shape,c,i,n,r),Uy(A,c,i.shape,n,r)];if(null!=u){const e=Yy(u,c);d.push(e)}return d},I={x:h,filter:d,bias:m,preluActivationWeights:b},w={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:o,leakyreluAlpha:u};if(null==A){const e=$k(((e,t,n)=>{let r=_C.runKernel(Bb,I,w);return n([t,e,r]),f&&(r=kw(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:C}}));return e(h,d)}{const e=$k(((e,t,n,r)=>{let s=_C.runKernel(Bb,I,w);return r([t,e,s,n]),f&&(s=kw(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:C}}));return e(h,d,m)}}});const Zy=JC({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,s,a=[1,1],i){let A=e;3===e.rank&&(A=kw(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let o=t;3===o.rank&&(o=kw(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:A,dy:o},u={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return _C.runKernel(lp,l,u)}});const Jy=JC({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,s,a=[1,1],i){let A=t,o=!1;3===t.rank&&(o=!0,A=kw(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:A,filter:n},u={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},c=_C.runKernel(up,l,u);return o?kw(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const $y=JC({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:A=.2}){if(!1===Xy(_C.state.gradientDepth,a)){let o=Ew(e,t,n,r);return null!=s&&(o=UI(o,s)),Ky(o,a,i,A)}let o=qC(e,"a","fused matMul"),l=qC(t,"b","fused matMul");[o,l]=PC(o,l);const u=n?o.shape[o.rank-2]:o.shape[o.rank-1],c=r?l.shape[l.rank-1]:l.shape[l.rank-2],d=n?o.shape[o.rank-1]:o.shape[o.rank-2],h=r?l.shape[l.rank-2]:l.shape[l.rank-1],f=o.shape.slice(0,-2),g=l.shape.slice(0,-2),p=Of(f),m=Of(g);Pf(u===c,(()=>`Error in fused matMul: inner shapes (${u}) and (${c}) of Tensors with shapes ${o.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`));const b=Ak(o.shape.slice(0,-2),l.shape.slice(0,-2)).concat([d,h]),C=kw(o,n?[p,u,d]:[p,d,u]),I=kw(l,r?[m,h,c]:[m,c,h]);let w,k;null!=s&&(w=qC(s,"bias","fused matMul"),[w]=PC(w,o),Ak(b,w.shape)),null!=i&&(k=qC(i,"prelu weights","fused matMul"));const x=(e,t)=>{const[i,A,o,l]=t,u=jy(kw(e,o.shape),o,a);let c,d;if(n||r?!n&&r?(c=Ew(u,A,!1,!1),d=Ew(u,i,!0,!1)):n&&!r?(c=Ew(A,u,!1,!0),d=Ew(i,u,!1,!1)):(c=Ew(A,u,!0,!0),d=Ew(u,i,!0,!0)):(c=Ew(u,A,!1,!0),d=Ew(i,u,!0,!1)),null!=s){return[c,d,Yy(l,u)]}return[c,d]},y={a:C,b:I,bias:w,preluActivationWeights:k},v={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:A};if(null==s){const e=$k(((e,t,n)=>{const r=_C.runKernel(Eb,y,v);return n([e,t,r]),{value:kw(r,b),gradFunc:x}}));return e(C,I)}{const e=$k(((e,t,n,r)=>{const s=_C.runKernel(Eb,y,v);return r([e,t,s,n]),{value:kw(s,b),gradFunc:x}}));return e(C,I,w)}}});const tv=JC({cropAndResize_:function(e,t,n,r,s="bilinear",a=0){const i=qC(e,"image","cropAndResize"),A=qC(t,"boxes","cropAndResize","float32"),o=qC(n,"boxInd","cropAndResize","int32"),l=A.shape[0];Pf(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),Pf(2===A.rank&&4===A.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${A.shape}.`)),Pf(1===o.rank&&o.shape[0]===l,(()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${A.shape}.`)),Pf(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),Pf(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),Pf("bilinear"===s||"nearest"===s,(()=>`method must be bilinear or nearest, but was ${s}`));const u={image:i,boxes:A,boxInd:o},c={method:s,extrapolationValue:a,cropSize:r};return _C.runKernel(ap,u,c)}});const nv=JC({flipLeftRight_:function(e){const t=qC(e,"image","flipLeftRight","float32");Pf(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return _C.runKernel(Ep,n,{})}});const rv=JC({grayscaleToRGB_:function(e){const t=qC(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Pf(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),Pf(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,zk(t,s)}});const sv=JC({rgbToGrayscale_:function(e){const t=qC(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];Pf(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),Pf(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));const s=t.dtype,a=_I(t,"float32"),i=Gy([.2989,.587,.114]);let A;switch(t.rank){case 2:A=hk("ij,j->i",a,i);break;case 3:A=hk("ijk,k->ij",a,i);break;case 4:A=hk("ijkl,l->ijk",a,i);break;case 5:A=hk("ijklm,m->ijkl",a,i);break;case 6:A=hk("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return A=Pk(A,-1),_I(A,s)}});const av=JC({rotateWithOffset_:function(e,t,n=0,r=.5){const s=qC(e,"image","rotateWithOffset","float32");Pf(4===s.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`));const a={image:s},i={radians:t,fillValue:n,center:r};return _C.runKernel(vb,a,i)}});function iv(e,t,n,r,s,a){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),Pf(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),Pf(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),Pf(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),Pf(1===t.rank,(()=>"scores must be a 1D tensor")),Pf(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),Pf(0<=a&&a<=1,(()=>`softNmsSigma must be in [0, 1], but was '${a}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}const Av=JC({nonMaxSuppression_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=qC(e,"boxes","nonMaxSuppression","float32"),i=qC(t,"scores","nonMaxSuppression","float32"),A=iv(a,i,n,r,s),o={maxOutputSize:n=A.maxOutputSize,iouThreshold:r=A.iouThreshold,scoreThreshold:s=A.scoreThreshold};return _C.runKernel(hm,{boxes:a,scores:i},o)}});function ov(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const A=n(t,e[a]);A>0?r=a+1:(s=a,i=!A)}return i?r:-r-1}(e,t,n||lv)}(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function lv(e,t){return e>t?1:e<t?-1:0}function uv(e,t,n,r,s){return hv(e,t,n,r,s,0)}function cv(e,t,n,r,s,a){return hv(e,t,n,r,s,0,!1,a,!0)}function dv(e,t,n,r,s,a){return hv(e,t,n,r,s,a,!0)}function hv(e,t,n,r,s,a,i=!1,A=!1,o=!1){const l=[];for(let e=0;e<t.length;e++)t[e]>s&&l.push({score:t[e],boxIndex:e,suppressBeginIndex:0});l.sort(pv);const u=a>0?-.5/a:0,c=[],d=[];for(;c.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=t;if(n<s)break;let A=!1;for(let n=c.length-1;n>=i;--n){const i=fv(e,a,c[n]);if(i>=r){A=!0;break}if(t.score=t.score*gv(r,u,i),t.score<=s)break}t.suppressBeginIndex=c.length,A||(t.score===n?(c.push(a),d.push(t.score)):t.score>s&&ov(l,t,pv))}const h=c.length,f=n-h;A&&f>0&&(c.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:c};return i&&(g.selectedScores=d),o&&(g.validOutputs=h),g}function fv(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),A=Math.max(r[0],r[2]),o=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),u=Math.min(s[1],s[3]),c=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),h=(A-a)*(o-i),f=(c-l)*(d-u);if(h<=0||f<=0)return 0;const g=Math.max(a,l),p=Math.max(i,u),m=Math.min(A,c),b=Math.min(o,d),C=Math.max(m-g,0)*Math.max(b-p,0);return C/(h+f-C)}function gv(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function pv(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const mv=async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=qC(e,"boxes","nonMaxSuppressionAsync"),i=qC(t,"scores","nonMaxSuppressionAsync"),A=iv(a,i,n,r,s);n=A.maxOutputSize,r=A.iouThreshold,s=A.scoreThreshold;const o=await Promise.all([a.data(),i.data()]),l=o[0],u=o[1],{selectedIndices:c}=uv(l,u,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),Gy(c,"int32")};const bv=JC({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=qC(e,"boxes","nonMaxSuppression"),A=qC(t,"scores","nonMaxSuppression"),o=iv(i,A,n,r,s,a),l={boxes:i,scores:A},u={maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:s=o.scoreThreshold,softNmsSigma:a=o.softNmsSigma},c=_C.runKernel(gm,l,u);return{selectedIndices:c[0],selectedScores:c[1]}}});const Cv=async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=qC(e,"boxes","nonMaxSuppressionAsync"),A=qC(t,"scores","nonMaxSuppressionAsync"),o=iv(i,A,n,r,s,a);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold,a=o.softNmsSigma;const l=await Promise.all([i.data(),A.data()]),u=l[0],c=l[1],{selectedIndices:d,selectedScores:h}=dv(u,c,n,r,s,a);return i!==e&&i.dispose(),A!==t&&A.dispose(),{selectedIndices:Gy(d,"int32"),selectedScores:Gy(h)}};const Iv=JC({nonMaxSuppressionPadded_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=qC(e,"boxes","nonMaxSuppression"),A=qC(t,"scores","nonMaxSuppression"),o=iv(i,A,n,r,s,null),l={boxes:i,scores:A},u={maxOutputSize:o.maxOutputSize,iouThreshold:o.iouThreshold,scoreThreshold:o.scoreThreshold,padToMaxOutputSize:a},c=_C.runKernel(fm,l,u);return{selectedIndices:c[0],validOutputs:c[1]}}});const wv=async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=qC(e,"boxes","nonMaxSuppressionAsync"),A=qC(t,"scores","nonMaxSuppressionAsync"),o=iv(i,A,n,r,s,null),l=o.maxOutputSize,u=o.iouThreshold,c=o.scoreThreshold,[d,h]=await Promise.all([i.data(),A.data()]),{selectedIndices:f,validOutputs:g}=cv(d,h,l,u,c,a);return i!==e&&i.dispose(),A!==t&&A.dispose(),{selectedIndices:Gy(f,"int32"),validOutputs:Bk(g,"int32")}};const kv=JC({resizeBilinear_:function(e,t,n=!1,r=!1){const s=qC(e,"images","resizeBilinear");Pf(3===s.rank||4===s.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`)),Pf(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),Pf(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=kw(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const A={images:a},o={alignCorners:n,halfPixelCenters:r,size:t},l=_C.runKernel(Gm,A,o);return i?kw(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const xv=JC({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const s=qC(e,"images","resizeNearestNeighbor");Pf(3===s.rank||4===s.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`)),Pf(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),Pf("float32"===s.dtype||"int32"===s.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Pf(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=kw(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const A={images:a},o={alignCorners:n,halfPixelCenters:r,size:t},l=_C.runKernel(Sm,A,o);return i?kw(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const yv=JC({threshold_:function(e,t="binary",n=!1,r=.5){const s=qC(e,"image","threshold"),a=s.shape[0]*s.shape[1];let i,A,o,l,u=KI(Gy([r]),255);if(Pf(3===s.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`)),Pf(3===s.shape[2]||1===s.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`)),Pf("int32"===s.dtype||"float32"===s.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`)),Pf("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===s.shape[2]){[i,A,o]=vy(s,[1,1,1],-1);const e=KI(i,.2989),t=KI(A,.587),n=KI(o,.114);l=UI(UI(e,t),n)}else l=e;if("otsu"===t){u=function(e,t){let n,r,s,a,i,A,o=Gy([-1]),l=Gy([0]),u=Gy([0]);for(let c=0;c<e.size-1;c++){n=Mw(e,0,c+1),r=Mw(e,c+1),i=YI(Tk(n),t),A=YI(Tk(r),t);const d=Tk(KI(n,sy(0,n.size)));s=YI(d,Tk(n));const h=Ow(r.shape,n.size),f=UI(sy(0,r.size),h),g=KI(r,f);a=YI(Tk(g),Tk(r));const p=rx(s,a),m=rx(s,a),b=KI(i,A);u=KI(KI(b,p),m);const C=Wk(u,l);l=lk(C,u,l),o=lk(C,Gy([c]),o)}return o}(Pw(_I(uy(l),"int32"),tI([]),256),a)}const c=n?Xk(l,u):Wk(l,u);return _I(KI(c,255),"int32")}});const vv=JC({transform_:function(e,t,n="nearest",r="constant",s=0,a){const i=qC(e,"image","transform","float32"),A=qC(t,"transforms","transform","float32");Pf(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),Pf(2===A.rank&&(A.shape[0]===i.shape[0]||1===A.shape[0])&&8===A.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Pf(null==a||2===a.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`));const o={image:i,transforms:A},l={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return _C.runKernel(bb,o,l)}});const Ev=JC({bandPart_:function(e,t,n){const r=qC(e,"a","bandPart");Pf(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const s=r.shape,[a,i]=r.shape.slice(-2);let A,o;"number"==typeof t?(Pf(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),Pf(t<=a,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`)),A=qC(t<0?a:t,"numLower","bandPart")):(Pf("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),A=lk(Kk(t,0),a,px(t,a))),"number"==typeof n?(Pf(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),Pf(n<=i,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`)),o=qC(n<0?i:n,"numUpper","bandPart")):(Pf("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),o=lk(Kk(n,0),i,px(n,i)));const l=kw(sy(0,a,1,"int32"),[-1,1]),u=sy(0,i,1,"int32"),c=rx(l,u),d=ix(Xk(c,A),_k(c,ex(o))),h=fx([a,i],r.dtype);return kw(Dy(Wy(kw(r,[-1,a,i])).map((e=>lk(d,e,h)))),s)}});const Bv=JC({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Pf(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)Pf(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=vy(e,e.shape[0],0).map((e=>My(e,[0])));Pf(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let t=0;t<e.length;++t)n.push(_C.tidy((()=>{let e=r[t];if(t>0)for(let r=0;r<t;++r){const t=KI(Tk(KI(n[r],e)),n[r]);e=rx(e,t)}return YI(e,Nk(e,"euclidean"))})));return t?Dy(n,0):n}});function Mv(e,t=!1){return _C.tidy((()=>{Pf(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let s=Ok(n),a=VI(e);const i=Fy([[1]],[1,1]);let A=VI(i);const o=n>=r?r:n;for(let e=0;e<o;++e){const t=a,o=A,l=s;[A,a,s]=_C.tidy((()=>{const t=Mw(a,[e,e],[n-e,1]),o=Nk(t),l=Mw(a,[e,e],[1,1]),u=lk(Wk(l,0),Fy([[-1]]),Fy([[1]])),c=rx(l,KI(u,o)),d=YI(t,c);A=1===d.shape[0]?VI(i):vw([i,Mw(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const h=ex(YI(Ew(u,c),o)),f=Mw(a,[e,0],[n-e,r]),g=KI(h,A),p=Vy(A);if(0===e)a=rx(f,Ew(g,Ew(p,f)));else{const t=rx(f,Ew(g,Ew(p,f)));a=vw([Mw(a,[0,0],[e,r]),t],0)}const m=Vy(g),b=Mw(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=rx(b,Ew(Ew(b,A),m));else{const t=rx(b,Ew(Ew(b,A),m));s=vw([Mw(s,[0,0],[n,e]),t],1)}return[A,a,s]})),iI([t,o,l])}return!t&&n>r&&(s=Mw(s,[0,0],[n,r]),a=Mw(a,[0,0],[r,r])),[s,a]}))}const Dv=JC({qr_:function(e,t=!1){if(Pf(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return Mv(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=Wy(kw(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach((e=>{const[n,r]=Mv(e,t);s.push(n),a.push(r)}));return[kw(Dy(s,0),e.shape),kw(Dy(a,0),e.shape)]}}}),Tv={flipLeftRight:nv,grayscaleToRGB:rv,resizeNearestNeighbor:xv,resizeBilinear:kv,rgbToGrayscale:sv,rotateWithOffset:av,cropAndResize:tv,nonMaxSuppression:Av,nonMaxSuppressionAsync:mv,nonMaxSuppressionWithScore:bv,nonMaxSuppressionWithScoreAsync:Cv,nonMaxSuppressionPadded:Iv,nonMaxSuppressionPaddedAsync:wv,threshold:yv,transform:vv},Sv={bandPart:Ev,gramSchmidt:Bv,qr:Dv},Nv=new Map,Gv=new Map;class Fv{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Pv{constructor(){this.classNameMap={}}static getMap(){return null==Pv.instance&&(Pv.instance=new Pv),Pv.instance}static register(e){Pv.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Qv(e,t,n){Pf(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Pf("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Pf(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),void 0===t&&(t="Custom"),void 0===n&&(n=e.className);const r=t+">"+n;return Pv.register(e),Nv.set(r,e),Gv.set(e,r),e}class zv extends Fv{minimize(e,t=!1,n){const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:s[e.name]})));this.applyGradients(e)}else this.applyGradients(s);return iI(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){Pf(eg(e),(()=>"The f passed in variableGrads(f) must be a function")),Pf(null==t||Array.isArray(t)&&t.every((e=>e instanceof yC)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in _C.registeredVariables)t.push(_C.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,s=t.length;t=t.filter((e=>e.trainable)),Pf(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`));const{value:a,grads:i}=_C.gradients(e,t,null,!0);Pf(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Pf(0===a.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`));const A={};return t.forEach(((e,t)=>{null!=i[t]&&(A[e.name]=i[t])})),null!=r&&r.forEach((e=>A[e.name]=null)),{value:a,grads:A}}(e,t)}dispose(){null!=this.iterations_&&iI(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Bk(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(zv,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class Ov extends zv{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=_C.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=_C.registeredVariables[t],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:aI((()=>uk(r).variable(s)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:aI((()=>uk(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedGrads[n].variable,A=this.accumulatedUpdates[n].variable;aI((()=>{const e=UI(KI(i,this.rho),KI(Dk(a),1-this.rho)),t=KI(YI(Mk(UI(A,this.epsilon)),Mk(UI(i,this.epsilon))),a),n=UI(KI(A,this.rho),KI(Dk(t),1-this.rho));i.assign(e),A.assign(n);const s=UI(KI(t,-this.learningRate),r);r.assign(s)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(iI(this.accumulatedGrads.map((e=>e.variable))),iI(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}class Rv extends zv{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=_C.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:aI((()=>Ow(r.shape,this.initialAccumulatorValue).variable(e)))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable;aI((()=>{const e=UI(a,Dk(s));a.assign(e);const t=UI(KI(YI(s,Mk(UI(e,_C.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&iI(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}class Lv extends zv{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],aI((()=>{this.accBeta1=Bk(t).variable(),this.accBeta2=Bk(n).variable()})),null==r&&(this.epsilon=_C.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);aI((()=>{const n=rx(1,this.accBeta1),r=rx(1,this.accBeta2);t.forEach(((t,s)=>{const a=_C.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:aI((()=>uk(a).variable(i)))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:aI((()=>uk(a).variable(i)))});const A=Array.isArray(e)?e[s].tensor:e[t];if(null==A)return;const o=this.accumulatedFirstMoment[s].variable,l=this.accumulatedSecondMoment[s].variable,u=UI(KI(o,this.beta1),KI(A,1-this.beta1)),c=UI(KI(l,this.beta2),KI(Dk(A),1-this.beta2)),d=YI(u,n),h=YI(c,r);o.assign(u),l.assign(c);const f=UI(KI(YI(d,UI(Mk(h),this.epsilon)),-this.learningRate),a);a.assign(f)})),this.accBeta1.assign(KI(this.accBeta1,this.beta1)),this.accBeta2.assign(KI(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&iI(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&iI(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),aI((()=>{this.accBeta1.assign(Ek(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ek(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}class Wv extends zv{static get className(){return"Adamax"}constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],aI((()=>{this.iteration=Bk(0).variable(),this.accBeta1=Bk(t).variable()})),null==r&&(this.epsilon=_C.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);aI((()=>{const n=rx(1,this.accBeta1),r=YI(-this.learningRate,UI(KI(this.iteration,this.decay),1));t.forEach(((t,s)=>{const a=_C.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:uk(a).variable(i)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:uk(a).variable(i)});const A=Array.isArray(e)?e[s].tensor:e[t];if(null==A)return;const o=this.accumulatedFirstMoment[s].variable,l=this.accumulatedWeightedInfNorm[s].variable,u=UI(KI(o,this.beta1),KI(A,1-this.beta1)),c=KI(l,this.beta2),d=XI(A),h=dx(c,d);o.assign(u),l.assign(h);const f=UI(KI(YI(r,n),YI(u,UI(h,this.epsilon))),a);a.assign(f)})),this.iteration.assign(UI(this.iteration,1)),this.accBeta1.assign(KI(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&iI(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&iI(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class _v extends zv{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=_C.registeredVariables[t];aI((()=>{const e=UI(KI(this.c,r),s);s.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=AI(Bk(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class Vv extends _v{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Bk(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=_C.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:aI((()=>uk(r).variable(e)))}}const s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&aI((()=>{let e;const t=UI(KI(this.m,s),a);e=this.useNesterov?UI(KI(this.c,UI(a,KI(t,this.m))),r):UI(KI(this.c,t),r),s.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&iI(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class Hv extends zv{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=_C.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=_C.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:aI((()=>uk(r).variable(s)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:aI((()=>uk(r).variable(s)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:aI((()=>uk(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,A=this.accumulatedMoments[n].variable;aI((()=>{const e=UI(KI(i,this.decay),KI(Dk(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=UI(KI(t,this.decay),KI(a,1-this.decay)),o=YI(KI(a,this.learningRate),Mk(rx(e,UI(Dk(s),this.epsilon)))),l=UI(KI(A,this.momentum),o);i.assign(e),t.assign(s),A.assign(l);const u=rx(r,l);r.assign(u)}else{const e=UI(KI(i,this.decay),KI(Dk(a),1-this.decay)),t=UI(KI(A,this.momentum),YI(KI(a,this.learningRate),Mk(UI(e,this.epsilon))));i.assign(e),A.assign(t);const n=rx(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&iI(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&iI(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&iI(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const Uv=[Ov,Rv,Lv,Wv,Vv,Hv,_v];function jv(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Of(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let e=0;e<s.length-1;++e)i*=s[e];const A=e.shape,o=s.slice();o.pop();let l=1;for(let e=a;e<n;++e)l*=A[e],o.push(A[e]);const u=[...ng(e.shape).map((e=>e/l)),1].slice(0,a);return[o,i,l,u]}function Yv(e,t,n){const r=e.shape.length;Pf(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),Pf(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let s=0;s<r;++s)Pf(t[s]+n[s]<=e.shape[s],(()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`))}function Kv(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function Xv(e,t,n,r){const s=[...e];for(let e=s.length;e<r.length;e++)s.push(1);for(let e=0;e<n;e++)0===e?s[t]=1:(s.splice(t,0,1),s.pop());return s}function qv(e,t,n){return n<=e?n:n-(t-1)}function Zv(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Jv(e,t,n,r,s){const a=[...s],i=Zv(n,t);for(let s=0;s<a.length;s++)if(i.indexOf(s)>-1)a[s]=0;else{const i=qv(t,n,s);let A=r[i];e&1<<i&&(A=0),a[s]=A}return a}function $v(e,t,n,r,s){const a=[...s],i=Zv(n,t);for(let s=0;s<a.length;s++)if(i.indexOf(s)>-1)a[s]=Number.MAX_SAFE_INTEGER;else{const i=qv(t,n,s);let A=r[i];e&1<<i&&(A=Number.MAX_SAFE_INTEGER),a[s]=A}for(let e=0;e<a.length;e++){const t=s[e];a[e]<0&&(a[e]+=t),a[e]=Nf(0,a[e],s[e])}return a}function eE(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function tE(e,t,n,r,s,a){let i=t[s];const A=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=A>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const o=r[s];return i<0&&(i+=o),i=Nf(0,i,o-1),i}function nE(e,t,n,r,s,a){let i=t[s];const A=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=A>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const o=r[s];return i<0&&(i+=o),i=A>0?Nf(0,i,o):Nf(-1,i,o-1),i}function rE(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function sE(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function aE(e,t,n){let r;const s=e.shape.length;let a;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{Pf(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(Pf(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function iE(e,t,n,r,s,a,i,A,o){let l;if(null==r?(l=new Array(t.length),l.fill(1)):l=r,null!=i&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const c={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:A,shrinkAxisMask:o};for(let e=0;e<c.dims;e++)u&&1<<e&A&&c.numAddAxisAfterEllipsis++,1<<e&i&&(u=!0);u||(c.ellipsisMask|=1<<c.dims,c.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(c,d);let h=!0,f=!0,g=!0;const p=[],m=[];for(let t=0;t<e.length;++t){if(0===d.strides[t])throw Error(`strides[${t}] must be non-zero`);const n=!!(d.shrinkAxisMask&1<<t),r=e[t];if(-1===r){p.push(n?1:-1);continue}const s=[d.beginMask&1<<t,d.endMask&1<<t],a=[d.strides[t]>0?0:-1,d.strides[t]>0?r:r-1];if(n&&d.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===d.strides[t];const i=!!(d.beginMask&1<<t&&d.endMask&1<<t);if(d.beginValid&&d.endValid){if(n){const e=d.begin[t]<0?r+d.begin[t]:d.begin[t];if(d.begin[t]=e,d.end[t]=d.begin[t]+1,e<0||e>=r)throw Error(`slice index ${d.begin[t]} of dimension ${t} out of bounds.`)}else d.begin[t]=AE(d.begin[t],0,d.strides[t],r,s,a),d.end[t]=AE(d.end[t],1,d.strides[t],r,s,a);const e=1===d.strides[t]&&0===d.begin[t]&&d.end[t]===r;h=h&&e,f=f&&(0===t&&1===d.strides[t]||e)}else h=h&&1===d.strides[t]&&i,f=f&&(0===t&&1===d.strides[t]||i);let A,o=!1;if(d.beginValid&&d.endValid?(A=d.end[t]-d.begin[t],o=!0):n?(A=1,o=!0):i&&r>=0&&(A=d.strides[t]<0?-r:r,o=!0),o){let e;e=0===A||A<0!=d.strides[t]<0?0:Math.trunc(A/d.strides[t])+(A%d.strides[t]!==0?1:0),p.push(e)}else p.push(-1)}for(let e=0;e<d.finalShapeGatherIndices.length;++e){const t=d.finalShapeGatherIndices[e];t>=0?m.push(p[t]):-2===t&&m.push(1)}const b=m.filter(((e,t)=>-2!==d.finalShapeGatherIndices[t]));return{finalShapeSparse:b,finalShape:m,isIdentity:h,sliceDim0:f,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function AE(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}var oE=Object.freeze({__proto__:null,assertParamsValid:Yv,computeFlatOffset:sE,computeOutShape:Kv,getNormalizedAxes:function(e,t,n,r,s,a,i,A,o){const l=e.length;let u=new Array(l),c=new Array(l),d=new Array(l);if(t.length&&n>0){const o=t[0],l=n+1;u=Jv(i,o,l,r,e),c=$v(A,o,l,s,e),d=Xv(a,o,l,e)}else for(let t=0;t<l;t++)u[t]=tE(i,r,a,e,t,o),c[t]=nE(A,s,a,e,t,o),d[t]=eE(a,t,o);return{begin:u,end:c,strides:d}},isSliceContinous:rE,maskToAxes:function(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t},parseSliceParams:aE,sliceInfo:iE,startForAxis:tE,startIndicesWithElidedDims:Jv,stopForAxis:nE,stopIndicesWithElidedDims:$v,stridesForAxis:eE,stridesWithElidedDims:Xv});const lE=class{static sgd(e){return new _v(e)}static momentum(e,t,n=!1){return new Vv(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new Hv(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new Lv(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new Ov(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new Wv(e,t,n,r,s)}static adagrad(e,t=.1){return new Rv(e,t)}},uE="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function cE(){return new Promise((e=>uE((()=>e()))))}function dE(e,t){const n=e[0].length;e.forEach(((e,t)=>{Pf(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),Pf(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,s)=>{for(let a=0;a<n;a++)Pf(a===t||e[a]===r[a],(()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`))}))}function hE(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var fE;function gE(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],A=r[i];if(a>=0)if(A>=0){if(A!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${A}`)}else r[i]=a}return r}function pE(e){const t={FIRST_DIM_SIZE:fE.FIRST_DIM_SIZE,VALUE_ROWIDS:fE.VALUE_ROWIDS,ROW_LENGTHS:fE.ROW_LENGTHS,ROW_SPLITS:fE.ROW_SPLITS,ROW_LIMITS:fE.ROW_LIMITS,ROW_STARTS:fE.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function mE(e){return 0===e.length?0:e[0]===fE.FIRST_DIM_SIZE?e.length-1:e.length}function bE(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const n=e[s],r=t[s+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${n} but ragged tensor input.flatValues.shape[${s-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(fE||(fE={}));function CE(e){return e<=30?e:tg(e,Math.floor(Math.sqrt(e)))}function IE(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function wE(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)s=s.concat([e[r+1]/t[r],t[r]]);s=s.concat(e.slice(n+1))}return s}function kE(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function xE(e,t,n,r=!0){const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?s.push(t[n-1]*e[n]):s.push(e[n]/t[n-1]):s.push(e[n]);return s}function yE(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function vE(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}const EE=1.7580993408473768,BE=1.0507009873554805,ME=.3275911,DE=.254829592,TE=-.284496736,SE=1.421413741,NE=-1.453152027,GE=1.061405429;function FE(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function PE(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function QE(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function zE(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function OE(e,t){return{real:e[2*t],imag:e[2*t+1]}}function RE(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function LE(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function WE(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const _E="->",VE=/->/g;function HE(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(VE,"").length)/2;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${_E}").`);const[r,s]=e.split(_E);Pf(-1===r.indexOf("..."),(()=>'The ellipsis notation ("...") is not supported yet.'));const a=r.split(","),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const A=[];for(let e=0;e<s.length;++e){const t=s[e];if(!a.some((e=>-1!==e.indexOf(t))))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===A.indexOf(t)&&A.push(t)}for(let e=0;e<r.length;++e){const t=r[e];-1===A.indexOf(t)&&","!==t&&A.push(t)}const o=new Array(a.length);for(let e=0;e<i;++e){if(new Set(a[e].split("")).size!==a[e].length)throw new Error(`Found duplicate axes in input component ${a[e]}. Support for duplicate axes in input is not implemented yet.`);o[e]=[];for(let t=0;t<a[e].length;++t)o[e].push(A.indexOf(a[e][t]))}const l=A.length,u=[];for(let e=s.length;e<l;++e)u.push(e);return{allDims:A,summedDims:u,idDims:o}}function UE(e,t){let n=new Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;const r=[];for(let t=0;t<e;++t)-1===n[t]&&r.push(t);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function jE(e,t,n){const r=new Array(e);for(let e=0;e<n.length;++e){const s=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===r[t[e][n]]?r[t[e][n]]=s[n]:Pf(r[t[e][n]]===s[n],(()=>`Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(s)}, but got dimension ${s[n]}`))}}function YE(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let e=0;e<s;++e)r.push([]);const a=[];for(let e=0;e<n.length;++e){const s=XE(t,n[e]);for(const t of s)-1===a.indexOf(t)&&(r[e].push(t),a.push(t))}return{path:n,steps:r}}function KE(e){return e.every(((e,t)=>e===t))}function XE(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function qE(e,t,n=0){let r=[];if("number"==typeof t)Pf(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Pf(s<=1,(()=>"There should be only one negative value in split array."));const a=t.indexOf(-1);if(-1!==a){const r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}Pf(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function ZE(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function JE(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function $E(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function eB(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function tB(e,t){return`size ${e} must be non-negative, not ${t}`}function nB(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function rB(e,t){return`Input to reshape is a SparseTensor with ${Of(e)}\n  dense values, but the requested shape requires a multiple of ${Of(t)}. inputShape=${e} outputShape= ${t}`}function sB(e,t){return`Input to reshape is a tensor with ${Of(e)} dense values, but the requested shape has ${Of(t)}. inputShape=${e} outputShape=${t}`}function aB(){return"segment ids must be >= 0"}function iB(){return"segment ids are not increasing"}function AB(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function oB(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function lB(e,t){let n,r=!1;for(e<=30?(n=e,r=!0):n=tg(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=tg(e,n+1);return n}function uB(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function cB(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const i=e.shape[n],A=[];let o=1,l=1,u=1;for(let t=0;t<r;++t)A.push(e.shape[t]),o*=e.shape[t];for(let t=r;t<n;t++)A.push(e.shape[t]),l*=e.shape[t];for(let e=r;e<s;e++)A.push(t.shape[e]);for(let t=n+1;t<a;t++)A.push(e.shape[t]),u*=e.shape[t];return{batchSize:o,sliceSize:u,outerSize:l,dimSize:i,outputShape:A}}var dB=Object.freeze({__proto__:null,collectGatherOpShapeInfo:cB,computeOutShape:uB,segOpComputeOptimalWindowSize:lB});function hB(e){try{return e.map((e=>oC(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function fB(e){return e.map((e=>AC(e)))}var gB=Object.freeze({__proto__:null,ERF_A1:DE,ERF_A2:TE,ERF_A3:SE,ERF_A4:NE,ERF_A5:GE,ERF_P:ME,PARALLELIZE_THRESHOLD:30,get RowPartitionType(){return fE},SELU_SCALE:BE,SELU_SCALEALPHA:EE,applyActivation:Ky,assertAndGetBroadcastShape:Ak,assertAxesAreInnerMostDims:Ik,assertParamsConsistent:dE,assignToTypedArray:RE,axesAreInnerMostDims:pk,calculateShapes:Qy,checkEinsumDimSizes:jE,checkPadOnDimRoundingMode:ww,combineLocations:mk,combineRaggedTensorToTensorShapes:gE,complexWithEvenIndex:QE,complexWithOddIndex:zE,computeConv2DInfo:uw,computeConv3DInfo:cw,computeDefaultPad:dw,computeDilation2DInfo:Aw,computeOptimalWindowSize:CE,computeOutAndReduceShapes:bk,computeOutShape:hE,computePool2DInfo:ow,computePool3DInfo:lw,convertConv2DDataFormat:Iw,decodeEinsumEquation:HE,eitherStridesOrDilationsAreOne:bw,expandShapeToKeepDim:Ck,exponent:WE,exponents:LE,fromStringArrayToUint8:fB,fromUint8ToStringArray:hB,getAxesPermutation:wk,getBroadcastDims:ak,getComplexWithIndex:OE,getEinsumComputePath:YE,getEinsumPermutation:UE,getFusedBiasGradient:Yy,getFusedDyActivation:jy,getImageCenter:IE,getInnerMostAxes:xk,getPermuted:kE,getRaggedRank:mE,getReductionAxes:ik,getReshaped:wE,getReshapedPermuted:xE,getRowPartitionTypesHelper:pE,getSliceBeginCoords:yE,getSliceSize:vE,getSparseFillEmptyRowsIndicesDenseShapeMismatch:ZE,getSparseFillEmptyRowsNegativeIndexErrorMessage:JE,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:$E,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:nB,getSparseReshapeInputOutputMismatchErrorMessage:sB,getSparseReshapeInputOutputMultipleErrorMessage:rB,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:eB,getSparseReshapeNegativeOutputDimErrorMessage:tB,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:oB,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:aB,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:iB,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:AB,getUndoAxesPermutation:kk,isIdentityPermutation:KE,log:function(...e){gg().getBool("IS_TEST")||gg().getBool("PROD")||console.log(...e)},mergeRealAndImagArrays:FE,prepareAndValidate:jv,prepareSplitSize:qE,segment_util:dB,shouldFuse:Xy,slice_util:oE,splitRealAndImagArrays:PE,stridesOrDilationsArePositive:Cw,tupleValuesAreOne:mw,upcastType:SC,validateDefaultValueShape:bE,validateInput:function(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Py(n,t,e)},validateUpdateShape:Py,warn:Db});!function(){for(const e of Uv)Qv(e)}();const pB={kernelName:Ig,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>KI(e,Ty(_I(n,"float32"),-1))}}},mB={kernelName:wg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Dk(_I(n,"float32")),r=Mk(rx(Bk(1),t));return ex(YI(e,r))}}}},bB={kernelName:kg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Mk(rx(Dk(_I(n,"float32")),1));return YI(e,t)}}}},CB={kernelName:xg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ak(n.shape,r.shape);return{a:()=>{let t=e;const r=ik(n.shape,s);return r.length>0&&(t=Tk(t,r)),kw(t,n.shape)},b:()=>{let t=e;const n=ik(r.shape,s);return n.length>0&&(t=Tk(t,n)),kw(t,r.shape)}}}},IB={kernelName:yg,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},wB={kernelName:Bg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>uk(n)}}},kB={kernelName:Mg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>uk(n)}}},xB={kernelName:Dg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>YI(e,Mk(rx(Bk(1),Dk(_I(n,"float32")))))}}},yB={kernelName:Tg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Mk(UI(Bk(1),Dk(_I(n,"float32"))));return YI(e,t)}}}},vB={kernelName:Gg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ak(n.shape,r.shape);return{a:()=>{const t=UI(Dk(n),Dk(r));let a=KI(e,YI(r,t));const i=ik(n.shape,s);return i.length>0&&(a=Tk(a,i)),kw(a,n.shape)},b:()=>{const t=UI(Dk(n),Dk(r));let a=ex(KI(e,YI(n,t)));const i=ik(r.shape,s);return i.length>0&&(a=Tk(a,i)),kw(a,r.shape)}}}},EB={kernelName:Sg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>YI(e,UI(Dk(_I(n,"float32")),1))}}},BB={kernelName:Ng,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>YI(e,rx(Bk(1),Dk(_I(n,"float32"))))}}};const MB=JC({avgPool3dGrad_:function(e,t,n,r,s,a){const i=qC(e,"dy","avgPool3dGrad"),A=qC(t,"input","avgPool3dGrad");let o=i,l=A,u=!1;4===A.rank&&(u=!0,o=kw(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=kw(A,[1,A.shape[0],A.shape[1],A.shape[2],A.shape[3]])),Pf(5===o.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${o.rank}.`)),Pf(5===l.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`)),ww("avgPool3dGrad",s,a);const c={dy:o,input:l},d={filterSize:n,strides:r,pad:s,dimRoundingMode:a},h=_C.runKernel(zg,c,d);return u?kw(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),DB={kernelName:Qg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:A}=n;return{x:()=>MB(e,r,s,a,i,A)}}};const TB=JC({avgPoolGrad_:function(e,t,n,r,s){const a=qC(e,"dy","avgPoolGrad"),i=qC(t,"input","avgPoolGrad");Pf(i.rank===a.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`));let A=i,o=a,l=!1;3===i.rank&&(l=!0,A=kw(i,[1,i.shape[0],i.shape[1],i.shape[2]]),o=kw(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Pf(4===o.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),Pf(4===A.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${A.rank}.`));const u={dy:o,input:A},c={filterSize:n,strides:r,pad:s},d=_C.runKernel(Pg,u,c);return l?kw(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),SB={kernelName:Fg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>TB(e,r,s,a,i)}}},NB={kernelName:Og,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return a||i?!a&&i?{a:()=>Ew(e,s,!1,!1),b:()=>Ew(e,r,!0,!1)}:a&&!i?{a:()=>Ew(s,e,!1,!0),b:()=>Ew(r,e,!1,!1)}:{a:()=>Ew(s,e,!0,!0),b:()=>Ew(e,r,!0,!0)}:{a:()=>Ew(e,s,!1,!0),b:()=>Ew(r,e,!0,!1)}}},GB={kernelName:Rg,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>yx(e,r,s)}}},FB={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let e=s.length-1;e>=0;e--)if(s[e]===a[e])i[e]=1;else if(1!==s[e])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const A=[];for(let e=0;e<i.length;e++)i[e]>1&&A.push(e);return{x:()=>Tk(e,A,!0)}}},PB={kernelName:Vg,gradFunc:e=>({x:()=>e.clone()})},QB={kernelName:Hg,gradFunc:e=>({x:()=>uk(e)})},zB={kernelName:Ug,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>lk(ix(_k(r,s),Xk(r,a)),e,uk(e))}}},OB={kernelName:Yg,inputsToSave:["x"],gradFunc:pB.gradFunc},RB={kernelName:Kg,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:s}=n,a=Uf(s,t[0].shape)[0],i=r.map((e=>e[a]));return vy(e,i,a).map((e=>()=>e))}},LB={kernelName:Xg,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:A,dataFormat:o}=n;return Pf(mw(a),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`)),{x:()=>jw(r.shape,e,s,i,A,o),filter:()=>Uy(r,e,s.shape,i,A,o)}}},WB={kernelName:Zg,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:A,dimRoundingMode:o}=n;return{dy:()=>Hw(e,s,a,i,A,1,o),filter:()=>Uy(e,r,s.shape,a,i,A,o)}}};const _B=JC({conv3DBackpropFilter_:function(e,t,n,r,s){let a=e;4===e.rank&&(a=kw(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=kw(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Pf(5===a.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`)),Pf(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),Pf(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),Pf(a.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`)),Pf(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));const A={x:a,dy:i},o={strides:r,pad:s,filterShape:n};return _C.runKernel($g,A,o)}}),VB={kernelName:Jg,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;Pf(mw(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[i,A]=t;return{x:()=>Xw(i.shape,e,A,s,a),filter:()=>_B(i,e,A.shape,s,a)}}},HB={kernelName:tp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>KI(ex(gy(_I(n,"float32"))),e)}}},UB={kernelName:np,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>KI(py(_I(n,"float32")),e)}}},jB={kernelName:sp,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const t=wk([s],r.rank);let n=ek(e,s,a,!i);return null!=t&&(n=Vy(n,t)),n}}}},YB={kernelName:op,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,A=null==r?[1,1]:r;Pf(mw(A),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${A}'`));const[o,l]=t;return Pf(4===o.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${o.rank}.`)),Pf(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`)),Pf(o.shape[3]===l.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${o.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`)),Pf(bw(s,A),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${A}'.`)),ww("depthwiseConv2d",a,i),{x:()=>Jy(o.shape,e,l,s,a,A,i),filter:()=>Zy(o,e,l.shape,s,a,A,i)}}},KB={kernelName:dp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>_C.runKernel(hp,a,n),filter:()=>_C.runKernel(fp,i,n)}}},XB={kernelName:mp,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>_C.runKernel(bp,r)}}},qB={kernelName:Cp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=KI(Fk(ex(Dk(n))),2/Math.sqrt(Math.PI));return{x:()=>KI(e,r)}}},ZB={kernelName:wp,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>KI(e,n)}}},JB={kernelName:kp,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>kw(e,n.shape)}}},$B={kernelName:xp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>KI(e,Fk(n))}}},eM={kernelName:Bp,gradFunc:e=>({x:()=>uk(e)})},tM={kernelName:Mp,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ak(n.shape,r.shape);return{a:()=>{const t=YI(e,_I(r,"float32")),a=ik(n.shape,s);return a.length>0?kw(Tk(t,a),n.shape):t},b:()=>{let t=KI(e,_I(n,"float32"));const a=ik(r.shape,s);a.length>0&&(t=kw(Tk(t,a),r.shape));const i=Dk(r);return ex(YI(t,_I(i,"float32")))}}}},nM={kernelName:Dp,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,A]=t,o=null==A?Bk(1):A,l=ik(a.shape,s.shape),u=[];if(1===a.rank){for(let e=0;e<s.shape.length-1;++e)u.push(s.shape[e]);u.push(1)}const c=rx(s,a),d=KI(e,o),h=cy(UI(i,Bk(r))),f=KI(KI(KI(h,h),h),Bk(-.5));return{x:()=>1===a.rank?kw(KI(KI(e,zk(kw(h,[1,1,1,a.shape[0]]),u)),o),s.shape):kw(KI(KI(e,h),o),s.shape),mean:()=>{let e=KI(KI(h,Bk(-1)),d);return 1===a.rank&&(e=Tk(e,l)),kw(e,a.shape)},variance:()=>{let e=KI(KI(f,c),d);return 1===a.rank&&(e=Tk(e,l)),kw(e,a.shape)},scale:()=>{const t=KI(c,h);let n=KI(e,t);return 1===a.rank&&(n=Tk(n,l)),kw(n,a.shape)},offset:()=>{let t=e;return 1===a.rank&&(t=Tk(t,l)),kw(t,a.shape)}}}},rM={kernelName:Tp,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a,batchDims:i}=n,A=Uf(a,r.shape)[0],o=(e,t,n)=>()=>{const r=e.shape,s=t.size,i=r.slice(0,A),o=i.length,l=r.slice(a,r.length).slice(1),u=l.length,c=sM(0,o),d=sM(o+1,o+1+u),h=aM([i,[s],l]),f=kw(n,h),g=kw(t,[s]),p=aM([[o],c,d]),m=Vy(f,p);let b=Ly(m,g,e.shape[A]);const C=kk(p);return b=Vy(b,C),b};if(1===i){const t=r.shape[0],n=r.split(t,0),a=()=>{const t=Dy(n.map(((t,n)=>o(t,s.slice(n,1),e.slice(n,1))())));return t.reshape(r.shape)};return{x:a,indices:()=>s}}return{x:o(r,s,e),indices:()=>s}}};function sM(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function aM(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const iM={kernelName:Gp,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>uk(n),b:()=>uk(r)}}},AM={kernelName:Fp,gradFunc:e=>({x:()=>_I(e,"float32")})},oM={kernelName:zp,gradFunc:e=>({x:()=>uk(e)})},lM={kernelName:Op,gradFunc:e=>({x:()=>uk(e)})},uM={kernelName:Rp,gradFunc:e=>({x:()=>uk(e)})},cM={kernelName:Lp,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=Wk(r,0);return{x:()=>lk(a,e,KI(e,s))}}},dM={kernelName:Up,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>YI(e,UI(n,1))}}},hM={kernelName:Hp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>YI(e,_I(n,"float32"))}}},fM={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const t=Fk(r);return rx(e,KI(Tk(e,s,!0),t))}}}};const gM=JC({localResponseNormalizationBackprop_:function(e,t,n,r=5,s=1,a=1,i=.5){const A={x:e,y:t,dy:n},o={depthRadius:r,bias:s,alpha:a,beta:i};return _C.runKernel(qp,A,o)}}),pM={kernelName:Xp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:A,beta:o}=n;return{x:()=>gM(r,s,e,a,i,A,o)}}};function mM(e,t,n,r){return t.rank<n.rank&&(t=kw(t,Ck(t.shape,r))),e.rank<n.rank&&(e=kw(e,Ck(e.shape,r))),{x:()=>KI(e,_I(ok(n,t),e.dtype))}}const bM={kernelName:Zp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=mM(e,t[1],a,Uf(s,a.shape));return{x:()=>i.x()}}},CM={kernelName:Jp,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>KI(e,_I(_k(n,r),"float32")),b:()=>KI(e,_I(Kk(n,r),"float32"))}}};const IM=JC({maxPool3dGrad_:function(e,t,n,r,s,a,i){const A=qC(e,"dy","maxPool3dGrad"),o=qC(t,"input","maxPool3dGrad"),l=qC(n,"output","maxPool3dGrad");let u=A,c=o,d=l,h=!1;4===o.rank&&(h=!0,u=kw(A,[1,A.shape[0],A.shape[1],A.shape[2],A.shape[3]]),c=kw(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=kw(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),Pf(5===u.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`)),Pf(5===c.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${c.rank}.`)),Pf(5===d.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`)),ww("maxPool3dGrad",a,i);const f={dy:u,input:c,output:d},g={filterSize:r,strides:s,pad:a,dimRoundingMode:i},p=_C.runKernel(nm,f,g);return h?kw(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),wM={kernelName:tm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:A,dimRoundingMode:o}=n;return{x:()=>IM(e,r,s,a,i,A,o)}}};const kM=JC({maxPoolGrad_:function(e,t,n,r,s,a,i){const A=qC(e,"dy","maxPoolGrad"),o=qC(t,"input","maxPoolGrad"),l=qC(n,"output","maxPoolGrad");Pf(o.rank===A.rank,(()=>`Rank of input (${o.rank}) does not match rank of dy (${A.rank})`)),Pf(4===A.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${A.rank}.`)),Pf(4===o.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${o.rank}.`)),ww("maxPoolGrad",a,i);const u={dy:A,input:o,output:l},c={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return _C.runKernel(em,u,c)}}),xM={kernelName:$p,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:A}=n;return{x:()=>kM(e,r,s,a,i,A)}}},yM={kernelName:sm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=Uf(s,r.shape),i=Of(bk(r.shape,a)[1]);return{x:()=>{const t=r.shape.slice();a.forEach((e=>{t[e]=1}));const n=kw(e,t);return YI(KI(n,gx(r.shape,"float32")),i)}}}},vM={kernelName:am,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,A=mM(e,i,a,Uf(s,a.shape));return{x:()=>A.x()}}},EM={kernelName:im,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>KI(e,_I(Xk(n,r),"float32")),b:()=>KI(e,_I(Wk(n,r),"float32"))}}},BM={kernelName:Am,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>Mw(e,a,r.shape)}}},MM={kernelName:om,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ak(n.shape,r.shape);return{a:()=>{const t=ik(n.shape,s);return t.length>0?kw(Tk(e,t),n.shape):e},b:()=>{const t=KI(e,ex(Rk(YI(n,r)))),a=ik(r.shape,s);return a.length>0?kw(Tk(t,a),r.shape):t}}}},DM={kernelName:um,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ak(n.shape,r.shape);return{a:()=>{const t=KI(e,_I(r,"float32")),a=ik(n.shape,s);return a.length>0?kw(Tk(t,a),n.shape):t},b:()=>{const t=KI(e,_I(n,"float32")),a=ik(r.shape,s);return a.length>0?kw(Tk(t,a),r.shape):t}}}},TM={kernelName:bm,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return Wy(e,r).map((e=>()=>e))}},SM={kernelName:Cm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>Mw(e,a,r.shape)}}},NM={kernelName:Im,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,A=Ak(a.shape,i.shape);return{a:()=>{const t=_I(i,"float32");let n=KI(e,KI(t,Ek(a,rx(t,Bk(1)))));const r=ik(a.shape,A);return r.length>0&&(n=Tk(n,r)),kw(n,a.shape)},b:()=>{const t=Wk(a,0),n=lk(t,Zk(a),uk(a));let r=KI(e,KI(s,n));const o=ik(i.shape,A);return o.length>0&&(r=Tk(r,o)),kw(r,i.shape)}}}},GM={kernelName:wm,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=Wk(n,0);return{x:()=>lk(s,e,KI(e,r)),alpha:()=>{let t=lk(s,uk(e),KI(e,n));const a=ik(r.shape,e.shape);return a.length>0&&(t=Tk(t,a)),kw(t,r.shape)}}}};function FM(e,t,n){const r=e.shape.length,s=r-n.length,a=wk(n,r);let i=e;null!=a&&(i=Vy(e,a));const A=i.shape.slice(),o=A.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);A.push(o);let l=function(e,t,n){const r=e.shape.slice();r[n]=1;const s=kw(t,r),a=$w(e,n,!0,!1),i=$w(e,n,!0,!0),A=KI(a,i);return KI(s,A)}(i.reshape(A),t,s);if(l=l.reshape(i.shape),null!=a){const e=kk(a);l=Vy(l,e)}return l}const PM={kernelName:km,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;let a=[];return a=null==s?r.shape.map(((e,t)=>t)):"number"==typeof s?[s]:s,{x:()=>FM(r,e,a)}}},QM={kernelName:gp,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ak(n.shape,r.shape);return{a:()=>{const t=YI(e,_I(r,"float32")),a=ik(n.shape,s);return a.length>0?kw(Tk(t,a),n.shape):t},b:()=>{let t=KI(e,_I(n,"float32"));const a=ik(r.shape,s);a.length>0&&(t=kw(Tk(t,a),r.shape));const i=Dk(r);return ex(YI(t,_I(i,"float32")))}}}},zM={kernelName:Mm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>YI(e,ex(Dk(n)))}}},OM={kernelName:Pm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=KI(Xk(n,6),Ty(n));return{x:()=>KI(e,_I(r,"float32"))}}},RM={kernelName:Dm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>KI(e,_I(Ty(n),"float32"))}}},LM={kernelName:Tm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>kw(e,n.shape)}}},WM={kernelName:Om,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ex(YI(e,KI(Ek(n,1.5),2)))}}},_M={kernelName:Vm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Wk(n,Bk(0)),r=Bk(EE),s=Bk(BE),a=KI(e,s),i=KI(KI(e,r),Fk(_I(n,"float32")));return lk(t,a,i)}}}},VM={kernelName:Km,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>KI(e,KI(n,rx(Bk(1),n)))}}},HM={kernelName:Um,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>KI(Zw(_I(n,"float32")),e)}}},UM={kernelName:jm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>KI(Jw(_I(n,"float32")),e)}}},jM={kernelName:Hm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[A,o]=aE(r,s,a),l=[];for(let t=0;t<e.rank;t++)l.push([A[t],i[t]-A[t]-o[t]]);return{x:()=>xx(e,l)}}},YM={kernelName:eb,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=KI(e,r);return{logits:()=>rx(a,KI(Tk(a,[s],true),r))}}},KM={kernelName:Xm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>KI(e,Bw(n))}}},XM={kernelName:Jm,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>Tw(e,r,s)}}},qM={kernelName:$m,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>vw(e,r)}}},ZM={kernelName:qm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>YI(e,KI(Mk(_I(n,"float32")),2))}}},JM={kernelName:Ab,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>KI(e,KI(_I(n,"float32"),2))}}},$M={kernelName:ib,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Bk(2);return{a:()=>KI(e,KI(s,rx(n,r))),b:()=>KI(e,KI(s,rx(r,n)))}}},eD={kernelName:hb,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ak(n.shape,r.shape);return{a:()=>{let t=e;const r=ik(n.shape,s);return r.length>0&&(t=Tk(t,r)),kw(t,n.shape)},b:()=>{let t=e;const n=ik(r.shape,s);return n.length>0&&(t=Tk(t,n)),kw(ex(t),r.shape)}}}},tD={kernelName:Zm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;Uf(a,r.shape).forEach((e=>{s[e]=1}));const i=kw(e,s),A=KI(i,gx(r.shape,"float32"));return{x:()=>A}}},nD={kernelName:fb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>YI(e,Dk(Zw(n)))}}},rD={kernelName:gb,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>KI(rx(Bk(1),Dk(n)),e)}}},sD={kernelName:pb,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let t=uk(r);if(1===r.rank)for(let n=0;n<s[0];++n)t=UI(t,Mw(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)t=UI(t,Mw(e,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)t=UI(t,Mw(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)for(let A=0;A<s[3];++A)t=UI(t,Mw(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2],A*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},aD={kernelName:kb,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=dx(t,uk(t)),r=Lk(e,n);let s=_k(t,Bk(0,"int32"));const a=r.rank-s.rank;for(let e=0;e<a;++e)s=Pk(s,e+1);s=ix(s,gx(r.shape,"bool"));const i=uk(r);return lk(s,r,i)}(e,n)}}};const iD=[pB,mB,bB,CB,IB,wB,kB,xB,yB,vB,EB,BB,DB,SB,NB,GB,FB,PB,QB,zB,OB,RB,WB,LB,VB,HB,UB,jB,YB,KB,QM,XB,qB,ZB,JB,$B,tM,eM,nM,rM,iM,AM,oM,lM,uM,cM,dM,hM,fM,pM,bM,bM,CM,wM,xM,yM,vM,EM,BM,MM,DM,{kernelName:cm,gradFunc:e=>({x:()=>ex(e)})},{kernelName:mm,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>fx(n.shape,"float32")}}},{kernelName:pm,gradFunc:e=>({x:()=>uk(e)})},TM,SM,SM,NM,GM,PM,zM,OM,RM,LM,{kernelName:Gm,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>_C.runKernel(Fm,s,n)}}},{kernelName:Sm,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>_C.runKernel(Nm,s,n)}}},{kernelName:Qm,gradFunc:(e,t,n)=>{const{dims:r}=n,s=Uf(r,e.shape);return{x:()=>ly(e,s)}}},{kernelName:zm,gradFunc:e=>({x:()=>uk(e)})},WM,{kernelName:_m,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>_I(uk(n),"float32"),t:()=>KI(e,_I(n,e.dtype)),e:()=>KI(e,_I(Ax(n),e.dtype))}}},_M,VM,{kernelName:Ym,gradFunc:e=>({x:()=>uk(e)})},HM,UM,jM,YM,KM,XM,XM,qM,qM,ZM,$M,JM,{kernelName:yb,gradFunc:e=>({x:()=>uk(e)})},eD,tD,nD,rD,sD,{kernelName:Cb,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=kk(s);return{x:()=>Vy(e,a)}}},{kernelName:wb,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>Dy(e,s)}}},aD,{kernelName:xb,gradFunc:e=>({x:()=>uk(e)})}];for(const e of iD)Qb(e);xC().prototype.abs=function(){return this.throwIfDisposed(),XI(this)},xC().prototype.acos=function(){return this.throwIfDisposed(),qI(this)},xC().prototype.acosh=function(){return this.throwIfDisposed(),ZI(this)},xC().prototype.add=function(e){return this.throwIfDisposed(),UI(this,e)},xC().prototype.all=function(e,t){return this.throwIfDisposed(),JI(this,e,t)},xC().prototype.any=function(e,t){return this.throwIfDisposed(),$I(this,e,t)},xC().prototype.argMax=function(e){return this.throwIfDisposed(),ew(this,e)},xC().prototype.argMin=function(e){return this.throwIfDisposed(),tw(this,e)},xC().prototype.asScalar=function(){return this.throwIfDisposed(),Pf(1===this.size,(()=>"The array must have only 1 element.")),kw(this,[])},xC().prototype.asType=function(e){return this.throwIfDisposed(),_I(this,e)},xC().prototype.as1D=function(){return this.throwIfDisposed(),kw(this,[this.size])},xC().prototype.as2D=function(e,t){return this.throwIfDisposed(),kw(this,[e,t])},xC().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),kw(this,[e,t,n])},xC().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),kw(this,[e,t,n,r])},xC().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),kw(this,[e,t,n,r,s])},xC().prototype.asin=function(){return this.throwIfDisposed(),nw(this)},xC().prototype.asinh=function(){return this.throwIfDisposed(),rw(this)},xC().prototype.atan=function(){return this.throwIfDisposed(),sw(this)},xC().prototype.atan2=function(e){return this.throwIfDisposed(),aw(this,e)},xC().prototype.atanh=function(){return this.throwIfDisposed(),iw(this)},xC().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),xw(this,e,t,n,r)},xC().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Tw(this,e,t)},xC().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),Sw(this,e,t,n,r,s)},xC().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Qw(this,e)},xC().prototype.cast=function(e){return this.throwIfDisposed(),_I(this,e)},xC().prototype.ceil=function(){return this.throwIfDisposed(),zw(this)},xC().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Rw(this,e,t)},xC().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof kC&&(e=[e]),vw([this,...e],t)},xC().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Uw(this,e,t,n,r,s,a)},xC().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),Yw(this,e,t,n,r,s)},xC().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Hw(this,e,t,n,r,s,a)},xC().prototype.cos=function(){return this.throwIfDisposed(),Zw(this)},xC().prototype.cosh=function(){return this.throwIfDisposed(),Jw(this)},xC().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),$w(this,e,t,n)},xC().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),ek(this,e,t,n)},xC().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),nk(this,e,t)},xC().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),rk(this,e,t,n,r,s,a)},xC().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),sk(this,e,t,n,r,s)},xC().prototype.divNoNan=function(e){return this.throwIfDisposed(),ck(this,e)},xC().prototype.div=function(e){return this.throwIfDisposed(),YI(this,e)},xC().prototype.dot=function(e){return this.throwIfDisposed(),dk(this,e)},xC().prototype.elu=function(){return this.throwIfDisposed(),fk(this)},xC().prototype.equal=function(e){return this.throwIfDisposed(),ok(this,e)},xC().prototype.erf=function(){return this.throwIfDisposed(),gk(this)},xC().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),Gk(this,e,t)},xC().prototype.exp=function(){return this.throwIfDisposed(),Fk(this)},xC().prototype.expandDims=function(e){return this.throwIfDisposed(),Pk(this,e)},xC().prototype.expm1=function(){return this.throwIfDisposed(),Qk(this)},xC().prototype.fft=function(){return this.throwIfDisposed(),ky(this)},xC().prototype.flatten=function(){return this.throwIfDisposed(),kw(this,[this.size])},xC().prototype.floor=function(){return this.throwIfDisposed(),Rk(this)},xC().prototype.floorDiv=function(e){return this.throwIfDisposed(),jI(this,e)},xC().prototype.gather=function(e,t,n){return this.throwIfDisposed(),Lk(this,e,t,n)},xC().prototype.greaterEqual=function(e){return this.throwIfDisposed(),_k(this,e)},xC().prototype.greater=function(e){return this.throwIfDisposed(),Wk(this,e)},xC().prototype.ifft=function(){return this.throwIfDisposed(),xy(this)},xC().prototype.irfft=function(){return this.throwIfDisposed(),yy(this)},xC().prototype.isFinite=function(){return this.throwIfDisposed(),Hk(this)},xC().prototype.isInf=function(){return this.throwIfDisposed(),Uk(this)},xC().prototype.isNaN=function(){return this.throwIfDisposed(),jk(this)},xC().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Yk(this,e)},xC().prototype.lessEqual=function(e){return this.throwIfDisposed(),Xk(this,e)},xC().prototype.less=function(e){return this.throwIfDisposed(),Kk(this,e)},xC().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),qk(this,e,t,n,r)},xC().prototype.logSigmoid=function(){return this.throwIfDisposed(),nx(this)},xC().prototype.logSoftmax=function(e){return this.throwIfDisposed(),sx(this,e)},xC().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),ax(this,e,t)},xC().prototype.log=function(){return this.throwIfDisposed(),Zk(this)},xC().prototype.log1p=function(){return this.throwIfDisposed(),Jk(this)},xC().prototype.logicalAnd=function(e){return this.throwIfDisposed(),ix(this,e)},xC().prototype.logicalNot=function(){return this.throwIfDisposed(),Ax(this)},xC().prototype.logicalOr=function(e){return this.throwIfDisposed(),ox(this,e)},xC().prototype.logicalXor=function(e){return this.throwIfDisposed(),lx(this,e)},xC().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Ew(this,e,t,n)},xC().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),ux(this,e,t,n,r)},xC().prototype.max=function(e,t){return this.throwIfDisposed(),yk(this,e,t)},xC().prototype.maximum=function(e){return this.throwIfDisposed(),dx(this,e)},xC().prototype.mean=function(e,t){return this.throwIfDisposed(),hx(this,e,t)},xC().prototype.min=function(e,t){return this.throwIfDisposed(),vk(this,e,t)},xC().prototype.minimum=function(e){return this.throwIfDisposed(),px(this,e)},xC().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),mx(this,e,t)},xC().prototype.mod=function(e){return this.throwIfDisposed(),bx(this,e)},xC().prototype.mul=function(e){return this.throwIfDisposed(),KI(this,e)},xC().prototype.neg=function(){return this.throwIfDisposed(),ex(this)},xC().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Nk(this,e,t,n)},xC().prototype.notEqual=function(e){return this.throwIfDisposed(),Ix(this,e)},xC().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),wx(this,e,t,n)},xC().prototype.onesLike=function(){return this.throwIfDisposed(),kx(this)},xC().prototype.pad=function(e,t){return this.throwIfDisposed(),xx(this,e,t)},xC().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),vx(this,e,t,n,r,s,a)},xC().prototype.pow=function(e){return this.throwIfDisposed(),Ek(this,e)},xC().prototype.prelu=function(e){return this.throwIfDisposed(),Ex(this,e)},xC().prototype.prod=function(e,t){return this.throwIfDisposed(),Bx(this,e,t)},xC().prototype.reciprocal=function(){return this.throwIfDisposed(),iy(this)},xC().prototype.relu=function(){return this.throwIfDisposed(),Ay(this)},xC().prototype.relu6=function(){return this.throwIfDisposed(),oy(this)},xC().prototype.reshapeAs=function(e){return this.throwIfDisposed(),kw(this,e.shape)},xC().prototype.reshape=function(e){return this.throwIfDisposed(),kw(this,e)},xC().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),kv(this,e,t,n)},xC().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),xv(this,e,t,n)},xC().prototype.reverse=function(e){return this.throwIfDisposed(),ly(this,e)},xC().prototype.rfft=function(){return this.throwIfDisposed(),Ey(this)},xC().prototype.round=function(){return this.throwIfDisposed(),uy(this)},xC().prototype.rsqrt=function(){return this.throwIfDisposed(),cy(this)},xC().prototype.selu=function(){return this.throwIfDisposed(),dy(this)},xC().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),hy(this,e,t,n,r,s,a)},xC().prototype.sigmoid=function(){return this.throwIfDisposed(),Bw(this)},xC().prototype.sign=function(){return this.throwIfDisposed(),fy(this)},xC().prototype.sin=function(){return this.throwIfDisposed(),gy(this)},xC().prototype.sinh=function(){return this.throwIfDisposed(),py(this)},xC().prototype.slice=function(e,t){return this.throwIfDisposed(),Mw(this,e,t)},xC().prototype.softmax=function(e){return this.throwIfDisposed(),wy(this,e)},xC().prototype.softplus=function(){return this.throwIfDisposed(),tx(this)},xC().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),yx(this,e,t)},xC().prototype.split=function(e,t){return this.throwIfDisposed(),vy(this,e,t)},xC().prototype.sqrt=function(){return this.throwIfDisposed(),Mk(this)},xC().prototype.square=function(){return this.throwIfDisposed(),Dk(this)},xC().prototype.squaredDifference=function(e){return this.throwIfDisposed(),By(this,e)},xC().prototype.squeeze=function(e){return this.throwIfDisposed(),My(this,e)},xC().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof kC?[this,e]:[this,...e];return Dy(n,t)},xC().prototype.step=function(e){return this.throwIfDisposed(),Ty(this,e)},xC().prototype.stridedSlice=function(e,t,n,r,s,a,i,A){return this.throwIfDisposed(),Sy(this,e,t,n,r,s,a,i,A)},xC().prototype.sub=function(e){return this.throwIfDisposed(),rx(this,e)},xC().prototype.sum=function(e,t){return this.throwIfDisposed(),Tk(this,e,t)},xC().prototype.tan=function(){return this.throwIfDisposed(),Ny(this)},xC().prototype.tanh=function(){return this.throwIfDisposed(),Dw(this)},xC().prototype.tile=function(e){return this.throwIfDisposed(),zk(this,e)},xC().prototype.toBool=function(){return this.throwIfDisposed(),_I(this,"bool")},xC().prototype.toFloat=function(){return this.throwIfDisposed(),_I(this,"float32")},xC().prototype.toInt=function(){return this.throwIfDisposed(),_I(this,"int32")},xC().prototype.topk=function(e,t){return this.throwIfDisposed(),zy(this,e,t)},xC().prototype.transpose=function(e){return this.throwIfDisposed(),Vy(this,e)},xC().prototype.unique=function(e){return this.throwIfDisposed(),Ry(this,e)},xC().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Ly(this,e,t)},xC().prototype.unstack=function(e){return this.throwIfDisposed(),Wy(this,e)},xC().prototype.where=function(e,t){return this.throwIfDisposed(),lk(e,this,t)},xC().prototype.zerosLike=function(){return this.throwIfDisposed(),uk(this)};class AD extends Error{constructor(e){super(e),Object.setPrototypeOf(this,AD.prototype)}}class oD extends Error{constructor(e){super(e),Object.setPrototypeOf(this,oD.prototype)}}class lD extends Error{constructor(e){super(e),Object.setPrototypeOf(this,lD.prototype)}}class uD extends Error{constructor(e){super(e),Object.setPrototypeOf(this,uD.prototype)}}class cD extends Error{constructor(e){super(e),Object.setPrototypeOf(this,cD.prototype)}}class dD{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function hD(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function fD(e,t){if(!e)throw new cD(t)}function gD(e,t){let n=0;for(const r of e)r===t&&n++;return n}function pD(e){return 1===e.length?e[0]:e}function mD(e){return Array.isArray(e)?e:[e]}function bD(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function CD(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let ID={};function wD(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function kD(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>kD(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?kD(t):e[n]=t.value)}}}function xD(e,t={},n={},r="object",s=!1){if("string"==typeof e){const s=e;let a;if(s in n)a=n[s];else if(s in ID)a=ID[s];else if(a=t[s],null==a)throw new lD(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=e;if(null==a.className||null==a.config)throw new lD(`${r}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const i=a.className;let A,o;if(i in n?[A,o]=n[i]:i in ID?[A,o]=ID.className:i in t&&([A,o]=t[i]),null==A)throw new lD(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=o){const e={};for(const t of Object.keys(ID))e[t]=ID[t];for(const t of Object.keys(n))e[t]=n[t];a.config.customObjects=e;const t=Object.assign({},ID);for(const e of Object.keys(n))ID[e]=n[e];kD(a.config);const r=o(A,a.config,n,s);return ID=Object.assign({},t),r}{const e=Object.assign({},ID);for(const e of Object.keys(n))ID[e]=n[e];const t=new A(a.config);return ID=Object.assign({},e),t}}}function yD(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function vD(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function ED(e){if(null==e)throw new lD(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function BD(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new lD(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function MD(e,t,n=0,r=1/0){return fD(n>=0),fD(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function DD(e,t){Array.isArray(e)?(Pf(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>DD(e,`element ${n+1} of ${t}`)))):Pf(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${TD(e)}.`))}function TD(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>TD(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function SD(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let ND=0;function GD(){return ND++}const FD={};function PD(e=""){return e in FD||(FD[e]=0),FD[e]+=1,e+FD[e].toString()}const QD=["channelsFirst","channelsLast"],zD=["nearest","bilinear"],OD=["valid","same","causal"],RD=["max","avg"],LD=["sum","mul","concat","ave"],WD=new Map;function _D(e){BD(QD,"DataFormat",e)}function VD(e){BD(OD,"PaddingMode",e)}function HD(e){BD(RD,"PoolMode",e)}const UD=[];function jD(e,t){UD.push(e);try{const e=t();return UD.pop(),e}catch(e){throw UD.pop(),e}}function YD(e){if(!qD(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===UD.length?"":UD.join("/")+"/")+e}function KD(e){if(!qD(e))throw new Error("Not a valid tensor name: '"+e+"'");WD.has(e)||WD.set(e,0);const t=WD.get(e);if(WD.set(e,WD.get(e)+1),t>0){const n=`${e}_${t}`;return WD.set(n,1),n}return e}const XD=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function qD(e){return!!e.match(XD)}function ZD(e){return e===parseInt(e.toString(),10)}function JD(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function $D(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function eT(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function tT(e,t){if(t<e)throw new lD(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}let nT;function rT(){return null==nT&&(nT=_C.backend.epsilon()),nT}function sT(e,t){return _I(e,t)}function aT(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),kw(e,n)}function iT(e,t,n){return aI((()=>{switch(e.rank){case 1:return my(e,t,n);case 2:return by(e,[t,0],[n,e.shape[1]]);case 3:return Cy(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Iy(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Mw(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Mw(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new lD(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function AT(e,t,n){return aI((()=>{switch(e.rank){case 1:return my(e,t,n);case 2:return by(e,[0,t],[e.shape[0],n]);case 3:return Cy(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Iy(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new lD(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function oT(e,t,n,r){return aI((()=>{switch(e.rank){case 1:return my(e,t,n);case 2:switch(r){case 1:return iT(e,t,n);case 2:return AT(e,t,n);default:throw new lD(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return iT(e,t,n);case 2:return Cy(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return AT(e,t,n);default:throw new lD(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return iT(e,t,n);case 2:return Iy(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Iy(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return AT(e,t,n);default:throw new lD(`The axis is not within the rank of the tensor ${r}`)}default:throw new lD(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function lT(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),vw(e,t)}function uT(e,t){switch(e.rank){case 1:return Lw([e,t]);case 2:return Ww([e,t],0);case 3:return _w([e,t],0);case 4:return Vw([e,t],0);default:throw new lD(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function cT(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new lD(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return zk(e,t)}function dT(e,t=0,n=1,r,s){return ny(e,t,n,r,s)}function hT(e,t,n,r){if(e.rank<2||t.rank<2)throw new uD(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new uD(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){return $y({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?pT(e.rank,r,"channelsLast"):null,activation:n})}{const s=e.shape.slice(),a=s.pop();e=kw(e,[-1,a]);const i=t.shape.slice(),A=i.pop(),o=i.pop(),l=[...i,A],u=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=kw(Vy(t,u),[o,-1]);const c=[...s,...l];return kw($y({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?pT(e.rank,r,"channelsLast"):null,activation:n}),c)}}function fT(e,t,n){return aI((()=>(t=Array.isArray(t)?Gy(t,"int32"):_I(t,"int32"),Lk(e,t,n))))}function gT(e){return KI(e,e)}function pT(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new lD(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?kw(t,[1,r[0],1,1,1]):kw(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?kw(t,[1,1,1,1,r[0]]):kw(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?kw(t,[1,r[0],1,1]):kw(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?kw(t,[1,1,1,r[0]]):kw(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?kw(t,[1,r[0],1]):kw(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?kw(t,[1,1,r[0]]):kw(t,[1].concat(r))}else if(e<3)return t;throw new lD(`Unsupported input rank by biasAdd: ${t.rank}`)}function mT(e,t,n){return aI((()=>(null==n&&(n="channelsLast"),_D(n),UI(e,pT(e.rank,t,n)))))}function bT(e,t,n,r){return aI((()=>Hy(e,t,n,r)))}function CT(e,t,n=!1){return n?e():t()}const IT=["fanIn","fanOut","fanAvg"],wT=["normal","uniform","truncatedNormal"];class kT extends Fv{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class xT extends kT{apply(e,t){return fx(e,t)}}xT.className="Zeros",Qv(xT);class yT extends kT{apply(e,t){return gx(e,t)}}yT.className="Ones",Qv(yT);class vT extends kT{constructor(e){if(super(),"object"!=typeof e)throw new lD(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new lD(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return aI((()=>KI(Bk(this.value),gx(e,t))))}getConfig(){return{value:this.value}}}vT.className="Constant",Qv(vT);class ET extends kT{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return ry(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}ET.className="RandomUniform",Qv(ET);class BT extends kT{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new uD(`randomNormal does not support dType ${t}.`);return dT(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}BT.className="RandomNormal",Qv(BT);class MT extends kT{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new uD(`truncatedNormal does not support dType ${t}.`);return Oy(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}MT.className="TruncatedNormal",Qv(MT);class DT extends kT{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return aI((()=>{if(2!==e.length||e[0]!==e[1])throw new lD("Identity matrix initializer can only be used for 2D square matrices.");return KI(this.gain,Ok(e[0]))}))}getConfig(){return{gain:this.gain}}}DT.className="Identity",Qv(DT);class TT extends kT{constructor(e){if(super(),e.scale<0)throw new lD(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,BD(IT,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){BD(wT,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e,t="channelsLast"){let n,r;if(_D(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=JD(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){const t=JD(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{const t=JD(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}(e),r=n[0],s=n[1];let a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new uD(`${this.getClassName()} does not support dType ${t}.`);return Oy(e,0,n,t,this.seed)}{const n=Math.sqrt(3*a);return ry(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}TT.className="VarianceScaling",Qv(TT);class ST extends TT{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return TT.className}}ST.className="GlorotUniform",Qv(ST);class NT extends TT{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return TT.className}}NT.className="GlorotNormal",Qv(NT);class GT extends TT{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return TT.className}}GT.className="HeNormal",Qv(GT);class FT extends TT{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return TT.className}}FT.className="HeUniform",Qv(FT);class PT extends TT{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return TT.className}}PT.className="LeCunNormal",Qv(PT);class QT extends TT{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return TT.className}}QT.className="LeCunUniform",Qv(QT);class zT extends kT{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return aI((()=>{if(e.length<2)throw new uD("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=Of(e.slice(0,-1)),r=e[e.length-1],s=n*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);const a=dT([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=Sv.qr(a,!1);let A=i[0];const o=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return A=KI(A,o.sign()),n<r&&(A=A.transpose()),KI(Bk(this.gain),A.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}zT.className="Orthogonal",Qv(zT);const OT={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function RT(e,t={}){return xD(e,Pv.getMap().classNameMap,t,"initializer")}function LT(e){return wD(e)}function WT(e){if("string"==typeof e){const t=e in OT?OT[e]:e;if("GlorotNormal"===t)return new NT;if("GlorotUniform"===t)return new ST;if("HeNormal"===t)return new GT;if("HeUniform"===t)return new FT;if("LeCunNormal"===t)return new PT;if("LeCunUniform"===t)return new QT;{const e={};return e.className=t,e.config={},RT(e)}}return e instanceof kT?e:RT(e)}function _T(e){return Array.isArray(e)&&Array.isArray(e[0])}function VT(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function HT(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new lD(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function UT(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new lD(`Expected exactly 1 Shape; got ${e.length}`)}return e}function jT(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const YT="Variable";class KT{constructor(e,t="float32",n=YT,r=!0,s=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=GD(),n=null==n?YT:n,this.originalName=YD(n),this.name=KD(this.originalName),this.trainable_=r,this.constraint=s,this.val=function(e,t=!0,n,r){return _C.makeVariable(e,t,n,r)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function XT(e){return e.map((e=>e.read()))}function qT(e){e.forEach((e=>{e[0].write(e[1])}))}class ZT{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class JT{constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=GD(),null!=a&&(this.originalName=YD(a),this.name=KD(this.originalName)),this.rank=t.length}}let $T=0;class eS{constructor(e,t){this.callArgs=t,this.id=$T++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const t of e.inboundLayers)null!=t&&t.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let tS=0;class nS extends Fv{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=tS++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=bD(e)+"_"+PD(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new oD(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new lD(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return pD(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return pD(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new AD(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new AD(`Layer ${this.name} is not connected, no input to return.`);return pD(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new AD(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new AD(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return pD(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=mD(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=mD(this.inputSpec);if(t.length!==n.length)throw new lD(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let e=0;e<t.length;e++){const r=t[e],s=n[e];if(null==s)continue;const a=r.rank;if(null!=s.ndim&&a!==s.ndim)throw new lD(`Input ${e} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(null!=s.maxNDim&&a>s.maxNDim)throw new lD(`Input ${e} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(null!=s.minNDim&&a<s.minNDim)throw new lD(`Input ${e} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(null!=s.dtype&&r.dtype!==s.dtype)throw new lD(`Input ${e} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){const t=r.shape;for(const n in s.axes){const r=Number(n),a=s.axes[n],i=r>=0?t[r]:t[t.length+r];if(null!=a&&-1===[a,null].indexOf(i))throw new lD(`Input ${e} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${a} but got shape ${t}.`)}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const n=s.shape[t],a=r.shape[t];if(null!=n&&null!=a&&n!==a)throw new lD(`Input ${e} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=mD(e),r=function(e){let t=!0;for(const n of mD(e))if(!(n instanceof JT)){t=!1;break}return t}(e),s=function(e){let t=!0;for(const n of mD(e))if(n instanceof JT){t=!1;break}return t}(e);if(r===s)throw new lD("Arguments to apply() must be all SymbolicTensors or all Tensors");return jD(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of mD(e))t.push(n.shape);this.build(pD(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const s=mD(r),a=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),a.push(e);if(r=pD(a),null!=this.activityRegularizer)throw new uD("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=mD(e);const t=[];for(const n of e)t.push(n.shape);return pD(t)}(e),r=this.computeOutputShape(n);let s;const a="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new JT(a,n,this,mD(e),t,this.name,r))):new JT(a,r,this,mD(e),t,this.name),this.addInboundNode(e,s,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new uD("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new AD(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new AD(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new oD(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return jT(this.weights)}build(e){this.built=!0}getWeights(e=!1){return XT(e?this.trainableWeights:this.weights)}setWeights(e){aI((()=>{const t=this.weights;if(t.length!==e.length)throw new lD(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=XT(t);for(let s=0;s<r.length;++s){const a=r[s],i=t[s],A=e[s];if(!Rf(a.shape,A.shape))throw new lD(`Layer weight shape ${a.shape} not compatible with provided weight shape ${A.shape}`);n.push([i,A])}qT(n)}))}addWeight(e,t,n,r,s,a,i,A){if(-1!==this._addedWeightNames.indexOf(e))throw new lD(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=A?A():WT("zeros"));const o=r.apply(t,n),l=new KT(o,n,e,a,i);return o.dispose(),null!=s&&this.addLoss((()=>s.apply(l.read()))),null==a&&(a=!0),a?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=mD(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),s=mD(t),a=mD(r);if(s.length!==a.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let e=0;e<s.length;e++)s[e].kerasMask=a[e]}addInboundNode(e,t,n,r,s,a,i=null){const A=mD(e);t=mD(t),n=mD(n),r=mD(r),s=VT(s),a=VT(a);const o=[],l=[],u=[];for(const e of A)o.push(e.sourceLayer),l.push(e.nodeIndex),u.push(e.tensorIndex);new eS({outboundLayer:this,inboundLayers:o,nodeIndices:l,tensorIndices:u,inputTensors:A,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let e=0;e<t.length;e++)t[e].sourceLayer=this,t[e].nodeIndex=this.inboundNodes.length-1,t[e].tensorIndex=e}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function rS(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=rS(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class sS extends nS{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:PD("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new lD("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new lD("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new lD("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new JT(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new eS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new lD(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}sS.className="InputLayer",Qv(sS);class aS{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof aS)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new lD(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return _I(t,e.dtype)}catch(n){throw new lD(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof JT){if(null==this.id2Value[e.id])throw new lD(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new lD(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof JT){if(null==this.id2Value[e.id])throw new lD(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new lD(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&iI(this.id2Mask)}}const iS=new dD,AS=new dD;function oS(e,t,n,r){const s=null!=n&&n.training,a=Array.isArray(e),i=a?e:[e],A=i.map((e=>e.name)),o=[],l=t.names();for(const e of A)-1!==l.indexOf(e)?o.push(t.getValue(e)):o.push(null);const u=A.join(",")+"|"+t.names().sort().join(",");let c,d=iS.get(u);if(null==d){const e=function(e,t){Pf(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const s=uS(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:e,recipientMap:i}=uS(a,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const e in i)null==r[e]&&(r[e]=new Set),i[e].forEach((t=>r[e].add(t)))}}return{sorted:n,recipientCounts:lS(r)}}(i,t);d=e.sorted,c=e.recipientCounts,iS.put(u,d),AS.put(u,c)}c={},s||Object.assign(c,AS.get(u));const h=new aS(t);for(let e=0;e<d.length;++e){const r=d[e],a=r.sourceLayer;if(a instanceof sS)continue;const i=[],l=[],u=[];let f=!1;for(const e of r.inputs){const n=h.getValue(e),r=h.getMask(e);i.push(n),l.push(r),null!=r&&(f=!0),s||(c[e.name]--,0!==c[e.name]||t.hasKey(e)||-1!==A.indexOf(e.name)||n.isDisposed||!0===e.sourceLayer.stateful||u.push(n))}f&&((n=n||{}).mask=l[0]);const g=mD(a.apply(i,n));let p=null;a.supportsMasking&&(p=a.computeMask(i,l));const m=cS(r),b=Array.isArray(m)?m:[m];for(let e=0;e<b.length;++e){h.hasKey(b[e])||h.add(b[e],g[e],Array.isArray(p)?p[0]:p);const t=A.indexOf(b[e].name);-1!==t&&(o[t]=g[e])}s||iI(u)}return h.disposeMasks(),a?o:o[0]}function lS(e){const t={};for(const n in e)t[n]=e[n].size;return t}function uS(e,t){const n=new Set,r=[],s={};for(const e of t.names())n.add(e);const a=[],i=[];for(a.push(e);a.length>0;){const e=a[a.length-1];if(n.has(e.name)){a.pop();continue}const t=i[i.length-1]===a.length-1;if(0===e.inputs.length||t)a.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(a.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||a.push(t)}}return{sorted:r,recipientMap:s}}function cS(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function dS(e,t){return aI((()=>Mk(Tk(KI(e,e),t,!0))))}gg().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=iS&&iS.setMaxEntries(e),null!=AS&&AS.setMaxEntries(e)}));class hS extends Fv{getConfig(){return{}}}class fS extends hS{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return aI((()=>{const t=dS(e,this.axis),n=Rw(t,0,this.maxValue);return KI(e,YI(n,UI(rT(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}fS.className="MaxNorm",Qv(fS);class gS extends hS{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return aI((()=>YI(e,UI(rT(),dS(e,this.axis)))))}getConfig(){return{axis:this.axis}}}gS.className="UnitNorm",Qv(gS);class pS extends hS{apply(e){return Ay(e)}}pS.className="NonNeg",Qv(pS);class mS extends hS{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return aI((()=>{const t=dS(e,this.axis),n=UI(KI(this.rate,Rw(t,this.minValue,this.maxValue)),KI(1-this.rate,t));return KI(e,YI(n,UI(rT(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}mS.className="MinMaxNorm",Qv(mS);const bS={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function CS(e){return wD(e)}function IS(e,t={}){return xD(e,Pv.getMap().classNameMap,t,"constraint")}function wS(e){if(null==e)return null;if("string"==typeof e){return IS({className:e in bS?bS[e]:e,config:{}})}return e instanceof hS?e:IS(e)}async function kS(e){if(null==e)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if("number"!=typeof a){const e=a;t.push(e.data()),n.push(s),r.push(e)}}if(t.length>0){const s=await Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];iI(r)}}function xS(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}var yS;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(yS||(yS={}));class vS{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class ES{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class BS extends vS{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const e in t){const r=t[e];if("number"==typeof r)this.totals.hasOwnProperty(e)||(this.totals[e]=0),this.totals[e]=this.totals[e]+r*n;else{let t;e in this.totals?t=this.totals[e]:this.totals[e]=0;const s=aI((()=>UI(this.totals[e],KI(r,n))));this.totals[e]=s,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?t[e]=this.totals[e]/this.seen:aI((()=>{const n=KI(YI(1,this.seen),this.totals[e]);t[e]=n,this.totals[e].dispose(),AI(t[e])})))}}class MS extends vS{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const e in t)null==this.history[e]&&(this.history[e]=[]),this.history[e].push(t[e])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const s=this.history[r];for(let a=0;a<s.length;++a)if("number"!=typeof s[a]){const i=s[a];e.push(i.data()),t.push(r),n.push(a)}}const r=await Promise.all(e);for(let e=0;e<r.length;++e){this.history[t[e]][n[e]].dispose(),this.history[t[e]][n[e]]=r[e][0]}}}class DS extends vS{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||cE,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Jf(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,s=null!=n?n():iC();return(...a)=>{const i=null!=n?n():iC();return i-s<t||(s=i,r=e(...a)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await kS(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await kS(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await kS(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await kS(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await kS(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Jf(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await kS(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await kS(e),await this.trainEnd(e))}}function TS(e,t){if(null==e&&(e={}),e instanceof vS)return[e];if(Array.isArray(e)&&e[0]instanceof vS)return e;return mD(e).map((e=>new DS(e,t)))}class SS{constructor(){}static registerCallbackConstructor(e,t){Pf(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),SS.checkForDuplicate(t),null==SS.constructors[e]&&(SS.constructors[e]=[]),SS.constructors[e].push(t)}static checkForDuplicate(e){for(const t in SS.constructors){SS.constructors[+t].forEach((t=>{if(t===e)throw new lD("Duplicate callback constructor.")}))}}static clear(){SS.constructors={}}static createCallbacks(e){const t=[];for(const n in SS.constructors){const r=+n;e>=r&&t.push(...SS.constructors[r])}return t.map((e=>new e))}}function NS(e,t,n,r,s,a,i,A,o){const l=new MS,u=[new BS,...SS.createCallbacks(t)];null!=e&&u.push(...e),u.push(l);const c=new ES(u);return c.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:A,metrics:o}),{callbackList:c,history:l}}function GS(e,t={},n=!1){return xD(e,Pv.getMap().classNameMap,t,"layer",n)}function FS(e,t){return aI((()=>{"float32"!==e.dtype&&(e=_I(e,"float32"));const n=Tk(gT(e),t,!0),r=Ow(n.shape,rT()),s=Mk(dx(n,r));return YI(e,s)}))}function PS(e,t){return aI((()=>hx(gT(rx(t,e)),-1)))}function QS(e,t){return aI((()=>hx(XI(rx(t,e)),-1)))}function zS(e,t){return aI((()=>{const n=rx(e,t),r=Rw(XI(e),rT(),Number.MAX_VALUE),s=XI(YI(n,r));return KI(100,hx(s,-1))}))}function OS(e,t,n=!1){return aI((()=>{if(n)t=wy(t);else{const e=Tk(t,t.shape.length-1,!0);t=YI(t,e)}return t=Rw(t,rT(),1-rT()),ex(Tk(KI(_I(e,"float32"),Zk(t)),t.shape.length-1))}))}function RS(e,t,n=!1){return aI((()=>{const r=_I(Rk(function(e){const t=[JD(e.shape)];return kw(e,t)}(e)),"int32"),s=(t=Rw(t,rT(),1-rT())).shape;return OS(kw(wx(r,s[s.length-1]),s),t,n)}))}function LS(e,t){return aI((()=>{let n;return n=Rw(t,rT(),1-rT()),n=Zk(YI(n,rx(1,n))),hx(function(e,t){if(!Rf(e.shape,t.shape))throw new lD(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return aI((()=>{const n=Ay(t),r=ex(XI(t));return UI(rx(n,KI(t,e)),Jk(Fk(r)))}))}(e,n),-1)}))}function WS(e,t){return aI((()=>{const n=FS(e,-1),r=FS(t,-1),s=KI(n,r);return ex(Tk(s,-1))}))}SS.constructors={};const _S={meanSquaredError:PS,meanAbsoluteError:QS,meanAbsolutePercentageError:zS,meanSquaredLogarithmicError:function(e,t){return aI((()=>{const n=Rw(t,rT(),Number.MAX_VALUE),r=Zk(UI(1,n)),s=Rw(e,rT(),Number.MAX_VALUE),a=Zk(UI(1,s));return hx(gT(rx(r,a)),-1)}))},squaredHinge:function(e,t){return aI((()=>{const n=dx(0,rx(1,KI(e,t)));return hx(gT(n),-1)}))},hinge:function(e,t){return aI((()=>{const n=dx(0,rx(1,KI(e,t)));return hx(n,-1)}))},categoricalHinge:function(e,t){return aI((()=>{const n=Tk(KI(e,t),-1),r=yk(KI(rx(1,e),t),-1);return dx(0,UI(1,rx(r,n)))}))},logcosh:function(e,t){return aI((()=>{const n=Math.log(2),r=rx(t,e),s=rx(UI(r,tx(KI(-2,r))),n);return hx(s,-1)}))},categoricalCrossentropy:OS,sparseCategoricalCrossentropy:RS,binaryCrossentropy:LS,kullbackLeiblerDivergence:function(e,t){return aI((()=>{const n=Rw(e,rT(),1),r=Rw(t,rT(),1);return Tk(KI(e,Zk(YI(n,r))),-1)}))},poisson:function(e,t){return aI((()=>{const n=Zk(UI(rT(),t));return hx(rx(t,KI(e,n)),-1)}))},cosineProximity:WS};function VS(e){if("string"==typeof e){if(e in _S)return _S[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new lD(t)}return e}function HS(e,t){return aI((()=>{const n=KI(.5,kx(t)),r=sT(Wk(t,n),e.dtype);return hx(ok(e,r),-1)}))}function US(e,t){return aI((()=>sT(ok(ew(e,-1),ew(t,-1)),"float32")))}function jS(e,t){return LS(e,t)}function YS(e,t){return e.rank===t.rank&&(e=My(e,[e.rank-1])),(t=ew(t,-1)).dtype!==e.dtype&&(t=_I(t,e.dtype)),_I(ok(e,t),"float32")}const KS=OS,XS=RS,qS={binaryAccuracy:HS,categoricalAccuracy:US,precision:function(e,t){return aI((()=>{const n=function(e,t){return aI((()=>_I(Tk(ix(ok(e,1),ok(t,1))),"float32")))}(e,t),r=function(e,t){return aI((()=>_I(Tk(ix(ok(e,0),ok(t,1))),"float32")))}(e,t),s=UI(n,r);return _I(lk(Wk(s,0),YI(n,s),0),"float32")}))},categoricalCrossentropy:KS,sparseCategoricalCrossentropy:XS,mse:PS,MSE:PS,mae:QS,MAE:QS,mape:zS,MAPE:zS,cosine:WS};function ZS(e){if("string"==typeof e&&e in qS)return qS[e];if("string"!=typeof e&&null!=e)return e;throw new lD(`Unknown metric ${e}`)}function JS(e){if(fD(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(_S))if(_S[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(qS))if(qS[n]===e){t=n;break}return void 0!==t?t:e.name}}const $S=1048576;function eN(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!tN(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>$S&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function tN(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!tN(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!tN(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function nN(e,t,n,r=console.log){const s=function(e){let t=!0;const n=[],r=[];for(const t in e.nodesByDepth)n.push(e.nodesByDepth[t]);for(const e of n){if(e.length>1||1===e.length&&e[0].inboundLayers.length>1){t=!1;break}r.push(...e)}if(t)for(const n of e.layers){let e=!1;for(const s of n.inboundNodes)if(-1!==r.indexOf(s)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),a=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){a.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),rN(a,n,r),r("=".repeat(t));const A=e.layers;for(let e=0;e<A.length;++e)s?sN(A[e],n,r):aN(A[e],n,i,r),r((e===A.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const o=function(e){let t;t=null!=e.collectedTrainableWeights?jT(e.collectedTrainableWeights):jT(e.trainableWeights);return t}(e),l=jT(e.nonTrainableWeights);r(`Total params: ${o+l}`),r(`Trainable params: ${o}`),r(`Non-trainable params: ${l}`),r("_".repeat(t))}function rN(e,t,n=console.log){let r="";for(let n=0;n<e.length;++n)n>0&&(r=r.slice(0,r.length-1)+" "),r+=e[n],r=r.slice(0,t[n]),r+=" ".repeat(t[n]-r.length);n(r)}function sN(e,t,n){let r,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(e){s="multiple"}try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}rN([`${e.name} (${e.getClassName()})`,s,r,e.countParams().toString()],t,n)}function aN(e,t,n,r){let s,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(e){a="multiple"}try{s=JSON.stringify(e.outputShape)}catch(e){s="multiple"}const i=[];for(const t of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(t)))for(let e=0;e<t.inboundLayers.length;++e){const n=t.inboundLayers[e].name,r=t.nodeIndices[e],s=t.tensorIndices[e];i.push(`${n}[${r}][${s}]`)}const A=e.name,o=e.getClassName(),l=0===i.length?"":i[0];rN([`${A} (${o})`,a,s,e.countParams().toString(),l],t,r);for(let e=1;e<i.length;++e)rN(["","","","",i[e]],t,r)}function iN(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function AN(e,t){if(null===e)return null;if("string"==typeof e)return CD(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];iN(t,s,r)?n.push(r):n.push(AN(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{const e=CD(n);t[e]=AN(r,e)}}return t}}function oN(e,t){if(null==e)return null;if("string"==typeof e)return bD(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];iN(t,s,r)?n.push(r):n.push(oN(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n],s=bD(n);t[s]="name"!==n&&"className"!==n||"string"!=typeof r?oN(r,n):r}return t}}const lN="4.22.0";class uN extends nS{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=PD(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],vD(this.inputs).length!==this.inputs.length)throw new lD(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);vD(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const e of this.outputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(const e of this.inputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;fD(0===n,"input layer has >1 nodes"),fD(0===r,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let t=0;t<this.inputLayers.length;t++){const n=this.inputLayers[t];if(!(n instanceof sS))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${t} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(const e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},s={},a={},i=[],A=(e,t,n,r,s,o)=>{null!=r&&null!=s&&null!=o||(r=e.sourceLayer,s=e.nodeIndex,o=e.tensorIndex);const l=r.inboundNodes[s];if(-1!==n.indexOf(l))throw new oD(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(l))return;this.containerNodes.add(uN.nodeKey(r,s)),r.id in a||(a[r.id]=Object.keys(a).length),-1===n.indexOf(l)&&n.push(l);const u=l.inboundLayers.length;for(let e=0;e<u;e++){const r=l.inputTensors[e],s=l.inboundLayers[e],a=l.nodeIndices[e],i=l.tensorIndices[e];A(r,t,n,s,a,i)}for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);i.push(l)},o=[],l=[];for(const e of this.outputs)A(e,o,l);const u=i.slice().reverse();for(const e of u){n[e.id]=e,e.id in t||(t[e.id]=0);let a=t[e.id];const i=null==r[e.outboundLayer.id]?0:r[e.outboundLayer.id];a=Math.max(a,i),r[e.outboundLayer.id]=a,s[e.outboundLayer.id]=e.outboundLayer,t[e.id]=a;for(let r=0;r<e.inboundLayers.length;r++){const s=e.inboundLayers[r],i=e.nodeIndices[r],A=s.inboundNodes[i],o=null==t[A.id]?0:t[A.id];t[A.id]=Math.max(a+1,o),n[A.id]=A}}const c={};for(const e in t){const r=t[e];r in c||(c[r]=[]),c[r].push(n[e])}const d={};for(const e in r){const t=r[e];t in d||(d[t]=[]),d[t].push(s[e])}let h=Object.keys(d).map((e=>parseInt(e,10))).sort(yD);this.layers=[];for(const e of h){const t=d[e];t.sort(((e,t)=>{const n=a[e.id],r=a[t.id];return n<r?-1:n>r?1:0}));for(const e of t)e instanceof uN&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,h=Object.keys(c).map((e=>parseInt(e,10))).sort(yD);const f=this.inputs.slice(),g=[];for(const e of h)for(const t of c[e]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new oD(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${g}`);for(const e of t.outputTensors)f.push(e);g.push(e.name)}}this.nodesByDepth=c;const p=this.layers.map((e=>e.name));for(const e of p){const t=p.filter((t=>t===e)).length;if(1!==t)throw new oD(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(p))}this.outboundNodes=[],this.inboundNodes=[],new eS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new lD("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let r=0;const s=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);s&&this.parseWeights(e);for(const e of this.layers)for(const[t,a]of e.weights.entries()){const e=s?`${a.name.split("/").slice(0,-1).join("/")+"/"}${t}`:a.originalName;if(null!=n[e])throw new lD(`Duplicate weight name: ${e}`);n[e]=a,r++}const a=[];for(const r in e){let s=r;if(null==n[r]){const e=r.split("/");s=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[s])a.push([n[s],e[r]]);else if(t)throw new lD(`Provided weight data has no target variable: ${r}`);delete n[s]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new lD(`${e.length} of ${r} weights are not set: ${e}`)}qT(a)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],s=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");s!==t&&(e[s]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${lN}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=oN(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return aI((()=>{e=mD(e);const n=new aS;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return oS(this.outputs,n,t)}))}computeMask(e,t){return aI((()=>{let n;return e=mD(e),n=null==t?hD(null,e.length):mD(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=VT(e);if(t.length!==this.inputLayers.length)throw new lD(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let e=0;e<t.length;e++){const r=this.inputLayers[e],s=t[e];n[r.name+"_0_0"]=s}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(yD);if(r.length>1)for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(t.id))continue;const r=[];for(let t=0;t<e.inboundLayers.length;t++){const s=e.inboundLayers[t],a=e.nodeIndices[t],i=e.tensorIndices[t],A=n[`${s.name}_${a}_${i}`];r.push(A)}const s=VT(t.computeOutputShape(pD(r))),a=t.inboundNodes.indexOf(e);for(let e=0;e<s.length;e++){n[`${t.name}_${a}_${e}`]=s[e]}}}const s=[],a=[];for(let e=0;e<this.outputLayers.length;e++){const t=this.outputLayers[e],n=this.outputLayersNodeIndices[e],r=this.outputLayersTensorIndices[e],s=`${t.name}_${n}_${r}`;a.push(s)}for(let e=0;e<a.length;e++){const t=a[e];fD(t in n),s.push(n[t])}return pD(s)}runInternalGraph(e,t){null==t&&(t=hD(null,e.length));const n={};for(let r=0;r<this.inputs.length;++r){const s=this.inputs[r],a=e[r],i=t[r];n[s.id]=[a,i]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(yD);for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,s=e.outputTensors,a=new Array;for(const e of r)e.id in n&&a.push(n[e.id]);if(a.length===r.length){let r,i,A,o,l={};if(null!=e.callArgs&&(l=e.callArgs),1===a.length){const[e,n]=a[0];null==l.mask&&(l.mask=n),A=mD(t.call(e,l)),o=mD(t.computeMask(e,n)),r=[e],i=[n]}else r=a.map((e=>e[0])),i=a.map((e=>e[1])),null==l.mask&&(l.mask=i),A=mD(t.call(r,l)),o=mD(t.computeMask(r,i));if(t.activityRegularizer)throw new uD("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e){const t=s[e],r=A[e],a=o[e];n[t.id]=[r,a]}}}}const s=[],a=[],i=[];for(const e of this.outputs){fD(e.id in n,`Could not compute output ${e.name} : ${e.id}`);const[t,r]=n[e.id];i.push(t.shape),s.push(t),a.push(r)}return[s,a,i]}buildNodeConversionMap(e){const t={};let n;for(const e of this.layers){n=e instanceof uN?1:0;for(let r=0;r<e.inboundNodes.length;r++){const s=uN.nodeKey(e,r);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new lD("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(const t of this.layers)if(t.name===e)return t;throw new lD(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new lD(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return aI((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=uN.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const e of this.layers){const r=e.getClassName(),s=e.getConfig(),a=[];for(let n=0;n<e.inboundNodes.length;n++){const r=e.inboundNodes[n],s=uN.nodeKey(e,n);let i={};if(this.containerNodes.has(s)){if(r.callArgs)try{JSON.stringify(r.callArgs),i=r.callArgs}catch(t){console.warn(`Layer ${e.name} was passed non-serializable keyword arguments: ${r.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(r.inboundLayers.length>0){const e=[];for(let n=0;n<r.inboundLayers.length;n++){const s=r.inboundLayers[n],a=r.nodeIndices[n],A=r.tensorIndices[n];let o=t[uN.nodeKey(s,a)];null==o&&(o=0),e.push([s.name,o,A,i])}a.push(e)}}}const i={};i.name=e.name,i.className=r,i.config=s,i.inboundNodes=a,n.push(i)}e.layers=n;const r=[];for(let e=0;e<this.inputLayers.length;e++){const n=this.inputLayers[e],s=this.inputLayersNodeIndices[e],a=uN.nodeKey(n,s);if(!this.containerNodes.has(a))continue;let i=t[a];null==i&&(i=0);const A=this.inputLayersTensorIndices[e];r.push([n.name,i,A])}e.inputLayers=r;const s=[];for(let e=0;e<this.outputLayers.length;e++){const n=this.outputLayers[e],r=this.outputLayersNodeIndices[e],a=uN.nodeKey(n,r);if(!this.containerNodes.has(a))continue;let i=t[a];null==i&&(i=0);const A=this.outputLayersTensorIndices[e];s.push([n.name,i,A])}return e.outputLayers=s,e}static fromConfig(e,t,n={},r=!1){const s={},a={};function i(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function A(e,t){const n=[];let r;for(const a of t){const A=a[0],o=a[1],l=a[2];if(r=null==a[3]?{}:a[3],!(A in s))return void i(e,t);const u=s[A];if(u.inboundNodes.length<=o)return void i(e,t);const c=u.inboundNodes[o];n.push(c.outputTensors[l])}n.length>0&&e.apply(pD(n),r)}function o(e){const n=e.name,a=GS(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(r),s[n]=a;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new lD(`Corrupted configuration, expected array for nodeData: ${e}`);i(a,e)}))}const l=t.name,u=t.layers;for(const e of u)o(e);for(;!ED(a);)for(const e of u){const t=s[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)A(t,n)}}const c=[],d=[],h=t.inputLayers;for(const e of h){const t=e[0],n=e[1],r=e[2];fD(t in s);const a=s[t].inboundNodes[n].outputTensors;c.push(a[r])}const f=t.outputLayers;for(const e of f){const t=e[0],n=e[1],r=e[2];fD(t in s);const a=s[t].inboundNodes[n].outputTensors;d.push(a[r])}return new e({inputs:c,outputs:d,name:l})}get stateful(){if(this._stateful)throw new lD("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){aI((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function cN(e,t){return function(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}async function dN(e,t,n,r){if(null!=n){const t=aI((()=>{if(1===e.shape.length)return VI(e);if(2===e.shape.length){if(e.shape[1]>1){return ew(e,1)}if(1===e.shape[1])return kw(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());iI(t);const s=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);s.push(n[e])})),Gy(s,"float32")}return null}function hN(e,t){return KI(e,t)}function fN(e,t){let n,r;const s=t;n=s.xs,r=s.ys,Pf(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const a=gN("input",e.inputNames,n),i=gN("output",e.outputNames,r),A=a[0].shape[0];Pf(a.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),Pf(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let t=0;t<a.length;t++)Pf(a[t].shape[0]===A,(()=>`Batch size mismatch: input ${e.inputNames[t]} has ${a[t].shape[0]}; expected  ${A} based on input ${e.inputNames[0]}.`));for(let t=0;t<i.length;t++)Pf(i[t].shape[0]===A,(()=>`Batch size mismatch: output ${e.outputNames[t]} has ${i[t].shape[0]}; expected  ${A} based on input ${e.inputNames[0]}.`));return{xs:a,ys:i}}function gN(e,t,n){if(n instanceof kC)return[n];if(Array.isArray(n))return Pf(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const s of t){if(null==n[s])throw new lD(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}async function pN(e,t,n){const r=null!=n.batchesPerEpoch;if(Pf(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Pf(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Pf(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),Pf(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),Pf(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let a,i;if(s)if(mN(n.validationData))Pf(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new uD("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,i=e.ys}const A=e.makeTrainFunction(),o=e.getDedupedMetricsNames();let l;l=s?o.slice().concat(o.map((e=>"val_"+e))):o.slice();const u=TS(n.callbacks,n.yieldEvery),c=null==n.verbose?1:n.verbose,{callbackList:d,history:h}=NS(u,c,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,s,l);d.setModel(e),e.history=h,await d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,g=await t.iterator();for(;f<n.epochs;){const l={};await d.onEpochBegin(f);let u=0,c=0;for(r||(g=await t.iterator());!r||u<n.batchesPerEpoch;){const t=await g.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${u} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:s}=fN(e,t.value),a={};a.batch=c,a.size=r[0].shape[0],await d.onBatchBegin(c,a);const i=[];if(null!=n.classWeight){const t=cN(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await dN(s[e],0,t[e]))}const l=r.concat(s).concat(i),h=A(l);iI(l);for(let e=0;e<o.length;++e){const t=o[e],n=h[e];a[t]=n,AI(n)}await d.onBatchEnd(c,a),xS(a),c++,u++}if(r?u>=n.batchesPerEpoch:t.done){if(s){let t;t=mN(n.validationData)?mD(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):mD(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,l),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function mN(e){return"function"==typeof e.iterator}function bN(e){Pf(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function CN(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>iT(e,t,n-t))):iT(e,t,n-t)}function IN(e,t){return aI((()=>null==e?null:Array.isArray(e)?e.map((e=>IN(e,t))):fT(e,"int32"===t.dtype?t:_I(t,"int32"))))}function wN(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function kN(e){const t=[];e instanceof kC&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(aT(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function xN(e,t){if(null==e)return;const n=[];if(t instanceof kC)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const e in t){const r=t[e];n.push(r.id)}const r=[];if(e instanceof kC)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const t in e){const s=e[t];-1===n.indexOf(s.id)&&r.push(s)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function yN(e){return Array.isArray(e)}function vN(e){return!function(e){return e instanceof kC}(e)&&!yN(e)}function EN(e,t,n,r=!0,s=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(yN(e)&&e.length>0)t=!0;else if(vN(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new lD(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let a;if(vN(e)){a=[];for(const n of t){if(null==e[n])throw new lD(`No data provided for "${n}". Need data for each key in: ${t}`);a.push(e[n])}}else if(yN(e)){if(e.length!==t.length)throw new lD(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(t.length>1)throw new lD(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=kN(a),null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const i=a[e];if(i.shape.length!==n[e].length)throw new lD(`Error when checking ${s}: expected ${t[e]} to have ${n[e].length} dimension(s). but got array with shape ${i.shape}`);for(let t=0;t<n[e].length;++t){if(0===t&&!r)continue;const a=i.shape[t],A=n[e][t];if(null!=A&&A>=0&&a!==A)throw new lD(`${s} expected a batch of elements where each example has shape [${n[e].slice(1,n[e].length)}] (i.e.,tensor shape [*,${n[e].slice(1,n[e].length)}]) but the ${s} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return a}function BN(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new lD(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new lD(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const i=a[e];if(i.shape.length!==n[e].length)throw new lD(`Error when checking ${s}: expected ${t[e]} to have ${n[e].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let a=0;a<n[e].length;++a){if(0===a&&!r)continue;const A=i.shape[a],o=n[e][a];if(null!=o&&o!==A)throw new lD(`Error when checking ${s}: expected ${t[e]} to have shape ${JSON.stringify(n[e])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}class MN extends uN{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new lD("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");nN(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>lE.adagrad(.01),Adadelta:()=>lE.adadelta(1,.95,rT()),Adam:()=>lE.adam(.001,.9,.999,rT()),Adamax:()=>lE.adamax(.002,.9,.999,rT(),0),RMSProp:()=>lE.rmsprop(.001,.9,0,rT()),SGD:()=>lE.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new lD(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof zv))throw new lD("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new lD(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>VS(e)))}else{const n=VS(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new lD(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(VS(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){const t=this.internalOutputShapes[e],n=this.outputNames[e];this.feedOutputNames.push(n),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],jD("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};jD("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,a;for(const i of t){if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===LS?-1!==["accuracy","acc"].indexOf(i)?r=HS:-1!==["crossentropy","ce"].indexOf(i)&&(r=jS):this.lossFunctions[e]===RS?-1!==["accuracy","acc"].indexOf(i)?r=YS:-1!==["crossentropy","ce"].indexOf(i)&&(r=XS):-1!==["accuracy","acc"].indexOf(i)?r=US:-1!==["crossentropy","ce"].indexOf(i)&&(r=KS),-1!==["accuracy","acc"].indexOf(i)?s="acc":-1!==["crossentropy","ce"].indexOf(i)&&(s="ce"),a=r,n=""+s}else{const e=ZS(i);a=e,n=""+JS(i)}let t;jD(n,(()=>{t=a})),s(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const r=null==n.batchSize?32:n.batchSize;bN(r);const s=this.standardizeUserDataXY(e,t,!0,r);try{const e=s[0].concat(s[1]);this.makeTestFunction();const t=this.testFunction;return pD(this.testLoop(t,e,r,n.verbose,n.steps))}finally{xN(s[0],e),xN(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,s=e.testFunction;let a=[];if(n.verbose>0)throw new uD("Verbose mode is not implemented yet.");Pf(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const i="function"==typeof t.next?t:await t.iterator();let A=0,o=0;for(;!r||o<n.batches;){const t=await i.next();if(a=aI((()=>{if(t.value){const{xs:n,ys:r}=fN(e,t.value),i=n.concat(r),l=aI((()=>s(i)));if(iI(i),0===o)for(let e=0;e<l.length;++e)a.push(Bk(0));const u=i[0].shape[0];for(let e=0;e<l.length;++e){const t=l[e],n=a[e];a[e]=aI((()=>UI(a[e],KI(u,t)))),o>0&&iI(n)}iI(l),A+=u,++o}return a})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let e=0;e<a.length;++e){const t=a[e];a[e]=YI(a[e],A),iI(t)}return pD(a)}(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(null!=n){if(s=null,null!=t)throw new lD(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new lD(`Either the input data should have a defined shape, or ${r} shoud be specified.`);s=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return s}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new lD("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new aS;if(e instanceof kC&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new lD(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)a.add(this.inputs[t],e[t])}else for(const t of this.inputs){const n=e[t.name];if(null==n)throw new lD(`No value is provided for the model's input ${t.name}`);a.add(t,n)}const i=oS(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){const t=hD(null,e.length);let n=e.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],a=s.map((e=>e.name));for(let r=0;r<e.length;++r){const i=a.indexOf(e[r]);if(-1!==i&&(t[r]=s[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new lD(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return aI((()=>{const r=this.checkNumSamples(e);if(n)throw new uD("Verbose predictLoop() is not implemented yet.");const s=wN(r,t),a=this.outputs.map((e=>[]));for(let t=0;t<s.length;++t){const n=aI((()=>{const n=s[t][0],r=s[t][1],a=CN(e,n,r),i=[];if(Array.isArray(a))for(let e=0;e<a.length;++e)i.push({key:this.inputs[e],value:a[e]});else i.push({key:this.inputs[0],value:a});const A=new aS(i);return oS(this.outputs,A)}));n.forEach(((e,t)=>a[t].push(e)))}return pD(a.map((e=>vw(e,0))))}))}predict(e,t={}){const n=kN(e);BN(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return bN(e),this.predictLoop(n,e)}finally{xN(n,e)}}predictOnBatch(e){BN(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new oD("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let e=0;e<this.feedOutputShapes.length;++e){const t=this.feedOutputShapes[e];this.feedLossFns[e]===RS?s.push(t.slice(0,t.length-1).concat([1])):s.push(t)}if(function(e,t){const n=vD(e.map((e=>e.shape[0])));n.sort();const r=vD(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new lD(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new lD(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&r.length>0&&!Rf(n,r))throw new lD(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=EN(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=EN(t,this.feedOutputNames,s,!1,"target")),function(e,t,n){const r=[PS,LS,OS];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],A=n[s];if(null!=i){if(i===OS&&1===a.shape[a.shape.length-1])throw new lD(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=a.shape.slice(1),t=A.slice(1);for(let n=0;n<e.length;++n){const r=e[n],s=t[n];if(null!=s&&r!==s)throw new lD(`A target Tensor with shape ${a.shape} was passed for an output of shape ${A}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!==0)throw new lD(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,a){const[i,A]=this.standardizeUserDataXY(e,t,s,a);if(null!=n)throw new Error("sample weight is not supported yet.");let o=null;if(null!=r){const e=cN(r,this.outputNames);o=[];for(let t=0;t<e.length;++t)o.push(await dN(A[t],0,e[t]))}return[i,A,o]}testLoop(e,t,n,r=0,s){return aI((()=>{const a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new uD("Verbose mode is not implemented yet.");if(null!=s)throw new uD("steps mode in testLoop() is not implemented yet");{const r=wN(a,n),s=Gy(tT(0,a));for(let n=0;n<r.length;++n){const a=r[n][0],A=r[n][1],o=iT(s,a,A-a),l=IN(t,o),u=e(l);if(0===n)for(let e=0;e<u.length;++e)i.push(Bk(0));for(let e=0;e<u.length;++e){const t=u[e];i[e]=UI(i[e],KI(A-a,t))}}for(let e=0;e<i.length;++e)i[e]=YI(i[e],a)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let s=r;if(gD(e,r)>1){s+=`_${gD(e.slice(0,n),r)}`}t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],i=this.collectedTrainableWeights.map((e=>e.read())),A=this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new aS(e),A=oS(this.outputs,i,{training:!0});let o;for(let e=0;e<this.lossFunctions.length;++e){let n=(0,this.lossFunctions[e])(r[e],A[e]);null!=s[e]&&(n=hN(n,s[e]));const a=hx(n);t.push(a),o=0===e?n:UI(o,n)}for(let e=0;e<this.metricsTensors.length;++e){let n;if(this.outputs.length>1&&e<this.outputs.length)n=t[e];else{const t=this.metricsTensors[e][0],s=this.metricsTensors[e][1];n=hx(t(r[s],A[s]))}AI(n),a.push(n)}return o=hx(o),this.calculateLosses().forEach((e=>{o=UI(o,e)})),o}),!0,i);return[A].concat(a)}}makeTestFunction(){this.testFunction=e=>aI((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:r[e]});const i=new aS(a),A=oS(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],a=hx(r(s[e],A[e]));n=0===e?a:UI(n,a),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],a=hx(n(s[r],A[r]));t.push(a)}return t}))}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,s,a,i,A,o,l,u,c;this.isTraining=!0;try{const d=null==n.batchSize?32:n.batchSize;bN(d);const h=!1,f=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,h,d);r=f[0],s=f[1],c=f[2];let g,p=!1;if(null!=n.validationData&&n.validationData.length>0){if(p=!0,2!==n.validationData.length)throw 3===n.validationData.length?new uD("validationData including sample weights is not supported yet."):new lD(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);A=n.validationData[0],o=n.validationData[1];const e=!0,t=await this.standardizeUserData(A,o,null,null,e,d);l=t[0],u=t[1],g=l.concat(u)}else if(null!=n.validationSplit&&n.validationSplit>0&&n.validationSplit<1){p=!0;const e=Math.floor(r[0].shape[0]*(1-n.validationSplit)),t=r[0].shape[0];l=CN(r,e,t),a=r,r=CN(r,0,e),u=CN(s,e,t),i=s,s=CN(s,0,e),g=l.concat(u)}else null!=n.validationSteps&&(p=!0);const m=r.concat(s).concat(c);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),C=this.getDedupedMetricsNames();let I,w;p?(this.makeTestFunction(),I=this.testFunction,w=C.slice().concat(C.map((e=>"val_"+e)))):(I=null,g=[],w=C.slice());const k=TS(n.callbacks,n.yieldEvery);return await this.fitLoop(b,m,C,d,n.epochs,n.verbose,k,I,g,n.shuffle,w,n.initialEpoch,null,null)}finally{this.isTraining=!1,xN(r,e),xN(s,t),xN(a,e),xN(i,t),xN(l,A),xN(u,o),null!=c&&iI(c)}}async fitLoop(e,t,n,r,s,a,i,A,o,l,u,c,d,h){null==r&&(r=32),null==s&&(s=1),null==l&&(l=!0),null==c&&(c=0);let f=!1;if(null!=A&&null!=o&&(f=!0),null!=h&&(f=!0,null==d))throw new lD("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(t,r,d,"steps_per_epoch");let p;null!=g&&(p=tT(0,g)),null==a&&(a=1);const{callbackList:m,history:b}=NS(i,a,s,c,g,d,r,f,u);m.setModel(this),this.history=b,await m.onTrainBegin(),this.stopTraining_=!1;for(let a=c;a<s;++a){await m.onEpochBegin(a);const s={};if(null!=d)throw new uD("stepsPerEpoch mode is not implemented yet.");{if("batch"===l)throw new uD("batch shuffling is not implemneted yet");l&&Sf(p);const a=Gy(p),i=wN(g,r);for(let l=0;l<i.length;++l){const u={};if(await m.onBatchBegin(l,u),aI((()=>{const c=i[l][0],d=i[l][1],h=iT(a,c,d-c);u.batch=l,u.size=d-c;const g=IN(t,h),p=e(g);for(let e=0;e<n.length;++e){const t=n[e],r=p[e];u[t]=r,AI(r)}if(l===i.length-1&&f){const e=this.testLoop(A,o,r);for(let t=0;t<n.length;++t){const r=n[t],a=e[t];AI(a),s["val_"+r]=a}}})),await m.onBatchEnd(l,u),xS(u),this.stopTraining_)break}a.dispose()}if(await m.onEpochEnd(a,s),this.stopTraining_)break}return await m.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return pN(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(const e of a){const t=await e.data();i.push(t[0])}return iI(a),xN(n[0],e),xN(n[1],t),pD(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let e=0;e<r.length;++e)n&&!r[e].trainable||t.push({name:r[e].originalName,tensor:s[e]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=sI().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-sI().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=bD(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>bD(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=bD(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[bD(JS(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>bD(JS(e))));{const e={};for(const t in this.metrics)e[t]=bD(JS(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=GS(AN(e.optimizer_config));let n,r;if("string"==typeof e.loss)n=CD(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>CD(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=CD(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>CD(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=CD(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"==typeof e){const t=(n=e,fI.getSaveHandlers(n));if(0===t.length)throw new lD(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new lD(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}var n;if(null==e.save)throw new lD("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await lI(this.getNamedWeights(t)),s={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${lN}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){s.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:n}=await lI(await this.optimizer.getWeights(),e);r.specs.push(...n),r.data=(a=[r.data,t],nI.join(a))}var a;if(null!=this.userDefinedMetadata){const e=!0;eN(this.userDefinedMetadata,this.name,e),s.userDefinedMetadata=this.userDefinedMetadata}return s.weightData=r.data,s.weightSpecs=r.specs,e.save(s)}setUserDefinedMetadata(e){eN(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}MN.className="Model",Qv(MN);class DN extends MN{}DN.className="Functional",Qv(DN);class TN extends MN{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:PD("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new lD(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof TN||e instanceof MN;let n;if(t){if(n=e,1!==n.outputs.length)throw new lD("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new lD("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new lD("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new lD("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new sS({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new lD(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new lD("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=rS(this.outputs[0])}this.inboundNodes=[],new eS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:hD(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(UT(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new MN({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new oD("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new oD("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new oD("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new oD("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let s,a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new lD("Legacy serialization format not supported yet.");s=t}else Pf(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),s=t.layers,delete t.layers,a=t;const i=new e(a);if(!(i instanceof TN))throw new uD(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(const e of s){const t=GS(e,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),i.add(t)}return i}set stopTraining(e){if(null==this.model)throw new lD("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new lD("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}TN.className="Sequential",Qv(TN);let SN=class extends Fv{getConfig(){return{}}};class NN extends SN{apply(e,t=1){return function(e,t=1){if(1!==t)throw new uD(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return fk(e)}(e,t)}}NN.className="elu",Qv(NN);class GN extends SN{apply(e){return dy(e)}}GN.className="selu",Qv(GN);class FN extends SN{apply(e){return Ay(e)}}FN.className="relu",Qv(FN);class PN extends SN{apply(e){return aI((()=>px(6,Ay(e))))}}PN.className="relu6",Qv(PN);class QN extends SN{apply(e){return e}}QN.className="linear",Qv(QN);class zN extends SN{apply(e){return Bw(e)}}zN.className="sigmoid",Qv(zN);class ON extends SN{apply(e){return function(e){return aI((()=>{const t=UI(.5,KI(.2,e));return Rw(t,0,1)}))}(e)}}ON.className="hardSigmoid",Qv(ON);class RN extends SN{apply(e){return tx(e)}}RN.className="softplus",Qv(RN);class LN extends SN{apply(e){return function(e){return aI((()=>YI(e,UI(XI(e),1))))}(e)}}LN.className="softsign",Qv(LN);class WN extends SN{apply(e){return Dw(e)}}WN.className="tanh",Qv(WN);let _N=class extends SN{apply(e,t=-1){return wy(e,t)}};_N.className="softmax",Qv(_N);class VN extends SN{apply(e,t=-1){return sx(e,t)}}VN.className="logSoftmax",Qv(VN);class HN extends SN{apply(e){return aI((()=>aI((()=>{const t=Math.sqrt(2),n=KI(.5,UI(1,gk(YI(e,t))));return KI(e,n)}))))}}HN.className="gelu",Qv(HN);class UN extends SN{apply(e){return aI((()=>KI(.5,KI(e,UI(1,Dw(KI(Mk(YI(2,Math.PI)),UI(e,KI(.044715,Ek(e,3))))))))))}}UN.className="gelu_new",Qv(UN);class jN extends SN{apply(e){return aI((()=>KI(e,Dw(tx(e)))))}}jN.className="mish",Qv(jN);class YN extends SN{apply(e,t=1){return aI((()=>KI(Bw(KI(e,t)),e)))}}function KN(e){return e.getClassName()}function XN(e,t={}){return xD(e,Pv.getMap().classNameMap,t,"activation")}function qN(e){if(null==e){const e={className:"linear",config:{}};return XN(e)}if("string"==typeof e){const t={};return t.className=e,t.config={},XN(t)}return e instanceof SN?e:XN(e)}YN.className="swish",Qv(YN);class ZN extends Fv{}class JN extends ZN{constructor(e){super(),function(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return aI((()=>{let t=fx([1]);return this.hasL1&&(t=UI(t,Tk(KI(this.l1,XI(e))))),this.hasL2&&(t=UI(t,Tk(KI(this.l2,gT(e))))),kw(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}JN.className="L1L2",Qv(JN);const $N={l1l2:"L1L2"};function eG(e){return wD(e)}function tG(e,t={}){return xD(e,Pv.getMap().classNameMap,t,"regularizer")}function nG(e){if(null==e)return null;if("string"==typeof e){return tG({className:e in $N?$N[e]:e,config:{}})}return e instanceof ZN?e:tG(e)}class rG extends nS{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=HT(e);let n=Ay(e);return null!=this.maxValue&&(n=Rw(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}rG.className="ReLU",Qv(rG);class sG extends nS{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=HT(e);return Yk(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}sG.className="LeakyReLU",Qv(sG);class aG extends nS{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=WT(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=nG(e.alphaRegularizer),this.alphaConstraint=wS(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new lD(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=UT(e)).slice(1);if(null!=this.sharedAxes)for(const e of this.sharedAxes)t[e-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let t=1;t<e.length;++t)n[t]=e[t];this.inputSpec=[new ZT({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=HT(e),Ex(e,this.alpha.read())}getConfig(){const e={alphaInitializer:LT(this.alphaInitializer),alphaRegularizer:eG(this.alphaRegularizer),alphaConstraint:CS(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}aG.className="PReLU",Qv(aG);let iG=class extends nS{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new uD(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=HT(e);return fk(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};iG.className="ELU",Qv(iG);class AG extends nS{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=HT(e);return KI(n,_I(Wk(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}AG.className="ThresholdedReLU",Qv(AG);class oG extends nS{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new _N).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return aI((()=>{let n=HT(e);const r=t.mask;if(null!=r){const e=KI(rx(gx(n.shape),_I(r,n.dtype)),Bk(-1e9));n=UI(n,e)}return this.axis instanceof Array?this.axis.length>1?Fk(rx(n,ax(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function lG(e,t,n){if("number"==typeof e)return hD(e,t);if(e.length!==t)throw new lD(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const s=e[r];if(!ZD(s))throw new lD(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function uG(e,t,n,r,s=1){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*(s-1))+1,Math.floor((a+r-1)/r)}function cG(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+eT([n-t,0]);else{if("same"!==r)throw new lD(`Unsupport padding mode: ${r}.`);e*=t}return e}function dG(e,t){return aI((()=>(_D(t),"channelsFirst"===t?Vy(e,[0,2,3,1]):e)))}function hG(e,t){return aI((()=>(_D(t),"channelsFirst"===t?Vy(e,[0,2,3,4,1]):e)))}function fG(e,t,n,r=[1,1],s="valid",a,i,A=null){return aI((()=>{if(null==a&&(a="channelsLast"),_D(a),3!==e.rank&&4!==e.rank)throw new lD(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new lD(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let o=dG(e,a);if("causal"===s)throw new uD("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return o=qy({x:o,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:A}),"channelsFirst"===a&&(o=Vy(o,[0,3,1,2])),o}))}oG.className="Softmax",Qv(oG);class gG extends nS{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",gG.verifyArgs(t),this.rank=e,DD(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new uD(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=lG(t.kernelSize,e,"kernelSize"),this.strides=lG(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,VD(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,_D(this.dataFormat),this.activation=qN(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=WT(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=wS(t.biasConstraint),this.biasRegularizer=nG(t.biasRegularizer),this.activityRegularizer=nG(t.activityRegularizer),this.dilationRate=lG(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new lD(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new lD(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new lD(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(fD("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!MD(e.kernelSize,"number",1,3))throw new lD(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:KN(this.activation),useBias:this.useBias,biasInitializer:LT(this.biasInitializer),biasRegularizer:eG(this.biasRegularizer),activityRegularizer:eG(this.activityRegularizer),biasConstraint:CS(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class pG extends gG{constructor(e,t){super(e,t),this.kernel=null,pG.verifyArgs(t),this.filters=t.filters,DD(this.filters,"filters"),this.kernelInitializer=WT(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=wS(t.kernelConstraint),this.kernelRegularizer=nG(t.kernelRegularizer)}build(e){e=UT(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new lD(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return aI((()=>{let t;e=HT(e);const n=null==this.bias?null:this.bias.read(),r=SD(this.activation.getClassName());if(null!=r&&2===this.rank)t=fG(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n,r=1,s="valid",a,i=1){return aI((()=>{if(null==a&&(a="channelsLast"),_D(a),3!==e.shape.length)throw new lD(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new lD(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new lD(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===a&&(e=Vy(e,[0,2,1])),"causal"===s)throw new uD("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let A=Uw(e,t,r,"same"===s?"same":"valid","NWC",i);return null!=n&&(A=mT(A,n)),A}))}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=fG(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new uD("convolutions greater than 3D are not implemented yet.");t=function(e,t,n,r=[1,1,1],s="valid",a,i){return aI((()=>{if(null==a&&(a="channelsLast"),_D(a),4!==e.rank&&5!==e.rank)throw new lD(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new lD(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let A=hG(e,a);if("causal"===s)throw new uD("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return A=Kw(A,t,r,"same"===s?"same":"valid","NDHWC",i),null!=n&&(A=mT(A,n)),"channelsFirst"===a&&(A=Vy(A,[0,4,1,2,3])),A}))}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=UT(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let e=0;e<n.length;++e){const r=uG(n[e],this.kernelSize[e],this.padding,this.strides[e],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[e]);t.push(r)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:LT(this.kernelInitializer),kernelRegularizer:eG(this.kernelRegularizer),kernelConstraint:CS(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new lD(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class mG extends pG{constructor(e){super(2,e),mG.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!MD(e.kernelSize,"number",1,2))throw new lD(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}mG.className="Conv2D",Qv(mG);class bG extends pG{constructor(e){super(3,e),bG.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new lD(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}bG.className="Conv3D",Qv(bG);class CG extends mG{constructor(e){if(super(e),this.inputSpec=[new ZT({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new lD(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=UT(e)).length)throw new lD("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new lD("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ZT({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return aI((()=>{let t=HT(e);if(4!==t.shape.length)throw new lD(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a;"channelsFirst"===this.dataFormat?(s=2,a=3):(s=1,a=2);const i=n[s],A=n[a],o=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],c=this.strides[1],d=[r,cG(i,u,o,this.padding),cG(A,c,l,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Vy(t,[0,2,3,1]));let h=Yw(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(h=Vy(h,[0,3,1,2])),null!=this.bias&&(h=mT(h,this.bias.read(),this.dataFormat)),null!=this.activation&&(h=this.activation.apply(h)),h}))}computeOutputShape(e){const t=(e=UT(e)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const a=this.kernelSize[0],i=this.kernelSize[1],A=this.strides[0],o=this.strides[1];return t[n]=this.filters,t[r]=cG(t[r],A,a,this.padding),t[s]=cG(t[s],o,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}CG.className="Conv2DTranspose",Qv(CG);class IG extends bG{constructor(e){if(super(e),this.inputSpec=[new ZT({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new lD(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=UT(e)).length)throw new lD("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new lD("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ZT({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return aI((()=>{let t=HT(e);if(5!==t.shape.length)throw new lD(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a,i;"channelsFirst"===this.dataFormat?(i=2,s=3,a=4):(i=1,s=2,a=3);const A=n[i],o=n[s],l=n[a],u=this.kernelSize[0],c=this.kernelSize[1],d=this.kernelSize[2],h=this.strides[0],f=this.strides[1],g=this.strides[2],p=[r,cG(A,h,u,this.padding),cG(o,f,c,this.padding),cG(l,g,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Vy(t,[0,2,3,4,1]));let m=qw(t,this.kernel.read(),p,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(m=Vy(m,[0,4,1,2,3])),null!==this.bias&&(m=mT(m,this.bias.read(),this.dataFormat)),null!==this.activation&&(m=this.activation.apply(m)),m}))}computeOutputShape(e){const t=(e=UT(e)).slice();let n,r,s,a;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);const i=this.kernelSize[0],A=this.kernelSize[1],o=this.kernelSize[2],l=this.strides[0],u=this.strides[1],c=this.strides[2];return t[n]=this.filters,t[r]=cG(t[r],l,i,this.padding),t[s]=cG(t[s],u,A,this.padding),t[a]=cG(t[a],c,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}IG.className="Conv3DTranspose",Qv(IG);class wG extends pG{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new lD("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new lD("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new lD(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=WT(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=nG(t.depthwiseRegularizer),this.depthwiseConstraint=wS(t.depthwiseConstraint),this.pointwiseInitializer=WT(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=nG(t.pointwiseRegularizer),this.pointwiseConstraint=wS(t.pointwiseConstraint)}build(e){if((e=UT(e)).length<this.rank+2)throw new lD(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new lD(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let e=0;e<this.rank;++e)s.push(1);s.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new ZT({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return aI((()=>{let t;if(e=HT(e),1===this.rank)throw new uD("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Vy(e,[0,2,3,1])),t=hy(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=mT(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=Vy(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=LT(this.depthwiseInitializer),e.pointwiseInitializer=LT(this.pointwiseInitializer),e.depthwiseRegularizer=eG(this.depthwiseRegularizer),e.pointwiseRegularizer=eG(this.pointwiseRegularizer),e.depthwiseConstraint=CS(this.depthwiseConstraint),e.pointwiseConstraint=CS(this.pointwiseConstraint),e}}wG.className="SeparableConv";class kG extends wG{constructor(e){super(2,e)}}kG.className="SeparableConv2D",Qv(kG);class xG extends pG{constructor(e){super(1,e),xG.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!MD(e.kernelSize,"number",1,1))throw new lD(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}xG.className="Conv1D",Qv(xG);class yG extends nS{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return aI((()=>{if(e=HT(e),"channelsLast"===this.dataFormat){const t=oT(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return oT(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=oT(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return oT(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}yG.className="Cropping2D",Qv(yG);class vG extends nS{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,_D(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,BD(zD,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return aI((()=>{let t=HT(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=Vy(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],s="nearest"===this.interpolation?Tv.resizeNearestNeighbor(t,[e,r]):Tv.resizeBilinear(t,[e,r]);return Vy(s,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?Tv.resizeNearestNeighbor(t,[e,r]):Tv.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}vG.className="UpSampling2D",Qv(vG);class EG extends gG{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=WT(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=wS(e.depthwiseConstraint),this.depthwiseRegularizer=nG(e.depthwiseRegularizer)}build(e){if((e=UT(e)).length<4)throw new lD(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new lD(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return aI((()=>{let t=function(e,t,n=[1,1],r="valid",s,a){return aI((()=>{null==s&&(s="channelsLast"),_D(s);let i=dG(e,s);if(4!==e.rank)throw new lD(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new lD(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=rk(i,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===s&&(i=Vy(i,[0,3,1,2])),i}))}(e=HT(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=mT(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=UT(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=uG(t,this.kernelSize[0],this.padding,this.strides[0]),a=uG(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=LT(this.depthwiseInitializer),e.depthwiseRegularizer=eG(this.depthwiseRegularizer),e.depthwiseConstraint=CS(this.depthwiseRegularizer),e}}function BG(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new lD("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=s(t),constants:n=s(n)}}function MG(e,t,n,r=!1,s,a,i=!1,A=!1){return aI((()=>{const a=t.shape.length;if(a<3)throw new lD(`Input should be at least 3D, but is ${a}D.`);const o=[1,0].concat(tT(2,a));t=Vy(t,o),i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=_I(_I(s,"bool"),"float32")).rank===a-1&&(s=Pk(s,-1)),s=Vy(s,o)),r&&(t=ly(t,0),null!=s&&(s=ly(s,0)));const l=[];let u,c=n;const d=t.shape[0],h=Wy(t);let f,g;null!=s&&(f=Wy(s));for(let t=0;t<d;++t){const n=h[t],r=aI((()=>e(n,c)));if(null==s)u=r[0],c=r[1];else{const e=aI((()=>{const e=f[t],n=rx(kx(e),e),s=UI(KI(r[0],e),KI(c[0],n)),a=c.map(((t,s)=>UI(KI(r[1][s],e),KI(t,n))));return{output:s,newStates:a}}));u=e.output,c=e.newStates}A&&l.push(u)}if(A){g=Dy(l,1)}return[u,g,c]}))}EG.className="DepthwiseConv2D",Qv(EG);class DG extends nS{constructor(e){let t;if(super(e),null==e.cell)throw new lD("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new zG({cells:e.cell}):e.cell,null==t.stateSize)throw new lD("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new ZT({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return tT(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){_T(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return aI((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new uD("Constants support is not implemented in RNN yet.");_T(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new ZT({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let s;if(this.cell.build(r),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Rf(this.stateSpec.map((e=>e.shape[e.shape.length-1])),s))throw new lD(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map((e=>new ZT({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){aI((()=>{if(!this.stateful)throw new AD("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new lD("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>fx([n,e]))):this.states_=[fx([n,this.cell.stateSize])];else if(null==e)iI(this.states_),null!=this.keptStates&&(iI(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>fx([n,e]))):this.states_[0]=fx([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new lD(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):iI(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,s];if(!Rf(r.shape,a))throw new lD(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>AI(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=BG(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],i=[];if(null!=n){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new ZT({shape:e.shape}));i=i.concat(this.stateSpec)}null!=r&&(t.constants=r,a=a.concat(r),this.numConstants=r.length);if(a[0]instanceof JT){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const A=super.apply(n,t);return this.inputSpec=s,A}return super.apply(e,t)}call(e,t){return aI((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let s=null==t?null:t.initialState;e=HT(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new lD(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},A=MG(((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,s,this.goBackwards,n,0,this.unroll,this.returnSequences),o=A[0],l=A[1],u=A[2];this.stateful&&this.resetStates(u,r);const c=this.returnSequences?l:o;return this.returnState?[c].concat(u):c}))}getInitialState(e){return aI((()=>{let t=fx(e.shape);return t=Tk(t,[1,2]),t=aT(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?cT(t,[1,e]):t)):this.cell.stateSize>1?[cT(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===DG.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){const r=GS(t.cell,n);return new e(Object.assign(t,{cell:r}))}}DG.className="RNN",Qv(DG);class TG extends nS{}class SG extends TG{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,DD(this.units,"units"),this.activation=qN(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=WT(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=WT(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=WT(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=nG(e.kernelRegularizer),this.recurrentRegularizer=nG(e.recurrentRegularizer),this.biasRegularizer=nG(e.biasRegularizer),this.kernelConstraint=wS(e.kernelConstraint),this.recurrentConstraint=wS(e.recurrentConstraint),this.biasConstraint=wS(e.biasConstraint),this.dropout=$D([1,eT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=$D([1,eT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=UT(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return aI((()=>{if(2!==e.length)throw new lD(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=OG({ones:()=>kx(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=OG({ones:()=>kx(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;s=hT(null!=a?KI(e,a):e,this.kernel.read()),null!=this.bias&&(s=mT(s,this.bias.read())),null!=i&&(n=KI(n,i));let A=UI(s,hT(n,this.recurrentKernel.read()));return null!=this.activation&&(A=this.activation.apply(A)),[A,A]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:KN(this.activation),useBias:this.useBias,kernelInitializer:LT(this.kernelInitializer),recurrentInitializer:LT(this.recurrentInitializer),biasInitializer:LT(this.biasInitializer),kernelRegularizer:eG(this.kernelRegularizer),recurrentRegularizer:eG(this.recurrentRegularizer),biasRegularizer:eG(this.biasRegularizer),activityRegularizer:eG(this.activityRegularizer),kernelConstraint:CS(this.kernelConstraint),recurrentConstraint:CS(this.recurrentConstraint),biasConstraint:CS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}SG.className="SimpleRNNCell",Qv(SG);class NG extends DG{constructor(e){e.cell=new SG(e),super(e)}call(e,t){return aI((()=>{null!=this.cell.dropoutMask&&(iI(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(iI(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return new e(t)}}NG.className="SimpleRNN",Qv(NG);class GG extends TG{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new lD("GRUCell does not support reset_after parameter set to true.");this.units=e.units,DD(this.units,"units"),this.activation=qN(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=qN(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=WT(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=WT(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=WT(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=nG(e.kernelRegularizer),this.recurrentRegularizer=nG(e.recurrentRegularizer),this.biasRegularizer=nG(e.biasRegularizer),this.kernelConstraint=wS(e.kernelConstraint),this.recurrentConstraint=wS(e.recurrentConstraint),this.biasConstraint=wS(e.biasConstraint),this.dropout=$D([1,eT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=$D([1,eT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=UT(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return aI((()=>{if(2!==e.length)throw new lD(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=OG({ones:()=>kx(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=OG({ones:()=>kx(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;let i,A,o;0<this.dropout&&this.dropout<1&&(e=KI(e,s[0]));let l=hT(e,this.kernel.read());this.useBias&&(l=mT(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=KI(r,a[0]));const u=this.recurrentKernel.read(),[c,d]=vy(u,[2*this.units,this.units],u.rank-1),h=hT(r,c),[f,g,p]=vy(l,3,l.rank-1),[m,b]=vy(h,2,h.rank-1);i=this.recurrentActivation.apply(UI(f,m)),A=this.recurrentActivation.apply(UI(g,b));const C=hT(KI(A,r),d);o=this.activation.apply(UI(p,C));const I=UI(KI(i,r),KI(UI(1,ex(i)),o));return[I,I]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:KN(this.activation),recurrentActivation:KN(this.recurrentActivation),useBias:this.useBias,kernelInitializer:LT(this.kernelInitializer),recurrentInitializer:LT(this.recurrentInitializer),biasInitializer:LT(this.biasInitializer),kernelRegularizer:eG(this.kernelRegularizer),recurrentRegularizer:eG(this.recurrentRegularizer),biasRegularizer:eG(this.biasRegularizer),activityRegularizer:eG(this.activityRegularizer),kernelConstraint:CS(this.kernelConstraint),recurrentConstraint:CS(this.recurrentConstraint),biasConstraint:CS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}GG.className="GRUCell",Qv(GG);class FG extends DG{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new GG(e),super(e)}call(e,t){return aI((()=>{null!=this.cell.dropoutMask&&(iI(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(iI(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}FG.className="GRU",Qv(FG);class PG extends TG{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,DD(this.units,"units"),this.activation=qN(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=qN(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=WT(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=WT(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=WT(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=nG(e.kernelRegularizer),this.recurrentRegularizer=nG(e.recurrentRegularizer),this.biasRegularizer=nG(e.biasRegularizer),this.kernelConstraint=wS(e.kernelConstraint),this.recurrentConstraint=wS(e.recurrentConstraint),this.biasConstraint=wS(e.biasConstraint),this.dropout=$D([1,eT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=$D([1,eT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=UT(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends kT{apply(t,r){const s=e.apply([n]),a=(new yT).apply([n]),i=e.apply([2*n]);return uT(uT(s,a),i)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return aI((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new lD(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=OG({ones:()=>kx(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=OG({ones:()=>kx(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let A,o,l,u;0<this.dropout&&this.dropout<1&&(e=KI(e,a[0]));let c=hT(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=KI(r,i[0])),c=UI(c,hT(r,this.recurrentKernel.read())),this.useBias&&(c=mT(c,this.bias.read()));const[d,h,f,g]=vy(c,4,c.rank-1);A=this.recurrentActivation.apply(d),o=this.recurrentActivation.apply(h),l=UI(KI(o,s),KI(A,this.activation.apply(f))),u=this.recurrentActivation.apply(g);const p=KI(u,this.activation.apply(l));return[p,p,l]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:KN(this.activation),recurrentActivation:KN(this.recurrentActivation),useBias:this.useBias,kernelInitializer:LT(this.kernelInitializer),recurrentInitializer:LT(this.recurrentInitializer),biasInitializer:LT(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:eG(this.kernelRegularizer),recurrentRegularizer:eG(this.recurrentRegularizer),biasRegularizer:eG(this.biasRegularizer),activityRegularizer:eG(this.activityRegularizer),kernelConstraint:CS(this.kernelConstraint),recurrentConstraint:CS(this.recurrentConstraint),biasConstraint:CS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}PG.className="LSTMCell",Qv(PG);class QG extends DG{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new PG(e),super(e)}call(e,t){return aI((()=>{null!=this.cell.dropoutMask&&(iI(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(iI(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}QG.className="LSTM",Qv(QG);class zG extends TG{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return aI((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let a;for(let i=0;i<this.cells.length;++i){const A=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=A.call(a,t),s.push(a.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;_T(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{jD(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t,n={}){const r=[];for(const e of t.cells)r.push(GS(e,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return XT(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,s=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}qT(t)}}function OG(e){const{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>null!=a?a(t(),n):bT(t(),n),A=()=>CT(i,t,r);if(!s||s<=1)return AI(A().clone());return Array(s).fill(void 0).map(A).map((e=>AI(e.clone())))}zG.className="StackedRNNCells",Qv(zG);var RG=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n};class LG extends DG{constructor(e){if(e.unroll)throw new uD("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new uD("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new ZT({ndim:5})]}call(e,t){return aI((()=>{if(null!=this.cell.dropoutMask&&(iI(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(iI(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new lD("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return aI((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=fx([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(s):[s]}))}resetStates(e,t=!1){aI((()=>{if(!this.stateful)throw new AD("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(null==n[0])throw new lD("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>fx(s))):this.states_=[fx(s)];else if(null==e)iI(this.states_),null!=this.keptStates&&(iI(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>fx(s))):this.states_[0]=fx(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new lD(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):iI(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=s;if(!Rf(n.shape,r))throw new lD(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>AI(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,A="channelsFirst"===t,o=e[A?3:2],l=e[A?4:3],u=uG(o,r[0],s,a[0],i[0]),c=uG(l,r[1],s,a[1],i[1]);return[...e.slice(0,2),...A?[n,u,c]:[u,c,n]]}}LG.className="ConvRNN2D";class WG extends PG{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,DD(this.filters,"filters"),this.kernelSize=lG(n,2,"kernelSize"),this.kernelSize.forEach((e=>DD(e,"kernelSize"))),this.strides=lG(r||1,2,"strides"),this.strides.forEach((e=>DD(e,"strides"))),this.padding=s||"valid",VD(this.padding),this.dataFormat=a||"channelsLast",_D(this.dataFormat),this.dilationRate=lG(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>DD(e,"dilationRate")))}build(e){var t;e=UT(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new lD(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],s=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends kT{apply(e,t){return lT([n.apply([r]),gx([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return aI((()=>{if(3!==e.length)throw new lD(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],s=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=OG({ones:()=>kx(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,A=(e,t,n)=>t&&t[n]?KI(t[n],e):e;let o=A(r,i,0),l=A(r,i,1),u=A(r,i,2),c=A(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=OG({ones:()=>kx(s),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let h=A(s,d,0),f=A(s,d,1),g=A(s,d,2),p=A(s,d,3);const[m,b,C,I]=vy(this.kernel.read(),4,3),[w,k,x,y]=this.useBias?vy(this.bias.read(),4):[null,null,null,null];o=this.inputConv(o,m,w,this.padding),l=this.inputConv(l,b,k,this.padding),u=this.inputConv(u,C,x,this.padding),c=this.inputConv(c,I,y,this.padding);const[v,E,B,M]=vy(this.recurrentKernel.read(),4,3);h=this.recurrentConv(h,v),f=this.recurrentConv(f,E),g=this.recurrentConv(g,B),p=this.recurrentConv(p,M);const D=this.recurrentActivation.apply(UI(o,h)),T=this.recurrentActivation.apply(UI(l,f)),S=UI(KI(T,a),KI(D,this.activation.apply(UI(u,g)))),N=KI(this.recurrentActivation.apply(UI(c,p)),this.activation.apply(S));return[N,N,S]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=RG(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const s=Hw(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?mT(s,n,this.dataFormat):s}recurrentConv(e,t){return Hw(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}WG.className="ConvLSTM2DCell",Qv(WG);class _G extends LG{constructor(e){const t=new WG(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}_G.className="ConvLSTM2D",Qv(_G);class VG extends nS{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let e=0;e<this.noiseShape.length;++e)n.push(null==this.noiseShape[e]?t[e]:this.noiseShape[e]);return n}call(e,t){return aI((()=>{this.invokeCallHook(e,t);const n=HT(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return CT((()=>bT(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}VG.className="Dropout",Qv(VG);class HG extends VG{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}HG.className="SpatialDropout1D",Qv(HG);class UG extends nS{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,DD(this.units,"units"),this.activation=qN(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=WT(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=WT(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=wS(e.kernelConstraint),this.biasConstraint=wS(e.biasConstraint),this.kernelRegularizer=nG(e.kernelRegularizer),this.biasRegularizer=nG(e.biasRegularizer),this.activityRegularizer=nG(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=UT(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=UT(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return aI((()=>{this.invokeCallHook(e,t);const n=HT(e),r=SD(this.activation.getClassName());let s;return null!=r?s=hT(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=hT(n,this.kernel.read()),null!=this.bias&&(s=mT(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s}))}getConfig(){const e={units:this.units,activation:KN(this.activation),useBias:this.useBias,kernelInitializer:LT(this.kernelInitializer),biasInitializer:LT(this.biasInitializer),kernelRegularizer:eG(this.kernelRegularizer),biasRegularizer:eG(this.biasRegularizer),activityRegularizer:eG(this.activityRegularizer),kernelConstraint:CS(this.kernelConstraint),biasConstraint:CS(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}UG.className="Dense",Qv(UG);class jG extends nS{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=UT(e);for(const t of e.slice(1))if(null==t)throw new lD(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],JD(e,1)]}call(e,t){return aI((()=>{this.invokeCallHook(e,t);let n=HT(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=Vy(n,e)}return function(e){if(e.rank<=1)throw new lD(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],JD(e.shape,1)];return kw(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}jG.className="Flatten",Qv(jG);class YG extends nS{constructor(e){super(e),this.supportsMasking=!0,this.activation=qN(e.activation)}call(e,t){return aI((()=>{this.invokeCallHook(e,t);const n=HT(e);return this.activation.apply(n)}))}getConfig(){const e={activation:KN(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}YG.className="Activation",Qv(YG);class KG extends nS{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return aI((()=>function(e,t){return aI((()=>{if(2!==e.shape.length)throw new lD(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return cT(aT(e,1),[1,t,1])}))}(e=HT(e),this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}KG.className="RepeatVector",Qv(KG);class XG extends nS{constructor(e){super(e),this.targetShape=e.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let s=1,a=null;for(let e=0;e<r.length;++e){const t=r[e];if(this.isUnknown(t)){if(null!==a)throw new lD("Can only specifiy one unknown dimension.");a=e}else s*=t}const i=JD(e);if(null!==a){if(0===s||i%s!==0)throw new lD(n);r[a]=i/s}else if(i!==s)throw new lD(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return aI((()=>{this.invokeCallHook(e,t);const n=HT(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return kw(n,s)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}XG.className="Reshape",Qv(XG);class qG extends nS{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=tT(1,e.dims.length+1);if(!Rf(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ZT({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=UT(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return Vy(HT(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}qG.className="Permute",Qv(qG);class ZG extends nS{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=HT(e);return $I(Ix(n,this.maskValue),-1)}call(e,t){return aI((()=>{this.invokeCallHook(e,t);const n=HT(e),r=$I(Ix(n,this.maskValue),-1,!0);return KI(n,_I(r,n.dtype))}))}}ZG.className="Masking",Qv(ZG);class JG extends nS{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(mD(e.inputLength))}this.inputDim=e.inputDim,DD(this.inputDim,"inputDim"),this.outputDim=e.outputDim,DD(this.outputDim,"outputDim"),this.embeddingsInitializer=WT(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=nG(e.embeddingsRegularizer),this.activityRegularizer=nG(e.activityRegularizer),this.embeddingsConstraint=wS(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return aI((()=>this.maskZero?(e=HT(e),Ix(e,uk(e))):null))}computeOutputShape(e){if(e=UT(e),null==this.inputLength)return[...e,this.outputDim];const t=mD(this.inputLength);if(t.length!==e.length-1)throw new lD(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const s=t[r],a=e[r+1];if(null!=s&&null!=a&&s!==a)throw new lD(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==s&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return aI((()=>{this.invokeCallHook(e,t);let n=HT(e);"int32"!==n.dtype&&(n=sT(n,"int32"));const r=fT(this.embeddings.read(),kw(n,[n.size]));return kw(r,UT(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:LT(this.embeddingsInitializer),embeddingsRegularizer:eG(this.embeddingsRegularizer),activityRegularizer:eG(this.activityRegularizer),embeddingsConstraint:CS(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}JG.className="Embedding",Qv(JG);class $G extends nS{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new uD}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const s=e[e.length-t.length+r],a=t[r];if(null==s||null==a||s<0||a<0)n.push(null);else if(1===s)n.push(a);else if(1===a)n.push(s);else{if(s!==a)throw new lD("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[UT(e)]),e.length<2)throw new lD(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const n of e)null!=n&&null!==n[0]&&t.push(n[0]);if(t=vD(t),t.length>1)throw new lD(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let t=1;t<e.length;++t){const r=null==e[t]?null:e[t].slice(1);n=this.computeElementwiseOpOutputShape(n,r)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===vD(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return aI((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=eT(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=aT(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const r of e){const e=r.rank;if(null==e){const e=r.shape,s=e[0],a=e.slice(1).concat([s]);let i=kw(r,[s].concat(JD(e.slice(1))));i=Vy(i,[1,0]),i=kw(i,a),t.push(i),n=!0}else if(e>1){const s=tT(1,e).concat([0]);t.push(Vy(r,s)),n=!0}else t.push(r)}let r=this.mergeFunction(t);const s=r.rank;if(n)if(null==s){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=kw(Vy(kw(r,[-1,t]),[1,0]),n)}else if(s>1){const e=[s-1].concat(tT(0,s-1));r=Vy(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let n=1;n<e.length;++n){const r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(const t of e)null!=t&&null!==t[0]&&n.push(t[0]);return n=vD(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return aI((()=>{if(null==t)return null;if(!Array.isArray(t))throw new lD("`mask` should be an Array");if(!Array.isArray(e))throw new lD("`inputs` should be an Array");if(t.length!==e.length)throw new lD(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;t=t.map((e=>null==e?e:Pk(e,0)));let n=t[0];for(let e=1;e<t.length-1;++e)n=ix(n,t[e]);return n}))}}class eF extends $G{constructor(e){super(e)}mergeFunction(e){return aI((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=UI(t,e[n]);return t}))}}eF.className="Add",Qv(eF);class tF extends $G{constructor(e){super(e)}mergeFunction(e){return aI((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=KI(t,e[n]);return t}))}}tF.className="Multiply",Qv(tF);class nF extends $G{constructor(e){super(e)}mergeFunction(e){return aI((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=UI(t,e[n]);return KI(1/e.length,t)}))}}nF.className="Average",Qv(nF);class rF extends $G{constructor(e){super(e)}mergeFunction(e){return aI((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=dx(t,e[n]);return t}))}}rF.className="Maximum",Qv(rF);class sF extends $G{constructor(e){super(e)}mergeFunction(e){return aI((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=px(t,e[n]);return t}))}}sF.className="Minimum",Qv(sF);class aF extends $G{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new lD("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const n of e)if(null!=n){t=!1;break}if(t)return;const n=[];for(let t=0;t<e.length;++t){const r=e[t].slice();r.splice(this.axis,1);let s=!1;for(const e of n)if(Rf(e,r)){s=!0;break}s||n.push(r)}if(n.length>1)throw new lD("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return aI((()=>lT(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new lD("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const e of t.slice(1)){if(null==n[r]||null==e[r]){n[r]=null;break}n[r]+=e[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new lD("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new lD("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new lD(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return aI((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let n=0;n<e.length;++n)null==t[n]?r.push(_I(kx(e[n]),"bool")):t[n].rank<e[n].rank?r.push(Pk(t[n],-1)):r.push(t[n]);const s=vw(r,this.axis);return JI(s,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function iF(e,t){for(;e<0;)e+=t;return e}aF.className="Concatenate",Qv(aF);class AF extends $G{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Pf(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new uD("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new lD(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new lD(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>iF(t,e[n].shape.length))):[iF(this.axes,n.shape.length),iF(this.axes,r.shape.length)],this.normalize&&(n=FS(n,t[0]),r=FS(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new uD("batchDot is not implemented for tensors of 4D or higher rank yet");if(Pf(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),Pf(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new uD("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;null==n&&(n=[r-1,s-2]);const a=n;return aI((()=>{let n,i;if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=kw(t,t.shape.concat(e))}else if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=kw(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=a[0]===a[1]?Tk(KI(e,t),a[0]):Tk(KI(Vy(e,[1,0]),t),a[1]);else{const n=a[0]!==e.shape.length-1,r=a[1]===t.shape.length-1;i=Ew(e,t,n,r)}if(n>0){let e;e=r>s?r+s-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=My(i,t)}return 1===i.shape.length&&(i=Pk(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[iF(this.axes,e.length),iF(this.axes,t.length)],n}computeOutputShape(e){Pf(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new uD("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}AF.className="Dot",Qv(AF);class oF extends nS{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return aI((()=>{this.invokeCallHook(e,t);const n=HT(e);return CT((()=>UI(dT(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}oF.className="GaussianNoise",Qv(oF);class lF extends nS{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return aI((()=>{this.invokeCallHook(e,t);const n=HT(e);if(this.rate>0&&this.rate<1){return CT((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return KI(n,dT(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}lF.className="GaussianDropout",Qv(lF);class uF extends nS{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||HT(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return aI((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=HT(e),r=-1.7580993408473766;let s=_k(ry(n),this.rate);s=sT(s,"float32");const a=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-a*r*this.rate,A=UI(KI(t,s),KI(UI(s,-1),r));return UI(KI(A,a),i)};return CT(r,(()=>HT(e)),t.training||!1)}return e}))}}function cF(e,t,n,r,s,a=.001){let i;if(2===e.rank)i=Nw(e,t,n,r,s,a);else if(3===e.rank)i=Gw(e,t,n,r,s,a);else{if(4!==e.rank)throw new uD(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=Fw(e,t,n,r,s,a)}return i}function dF(e,t,n,r,s=.001){return Rf(r.slice().sort(),tT(0,e.rank-1))?function(e,t,n,r,s=.001){return aI((()=>{const a=Cx(e,r),i=a.mean,A=a.variance;return[cF(e,i,A,n,t,s),i,A]}))}(e,t,n,r,s):function(e,t,n,r,s=.001){return aI((()=>{const a=Cx(e,r),i=a.mean,A=a.variance,o=[];for(const t of tT(0,e.rank))-1!==r.indexOf(t)?o.push(1):o.push(e.shape[t]);const l=kw(i,o),u=kw(A,o),c=null==t?null:kw(t,o),d=null==n?null:kw(n,o);return[cF(e,l,u,d,c,s),i,A]}))}(e,t,n,r,s)}uF.className="AlphaDropout",Qv(uF);class hF extends nS{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=WT(e.betaInitializer||"zeros"),this.gammaInitializer=WT(e.gammaInitializer||"ones"),this.movingMeanInitializer=WT(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=WT(e.movingVarianceInitializer||"ones"),this.betaConstraint=wS(e.betaConstraint),this.gammaConstraint=wS(e.gammaConstraint),this.betaRegularizer=nG(e.betaRegularizer),this.gammaRegularizer=nG(e.gammaRegularizer)}build(e){e=UT(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new lD(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new ZT({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return aI((()=>{const n=null!=t.training&&t.training,r=HT(e),s=r.shape,a=s.length,i=tT(0,a),A=this.axis>=0?this.axis:this.axis+a;i.splice(A,1);const o=hD(1,a);o[A]=s[A];const l=i.slice();l.sort();const u=!Rf(l,tT(0,a).slice(0,a-1));if(!n)return(()=>{if(u){const e=kw(this.movingMean.read(),o),t=kw(this.movingVariance.read(),o),n=this.center?kw(this.beta.read(),o):null,s=this.scale?kw(this.gamma.read(),o):null;return cF(r,e,t,n,s,this.epsilon)}return cF(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[c,d,h]=dF(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{aI((()=>{const r=1-n,s=e.read(),a=KI(rx(s,t),r);e.write(rx(s,a))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,h,this.momentum)})(),c}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:LT(this.betaInitializer),gammaInitializer:LT(this.gammaInitializer),movingMeanInitializer:LT(this.movingMeanInitializer),movingVarianceInitializer:LT(this.movingVarianceInitializer),betaRegularizer:eG(this.betaRegularizer),gammaRegularizer:eG(this.gammaRegularizer),betaConstraint:CS(this.betaConstraint),gammaConstraint:CS(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}hF.className="BatchNormalization",Qv(hF);class fF extends nS{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=WT(e.betaInitializer||"zeros"),this.gammaInitializer=WT(e.gammaInitializer||"ones"),this.betaRegularizer=nG(e.betaRegularizer),this.gammaRegularizer=nG(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=UT(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let e=0;e<this.axis.length;++e)this.axis[e]<0&&(this.axis[e]+=t);for(const e of this.axis)if(e<0||e>=t)throw new Error(`Invalid axis: ${e}`);if(this.axis.length!==vD(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=HT(e),r=n.shape,s=r.length;return aI((()=>{let{mean:e,variance:t}=Cx(n,this.axis,!0);const a=hD(1,s);for(const e of this.axis)a[e]=r[e];const i=e=>null!=e&&e.shape.length!==s?kw(e,a):e;let A=this.scale?i(this.gamma.read()):null,o=this.center?i(this.beta.read()):null;const l=[],u=[];for(let e=0;e<s;++e)-1!==this.axis.indexOf(e)?(l.push(r[e]),u.push(1)):(l.push(1),u.push(r[e]));return e=zk(e,l),t=zk(t,l),null!=A&&(A=zk(A,u)),null!=o&&(o=zk(o,u)),cF(n,e,t,o,A,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:LT(this.betaInitializer),gammaInitializer:LT(this.gammaInitializer),betaRegularizer:eG(this.betaRegularizer),gammaRegularizer:eG(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}fF.className="LayerNormalization",Qv(fF);class gF extends nS{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new lD(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new lD(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new lD(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new ZT({ndim:4})]}computeOutputShape(e){let t,n;return e=UT(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return aI((()=>function(e,t,n){return aI((()=>{if(4!==e.rank)throw new lD(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new lD("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new lD(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],xx(e,r)}))}(HT(e),this.padding,this.dataFormat)))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function pF(e,t,n,r,s,a){return aI((()=>{let i;_D(s),HD(a),VD(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=dG(e,s);const A="same"===r?"same":"valid";return i="max"===a?ux(e,t,n,A):xw(e,t,n,A),"channelsFirst"===s&&(i=Vy(i,[0,3,1,2])),i}))}function mF(e,t,n,r,s,a){return aI((()=>{let i;_D(s),HD(a),VD(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=hG(e,s);const A="same"===r?"same":"valid";return i="max"===a?cx(e,t,n,A):yw(e,t,n,A),"channelsFirst"===s&&(i=Vy(i,[0,4,1,2,3])),i}))}gF.className="ZeroPadding2D",Qv(gF);class bF extends nS{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new lD(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(DD(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new lD(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}DD(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,VD(this.padding),this.inputSpec=[new ZT({ndim:3})]}computeOutputShape(e){const t=uG((e=UT(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return aI((()=>{this.invokeCallHook(e,t),e=aT(HT(e),2);const n=this.poolingFunction(HT(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return My(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class CF extends bF{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return _D(s),VD(r),pF(e,t,n,r,s,"max")}}CF.className="MaxPooling1D",Qv(CF);class IF extends bF{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return _D(s),VD(r),pF(e,t,n,r,s,"avg")}}IF.className="AveragePooling1D",Qv(IF);class wF extends nS{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new lD(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];DD(this.poolSize,"poolSize"),DD(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,_D(this.dataFormat),VD(this.padding),this.inputSpec=[new ZT({ndim:4})]}computeOutputShape(e){e=UT(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=uG(t,this.poolSize[0],this.padding,this.strides[0]),n=uG(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return aI((()=>(this.invokeCallHook(e,t),this.poolingFunction(HT(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class kF extends wF{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return _D(s),VD(r),pF(e,t,n,r,s,"max")}}kF.className="MaxPooling2D",Qv(kF);class xF extends wF{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return _D(s),VD(r),pF(e,t,n,r,s,"avg")}}xF.className="AveragePooling2D",Qv(xF);class yF extends nS{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new lD(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];DD(this.poolSize,"poolSize"),DD(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,_D(this.dataFormat),VD(this.padding),this.inputSpec=[new ZT({ndim:5})]}computeOutputShape(e){e=UT(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=uG(t,this.poolSize[0],this.padding,this.strides[0]),n=uG(n,this.poolSize[1],this.padding,this.strides[1]),r=uG(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return aI((()=>(this.invokeCallHook(e,t),this.poolingFunction(HT(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class vF extends yF{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return _D(s),VD(r),mF(e,t,n,r,s,"max")}}vF.className="MaxPooling3D",Qv(vF);class EF extends yF{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return _D(s),VD(r),mF(e,t,n,r,s,"avg")}}EF.className="AveragePooling3D",Qv(EF);class BF extends nS{constructor(e){super(e),this.inputSpec=[new ZT({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new uD}}class MF extends BF{constructor(e){super(e||{})}call(e,t){return aI((()=>{const t=HT(e);return hx(t,1)}))}}MF.className="GlobalAveragePooling1D",Qv(MF);class DF extends BF{constructor(e){super(e||{})}call(e,t){return aI((()=>{const t=HT(e);return yk(t,1)}))}}DF.className="GlobalMaxPooling1D",Qv(DF);class TF extends nS{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,_D(this.dataFormat),this.inputSpec=[new ZT({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new uD}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class SF extends TF{call(e,t){return aI((()=>{const t=HT(e);return"channelsLast"===this.dataFormat?hx(t,[1,2]):hx(t,[2,3])}))}}SF.className="GlobalAveragePooling2D",Qv(SF);class NF extends TF{call(e,t){return aI((()=>{const t=HT(e);return"channelsLast"===this.dataFormat?yk(t,[1,2]):yk(t,[2,3])}))}}NF.className="GlobalMaxPooling2D",Qv(NF);class GF extends nS{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const r=GS(t.layer,n);delete t.layer;const s={layer:r};return Object.assign(s,t),new e(s)}}class FF extends GF{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=UT(e)).length<3)throw new lD(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=UT(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return aI((()=>MG(((e,n)=>[HT(this.layer.call(e,t)),[]]),e=HT(e),[],!1,null,0,!1,!0)[1]))}}FF.className="TimeDistributed",Qv(FF);class PF extends GF{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=GS(n),t.goBackwards=!0!==t.goBackwards;const r={};var s;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=GS(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,s=this.mergeMode,BD(LD,"BidirectionalMergeMode",s),e.weights)throw new uD("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState?(r=s.slice(1),t=s[0]):t=s[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):pD(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=BG(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const a=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new lD("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);const r=n.map((e=>new ZT({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new uD("Support for constants in Bidirectional layers is not implemented yet.");const A=a[0]instanceof JT;for(const e of a)if(e instanceof JT!==A)throw new lD("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(A){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const A=super.apply(n,t);return this.inputSpec=s,A}return super.apply(e,t)}call(e,t){return aI((()=>{const n=t.initialState;let r,s,a,i;if(null==n)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const a=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=ly(s,1)),"concat"===this.mergeMode?i=lT([r,s]):"sum"===this.mergeMode?i=UI(r,s):"ave"===this.mergeMode?i=KI(.5,UI(r,s)):"mul"===this.mergeMode?i=KI(r,s):null==this.mergeMode&&(i=[r,s]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){jD(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),jD(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=GS(t.layer);if(delete t.layer,null!=t.numConstants)throw new uD("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}PF.className="Bidirectional",Qv(PF);class QF extends nS{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return aI((()=>("float32"!==(e=HT(e)).dtype&&(e=sT(e,"float32")),UI(KI(e,this.scale),this.offset))))}}QF.className="Rescaling",Qv(QF);const{resizeBilinear:zF,cropAndResize:OF}=Tv;class RF extends nS{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,s,a,i,A){return aI((()=>{let o,l=!1;const u=[t/a,n/i,(r+t)/a,(s+n)/i],c=[];3===e.rank?(l=!0,o=Dy([e])):o=e;for(let e=0;e<o.shape[0];e++)c.push(u);const d=tI(c,[c.length,4]),h=sy(0,c.length,1,"int32"),f=OF(o,d,h,[r,s],"nearest");return sT(l?HT(Wy(f)):f,A)}))}upsize(e,t,n,r){return aI((()=>sT(zF(e,[t,n]),r)))}call(e,t){return aI((()=>{const t=HT(e),n=t.dtype,r=t.shape,s=r[r.length-3],a=r[r.length-2];let i=0;s!==this.height&&(i=Math.floor((s-this.height)/2));let A=0;return a!==this.width&&(A=Math.floor((a-this.width)/2),0===A&&(A=1)),i>=0&&A>=0?this.centerCrop(t,i,A,this.height,this.width,s,a,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=UT(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}RF.className="CenterCrop",Qv(RF);class LF extends nS{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=UT(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return aI((()=>{let n;if("int32"!==(e=HT(e)).dtype&&(e=sT(e,"int32")),void 0!==t.countWeights){if("count"!==this.outputMode)throw new lD(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=HT(t.countWeights)}const r=yk(e),s=vk(e),a=Wk(this.numTokens,r).bufferSync().get(0),i=_k(s,0).bufferSync().get(0);if(!a||!i)throw new lD(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let s=HT(e);if("int32"!==s.dtype&&(s=sT(s,"int32")),"int"===t)return s;const a=s.shape;if(0===s.rank&&(s=Pk(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=Pk(s,-1)),s.rank>2)throw new lD(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t);let A;if(A=tk(s,void 0!==r&&"count"===t?r:[],n,i),"tfIdf"!==t)return A;if(r)return KI(A,r);throw new lD("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}LF.className="CategoryEncoding",Qv(LF);const WF=new Set(["bilinear","nearest"]);class _F extends nS{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!WF.has(e.interpolation))throw new lD(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=UT(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return aI((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return Tv.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Tv.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...WF]} are supported`)}))}}_F.className="Resizing",Qv(_F);class VF{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}VF.className="RandomSeed";class HF extends nS{constructor(e){super(e),this.randomGenerator=new VF(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}HF.className="BaseRandomLayer";const UF=new Set(["bilinear","nearest"]);class jF extends HF{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new lD(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new lD(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new lD(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!UF.has(n))throw new lD(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=UT(e))[2];return[this.imgHeight,-1,t]}call(e,t){return aI((()=>{const t=HT(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=ry([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const s=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return Tv.resizeBilinear(e,s);case"nearest":return Tv.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...UF]} are supported`)}}))}}jF.className="RandomWidth",Qv(jF);var YF,KF,XF;function qF(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Pf("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}gg().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(YF||(YF={})),function(e){var t;(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(KF||(KF={})),function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(XF||(XF={}));const ZF=_y;class JF extends Df{nextDataId(){return JF.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Mf(this,rI())}write(e,t,n){this.firstUse&&(this.firstUse=!1,gg().get("IS_NODE")&&Db("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Zf(n[0])){const s=n.map((e=>AC(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return FE(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>oC(e)));return WI(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return WI(e.shape,e.dtype,t)}makeOutput(e,t,n){return rI().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=iC();e();return{kernelMs:iC()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){qF([e],"where");const t=this.readSync(e.dataId);return ZF(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function $F(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}JF.nextDataId=0;const eP={kernelName:Ig,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;qF(t,"abs");let r=new Float32Array(Of(t.shape));return r=$F(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}};function tP(e){return(t,n,r,s,a)=>{const i=Ak(t,n),A=i.length,o=ng(i),l=Yf(a,Of(i)),u=t.length,c=n.length,d=ng(t),h=ng(n),f=ak(t,i),g=ak(n,i);if(f.length+g.length===0)for(let t=0;t<l.length;++t)l[t]=e(r[t%r.length],s[t%s.length]);else for(let t=0;t<l.length;++t){const n=ug(t,A,o),a=n.slice(-u);f.forEach((e=>a[e]=0));const i=lg(a,u,d),p=n.slice(-c);g.forEach((e=>p[e]=0));const m=lg(p,c,h);l[t]=e(r[i],s[m])}return[l,i]}}function nP(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,A=n.makeTensorInfo(r.shape,"complex64");return n.data.get(A.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},A}const rP={kernelName:jg,backendName:"cpu",kernelFunc:nP};function sP(e,t,n="float32"){if("complex64"===n){return nP({inputs:{real:sP(e,t,"float32"),imag:sP(e,t,"float32")},backend:e})}const r=ig(Of(t),n);return e.makeTensorInfo(t,n,r)}function aP(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const iP={kernelName:Fp,backendName:"cpu",kernelFunc:aP};function AP(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const oP={kernelName:Bm,backendName:"cpu",kernelFunc:AP};function lP(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){const r=aC([0],n),[s,a]=tP(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function uP(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if("complex64"===a){if("complex64"===s.dtype)return aP({inputs:{x:s},backend:n});const e=sP(n,s.shape,s.dtype),t=uP({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=nP({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=AP({inputs:{input:s},backend:n}),t=uP({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!Xf(s.dtype,a)){const e=aP({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}const i=n.data.get(s.dataId).values,[A,o,l]=lP(i,s.shape,s.dtype,a);return n.makeTensorInfo(A,o,l)}const cP={kernelName:Vg,backendName:"cpu",kernelFunc:uP};function dP(e,t,n,r){return null==n?({inputs:n,backend:s})=>{const{a:a,b:i}=n,A=s;qF([a,i],e);const o=A.data.get(a.dataId).values,l=A.data.get(i.dataId).values,u="string"===a.dtype?hB(o):o,c="string"===a.dtype?hB(l):l,d=r||a.dtype,[h,f]=t(a.shape,i.shape,u,c,d);return A.makeTensorInfo(f,d,h)}:({inputs:e,backend:s})=>{const{a:a,b:i}=e,A=s;if("complex64"===a.dtype||"complex64"===i.dtype){const e=uP({inputs:{x:a},backend:A,attrs:{dtype:"complex64"}}),t=A.data.get(e.dataId),r=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,o=A.data.get(r.dataId).values,l=A.data.get(s.dataId).values,u=uP({inputs:{x:i},backend:A,attrs:{dtype:"complex64"}}),c=A.data.get(u.dataId),d=c.complexTensorInfos.real,h=c.complexTensorInfos.imag,f=A.data.get(d.dataId).values,g=A.data.get(h.dataId).values,[p,m,b]=n(a.shape,i.shape,o,l,f,g),C=A.makeTensorInfo(b,"float32",p),I=A.makeTensorInfo(b,"float32",m),w=nP({inputs:{real:C,imag:I},backend:A});return A.disposeIntermediateTensorInfo(e),A.disposeIntermediateTensorInfo(u),A.disposeIntermediateTensorInfo(C),A.disposeIntermediateTensorInfo(I),w}{const e=A.data.get(a.dataId).values,n=A.data.get(i.dataId).values,s=r||a.dtype,[o,l]=t(a.shape,i.shape,e,n,s);return A.makeTensorInfo(l,s,o)}}}function hP(e){return(t,n,r,s,a,i)=>{const A=Ak(t,n),o=Of(A),l=A.length,u=ng(A),c=Yf("float32",o),d=Yf("float32",o),h=ak(t,A),f=ak(n,A),g=FE(r,s),p=FE(a,i),m=t.length,b=ng(t),C=n.length,I=ng(n);if(h.length+f.length===0)for(let t=0;t<c.length;t++){const n=t%g.length,r=t%p.length,s=e(g[2*n],g[2*n+1],p[2*r],p[2*r+1]);c[t]=s.real,d[t]=s.imag}else for(let t=0;t<c.length;t++){const n=ug(t,l,u),r=n.slice(-m);h.forEach((e=>r[e]=0));const s=lg(r,m,b),a=n.slice(-C);f.forEach((e=>a[e]=0));const i=lg(a,C,I),A=e(g[2*s],g[2*s+1],p[2*i],p[2*i+1]);c[t]=A.real,d[t]=A.imag}return[c,d,A]}}const fP=tP(((e,t)=>e+t)),gP=hP(((e,t,n,r)=>({real:e+n,imag:t+r}))),pP=dP(xg,fP,gP),mP={kernelName:xg,backendName:"cpu",kernelFunc:pP};function bP(e,t,n,r,s){const a=Of(r),i=ig(s,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=s||(i[r]+=a>0?t[n]:1)}return i}function CP(e,t,n,r=!1){const s=e.shape[0],a=e.shape[1],i=WI([s,n],t.dtype);for(let A=0;A<s;A++)for(let s=0;s<a;s++){const a=e.get(A,s);if(a<0)throw new Error("Input x must be non-negative!");a>=n||(r?i.set(1,A,a):t.size>0?i.set(i.get(A,a)+t.get(A,s),A,a):i.set(i.get(A,a)+1,A,a))}return i}const IP=tP(((e,t)=>e&t)),wP={kernelName:Wg,backendName:"cpu",kernelFunc:dP(Wg,IP)};function kP(e){return(t,n,r)=>{const s=Kf(n,t.length);for(let n=0;n<t.length;++n)s[n]=e(t[n],r);return s}}function xP(e,t,n){return yP(e,kP(t),n)}function yP(e,t,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;qF(i,e);const A=a,o=A.data.get(i.dataId).values;let l;if("string"===i.dtype){if(!Array.isArray(o))throw new Error("String tensor's value was not an instance of Array");l=hB(o)}else l=o;const u=n||i.dtype,c=t(l,u,s);return A.makeTensorInfo(i.shape,u,c)}}const vP=kP((e=>Math.ceil(e))),EP=yP(Hg,vP),BP={kernelName:Hg,backendName:"cpu",kernelFunc:EP};function MP(e,t,n,r){const s=Kf(n,Of(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=Of(e.shape);s.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const a="string"===n?hB(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const A=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[A+t]=a[i++]}r+=e.shape[1]}))}return s}const DP=tP(((e,t)=>e===t?1:0)),TP=dP(Ip,DP,null,"bool"),SP={kernelName:Ip,backendName:"cpu",kernelFunc:TP},NP=kP((e=>Math.exp(e))),GP=yP(wp,NP,"float32"),FP={kernelName:wp,backendName:"cpu",kernelFunc:GP},PP=kP((e=>Math.expm1(e))),QP=yP(xp,PP),zP={kernelName:xp,backendName:"cpu",kernelFunc:QP},OP=kP((e=>Math.floor(e))),RP=yP(Bp,OP),LP={kernelName:Bp,backendName:"cpu",kernelFunc:RP},WP=tP(((e,t)=>Math.floor(e/t))),_P=dP(Mp,WP,null,"int32"),VP={kernelName:Mp,backendName:"cpu",kernelFunc:_P};function HP(e,t,n,r,s,a,i,A,o){const l=WI([r,a],n);for(let n=0;n<r;n++){const r=[];let u=0;for(let t=0;t<s;t++){const a=e[n*s+t];u+=a*i[t],r.push(a)}if(u<0||u>=o/a)throw new Error(`Invalid indices: ${r} does not index into ${A}`);for(let e=0;e<a;e++)l.values[n*a+e]=t.get(...t.indexToLoc(u*a+e))}return l}function UP(e,t,n){const r=WI(n,e.dtype);for(let n=0;n<r.size;++n){const s=r.indexToLoc(n).slice(),a=s[0],i=s[2],A=t.locToIndex([a,i]);s[2]=t.values[A];const o=e.locToIndex(s);0<=o&&o<e.values.length&&(r.values[n]=e.values[o])}return r}const jP=tP(((e,t)=>e>t?1:0)),YP=dP(Np,jP,null,"bool"),KP={kernelName:Np,backendName:"cpu",kernelFunc:YP},XP=tP(((e,t)=>e>=t?1:0)),qP=dP(Gp,XP,null,"bool"),ZP={kernelName:Gp,backendName:"cpu",kernelFunc:qP},JP=tP(((e,t)=>e<t?1:0)),$P=dP(Wp,JP,null,"bool"),eQ={kernelName:Wp,backendName:"cpu",kernelFunc:$P},tQ=tP(((e,t)=>e<=t?1:0)),nQ=dP(_p,tQ,null,"bool"),rQ={kernelName:_p,backendName:"cpu",kernelFunc:nQ};function sQ(e,t,n){const r=(t-e)/(n-1),s=ig(n,"float32");s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+r;return s}const aQ=kP((e=>Math.log(e))),iQ=yP(Hp,aQ),AQ={kernelName:Hp,backendName:"cpu",kernelFunc:iQ};function oQ(e,t,n,r){const s=Yf(r,Of(n));for(let n=0;n<s.length;++n){const r=n*t;let a=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>a)&&(a=t)}s[n]=a}return s}const lQ=tP(((e,t)=>Math.max(e,t))),uQ=dP(Jp,lQ),cQ={kernelName:Jp,backendName:"cpu",kernelFunc:uQ},dQ=tP(((e,t)=>Math.min(e,t))),hQ=dP(im,dQ),fQ={kernelName:im,backendName:"cpu",kernelFunc:hQ},gQ=tP(((e,t)=>e*t)),pQ=hP(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),mQ=dP(um,gQ,pQ),bQ={kernelName:um,backendName:"cpu",kernelFunc:mQ};function CQ(e,t,n){const r=sC(-1,n);return gQ([],t,r,e,n)}const IQ={kernelName:cm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;qF(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=CQ(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}},wQ=tP(((e,t)=>e!==t?1:0)),kQ=dP(dm,wQ,null,"bool"),xQ={kernelName:dm,backendName:"cpu",kernelFunc:kQ};function yQ(e,t,n,r,s){const a=t.length,i=Of(t),A=ng(t),o=ng(s),l=Yf(n,Of(s));for(let t=0;t<i;++t){const n=ug(t,a,A),s=new Array(n.length);for(let e=0;e<s.length;e++)s[e]=n[r[e]];l[lg(s,a,o)]=e[t]}return l}function vQ(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;qF(s,"transpose");const i=s.shape.length,A=new Array(i);for(let e=0;e<A.length;e++)A[e]=s.shape[a[e]];const o=yQ(r.data.get(s.dataId).values,s.shape,s.dtype,a,A);return{dataId:r.write(o,A,s.dtype),shape:A,dtype:s.dtype}}const EQ={kernelName:Cb,backendName:"cpu",kernelFunc:vQ};function BQ(e,t,n,r){const[s,a]=bk(e,r),i=SC(t,"int32"),A=ig(Of(s),i),o=Of(a);for(let e=0;e<A.length;++e){const t=e*o;let r=1;for(let e=0;e<o;++e)r*=n[t+e];A[e]=r}return{outVals:A,outShape:s,outDtype:i}}const MQ={kernelName:km,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;qF(s,"prod");const A=s.shape.length,o=Uf(a,s.shape),l=wk(o,A);let u=o,c=s;const d=[];null!=l&&(c=vQ({inputs:{x:s},backend:n,attrs:{perm:l}}),d.push(c),u=xk(u.length,A));const h=n.data.get(c.dataId).values,{outVals:f,outShape:g,outDtype:p}=BQ(c.shape,c.dtype,h,u);let m=g;return i&&(m=Ck(g,o)),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(m,p,f)}};function DQ(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,A=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let o=1;for(let e=0;e<t.length-1;++e){o*=t[e];const n=t[e+1];for(let t=1;t<o+1;++t)A[e].push(t*n)}for(let r=0;r<e.length;++r){let i=e[r],o=e[r]+1;for(let e=0;e<n.length;++e){const r=n[e],s=e+t.length-1;if(s>=0){const e=A[s],t=e[e.length-1]-r[i];for(let e=i;e<o;++e)A[s].push(r[e+1]+t)}i=r[i],o=r[o]}o!==i&&(s.push([i,o]),a+=o-i)}return{outSplits:A,valueSlices:s,numValues:a}}function TQ(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function SQ(e,t,n,r,s){const a=t.slice();a[0]=s;const i=Kf(n,Of(a)),A=e.length;return function(e,t,n,r,s,a){const i=TQ(t,2)[1],A=TQ(a,2)[1];let o=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)s[o*A+t]=e[n*i+t];++o}}(e,t,r,0===A?0:A/t[0],i,a),[i,a]}function NQ(e,t,n,r,s,a,i,A){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const s=ug(r,t.length,ng(t)).join(",");throw new Error(`indices[${s}] = ${e} is not in [0, ${n})`)}}))}(a,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const o=r[0],{outSplits:l,valueSlices:u,numValues:c}=DQ(a,i,e,o),d=function(e){const t=[];for(let n=0;n<e.length;++n){const r=Kf("int32",e[n].length);t.push(r),e[n].forEach(((e,t)=>r[t]=e))}return t}(l),h=SQ(n,r,s,u,c);return[d,h[0],h[1]]}const GQ=2147483647;function FQ(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const A=0===t.length,o=0===s.length,l=0===i.length,u=[];A||u.push(t[0]),o||u.push(s[0]),l||u.push(i[0]);for(let e=1;e<u.length;++e)if(u[e]!==u[e-1])throw new Error("starts, limits, and deltas must have the same shape");const c=0===u.length?1:u[0],d=Kf("int32",c+1);d[0]=0;for(let t=0;t<c;++t){const n=A?e[0]:e[t],s=o?r[0]:r[t],i=l?a[0]:a[t];if(0===i)throw new Error("Requires delta != 0");let u;if(i>0&&s<n||i<0&&s>n)u=0;else if(u=Math.ceil(Math.abs((s-n)/i)),u>GQ)throw new Error("Requires ((limit - start) / delta) <= 2147483647");d[t+1]=d[t]+u}const h=Kf(n,d[c]);let f=0;for(let t=0;t<c;++t){const n=d[t+1]-d[t];let r=A?e[0]:e[t];const s=l?a[0]:a[t];for(let e=0;e<n;++e)h[f++]=r,r+=s}return[d,h]}var PQ=fE;class QQ{constructor(e,t,n,r,s,a,i,A,o,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=A,this.rowPartitionValuesShapes=o,this.rowPartitionTypes=pE(l),this.raggedRank=mE(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===PQ.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===PQ.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case PQ.VALUE_ROWIDS:return QQ.getMaxWidthValueRowID(t);case PQ.ROW_SPLITS:return QQ.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${PQ[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],s=0;for(let a=1;a<t;++a){const t=e[a];t!==r&&(r=t,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return OQ(e,n)}calculateOutputSize(e){const t=this.valuesShape;bE(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=gE(this.raggedRank,n,t);r[0]<0&&(r[0]=e);for(let e=1;e<=this.raggedRank;++e)r[e]<0&&(r[e]=this.getMaxWidth(e));return r}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),s=[];let a=0;for(let e=0;e<r;++e,a+=t)s.push(a);for(let t=r;t<e;++t)s.push(-1);return Pf(s.length===e,(()=>"Final length of result must be equal to firstDimension.")),s}calculateOutputIndexRowSplit(e,t,n,r){const s=e.length,a=[];for(let i=0;i<s-1;++i){const s=e[i+1]-e[i];let A=Math.min(r,s),o=t[i];-1===o&&(A=0);for(let e=0;e<A;++e)a.push(o),o+=n;for(let e=0;e<s-A;++e)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){const s=e.length,a=[];if(0===s)return[];let i=0,A=e[0];if(A>=t.length)throw new Error(`Got currentValueRowId=${A}, which is not less than ${t.length}`);let o=t[A];a.push(o);for(let l=1;l<s;++l){const s=e[l];if(s===A)o>=0&&(++i,i<r?o+=n:o=-1);else{if(i=0,A=s,s>=t.length)throw new Error(`Got nextValueRowId=${s} which is not less than ${t.length}`);o=t[s]}a.push(o)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){const s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case PQ.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,r);case PQ.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,r);default:throw new Error(`Unsupported partition type: ${PQ[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case PQ.FIRST_DIM_SIZE:return e[0];case PQ.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case PQ.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${PQ[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];const r=OQ(t,!1),s=Kf(this.valuesDType,Of(r));if(n[0]*t[0]>0){let a=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){a=this.calculateOutputIndex(e-1,a,n[e],t[e])}this.setOutput(this.raggedRank,a,s,r)}return[r,s]}setOutput(e,t,n,r){if(0===n.length)return;const s=this.values,a=n;let i=r.slice();i=i.slice(e+1);const A=Of(i),o=t.length;let l=this.defaultValue;if(l.length!==A&&1!==l.length){const e=this.defaultValueShape;aI((()=>{const t=kw(l,e),n=Qw(t,i);l=n.dataSync()}))}let u=0,c=0,d=0;for(let e=0;e<=o;++e){let r=e<o?t[e]:-1;if(r!==d){if(c<d){const e=s.subarray(u*A);zQ(a.subarray(c*A),e,(d-c)*A)}if(e>=o){const e=n.length;r=Math.floor(e/A)}if(r>d)if(1===this.defaultValue.length)a.subarray(d*A,r*A).fill(this.defaultValue[0]),d=r;else for(;r>d;){zQ(a.slice(d*A),l,A),++d}r<0?(u=e+1,c=d):(u=e,c=d,d=c+1)}else++d}}}function zQ(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function OQ(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function RQ(e,t,n,r,s,a,i,A,o,l){return new QQ(e,t,n,r,s,a,i,A,o,l).compute()}function LQ(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return ig(0,r);const s=ig(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+n;return s}const WQ=kP((e=>1/Math.sqrt(e))),_Q=yP(Om,WQ),VQ={kernelName:Om,backendName:"cpu",kernelFunc:_Q};function HQ(e,t,n,r,s,a,i,A,o,l){const u=[r/s,s],c=e.values,d=t.values;if(0===r)return WI(n,t.dtype);const h=o instanceof CC?o:WI(u,t.dtype);"string"==typeof o||"number"==typeof o?h.values.fill(o):"boolean"==typeof o&&h.values.fill(+o);for(let e=0;e<a;e++){const a=[];let o=0;for(let t=0;t<i;t++){const n=c[e*i+t];a.push(n),o+=n*A[t]}if(o<0||o>=r/s)throw new Error(`Invalid indices: ${a} does not index into ${n}`);for(let n=0;n<s;n++)l?h.values[o*s+n]+=d[e*s+n]:h.values[o*s+n]=0===t.rank?d[0]:d[e*s+n]}return h}const UQ=kP((e=>1/(1+Math.exp(-e)))),jQ=xP(Km,(e=>1/(1+Math.exp(-e)))),YQ={kernelName:Km,backendName:"cpu",kernelFunc:jQ};function KQ(e,t,n,r,s){const a=rE(r,t,n),i=Of(n),A=ng(r);if(a){const n=sE(t,A);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const o=WI(r,s,"string"===s?hB(e):e),l=WI(n,s);for(let e=0;e<l.size;++e){const n=l.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));l.set(o.get(...r),...n)}return"string"===s?fB(l.values):l.values}function XQ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;qF(s,"slice");const[A,o]=aE(s,a,i);Yv(s,A,o);const l=KQ(n.data.get(s.dataId).values,A,o,s.shape,s.dtype);return n.makeTensorInfo(o,s.dtype,l)}const qQ={kernelName:Hm,backendName:"cpu",kernelFunc:XQ};function ZQ(e,t,n,r,s,a,i){const A=t[0],o=a[0],l=new Array(o),u=new Array(A),c=t[1];if(0===o){if(0!==A)throw new Error(ZE(A));return[Kf(n,0),[0,c],Kf(s,0),l,u]}let d=!0,h=0;const f=new Array(o).fill(0);for(let t=0;t<A;++t){const n=e[t*c];if(n<0)throw new Error(JE(t,n));if(n>=o)throw new Error($E(t,n,o));++f[n],d=d&&n>=h,h=n}let g=!0;for(let e=0;e<o;++e){const t=0===f[e];l[e]=t,g=g&&!t,f[e]=Math.max(f[e],1),e>0&&(f[e]+=f[e-1])}if(g&&d){const t=e,n=r;for(let e=0;e<A;++e)u[e]=e;return[t,[A,c],n,l,u]}{const t=f[o-1],a=Kf(n,t*c),d=Kf(s,t),h=new Array(o).fill(0);for(let t=0;t<A;++t){const n=e[t*c],s=h[n],i=(0===n?0:f[n-1])+s;h[n]++;for(let n=0;n<c;++n)a[i*c+n]=e[t*c+n];d[i]=r[t],u[t]=i}for(let e=0;e<o;++e){if(0===h[e]){const t=0===e?0:f[e-1];a[t*c+0]=e;for(let e=1;e<c;++e)a[t*c+e]=0;d[t]=i}}return[a,[t,c],d,l,u]}}function JQ(e,t,n,r,s){const a=Of(r),i=t[0],A=s.length,o=[];let l=1,u=-1;for(let e=0;e<A;++e){const t=s[e];if(-1===t){if(-1!==u)throw new Error(eB(u,e));u=e,o.push(1)}else{if(t<0)throw new Error(tB(e,t));l*=t,o.push(t)}}if(-1!==u){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(a/l);if(l*e!==a)throw new Error(rB(r,o));o[u]=e}if(Of(o)!==a)throw new Error(sB(r,o));const c=r.length,d=[];if(c>0){d[c-1]=1;for(let e=c-2;e>=0;--e)d[e]=d[e+1]*r[e+1]}const h=[];if(A>0){h[A-1]=1;for(let e=A-2;e>=0;--e)h[e]=h[e+1]*o[e+1]}const f=Kf(n,i*A);for(let t=0;t<i;++t){let n=0;for(let r=0;r<c;++r)n+=e[t*c+r]*d[r];for(let e=0;e<A;++e)f[t*A+e]=Math.trunc(n/h[e]),n%=h[e]}return[f,[i,A],o]}function $Q(e,t,n,r,s,a=!1,i=0){const A=r.length,o=[t[0],e.length/t[0]],l=o[1],u=A>0?s[A-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const c=t.slice();c[0]=u;const d=Kf(n,c.reduce(((e,t)=>e*t),1));if(0===A)return u>0&&d.fill(i),[d,c];if(u<=0)throw new Error("segment ids must be >= 0");let h=0,f=1,g=0,p=s[h];for(;;){let t=0;if(f<A){if(t=s[f],p===t){++f;continue}if(p>=t)throw new Error("segment ids are not increasing")}if(p<0||p>=u)throw new Error(AB(p,u));p>g&&d.fill(i,g*l,p*l);for(let t=h;t<f;++t){const n=r[t];if(n<0||n>=o[0])throw new Error(oB(t,r[t],o[0]));for(let t=0;t<l;t++)d[p*l+t]+=e[n*l+t]}if(a)for(let e=0;e<l;e++)d[p*l+e]/=f-h;if(h=f,++f,g=p+1,p=t,f>A)break}return g<u&&d.fill(i,g*l,u*l),[d,c]}const ez=kP((e=>Math.sqrt(e))),tz=xP(qm,(e=>Math.sqrt(e))),nz={kernelName:qm,backendName:"cpu",kernelFunc:tz},rz=tP(((e,t)=>{const n=e-t;return n*n})),sz=dP(ib,rz),az={kernelName:ib,backendName:"cpu",kernelFunc:sz},iz=kP(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)})),Az={kernelName:ob,backendName:"cpu",kernelFunc:yP(ob,iz)};function oz(e,t,n,r){const s=WI(e,t.dtype);for(let e=0;e<s.size;e++){const a=s.indexToLoc(e),i=new Array(a.length);for(let e=0;e<i.length;e++)i[e]=a[e]*n[e]+r[e];s.set(t.get(...i),...a)}return s}class lz{constructor(e,t,n,r,s,a){this.separator=AC(e),this.nGramWidths=t,this.leftPad=AC(n),this.rightPad=AC(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){const A=this.getPadWidth(a),o=Math.max(0,A-i),l=Math.max(0,A-(s-(i+1))),u=a-(o+l),c=t+(o>0?0:i-A);let d=0;d+=o*this.leftPad.length;for(let t=0;t<u;++t)d+=e[c+t].length;d+=l*this.rightPad.length;d+=(o+l+u-1)*this.separator.length,n[r+i]=new Uint8Array(d);const h=n[r+i];let f=0;const g=e=>e.forEach((e=>h[f++]=e));for(let e=0;e<o;++e)g(this.leftPad),g(this.separator);for(let t=0;t<u-1;++t)g(e[c+t]),g(this.separator);if(u>0){g(e[c+u-1]);for(let e=0;e<l;++e)g(this.separator),g(this.rightPad)}else{for(let e=0;e<l-1;++e)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let s=1;s<r;++s){let r=t[s]>=e;if(r=r&&t[s]<=n,!r)throw new Error(`Invalid split value ${t[s]}, must be in [${e}, ${n}]`);e=t[s]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=r-1,a=Kf("int32",r);if(0===n||0===r){const e=new Array(n);for(let e=0;e<=s;++e)a[e]=0;return[e,a]}a[0]=0;for(let e=1;e<=s;++e){const n=t[e]-t[e-1];let r=0;this.nGramWidths.forEach((e=>{r+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===r&&(r=1),a[e]=a[e-1]+r}const i=new Array(a[s]);for(let n=0;n<s;++n){const r=t[n];let s=a[n];if(this.nGramWidths.forEach((a=>{const A=t[n+1]-t[n],o=this.getNumNGrams(A,a);this.createNGrams(e,r,i,s,o,a),s+=o})),this.preserveShort&&s===a[n]){const a=t[n+1]-t[n];if(0===a)continue;const A=a+2*this.padWidth,o=1;this.createNGrams(e,r,i,s,o,A)}}return[i,a]}}function uz(e,t,n,r,s,a,i,A){return new lz(n,r,s,a,i,A).compute(e,t)}function cz(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let a=e.indexOf(s);for(;-1!==a;){const t=e.subarray(0,a);n&&0===t.length||r.push(t),a=(e=e.subarray(a+1)).indexOf(s)}return void(n&&0===e.length||r.push(e))}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||-1!==t.indexOf(e[a])){const t=e.subarray(s,a);n&&0===t.length||r.push(t),s=a+1}}function dz(e,t,n){const r=e.length,s=[];let a=0,i=0;const A=new Array(r);for(let o=0;o<r;++o){const r=s.length;cz(e[o],t,n,s);const l=s.length-r;A[o]=l,a+=l,i=Math.max(i,l)}const o=Kf("int32",2*a),l=new Array(a),u=[r,i];let c=0;for(let e=0;e<r;++e)for(let t=0;t<A[e];++t)o[2*c]=e,o[2*c+1]=t,l[c]=s[c],++c;return[o,l,u]}function hz(e,t){const n=Kf("int32",e.length);for(let r=0;r<e.length;++r)n[r]=rC(e[r]).modulo(t).getLowBitsUnsigned();return n}const fz=tP(((e,t)=>e-t)),gz=hP(((e,t,n,r)=>({real:e-n,imag:t-r}))),pz=dP(hb,fz,gz),mz={kernelName:hb,backendName:"cpu",kernelFunc:pz};function bz(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=WI(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),s=new Array(e.rank);for(let t=0;t<s.length;t++)s[t]=n[t]%e.shape[t];const a=e.locToIndex(s);r.values[t]=e.values[a]}return r}const Cz=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function Iz(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const s=r-n+1,a=t-n+1,i=Math.log(s),A=.5*Math.exp(2*i/3),o=.5*Math.sqrt(i*A*(s-A)/s)*Math.sign(a-s/2);Iz(e,t,Math.max(n,Math.floor(t-a*A/s+o)),Math.min(r,Math.floor(t+(s-a)*A/s+o)))}const s=e[t];let a=n,i=r;for(Ff(e,n,t),Cz(e[r],s)>0&&Ff(e,n,r);a<i;){for(Ff(e,a,i),a++,i--;Cz(e[a],s)<0;)a+=1;for(;Cz(e[i],s)>0;)i-=1}0===Cz(e[n],s)?Ff(e,n,i):(i+=1,Ff(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function wz(e,t,n,r,s){const a=t[t.length-1],[i,A]=[e.length/a,a],o=Yf(n,i*r),l=Yf("int32",i*r);for(let t=0;t<i;t++){const n=t*A,a=e.subarray(n,n+A);let i=new Array(a.length);a.forEach(((e,t)=>i[t]={value:e,index:t})),r<i.length&&(Iz(i,r),i=i.slice(0,r)),s&&i.sort(Cz);const u=t*r,c=o.subarray(u,u+r),d=l.subarray(u,u+r);for(let e=0;e<r;e++)c[e]=i[e].value,d[e]=i[e].index}const u=t.slice();return u[u.length-1]=r,[WI(u,n,o),WI(u,"int32",l)]}function kz(e,t,n,r){const s=Uf(t,n)[0],a=[1,n[0],1];for(let e=0;e<s;e++)a[0]*=n[e];a[1]=n[s];for(let e=s+1;e<n.length;e++)a[2]*=n[e];const i=new Map,A=new Int32Array(n[s]),o=new CC(a,r,e),l=[],u=1===a[0]&&1===a[2];for(let t=0;t<n[s];t++){let n;if(u)n=e[t].toString();else{const e=[];for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)e.push(o.get(n,t,r));n=e.join(",")}const r=i.get(n);if(null!=r)A[t]=r;else{const e=i.size;i.set(n,e),A[t]=e,l.push(t)}}const c=a.slice();c[1]=i.size;const d=new CC(c,r);l.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)d.set(o.get(n,e,r),n,t,r)}));const h=n.slice();return h[s]=c[1],{outputValues:d.values,outputShape:h,indices:A}}var xz=Object.freeze({__proto__:null,addImpl:fP,bincountImpl:bP,bincountReduceImpl:CP,bitwiseAndImpl:IP,castImpl:lP,ceilImpl:vP,concatImpl:MP,equalImpl:DP,expImpl:NP,expm1Impl:PP,floorDivImpl:WP,floorImpl:OP,gatherNdImpl:HP,gatherV2Impl:UP,greaterEqualImpl:XP,greaterImpl:jP,lessEqualImpl:tQ,lessImpl:JP,linSpaceImpl:sQ,logImpl:aQ,maxImpl:oQ,maximumImpl:lQ,minimumImpl:dQ,multiplyImpl:gQ,negImpl:CQ,notEqualImpl:wQ,prodImpl:BQ,raggedGatherImpl:NQ,raggedRangeImpl:FQ,raggedTensorToTensorImpl:RQ,rangeImpl:LQ,rsqrtImpl:WQ,scatterImpl:HQ,sigmoidImpl:UQ,simpleAbsImpl:$F,sliceImpl:KQ,sparseFillEmptyRowsImpl:ZQ,sparseReshapeImpl:JQ,sparseSegmentReductionImpl:$Q,sqrtImpl:ez,squaredDifferenceImpl:rz,staticRegexReplaceImpl:iz,stridedSliceImpl:oz,stringNGramsImpl:uz,stringSplitImpl:dz,stringToHashBucketFastImpl:hz,subImpl:fz,tileImpl:bz,topKImpl:wz,transposeImpl:yQ,uniqueImpl:kz});oI("cpu",(()=>new JF),1);const yz=xP(mp,(e=>e>=0?e:Math.exp(e)-1)),vz={kernelName:mp,backendName:"cpu",kernelFunc:yz};function Ez(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;qF([s],"leakyRelu");const i=Of(s.shape),A=n.data.get(s.dataId).values,o=Yf("float32",i);for(let e=0;e<A.length;e++)o[e]=A[e]<0?a*A[e]:A[e];return n.makeTensorInfo(s.shape,"float32",o)}const Bz={kernelName:Lp,backendName:"cpu",kernelFunc:Ez},Mz=tP(((e,t)=>e<0?t*e:e));function Dz(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;qF([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[A,o]=Mz(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(o,"float32",A)}const Tz={kernelName:wm,backendName:"cpu",kernelFunc:Dz},Sz=xP(Dm,(e=>Math.max(0,e))),Nz={kernelName:Dm,backendName:"cpu",kernelFunc:Sz},Gz=xP(Pm,(e=>Math.min(Math.max(0,e),6))),Fz={kernelName:Pm,backendName:"cpu",kernelFunc:Gz};function Pz(e,t,n,r,s){if("linear"===n)return aP({inputs:{x:t},backend:e});if("relu"===n)return Sz({inputs:{x:t},backend:e});if("elu"===n)return yz({inputs:{x:t},backend:e});if("relu6"===n)return Gz({inputs:{x:t},backend:e});if("prelu"===n)return Dz({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return Ez({inputs:{x:t},backend:e,attrs:{alpha:s}});if("sigmoid"===n)return jQ({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function Qz(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=Of(s.shape),A=Hf(a,i),o=Of(A);Pf(i===o,(()=>`The new shape (${A}) has ${o} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(s.dataId);const l=n.data.get(s.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=A,t.shape=A}return{dataId:s.dataId,shape:A,dtype:s.dtype}}const zz={kernelName:Tm,backendName:"cpu",kernelFunc:Qz};function Oz(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:A}=r;qF([s,a],"matMul");const o=s.shape.length,l=a.shape.length,u=i?s.shape[o-2]:s.shape[o-1],c=A?a.shape[l-1]:a.shape[l-2],d=i?s.shape[o-1]:s.shape[o-2],h=A?a.shape[l-2]:a.shape[l-1],f=s.shape.slice(0,-2),g=a.shape.slice(0,-2),p=Of(f),m=Of(g),b=Ak(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([d,h]);Pf(u===c,(()=>`Error in matMul: inner shapes (${u}) and (${c}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${A} must match.`));const C=A?[m,h,c]:[m,c,h],I=Qz({inputs:{x:s},backend:n,attrs:{shape:i?[p,u,d]:[p,d,u]}}),w=Qz({inputs:{x:a},backend:n,attrs:{shape:C}}),k=i?I.shape[1]:I.shape[2],x=i?I.shape[2]:I.shape[1],y=A?w.shape[1]:w.shape[2],v=Math.max(p,m),E=n.data.get(I.dataId).values,B=n.data.get(w.dataId).values,M=ng(I.shape),D=ng(w.shape),[T,S,N]=i?[M[0],1,M[1]]:[M[0],M[1],1],[G,F,P]=A?[1,D[1],D[0]]:[D[1],1,D[0]],Q=x*y,z=WI([v,x,y],I.dtype),O=z.values,R=n.blockSize;for(let e=0;e<v;e++){const t=e%p,n=e%m;for(let r=0;r<x;r+=R){const s=Math.min(r+R,x);for(let a=0;a<y;a+=R){const i=Math.min(a+R,y);for(let A=0;A<k;A+=R){const o=Math.min(A+R,k);for(let l=r;l<s;l++)for(let r=a;r<i;r++){let s=0;for(let e=A;e<o;e++){s+=E[t*T+l*S+e*N]*B[e*G+r*F+n*P]}O[e*Q+(l*y+r)]+=s}}}}}return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,z.dtype,z.values)}const Rz={kernelName:Og,backendName:"cpu",kernelFunc:Oz};const Lz={kernelName:Eb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:A}=t,{transposeA:o,transposeB:l,activation:u,leakyreluAlpha:c}=r;let d,h,f;const g=[];d=Oz({inputs:{a:s,b:a},attrs:{transposeA:o,transposeB:l},backend:n}),i&&(h=pP({inputs:{a:d,b:i},backend:n}),g.push(d),d=h),u&&(f=Pz(n,d,u,A,c),g.push(d),d=f);for(const e of g)n.disposeIntermediateTensorInfo(e);return d}},Wz=xP(wg,(e=>Math.acos(e))),_z={kernelName:wg,backendName:"cpu",kernelFunc:Wz},Vz=xP(kg,(e=>Math.acosh(e))),Hz={kernelName:kg,backendName:"cpu",kernelFunc:Vz};const Uz={kernelName:yg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;qF(t,"addN");const s=r.map((e=>n.data.get(e.dataId).values)),a=WI(r[0].shape,r[0].dtype),i=a.values;for(let e=0;e<r.length;e++){const t=s[e];for(let e=0;e<i.length;e++)i[e]+=t[e]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}};const jz={kernelName:vg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;qF(s,"all");const A=Uf(a,s.shape);let o=A;const l=wk(o,s.shape.length);let u=s;null!=l&&(u=vQ({inputs:{x:s},backend:n,attrs:{perm:l}}),o=xk(o.length,s.shape.length)),Ik("all",o,u.shape.length);const[c,d]=bk(u.shape,o),h=Of(d),f=ig(Of(c),u.dtype),g=n.data.get(u.dataId).values;for(let e=0;e<f.length;++e){const t=e*h;let n=g[t];for(let e=0;e<h;++e){const r=g[t+e];n=n&&r}f[e]=n}null!=l&&n.disposeIntermediateTensorInfo(u);const p=n.makeTensorInfo(c,u.dtype,f);if(i){const e=Qz({inputs:{x:p},backend:n,attrs:{shape:Ck(c,A)}});return n.disposeIntermediateTensorInfo(p),e}return p}};const Yz={kernelName:Eg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;qF(s,"any");const A=Uf(a,s.shape);let o=A;const l=wk(o,s.shape.length);let u=s;null!=l&&(u=vQ({inputs:{x:s},backend:n,attrs:{perm:l}}),o=xk(o.length,s.shape.length)),Ik("any",o,u.shape.length);const[c,d]=bk(u.shape,o),h=Of(d),f=ig(Of(c),u.dtype),g=n.data.get(u.dataId).values;for(let e=0;e<f.length;++e){const t=e*h;let n=g[t];for(let e=0;e<h;++e){const r=g[t+e];n=n||r}f[e]=n}null!=l&&n.disposeIntermediateTensorInfo(u);const p=n.makeTensorInfo(c,u.dtype,f);if(i){const e=Qz({inputs:{x:p},backend:n,attrs:{shape:Ck(c,A)}});return n.disposeIntermediateTensorInfo(p),e}return p}};const Kz={kernelName:Bg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;qF(s,"argMax");let i=Uf(a,s.shape);const A=wk(i,s.shape.length);let o=s;const l=[];null!=A&&(o=vQ({inputs:{x:s},backend:n,attrs:{perm:A}}),l.push(o),i=xk(i.length,o.shape.length)),i=[i[0]],Ik("argMax",i,o.shape.length);const[u,c]=bk(o.shape,i),d=ig(Of(u),"int32"),h=Of(c),f=n.data.get(o.dataId).values;for(let e=0;e<d.length;++e){const t=e*h;let n=f[t],r=0;for(let e=0;e<h;++e){const s=f[t+e];s>n&&(n=s,r=e)}d[e]=r}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",d)}};const Xz={kernelName:Mg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;qF(s,"argMin");let i=Uf(a,s.shape);const A=wk(i,s.shape.length);let o=s;const l=[];null!=A&&(o=vQ({inputs:{x:s},backend:n,attrs:{perm:A}}),l.push(o),i=xk(i.length,o.shape.length)),i=[i[0]],Ik("argMin",i,o.shape.length);const[u,c]=bk(o.shape,i),d=ig(Of(u),"int32"),h=Of(c),f=n.data.get(o.dataId).values;for(let e=0;e<d.length;++e){const t=e*h;let n=f[t],r=0;for(let e=0;e<h;++e){const s=f[t+e];s<n&&(n=s,r=e)}d[e]=r}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",d)}},qz=xP(Dg,(e=>Math.asin(e))),Zz={kernelName:Dg,backendName:"cpu",kernelFunc:qz},Jz=xP(Tg,(e=>Math.asinh(e))),$z={kernelName:Tg,backendName:"cpu",kernelFunc:Jz},eO=xP(Sg,(e=>Math.atan(e))),tO={kernelName:Sg,backendName:"cpu",kernelFunc:eO},nO=tP(((e,t)=>Math.atan2(e,t))),rO=dP(Gg,nO),sO={kernelName:Gg,backendName:"cpu",kernelFunc:rO},aO=xP(Ng,(e=>Math.atanh(e))),iO={kernelName:Ng,backendName:"cpu",kernelFunc:aO};function AO(e,t,n,r,s,a){const i=s.strideHeight,A=s.strideWidth,o=s.dilationHeight,l=s.dilationWidth,u=s.effectiveFilterHeight,c=s.effectiveFilterWidth,d=s.padInfo.top,h=s.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=WI(s.outShape,n),p=g.values,m=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],C=s.outShape[3];for(let t=0;t<s.batchSize;++t){const n=t*m,g=t*r[0];for(let t=0;t<s.inChannels;++t)for(let m=0;m<s.outHeight;++m){const I=m*i-d,w=Math.max(0,I),k=Math.min(s.inHeight,u+I),x=n+m*b;for(let n=0;n<s.outWidth;++n){const i=n*A-h,u=Math.max(0,i),d=Math.min(s.inWidth,c+i);let m=f,b=0,I=0;for(let n=w;n<k;n+=o){const s=g+n*r[1];for(let n=u;n<d;n+=l){const i=e[s+n*r[2]+t];"max"===a&&i>m?m=i:"avg"===a&&(b+=i,I++)}if(isNaN(m))break}p[x+n*C+t]="avg"===a?b/I:m}}}return g}function oO(e,t,n,r,s=!1,a=!1){const i=WI(r.outShape,"int32"),A=r.strideHeight,o=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,d=r.effectiveFilterWidth,h=r.padInfo.top,f=r.padInfo.left,g=WI(t,n,e);for(let e=0;e<r.batchSize;++e)for(let t=0;t<r.inChannels;++t)for(let n=0;n<r.outHeight;++n){const p=n*A-h;let m=p;for(;m<0;)m+=l;const b=Math.min(r.inHeight,c+p);for(let A=0;A<r.outWidth;++A){const c=A*o-f;let h=c;for(;h<0;)h+=u;const C=Math.min(r.inWidth,d+c);let I=Number.NEGATIVE_INFINITY,w=-1;for(let n=m;n<b;n+=l){const i=n-p;for(let A=h;A<C;A+=u){const o=A-c,l=g.get(e,n,A,t);l>I&&(I=l,w=s?a?((e*r.inHeight+n)*r.inWidth+A)*r.inChannels+t:(n*r.inWidth+A)*r.inChannels+t:i*d+o)}}i.set(w,e,n,A,t)}}return i}function lO(e,t,n,r,s,a){const i=s.strideDepth,A=s.strideHeight,o=s.strideWidth,l=s.dilationDepth,u=s.dilationHeight,c=s.dilationWidth,d=s.effectiveFilterDepth,h=s.effectiveFilterHeight,f=s.effectiveFilterWidth,g=s.padInfo.front,p=s.padInfo.top,m=s.padInfo.left,b="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,C=WI(s.outShape,n),I=C.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],x=s.outShape[3]*s.outShape[4],y=s.outShape[4];for(let t=0;t<s.batchSize;++t){const n=t*w,C=t*r[0];for(let t=0;t<s.inChannels;++t)for(let w=0;w<s.outDepth;++w){const v=w*i-g;let E=v;for(;E<0;)E+=l;const B=Math.min(s.inDepth,d+v),M=n+w*k;for(let n=0;n<s.outHeight;++n){const i=n*A-p;let d=i;for(;d<0;)d+=u;const g=Math.min(s.inHeight,h+i),w=M+n*x;for(let n=0;n<s.outWidth;++n){const i=n*o-m;let A=i;for(;A<0;)A+=c;const h=Math.min(s.inWidth,f+i),p=w+n*y;let k=b,x=0,v=0;for(let n=E;n<B;n+=l){const s=C+n*r[1];for(let n=d;n<g;n+=u){const i=s+n*r[2];for(let n=A;n<h;n+=c){const s=e[i+n*r[3]+t];if("max"===a&&s>k?k=s:"avg"===a&&(x+=s,v++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}I[p+t]="avg"===a?x/Math.max(v,1):k}}}}return C}const uO={kernelName:Fg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;qF(s,"avgPool");const{filterSize:a,strides:i,pad:A,dimRoundingMode:o}=r;Pf(bw(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const l=ow(s.shape,a,i,1,A,o);let u;if(1===l.filterWidth&&1===l.filterHeight&&Rf(l.inShape,l.outShape))u=aP({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=ng(s.shape),r=AO(e,s.shape,s.dtype,t,l,"avg");u=n.makeTensorInfo(l.outShape,s.dtype,r.values)}return u}};const cO={kernelName:Qg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:A,dimRoundingMode:o,dataFormat:l}=r;qF(s,"avgPool3d");const u=lw(s.shape,a,i,1,A,o,l),c=lO(n.data.get(s.dataId).values,s.shape,s.dtype,ng(s.shape),u,"avg");return n.makeTensorInfo(c.shape,"float32",c.values)}};const dO={kernelName:zg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:A,pad:o,dimRoundingMode:l}=r;qF([s,a],"avgPool3DGrad");const u=lw(a.shape,i,A,1,o,l),c=u.strideDepth,d=u.strideHeight,h=u.strideWidth,f=u.filterDepth,g=u.filterHeight,p=u.filterWidth,m=u.dilationDepth,b=u.dilationHeight,C=u.dilationWidth,I=u.effectiveFilterDepth,w=u.effectiveFilterHeight,k=u.effectiveFilterWidth,x=I-1-u.padInfo.front,y=k-1-u.padInfo.left,v=w-1-u.padInfo.top,E=WI(a.shape,"float32"),B=1/(f*g*p),M=n.bufferSync(s);for(let e=0;e<u.batchSize;++e)for(let t=0;t<u.inChannels;++t)for(let n=0;n<u.inDepth;++n)for(let r=0;r<u.inHeight;++r)for(let s=0;s<u.inWidth;++s){const a=n-x,i=r-v,A=s-y;let o=0;for(let n=0;n<I;n+=m){const r=(a+n)/c;if(!(r<0||r>=u.outDepth||Math.floor(r)!==r))for(let n=0;n<w;n+=b){const s=(i+n)/d;if(!(s<0||s>=u.outHeight||Math.floor(s)!==s))for(let n=0;n<k;n+=C){const a=(A+n)/h;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;o+=M.get(e,r,s,a,t)}}}E.set(o*B,e,n,r,s,t)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}};const hO={kernelName:Pg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;qF([s,a],"avgPoolGrad");const{filterSize:A,strides:o,pad:l}=r,u=ow(i.shape,A,o,1,l),c=u.strideHeight,d=u.strideWidth,h=u.filterHeight,f=u.filterWidth,g=u.dilationHeight,p=u.dilationWidth,m=u.effectiveFilterHeight,b=u.effectiveFilterWidth,C=b-1-u.padInfo.left,I=m-1-u.padInfo.top,w=WI(i.shape,"float32"),k=1/(h*f),x=n.data.get(s.dataId).values,y=WI(s.shape,"float32",x);for(let e=0;e<u.batchSize;++e)for(let t=0;t<u.inChannels;++t)for(let n=0;n<u.inHeight;++n)for(let r=0;r<u.inWidth;++r){const s=n-I,a=r-C;let i=0;for(let n=0;n<m;n+=g){const r=(s+n)/c;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let n=0;n<b;n+=p){const s=(a+n)/d;if(s<0||s>=u.outWidth||Math.floor(s)!==s)continue;i+=y.get(e,r,s,t)}}w.set(i*k,e,n,r,t)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const fO={kernelName:Dp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:A,variance:o}=t;Pf(A.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Pf(null==i||A.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Pf(null==a||A.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),qF([s,A,o,a,i],"batchNorm");let{varianceEpsilon:l}=r;null==l&&(l=.001);const u=n.data.get(s.dataId).values,c=n.data.get(A.dataId).values,d=n.data.get(o.dataId).values,h=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),g=new Float32Array(u.length),p=f.length,m=h.length,b=d.length,C=c.length;let I=0,w=0,k=0,x=0;for(let e=0;e<u.length;++e)g[e]=f[I++]+(u[e]-c[w++])*h[k++]/Math.sqrt(d[x++]+l),I>=p&&(I=0),w>=C&&(w=0),k>=m&&(k=0),x>=b&&(x=0);return n.makeTensorInfo(s.shape,s.dtype,g)}};const gO={kernelName:Rg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;qF([s],"batchToSpaceND");const A=a.reduce(((e,t)=>e*t)),o=wE(s.shape,a,A),l=kE(o.length,a.length),u=xE(s.shape,a,A),c=yE(i,a.length),d=vE(u,i,a.length),h=Qz({inputs:{x:s},backend:n,attrs:{shape:o}}),f=vQ({inputs:{x:h},backend:n,attrs:{perm:l}}),g=Qz({inputs:{x:f},backend:n,attrs:{shape:u}}),p=XQ({inputs:{x:g},backend:n,attrs:{begin:c,size:d}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),p}};const pO={kernelName:Lg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,A=bP(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,A)}};const mO={kernelName:_g,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,A=Ak(Array.from(a),Array.from(i));return n.makeTensorInfo([A.length],"int32",Int32Array.from(A))}},bO=xP(Ug,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),CO={kernelName:Ug,backendName:"cpu",kernelFunc:bO},IO={kernelName:Yg,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Of(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,A=n.data.get(a.dataId).values,o=n.data.get(i.dataId).values;for(let e=0;e<A.length;e++){const t=A[e],n=o[e];r[e]=Math.hypot(t,n)}return n.makeOutput(r,t.shape,"float32")}};function wO(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const kO={kernelName:Qp,backendName:"cpu",kernelFunc:wO};function xO(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Uf(s,t[0].shape)[0],i=t.map((e=>e.shape));dE(i,a);let A=hE(t.map((e=>e.shape)),a);if(0===Of(A))return n.makeTensorInfo(A,t[0].dtype,[]);const o=t.filter((e=>Of(e.shape)>0));if(1===o.length)return aP({inputs:{x:o[0]},backend:n});if("complex64"===o[0].dtype){const e=o.map((e=>AP({inputs:{input:e},backend:n}))),t=o.map((e=>wO({inputs:{input:e},backend:n}))),r=xO({inputs:e,backend:n,attrs:{axis:a}}),s=xO({inputs:t,backend:n,attrs:{axis:a}}),i=nP({inputs:{real:r,imag:s},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}const l=o.map((e=>{const t=Of(e.shape.slice(a));return Qz({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));A=hE(l.map((e=>e.shape)),1);const c=1===l[0].shape[0],d=MP(u,A,t[0].dtype,c),h=hE(o.map((e=>e.shape)),a),f=n.makeTensorInfo(h,t[0].dtype,d);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}const yO={kernelName:Kg,backendName:"cpu",kernelFunc:xO};function vO(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:A,dataFormat:o,dilations:l,dimRoundingMode:u}=r;qF([s,a],"conv2d");const c=Iw(o),d=uw(s.shape,a.shape,i,l,A,u,!1,c),h=d.filterHeight,f=d.filterWidth,g=d.dilationHeight,p=d.dilationWidth,m=d.padInfo.left,b=d.padInfo.top,C="channelsLast"===d.dataFormat,I=new CC(d.outShape,s.dtype),w=ng(s.shape),k=ng(a.shape),x=w[0],y=C?w[1]:w[2],v=C?w[2]:1,E=C?1:w[1],B=I.strides[0],M=C?I.strides[1]:I.strides[2],D=C?I.strides[2]:1,T=C?1:I.strides[1],S=n.data.get(s.dataId).values,N=n.data.get(a.dataId).values,G=I.values;for(let e=0;e<d.batchSize;++e){const t=e*x,n=e*B;for(let e=0;e<d.outHeight;++e){const r=n+e*M,s=e*d.strideHeight-b;for(let e=0;e<h;++e){const n=s+e*g;if(n<0||n>=d.inHeight)continue;const a=e*k[0],i=t+n*y;for(let e=0;e<d.outWidth;++e){const t=r+e*D,n=e*d.strideWidth-m;for(let e=0;e<f;++e){const r=n+e*p;if(r<0||r>=d.inWidth)continue;const s=i+r*v;let A=a+e*k[1];for(let e=0;e<d.inChannels;++e){const n=S[s+e*E];for(let e=0;e<d.outChannels;++e)G[t+e*T]+=n*N[A+e];A+=d.outChannels}}}}}}return n.makeTensorInfo(I.shape,I.dtype,G)}const EO={kernelName:Xg,backendName:"cpu",kernelFunc:vO};const BO={kernelName:qg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:A,dataFormat:o,dimRoundingMode:l,filterShape:u}=r;qF([s,a],"conv2dBackpropFilter");const c=Iw(o),d=uw(s.shape,u,i,1,A,l,!1,c),{strideHeight:h,strideWidth:f,filterHeight:g,filterWidth:p}=d,m="channelsLast"===d.dataFormat,b=new CC(d.filterShape,"float32"),C=d.padInfo.left,I=d.padInfo.top,w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,x=new CC(s.shape,s.dtype,w),y=new CC(a.shape,a.dtype,k);for(let e=0;e<g;++e){const t=Math.max(0,Math.ceil((I-e)/h)),n=Math.min(d.outHeight,(d.inHeight+I-e)/h);for(let r=0;r<p;++r){const s=Math.max(0,Math.ceil((C-r)/f)),a=Math.min(d.outWidth,(d.inWidth+C-r)/f);for(let i=0;i<d.inChannels;++i)for(let A=0;A<d.outChannels;++A){let o=0;for(let l=0;l<d.batchSize;++l)for(let u=t;u<n;++u){const t=e+u*h-I;for(let e=s;e<a;++e){const n=r+e*f-C;o+=m?x.get(l,t,n,i)*y.get(l,u,e,A):x.get(l,i,t,n)*y.get(l,A,u,e)}}b.set(o,e,r,i,A)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const MO={kernelName:Zg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:A,pad:o,dataFormat:l,dimRoundingMode:u}=r;qF([s,a],"conv2dBackpropInput");const c=ng(a.shape),d=ng(s.shape);let h=Iw(l);const f=uw(i,a.shape,A,1,o,u,!1,h),g=new CC(f.inShape,"float32"),p=g.values,m=n.data.get(s.dataId).values,b=n.data.get(a.dataId).values,[C,I,w]=c,{batchSize:k,filterHeight:x,filterWidth:y,inChannels:v,inHeight:E,inWidth:B,outChannels:M,outHeight:D,outWidth:T,strideHeight:S,strideWidth:N}=f;h=f.dataFormat;const G=x-1-f.padInfo.top,F=y-1-f.padInfo.left,P="channelsLast"===h,Q=g.strides[0],z=P?g.strides[1]:g.strides[2],O=P?g.strides[2]:1,R=P?1:g.strides[1],L=d[0],W=P?d[1]:d[2],_=P?d[2]:1,V=P?1:d[1];for(let e=0;e<k;++e)for(let t=0;t<v;++t)for(let n=0;n<E;++n){const r=n-G,s=Math.max(0,Math.ceil(r/S)),a=Math.min(D,(x+r)/S);for(let i=0;i<B;++i){const A=i-F,o=Math.max(0,Math.ceil(A/N)),l=Math.min(T,(y+A)/N);let u=0;for(let n=s;n<a;++n){const s=n*S-r;for(let r=o;r<l;++r){const a=L*e+W*n+_*r,i=C*(x-1-s)+I*(y-1-(r*N-A))+w*t;for(let e=0;e<M;++e){u+=m[a+V*e]*b[i+e]}}}p[Q*e+z*n+O*i+R*t]=u}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const DO={kernelName:Jg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:A,dilations:o}=r;qF([s,a],"conv3d");const l=cw(s.shape,a.shape,i,o,A),{filterDepth:u,filterHeight:c,filterWidth:d,dilationDepth:h,dilationHeight:f,dilationWidth:g,padInfo:p}=l,m=p.front,b=p.left,C=p.top,I=new CC(l.outShape,s.dtype),w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,x=I.values,y=ng(s.shape),v=ng(a.shape);for(let e=0;e<l.batchSize;++e){const t=e*y[0],n=e*I.strides[0];for(let e=0;e<l.outDepth;++e){const r=n+e*I.strides[1],s=e*l.strideDepth-m;for(let e=0;e<u;++e){const n=s+e*h;if(n<0||n>=l.inDepth)continue;const a=e*v[0],i=t+n*y[1];for(let e=0;e<l.outHeight;++e){const t=r+e*I.strides[2],n=e*l.strideHeight-C;for(let e=0;e<c;++e){const r=n+e*f;if(r<0||r>=l.inHeight)continue;const s=a+e*v[1],A=i+r*y[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,r=e*l.strideWidth-b;for(let e=0;e<d;++e){const t=r+e*g;if(t<0||t>=l.inWidth)continue;const a=s+e*v[2],i=A+t*l.inChannels;let o=a;for(let e=0;e<l.inChannels;++e){const t=w[i+e];for(let e=0;e<l.outChannels;++e)x[n+e]+=t*k[o+e];o+=l.outChannels}}}}}}}}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const TO={kernelName:$g,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:A,filterShape:o}=r;qF([s,a],"conv3dBackpropFilterV2");const l=ng(s.shape),u=ng(a.shape),c=cw(s.shape,o,i,1,A),d=c.strideDepth,h=c.strideHeight,f=c.strideWidth,g=c.filterDepth,p=c.filterHeight,m=c.filterWidth,b=new CC(c.filterShape,"float32"),C=b.values,[I,w,k,x]=b.strides,y=n.data.get(a.dataId).values,[v,E,B,M]=u,D=n.data.get(s.dataId).values,[T,S,N,G]=l,F=c.padInfo.front,P=c.padInfo.left,Q=c.padInfo.top;for(let e=0;e<g;++e){const t=Math.max(0,Math.ceil((F-e)/d)),n=Math.min(c.outDepth,(c.inDepth+F-e)/d),r=e*I;for(let s=0;s<p;++s){const a=Math.max(0,Math.ceil((Q-s)/h)),i=Math.min(c.outHeight,(c.inHeight+Q-s)/h),A=s*w+r;for(let r=0;r<m;++r){const o=Math.max(0,Math.ceil((P-r)/f)),l=Math.min(c.outWidth,(c.inWidth+P-r)/f),u=r*k+A;for(let A=0;A<c.inChannels;++A){const g=A*x+u;for(let u=0;u<c.outChannels;++u){let p=0;for(let g=0;g<c.batchSize;++g){const c=g*T,m=g*v;for(let g=t;g<n;++g){const t=(e+g*d-F)*S+c,n=g*E+m;for(let e=a;e<i;++e){const a=(s+e*h-Q)*N+t,i=e*B+n;for(let e=o;e<l;++e){const t=e*M+i;p+=D[(r+e*f-P)*G+a+A]*y[t+u]}}}}C[g+u]=p}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const SO={kernelName:ep,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:A,inputShape:o}=r;qF([s],"conv3dBackpropInputV2");const l=ng(s.shape),u=ng(a.shape),c=cw(o,a.shape,A,1,i),d=new CC(c.inShape,"float32"),h=d.values,[f,g,p,m]=d.strides,b=n.data.get(s.dataId).values,[C,I,w,k]=l,x=n.data.get(a.dataId).values,[y,v,E,B]=u,{batchSize:M,filterDepth:D,filterHeight:T,filterWidth:S,inChannels:N,inDepth:G,inHeight:F,inWidth:P,outChannels:Q,outDepth:z,outHeight:O,outWidth:R,strideDepth:L,strideHeight:W,strideWidth:_}=c,V=D-1-c.padInfo.front,H=T-1-c.padInfo.top,U=S-1-c.padInfo.left;for(let e=0;e<M;++e)for(let t=0;t<N;++t)for(let n=0;n<G;++n){const r=n-V,s=Math.max(0,Math.ceil(r/L)),a=Math.min(z,(D+r)/L);for(let i=0;i<F;++i){const A=i-H,o=Math.max(0,Math.ceil(A/W)),l=Math.min(O,(T+A)/W);for(let u=0;u<P;++u){const c=u-U,d=Math.max(0,Math.ceil(c/_)),M=Math.min(R,(S+c)/_);let N=0;for(let n=s;n<a;++n){const s=n*L-r;for(let r=o;r<l;++r){const a=r*W-A;for(let i=d;i<M;++i){const A=C*e+I*n+w*r+k*i,o=y*(D-1-s)+v*(T-1-a)+E*(S-1-(i*_-c))+B*t;for(let e=0;e<Q;++e){N+=b[A+e]*x[o+e]}}}}h[f*e+g*n+p*i+m*u+t]=N}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},NO=xP(tp,(e=>Math.cos(e))),GO={kernelName:tp,backendName:"cpu",kernelFunc:NO},FO=xP(np,(e=>Math.cosh(e))),PO={kernelName:np,backendName:"cpu",kernelFunc:FO};const QO={kernelName:ap,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:A,method:o,extrapolationValue:l}=r,[u,c,d,h]=s.shape,f=a.shape[0],[g,p]=A,m=WI([f,g,p,h],"float32"),b=n.data.get(a.dataId).values,C=n.data.get(i.dataId).values,I=n.data.get(s.dataId).values,w=ng(s.shape),k=ng(m.shape);for(let e=0;e<f;e++){const t=4*e,n=b[t],r=b[t+1],s=b[t+2],a=b[t+3],i=C[e];if(i>=u)continue;const A=g>1?(s-n)*(c-1)/(g-1):0,f=p>1?(a-r)*(d-1)/(p-1):0;for(let t=0;t<g;t++){const u=g>1?n*(c-1)+t*A:.5*(n+s)*(c-1);if(u<0||u>c-1)for(let n=0;n<p;n++)for(let r=0;r<h;r++){const s=r+n*k[2]+t*k[1]+e*k[0];m.values[s]=l}else if("bilinear"===o){const n=Math.floor(u),s=Math.ceil(u),A=u-n;for(let o=0;o<p;o++){const u=p>1?r*(d-1)+o*f:.5*(r+a)*(d-1);if(u<0||u>d-1){for(let n=0;n<h;n++){const r=n+o*k[2]+t*k[1]+e*k[0];m.values[r]=l}continue}const c=Math.floor(u),g=Math.ceil(u),b=u-c;for(let r=0;r<h;r++){let a=r+c*w[2]+n*w[1]+i*w[0];const l=I[a];a=r+g*w[2]+n*w[1]+i*w[0];const u=I[a];a=r+c*w[2]+s*w[1]+i*w[0];const d=I[a];a=r+g*w[2]+s*w[1]+i*w[0];const h=l+(u-l)*b,f=d+(I[a]-d)*b;a=r+o*k[2]+t*k[1]+e*k[0],m.values[a]=h+(f-h)*A}}}else for(let n=0;n<p;++n){const s=p>1?r*(d-1)+n*f:.5*(r+a)*(d-1);if(s<0||s>d-1){for(let r=0;r<h;r++){const s=r+n*k[2]+t*k[1]+e*k[0];m.values[s]=l}continue}const A=Math.round(s),o=Math.round(u);for(let r=0;r<h;r++){const s=r+A*w[2]+o*w[1]+i*w[0],a=r+n*k[2]+t*k[1]+e*k[0];m.values[a]=I[s]}}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const zO={kernelName:rp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:A}=r;qF(s,"cumprod");const o=wk([a],s.shape.length);let l=s;null!=o&&(l=vQ({inputs:{x:s},backend:n,attrs:{perm:o}}));const u=xk(1,s.shape.length)[0];if(u!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${u}`);const c=SC(l.dtype,"int32"),d=ag(Of(l.shape),c),h=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],g=A?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<h.length;e+=f)for(let t=0;t<f;t++){const n=g(e,t);if(0===t)d[n]=i?1:h[n];else{const r=g(e,t-1);d[n]=i?h[r]*d[r]:h[n]*d[r]}}const p=n.makeTensorInfo(l.shape,c,d);if(null!=o){const e=vQ({inputs:{x:p},backend:n,attrs:{perm:kk(o)}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(l),e}return p}};const OO={kernelName:sp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:A}=r;qF(s,"cumsum");const o=wk([a],s.shape.length);let l=s;null!=o&&(l=vQ({inputs:{x:s},backend:n,attrs:{perm:o}}));const u=xk(1,s.shape.length)[0];if(u!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${u}`);const c=SC(l.dtype,"int32"),d=ig(Of(l.shape),c),h=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],g=A?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<h.length;e+=f)for(let t=0;t<f;t++){const n=g(e,t);if(0===t)d[n]=i?0:h[n];else{const r=g(e,t-1);d[n]=i?h[r]+d[r]:h[n]+d[r]}}const p=n.makeTensorInfo(l.shape,c,d);if(null!=o){const e=vQ({inputs:{x:p},backend:n,attrs:{perm:kk(o)}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(l),e}return p}};const RO={kernelName:ip,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:A}=r;if(1===s.shape.length){const e=bP(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,e)}if(2===s.shape.length){const e=CP(n.bufferSync(s),n.bufferSync(a),i,A);return n.makeTensorInfo(e.shape,a.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};const LO={kernelName:Ap,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;Pf("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));const A=s.shape[0],o=s.shape[1],l=s.shape[2],u=s.shape[3],c=o*a,d=l*a,h=u/(a*a),f=n.data.get(s.dataId).values,g=new Float32Array(A*c*d*h);let p=0;for(let e=0;e<A;++e)for(let t=0;t<c;++t){const n=Math.floor(t/a),r=t%a;for(let t=0;t<d;++t){const s=Math.floor(t/a),i=(r*a+t%a)*h;for(let t=0;t<h;++t){const r=t+i+u*(s+l*(n+o*e));g[p++]=f[r]}}}return n.makeTensorInfo([A,c,d,h],s.dtype,g)}};function WO(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:A,dilations:o,dimRoundingMode:l}=r;qF([s,a],"depthwiseConv2DNative");const u=ng(s.shape),c=ng(a.shape);let d=o;null==d&&(d=[1,1]),Pf(bw(i,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`));const h=uw(s.shape,a.shape,i,d,A,l,!0),{filterHeight:f,filterWidth:g,dilationHeight:p,dilationWidth:m,padInfo:b}=h,C=b.left,I=b.top,w=h.outChannels/h.inChannels,k=new CC(h.outShape,s.dtype),x=n.data.get(s.dataId).values,y=n.data.get(a.dataId).values,v=k.values;for(let e=0;e<h.batchSize;++e){const t=e*u[0],n=e*k.strides[0];for(let e=0;e<h.outHeight;++e){const r=n+e*k.strides[1],s=e*h.strideHeight-I;for(let e=0;e<f;++e){const n=s+e*p;if(n<0||n>=h.inHeight)continue;const a=e*c[0],i=t+n*u[1];for(let e=0;e<h.outWidth;++e){const t=r+e*k.strides[2],n=e*h.strideWidth-C;for(let e=0;e<g;++e){const r=n+e*m;if(r<0||r>=h.inWidth)continue;const s=a+e*c[1],A=i+r*h.inChannels;let o=t,l=s;for(let e=0;e<h.inChannels;++e){const t=x[A+e];for(let e=0;e<w;++e)v[o+e]+=t*y[l+e];o+=w,l+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const _O={kernelName:op,backendName:"cpu",kernelFunc:WO};const VO={kernelName:lp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:A,pad:o,dimRoundingMode:l,filterShape:u}=r;qF([s,a],"depthwiseConv2dNativeBackpropFilter");const c=uw(s.shape,u,i,A,o,l,!0),{strideHeight:d,strideWidth:h,filterHeight:f,filterWidth:g}=c,p=new CC(c.filterShape,"float32"),m=c.padInfo.left,b=c.padInfo.top,C=c.outChannels/c.inChannels,I=n.data.get(s.dataId).values,w=new CC(s.shape,s.dtype,I),k=n.data.get(a.dataId).values,x=new CC(a.shape,a.dtype,k);for(let e=0;e<f;++e){const t=Math.max(0,Math.ceil((b-e)/d)),n=Math.min(c.outHeight,(c.inHeight+b-e)/d);for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((m-r)/h)),a=Math.min(c.outWidth,(c.inWidth+m-r)/h);for(let i=0;i<c.outChannels;++i){const A=Math.trunc(i/C),o=i%C;let l=0;for(let o=0;o<c.batchSize;++o)for(let u=t;u<n;++u){const t=e+u*d-b;for(let e=s;e<a;++e){const n=r+e*h-m;l+=w.get(o,t,n,A)*x.get(o,u,e,i)}}p.set(l,e,r,A,o)}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}};const HO={kernelName:up,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:A,pad:o,dimRoundingMode:l,inputShape:u}=r;qF([s,a],"depthwiseConv2DNativeBackpropInput");const c=ng(s.shape),d=ng(a.shape),h=uw(u,a.shape,i,A,o,l,!0),f=new CC(h.inShape,"float32"),g=f.values,[p,m,b]=f.strides,C=n.data.get(s.dataId).values,[I,w,k]=c,x=n.data.get(a.dataId).values,[y,v,E]=d,{batchSize:B,filterHeight:M,filterWidth:D,inChannels:T,inHeight:S,inWidth:N,outChannels:G,outHeight:F,outWidth:P,strideHeight:Q,strideWidth:z}=h,O=M-1-h.padInfo.top,R=D-1-h.padInfo.left,L=G/T;for(let e=0;e<B;++e)for(let t=0;t<T;++t)for(let n=0;n<S;++n){const r=n-O,s=Math.max(0,Math.ceil(r/Q)),a=Math.min(F,(M+r)/Q);for(let i=0;i<N;++i){const A=i-R,o=Math.max(0,Math.ceil(A/z)),l=Math.min(P,(D+A)/z);let u=0;for(let n=s;n<a;++n){const s=n*Q-r;for(let r=o;r<l;++r){const a=I*e+w*n+k*r,i=y*(M-1-s)+v*(D-1-(r*z-A))+E*t;for(let e=0;e<L;++e){u+=C[a+(t*L+e)]*x[i+e]}}}g[p*e+m*n+b*i+t]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const UO={kernelName:cp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=Of(r.shape),a=n.data.get(r.dataId).values,i=WI([s,s],r.dtype),A=i.values;for(let e=0;e<a.length;e++)A[e*s+e]=a[e];const o=[...r.shape,...r.shape];return n.makeTensorInfo(o,i.dtype,i.values)}},jO={kernelName:dp,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s}=e,{strides:a,pad:i,dilations:A}=n,o=t,l=o.data.get(r.dataId).values,u=r.shape.length,c=o.data.get(s.dataId).values,d=s.shape.length,{batchSize:h,inHeight:f,inWidth:g,inChannels:p,outHeight:m,outWidth:b,padInfo:C,strideHeight:I,strideWidth:w,filterHeight:k,filterWidth:x,dilationHeight:y,dilationWidth:v,outShape:E}=Aw(r.shape,s.shape,a,i,"NHWC",A),B=Of(E),M=E.length,D=Kf(r.dtype,B);for(let e=0;e<h;++e)for(let t=0;t<m;++t){const n=t*I-C.top;for(let a=0;a<b;++a){const i=a*w-C.left;for(let A=0;A<p;++A){let o=Number.MIN_SAFE_INTEGER;for(let t=0;t<k;++t){const a=n+t*y;if(a>=0&&a<f)for(let n=0;n<x;++n){const h=i+n*v;if(h>=0&&h<g){const i=lg([e,a,h,A],u,ng(r.shape)),f=lg([t,n,A],d,ng(s.shape)),g=l[i]+c[f];g>o&&(o=g)}}}D[lg([e,t,a,A],M,ng(E))]=o}}}return{dataId:o.write(aC(D,r.dtype),E,r.dtype),shape:E,dtype:r.dtype}}},YO={kernelName:fp,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:A,dilations:o}=n,l=t,u=sg(r.shape,l.data.get(r.dataId).values),c=sg(s.shape,l.data.get(s.dataId).values),{batchSize:d,inHeight:h,inWidth:f,inChannels:g,outHeight:p,outWidth:m,padInfo:b,strideHeight:C,strideWidth:I,filterHeight:w,filterWidth:k,dilationHeight:x,dilationWidth:y,outShape:v}=Aw(r.shape,s.shape,i,A,"NHWC",o);Pf(a.rank===v.length,(()=>`Error in ${fp}, dy must have the same rank as output ${v.length}, but got ${a.rank}`));const E=sg(v,l.data.get(a.dataId).values),B=Ag(s.shape,s.dtype);for(let e=0;e<d;++e)for(let t=0;t<p;++t){const n=t*C-b.top;for(let r=0;r<m;++r){const s=r*I-b.left;for(let a=0;a<g;++a){let i=Number.MIN_SAFE_INTEGER,A=0,o=0;for(let t=0;t<w;++t){const r=n+t*x;if(r>=0&&r<h)for(let n=0;n<k;++n){const l=s+n*y;if(l>=0&&l<f){const s=u[e][r][l][a]+c[t][n][a];s>i&&(i=s,A=t,o=n)}}}B[A][o][a]+=E[e][t][r][a]}}}return{dataId:l.write(aC(B,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},KO={kernelName:hp,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:A,dilations:o}=n,l=t,u=sg(r.shape,l.data.get(r.dataId).values),c=sg(s.shape,l.data.get(s.dataId).values),{batchSize:d,inHeight:h,inWidth:f,inChannels:g,outHeight:p,outWidth:m,padInfo:b,strideHeight:C,strideWidth:I,filterHeight:w,filterWidth:k,dilationHeight:x,dilationWidth:y,outShape:v}=Aw(r.shape,s.shape,i,A,"NHWC",o);Pf(a.rank===v.length,(()=>`Error in ${hp}, dy must have the same rank as output ${v.length}, but got ${a.rank}`));const E=sg(v,l.data.get(a.dataId).values),B=Ag(r.shape,r.dtype);for(let e=0;e<d;++e)for(let t=0;t<p;++t){const n=t*C-b.top;for(let r=0;r<m;++r){const s=r*I-b.left;for(let a=0;a<g;++a){let i=Number.MIN_SAFE_INTEGER,A=n<0?0:n,o=s<0?0:s;for(let t=0;t<w;++t){const r=n+t*x;if(r>=0&&r<h)for(let n=0;n<k;++n){const l=s+n*y;if(l>=0&&l<f){const s=u[e][r][l][a]+c[t][n][a];s>i&&(i=s,A=r,o=l)}}}B[e][A][o][a]+=E[e][t][r][a]}}}return{dataId:l.write(aC(B,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const XO={kernelName:"Draw",backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:A,imageOptions:o}=i||{},l=(null==o?void 0:o.alpha)||1,u=(null==A?void 0:A.contextType)||"2d";if("2d"!==u)throw new Error(`Context type ${A.contextType} is not supported by the CPU backend.`);const c=a.getContext(u,(null==A?void 0:A.contextAttributes)||{});if(null==c)throw new Error(`Could not get the context with ${u} type.`);const[d,h]=s.shape.slice(0,2),f=2===s.shape.length?1:s.shape[2],g=n.data.get(s.dataId).values,p="float32"===s.dtype?255:1,m=new Uint8ClampedArray(h*d*4);for(let e=0;e<d*h;++e){const t=[0,0,0,255*l];for(let n=0;n<f;n++){const r=g[e*f+n];if("float32"===s.dtype){if(r<0||r>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${r}.`)}else if("int32"===s.dtype&&(r<0||r>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${r}.`);1===f?(t[0]=r*p,t[1]=r*p,t[2]=r*p):t[n]=r*p}const n=4*e;m[n+0]=Math.round(t[0]),m[n+1]=Math.round(t[1]),m[n+2]=Math.round(t[2]),m[n+3]=Math.round(t[3])}a.width=h,a.height=d;const b=new ImageData(m,h,d);return c.putImageData(b,0,0),s}};function qO(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;let A;qF(s,"sum"),A="bool"===s.dtype?uP({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):aP({inputs:{x:s},backend:n});const o=A.shape.length,l=Uf(a,A.shape),u=wk(l,o);let c=l,d=A;null!=u&&(d=vQ({inputs:{x:A},backend:n,attrs:{perm:u}}),c=xk(c.length,o)),Ik("sum",c,d.shape.length);const[h,f]=bk(d.shape,c);let g=sP(n,h,SC(d.dtype,"int32"));const p=Of(f),m=n.data.get(g.dataId).values,b=n.data.get(d.dataId).values;for(let e=0;e<m.length;++e){const t=e*p;let n=0;for(let e=0;e<p;++e)n+=b[t+e];m[e]=n}if(i){const e=g;g=Qz({inputs:{x:g},backend:n,attrs:{shape:Ck(g.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(A),null!=u&&n.disposeIntermediateTensorInfo(d),g}const ZO={kernelName:Zm,backendName:"cpu",kernelFunc:qO};const JO={kernelName:pp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:A,idDims:o}=HE(s,a.length);jE(i.length,o,a);const{path:l,steps:u}=YE(A,o),c=u.length;let d=null,h=i.length;const f=[];for(let e=0;e<c;++e){for(const t of u[e]){const{permutationIndices:e,expandDims:r}=UE(h,o[t]);let s;KE(e)?s=a[t]:(s=vQ({inputs:{x:a[t]},backend:n,attrs:{perm:e}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Rf(s.shape,i)||(s=Qz({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=mQ({inputs:{a:s,b:d},backend:n}),f.push(d))}e<c-1&&(l[e]>=0&&(d=qO({inputs:{x:d},backend:n,attrs:{axis:l[e]-(i.length-h),keepDims:!1}}),f.push(d)),h--)}for(const e of f)e!==d&&n.disposeIntermediateTensorInfo(e);return d}};const $O={kernelName:bp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;qF([r,s],"eluGrad");const a=new Float32Array(Of(s.shape)),i=n.data.get(s.dataId).values,A=n.data.get(r.dataId).values;for(let e=0;e<i.length;++e){const t=i[e];a[e]=t>=0?A[e]:A[e]*(t+1)}return n.makeTensorInfo(s.shape,"float32",a)}},eR=ME,tR=DE,nR=TE,rR=SE,sR=NE,aR=GE,iR=xP(Cp,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+eR*n);return t*(1-((((aR*r+sR)*r+rR)*r+nR)*r+tR)*r*Math.exp(-n*n))})),AR={kernelName:Cp,backendName:"cpu",kernelFunc:iR};function oR(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,A=s.shape.slice();let o=a;return a<0&&(Pf(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),o=i+a+1),A.splice(o,0,1),Qz({inputs:{x:s},backend:n,attrs:{shape:A}})}const lR={kernelName:kp,backendName:"cpu",kernelFunc:oR},uR=tP(((e,t)=>e/t)),cR=dP(gp,uR),dR={kernelName:gp,backendName:"cpu",kernelFunc:cR};function hR(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),A=i.complexTensorInfos.real,o=i.complexTensorInfos.imag,l=[s,a],u=Of(l),c=Yf("float32",u),d=Yf("float32",u);for(let e=0;e<s;e++){const r=XQ({inputs:{x:A},backend:n,attrs:{begin:[e,0],size:[1,a]}}),s=XQ({inputs:{x:o},backend:n,attrs:{begin:[e,0],size:[1,a]}}),i=nP({inputs:{real:r,imag:s},backend:n}),{real:l,imag:u}=fR(i,t,n),h=FE(l,u);for(let t=0;t<a;t++){const n=OE(h,t);c[e*a+t]=n.real,d[e*a+t]=n.imag}n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i)}const h=n.makeTensorInfo(l,"float32",c),f=n.makeTensorInfo(l,"float32",d),g=nP({inputs:{real:h,imag:f},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),g}function fR(e,t,n){const r=Of(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if((A=r)&A-1){const e=function(e,t,n){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let a=0,i=0;for(let r=0;r<t;r++){const A=WE(s*r,t,n),o=OE(e,r);a+=o.real*A.real-o.imag*A.imag,i+=o.real*A.imag+o.imag*A.real}n&&(a/=t,i/=t),RE(r,a,i,s)}return r}(FE(a,i),r,t);return PE(e)}{const s=gR(a,i,r,t,n),A=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(A,"float32",s.real),t=n.makeTensorInfo(A,"float32",s.imag),a=n.makeTensorInfo([],"float32",sC(r,"float32")),i=aP({inputs:{x:a},backend:n}),o=dR.kernelFunc({inputs:{a:e,b:a},backend:n}),l=dR.kernelFunc({inputs:{a:t,b:i},backend:n}),u=n.data.get(o.dataId).values,c=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),{real:u,imag:c}}return s}var A}function gR(e,t,n,r,s){if(1===n)return{real:e,imag:t};const a=FE(e,t),i=n/2,A=QE(a),o=A.real,l=A.imag,u=[o.length],c=s.makeTensorInfo(u,"float32",o),d=s.makeTensorInfo(u,"float32",l),h=nP({inputs:{real:c,imag:d},backend:s}),f=zE(a),g=f.real,p=f.imag,m=[g.length],b=s.makeTensorInfo(m,"float32",g),C=s.makeTensorInfo(m,"float32",p),I=nP({inputs:{real:b,imag:C},backend:s}),w=gR(o,l,i,r,s),k=w.real,x=w.imag,y=[k.length],v=s.makeTensorInfo(y,"float32",k),E=s.makeTensorInfo(y,"float32",x),B=nP({inputs:{real:v,imag:E},backend:s}),M=gR(g,p,i,r,s),D=M.real,T=M.imag,S=[D.length],N=s.makeTensorInfo(S,"float32",D),G=s.makeTensorInfo(S,"float32",T),F=nP({inputs:{real:N,imag:G},backend:s}),P=LE(n,r),Q=[P.real.length],z=s.makeTensorInfo(Q,"float32",P.real),O=s.makeTensorInfo(Q,"float32",P.imag),R=nP({inputs:{real:z,imag:O},backend:s}),L=mQ({inputs:{a:R,b:F},backend:s}),W=pP({inputs:{a:B,b:L},backend:s}),_=pz({inputs:{a:B,b:L},backend:s}),V=AP({inputs:{input:W},backend:s}),H=AP({inputs:{input:_},backend:s}),U=wO({inputs:{input:W},backend:s}),j=wO({inputs:{input:_},backend:s}),Y=xO({inputs:[V,H],backend:s,attrs:{axis:0}}),K=xO({inputs:[U,j],backend:s,attrs:{axis:0}}),X=s.data.get(Y.dataId).values,q=s.data.get(K.dataId).values;return s.disposeIntermediateTensorInfo(c),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(I),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(E),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(Y),s.disposeIntermediateTensorInfo(K),{real:X,imag:q}}const pR={kernelName:yp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Of(r.shape),a=r.shape[r.shape.length-1],i=Qz({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),A=hR(i,!1,n),o=Qz({inputs:{x:A},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(A),o}};function mR(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||$f(s),A=Kf(i,Of(r));return function(e,t){e.fill(t)}(A,s),t.makeTensorInfo(r,i,A)}const bR={kernelName:vp,backendName:"cpu",kernelFunc:mR};const CR={kernelName:Ep,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,s=n,a=Yf(r.dtype,Of(r.shape)),[i,A,o,l]=r.shape,u=s.data.get(r.dataId).values;for(let e=0;e<i;e++){const t=e*o*A*l;for(let e=0;e<A;e++){const n=e*(o*l);for(let e=0;e<o;e++){const r=e*l;for(let s=0;s<l;s++){const i=Math.round(o-e-1),A=t+n+r+s;let c=u[A];if(i>=0&&i<o){c=u[t+n+i*l+s]}a[A]=c}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const IR={kernelName:Bb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:A}=t,{strides:o,pad:l,dataFormat:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r;let g=vO({inputs:{x:s,filter:a},backend:n,attrs:{strides:o,pad:l,dataFormat:u,dilations:c,dimRoundingMode:d}});if(i){const e=g;if("NCHW"===u&&1===i.shape.length&&1!==i.shape[0]){const e=Qz({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});g=pP({inputs:{a:g,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else g=pP({inputs:{a:g,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(h){const e=g;if("NCHW"===u&&"prelu"===h&&1===A.shape.length&&1!==A.shape[0]){const e=Qz({inputs:{x:A},backend:n,attrs:{shape:[A.shape[0],1,1]}});g=Pz(n,g,h,e,f),n.disposeIntermediateTensorInfo(e)}else g=Pz(n,g,h,A,f);n.disposeIntermediateTensorInfo(e)}return g}};const wR={kernelName:Mb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:A}=t,{strides:o,pad:l,dataFormat:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r;let g=WO({inputs:{x:s,filter:a},backend:n,attrs:{strides:o,pad:l,dataFormat:u,dilations:c,dimRoundingMode:d}});if(i){const e=g;g=pP({inputs:{a:g,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(h){const e=g;g=Pz(n,g,h,A,f),n.disposeIntermediateTensorInfo(e)}return g}};const kR={kernelName:Sp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=Of(r.shape),i=s.shape,A=i[i.length-1],[o,l,u,c]=jv(r,s);if(0===l)return n.makeTensorInfo(o,r.dtype,[]);const d=HP(n.data.get(s.dataId).values,n.bufferSync(r),r.dtype,l,A,u,c,r.shape,a);return n.makeTensorInfo(o,r.dtype,d.values)}};const xR={kernelName:Tp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:A}=r;qF([s,a],"gatherV2");const o=Uf(i,s.shape)[0],l=n.data.get(a.dataId).values,u=s.shape[o];for(let e=0;e<l.length;++e){const t=l[e];Pf(t<=u-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${u-1}]`))}let c=A;null==A&&(c=0);const d=Of(a.shape),h=cB(s,a,o,c),f=Qz({inputs:{x:s},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),g=Qz({inputs:{x:a},backend:n,attrs:{shape:[h.batchSize,d/h.batchSize]}}),p=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize],m=n.bufferSync(g),b=UP(n.bufferSync(f),m,p);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(h.outputShape,b.dtype,b.values)}};const yR={kernelName:Pp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Of(r.shape),a=r.shape[r.shape.length-1],i=Qz({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),A=hR(i,!0,n),o=Qz({inputs:{x:A},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(A),o}},vR=xP(zp,(e=>Number.isFinite(e)?1:0),"bool"),ER={kernelName:zp,backendName:"cpu",kernelFunc:vR},BR=xP(Op,(e=>Math.abs(e)===1/0?1:0),"bool"),MR={kernelName:Op,backendName:"cpu",kernelFunc:BR},DR=xP(Rp,(e=>Number.isNaN(e)?1:0),"bool"),TR={kernelName:Rp,backendName:"cpu",kernelFunc:DR};const SR={kernelName:Vp,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=sQ(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},NR=xP(Up,(e=>Math.log1p(e))),GR={kernelName:Up,backendName:"cpu",kernelFunc:NR},FR=tP(((e,t)=>e&&t)),PR=dP(jp,FR,null,"bool"),QR={kernelName:jp,backendName:"cpu",kernelFunc:PR},zR=xP(Yp,(e=>e?0:1),"bool"),OR={kernelName:Yp,backendName:"cpu",kernelFunc:zR},RR=tP(((e,t)=>e||t)),LR=dP(Kp,RR,null,"bool"),WR={kernelName:Kp,backendName:"cpu",kernelFunc:LR};const _R={kernelName:Xp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:A,beta:o}=r;qF(s,"LRN");const l=s.shape[3],u=l-1,c=n.data.get(s.dataId).values,d=Of(s.shape),h=new Float32Array(d);function f(e){const t=e%l;let n=e-t+Math.max(0,t-a);const r=e-t+Math.min(t+a,u);let s=0;for(;n<=r;n++){const e=c[n];s+=e*e}return s}for(let e=0;e<d;e++){const t=f(e),n=c[e]*Math.pow(i+A*t,-o);h[e]=n}return n.makeTensorInfo(s.shape,s.dtype,h)}};const VR={kernelName:qp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:A,bias:o,alpha:l,beta:u}=r;qF(i,"LRNGrad");const c=Of(i.shape),d=i.shape[3],h=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,g=n.data.get(a.dataId).values,p=new Float32Array(c),m=c;for(let e=0;e<m;e++){const t=e%d,n=e-t+Math.max(0,t-A),r=e-t+Math.min(d,t+A+1);let s=0;for(let e=n;e<r;e++)s+=Math.pow(f[e],2);s=l*s+o;for(let t=n;t<r;t++){let n=-2*l*u*f[t]*g[e]/s;e===t&&(n+=Math.pow(s,-u)),n*=h[e],p[t]+=n}}return n.makeTensorInfo(i.shape,s.dtype,p)}};function HR(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,A=n;let o=s.shape;const l=o.length,u=Uf(a,o);let c=u;const d=wk(c,l);let h=A.data.get(s.dataId).values;if(null!=d){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=o[d[t]];h=yQ(h,o,s.dtype,d,e),c=xk(c.length,l),o=e}qF(s,"max"),Ik("max",c,l);const[f,g]=bk(o,c),p=oQ(h,Of(g),f,s.dtype),m=A.write(p,f,s.dtype);let b=f;if(i){b=Ck(f,u)}return{dataId:m,shape:b,dtype:s.dtype}}const UR={kernelName:Zp,backendName:"cpu",kernelFunc:HR};const jR={kernelName:$p,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;qF(s,"maxPool");const{filterSize:a,strides:i,pad:A,dimRoundingMode:o}=r;Pf(bw(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const l=ow(s.shape,a,i,1,A,o);let u;if(1===l.filterWidth&&1===l.filterHeight&&Rf(l.inShape,l.outShape))u=aP({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=ng(s.shape),r=AO(e,s.shape,s.dtype,t,l,"max");u=n.makeTensorInfo(l.outShape,s.dtype,r.values)}return u}};const YR={kernelName:tm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:A,dimRoundingMode:o,dataFormat:l}=r;qF(s,"maxPool3d");const u=lw(s.shape,a,i,1,A,o,l),c=lO(n.data.get(s.dataId).values,s.shape,s.dtype,ng(s.shape),u,"max");return n.makeTensorInfo(c.shape,"float32",c.values)}};const KR={kernelName:nm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:A,pad:o,dimRoundingMode:l}=r;qF([s,a],"maxPool3DGrad");const u=lw(a.shape,i,A,1,o,l),c=function(e,t){const n=WI(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,A=t.dilationHeight,o=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,d=t.padInfo.front,h=t.padInfo.top,f=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let p=0;p<t.inChannels;++p)for(let m=0;m<t.outDepth;++m){const b=m*r-d;let C=b;for(;C<0;)C+=i;const I=Math.min(t.inDepth,l+b);for(let r=0;r<t.outHeight;++r){const l=r*s-h;let d=l;for(;d<0;)d+=A;const w=Math.min(t.inHeight,u+l);for(let s=0;s<t.outWidth;++s){const h=s*a-f;let k=h;for(;k<0;)k+=o;const x=Math.min(t.inWidth,c+h);let y=Number.NEGATIVE_INFINITY,v=-1;for(let t=C;t<I;t+=i){const n=t-b;for(let r=d;r<w;r+=A){const s=r-l;for(let a=k;a<x;a+=o){const i=a-h,A=e.get(g,t,r,a,p);A>=y&&(y=A,v=n*u*c+s*u+i)}}}n.set(v,g,m,r,s,p)}}}return n}(n.bufferSync(a),u),d=u.strideDepth,h=u.strideHeight,f=u.strideWidth,g=u.dilationDepth,p=u.dilationHeight,m=u.dilationWidth,b=u.effectiveFilterDepth,C=u.effectiveFilterHeight,I=u.effectiveFilterWidth,w=b-1-u.padInfo.front,k=I-1-u.padInfo.left,x=C-1-u.padInfo.top,y=WI(a.shape,"float32"),v=n.bufferSync(s);for(let e=0;e<u.batchSize;++e)for(let t=0;t<u.inChannels;++t)for(let n=0;n<u.inDepth;++n)for(let r=0;r<u.inHeight;++r)for(let s=0;s<u.inWidth;++s){const a=n-w,i=r-x,A=s-k;let o=0;for(let n=0;n<b;n+=g){const r=(a+n)/d;if(!(r<0||r>=u.outDepth||Math.floor(r)!==r))for(let s=0;s<C;s+=p){const a=(i+s)/h;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let i=0;i<I;i+=m){const l=(A+i)/f;if(l<0||l>=u.outWidth||Math.floor(l)!==l)continue;const d=b*C*I-1-c.get(e,r,a,l,t)===n*C*I+s*I+i?1:0;if(0===d)continue;o+=v.get(e,r,a,l,t)*d}}}y.set(o,e,n,r,s,t)}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const XR={kernelName:em,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,A=a;qF([a,i],"maxPoolGrad");const{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=ow(A.shape,o,l,1,u,c),h=n.data.get(A.dataId).values,f=WI(d.outShape,A.dtype,oO(h,A.shape,A.dtype,d).values),g=d.strideHeight,p=d.strideWidth,m=d.dilationHeight,b=d.dilationWidth,C=d.effectiveFilterHeight,I=d.effectiveFilterWidth,w=I-1-d.padInfo.left,k=C-1-d.padInfo.top,x=WI(A.shape,"float32"),y=n.data.get(s.dataId).values,v=WI(s.shape,"float32",y);for(let e=0;e<d.batchSize;++e)for(let t=0;t<d.inChannels;++t)for(let n=0;n<d.inHeight;++n)for(let r=0;r<d.inWidth;++r){const s=n-k,a=r-w;let i=0;for(let n=0;n<C;n+=m){const r=(s+n)/g;if(!(r<0||r>=d.outHeight||Math.floor(r)!==r))for(let s=0;s<I;s+=b){const A=(a+s)/p;if(A<0||A>=d.outWidth||Math.floor(A)!==A)continue;const o=C*I-1-f.get(e,r,A,t)===n*I+s?1:0;if(0===o)continue;i+=v.get(e,r,A,t)*o}}x.set(i,e,n,r,t)}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const qR={kernelName:rm,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:A}=t,o=n;qF(r,"MaxPoolWithArgmax");const l=o.data.get(r.dataId).values,u=ow(r.shape,s,a,[1,1],i),[c,d]=function(e,t,n,r,s){const a=AO(e,0,n,ng(t),s,"max"),i=oO(e,t,n,s,!0,r);return[a.values,i.values]}(l,r.shape,r.dtype,A,u),h=o.write(c,u.outShape,r.dtype),f=o.write(d,u.outShape,r.dtype);return[{dataId:h,shape:u.outShape,dtype:r.dtype},{dataId:f,shape:u.outShape,dtype:"int32"}]}};const ZR={kernelName:sm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,A=Uf(a,s.shape),o=Of(bk(s.shape,A)[1]),l=[],u=n.makeTensorInfo([],"float32",new Float32Array([o]));l.push(u);const c=uP({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});l.push(c);const d=cR({inputs:{a:c,b:u},backend:n});l.push(d);const h=qO({inputs:{x:d},backend:n,attrs:{axis:a,keepDims:i}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}};const JR={kernelName:am,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;qF(s,"min");const A=Uf(a,s.shape);let o=A;const l=wk(o,s.shape.length);let u=s;null!=l&&(u=vQ({inputs:{x:s},backend:n,attrs:{perm:l}}),o=xk(o.length,s.shape.length)),Ik("min",o,u.shape.length);const[c,d]=bk(u.shape,o),h=Of(d),f=ig(Of(c),u.dtype),g=n.data.get(u.dataId).values;for(let e=0;e<f.length;++e){const t=e*h;let n=g[t];for(let e=0;e<h;++e){const r=g[t+e];(Number.isNaN(r)||r<n)&&(n=r)}f[e]=n}null!=l&&n.disposeIntermediateTensorInfo(u);const p=n.makeTensorInfo(c,u.dtype,f);if(i){const e=Qz({inputs:{x:p},backend:n,attrs:{shape:Ck(c,A)}});return n.disposeIntermediateTensorInfo(p),e}return p}};const $R={kernelName:Am,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;qF(s,"mirrorPad");const A=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),o=a.map((e=>e[0])),l=a.map(((e,t)=>e[0]+s.shape[t])),u="reflect"===i?0:1,c=n.data.get(s.dataId).values,d=s.shape.length,h=ng(s.shape),f=Of(A),g=A.length,p=ng(A),m=Yf(s.dtype,f);for(let e=0;e<f;e++){let t=ug(e,g,p);for(let e=0;e<g;e++)t[e]<o[e]?t[e]=2*o[e]-t[e]-u:t[e]>=l[e]&&(t[e]=2*(l[e]-1)-t[e]+u);t=t.map(((e,t)=>e-o[t]));const n=lg(t,d,h);m[e]=c[n]}return{dataId:n.write(m,A,s.dtype),shape:A,dtype:s.dtype}}},eL=tP(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),tL=dP(om,eL),nL={kernelName:om,backendName:"cpu",kernelFunc:tL};function rL(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let A=a;if(-1===A&&(A=i-1),A!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${A}`);const o=Uf([A],s.shape),l=HR({inputs:{x:s},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),u=Ck(l.shape,o),c=Qz({inputs:{x:l},backend:n,attrs:{shape:u}}),d=pz({inputs:{a:s,b:c},backend:n}),h=GP({inputs:{x:d},backend:n}),f=qO({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:!1}}),g=Qz({inputs:{x:f},backend:n,attrs:{shape:u}}),p=cR({inputs:{a:h,b:g},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),p}const sL={kernelName:eb,backendName:"cpu",kernelFunc:rL};const aL={kernelName:lm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:A}=r;qF(s,"multinomial");const o=A?s:rL({inputs:{logits:s},backend:n,attrs:{dim:-1}}),l=o.shape[0],u=o.shape[1],c=n.data.get(o.dataId).values,d=[l,a],h=ig(Of(d),"int32");for(let e=0;e<l;++e){const t=e*u,n=new Float32Array(u-1);n[0]=c[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+c[t+e];const r=$x.alea(i.toString()),s=e*a;for(let e=0;e<a;++e){const t=r();h[s+e]=n.length;for(let r=0;r<n.length;r++)if(t<n[r]){h[s+e]=r;break}}}return A||n.disposeIntermediateTensorInfo(o),n.makeTensorInfo(d,"int32",h)}},iL=uv;const AL={kernelName:hm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:A,scoreThreshold:o}=r;qF(s,"NonMaxSuppression");const l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,{selectedIndices:c}=iL(l,u,i,A,o);return n.makeTensorInfo([c.length],"int32",new Int32Array(c))}},oL=cv;const lL={kernelName:fm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:A,scoreThreshold:o,padToMaxOutputSize:l}=r;qF(s,"NonMaxSuppressionPadded");const u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:d,validOutputs:h}=oL(u,c,i,A,o,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}},uL=dv;const cL={kernelName:gm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:A,scoreThreshold:o,softNmsSigma:l}=r;qF(s,"NonMaxSuppressionWithScore");const u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,d=i,h=A,f=o,g=l,{selectedIndices:p,selectedScores:m}=uL(u,c,d,h,f,g);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([m.length],"float32",new Float32Array(m))]}};const dL={kernelName:mm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:A,offValue:o}=r;qF(s,"oneHot");const l=Of(s.shape),u=new Float32Array(l*i);u.fill(o);const c=n.data.get(s.dataId).values;for(let e=0;e<l;++e)c[e]>=0&&c[e]<i&&(u[e*i+c[e]]=A);return n.makeTensorInfo([...s.shape,i],a,u)}};function hL(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=AP({inputs:{input:r},backend:n}),t=hL({inputs:{x:e},backend:n}),s=wO({inputs:{input:r},backend:n}),a=hL({inputs:{x:s},backend:n}),i=nP({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return mR({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const fL={kernelName:xb,backendName:"cpu",kernelFunc:hL};const gL={kernelName:pm,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const t=AP({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=wO({inputs:{input:s},backend:r}),i=hL({inputs:{x:a},backend:r}),A=nP({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),A}return mR({backend:r,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function pL(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return oR({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{Qf(a,e.shape,"All tensors passed to stack must have matching shapes"),Pf(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const A=[],o=t.map((e=>{const t=oR({inputs:{input:e},backend:n,attrs:{dim:s}});return A.push(t),t})),l=xO({inputs:o,backend:n,attrs:{axis:s}});return A.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const mL={kernelName:bm,backendName:"cpu",kernelFunc:pL};const bL={kernelName:Cm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;qF(s,"pad");const A=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),o=a.map((e=>e[0])),l=n.data.get(s.dataId).values,u=Of(s.shape),c=s.shape.length,d=ng(s.shape),h=Of(A),f=A.length,g=ng(A),p=Yf(s.dtype,h);0!==i&&p.fill(i);for(let e=0;e<u;e++){const t=ug(e,c,d).map(((e,t)=>e+o[t]));p[lg(t,f,g)]=l[e]}return{dataId:n.write(p,A,s.dtype),shape:A,dtype:s.dtype}}},CL=tP(((e,t)=>Math.pow(e,t))),IL=dP(Im,CL),wL={kernelName:Im,backendName:"cpu",kernelFunc:IL};const kL={kernelName:xm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:A}=r,o=s.map((e=>n.data.get(e.dataId).values)),l=s.map((e=>e.shape)),u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,[d,h,f]=NQ(o,l,u,a.shape,a.dtype,c,i.shape),g=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),p=n.makeTensorInfo(f,a.dtype,h);return g.concat([p])}};const xL={kernelName:ym,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,A=n.data.get(s.dataId).values,o=n.data.get(a.dataId).values,[l,u]=FQ(i,r.shape,r.dtype,A,s.shape,o,a.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],r.dtype,u)]}};const yL={kernelName:vm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:A}=t,{rowPartitionTypes:o}=r,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,d=A.map((e=>n.data.get(e.dataId).values)),h=A.map((e=>e.shape)),[f,g]=RQ(l,s.shape,u,a.shape,a.dtype,c,i.shape,d,h,o);return n.makeTensorInfo(f,a.dtype,g)}};const vL={kernelName:Em,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,A=LQ(r,s,i,a);return t.makeTensorInfo([A.length],a,A)}},EL=xP(Mm,(e=>1/e)),BL={kernelName:Mm,backendName:"cpu",kernelFunc:EL};const ML={kernelName:Gm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:A}=r;qF(s,"resizeBilinear");const o=ng(s.shape),[l,u]=A,[c,d,h,f]=s.shape,g=n.data.get(s.dataId).values,p=new Float32Array(Of([c,l,u,f])),m=[a&&l>1?d-1:d,a&&u>1?h-1:h],b=[a&&l>1?l-1:l,a&&u>1?u-1:u];let C=0;const I=m[0]/b[0],w=m[1]/b[1];for(let e=0;e<c;e++)for(let t=0;t<l;t++){let n;n=i?I*(t+.5)-.5:I*t;const r=Math.max(0,Math.floor(n)),s=n-r,a=Math.min(d-1,Math.ceil(n)),A=e*o[0]+r*o[1],l=e*o[0]+a*o[1];for(let e=0;e<u;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(h-1,Math.ceil(t)),u=A+n*o[2],c=l+n*o[2],d=A+a*o[2],m=l+a*o[2];for(let e=0;e<f;e++){const t=g[u+e],n=g[c+e],a=t+(g[d+e]-t)*r,i=a+(n+(g[m+e]-n)*r-a)*s;p[C++]=i}}}return n.makeTensorInfo([c,l,u,f],"float32",p)}};const DL={kernelName:Fm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;qF([a,s],"resizeBilinearGrad");const A=ng(s.shape),[o,l,u,c]=s.shape,[,d,h]=a.shape,f=new Float32Array(o*l*u*c),g=[i&&d>1?l-1:l,i&&h>1?u-1:u],p=[i&&d>1?d-1:d,i&&h>1?h-1:h],m=g[0]/p[0],b=g[1]/p[1],C=n.data.get(a.dataId).values;let I=0;for(let e=0;e<o;e++){const t=e*A[0];for(let e=0;e<d;e++){const n=e*m,r=Math.floor(n),s=Math.min(Math.ceil(n),l-1),a=t+r*A[1],i=t+s*A[1],o=n-r,d=1-o;for(let e=0;e<h;e++){const t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),u-1),s=t-n,l=1-s,h=a+n*A[2],g=a+r*A[2],p=i+n*A[2],m=i+r*A[2],w=d*l,k=d*s,x=o*l,y=o*s;for(let e=0;e<c;e++){const t=C[I++];f[h+e]+=t*w,f[g+e]+=t*k,f[p+e]+=t*x,f[m+e]+=t*y}}}}return n.makeTensorInfo([o,u,l,c],"float32",f)}};const TL={kernelName:Sm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:A}=r;qF(s,"resizeNearestNeighbor");const o=ng(s.shape),[l,u]=A,[c,d,h,f]=s.shape,g=n.data.get(s.dataId).values,p=new Float32Array(c*l*u*f),m=[a&&l>1?d-1:d,a&&u>1?h-1:h],b=[a&&l>1?l-1:l,a&&u>1?u-1:u],C=m[0]/b[0],I=m[1]/b[1];let w=0;for(let e=0;e<c;e++){const t=e*o[0];for(let e=0;e<l;e++){const n=i?C*(e+.5):C*e;let r=Math.min(d-1,a?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const s=t+r*o[1];for(let e=0;e<u;e++){const t=i?I*(e+.5):I*e;let n=Math.min(h-1,a?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=s+n*o[2];for(let e=0;e<f;e++){const t=g[r+e];p[w++]=t}}}}return n.makeTensorInfo([c,l,u,f],s.dtype,p)}};const SL={kernelName:Nm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;qF([a,s],"resizeNearestNeighborGrad");const A=ng(s.shape),o=ng(a.shape),[l,u,c,d]=s.shape,[,h,f]=a.shape,g=new Float32Array(l*u*c*d),p=n.data.get(a.dataId).values,m=[i&&h>1?u-1:u,i&&f>1?c-1:c],b=[i&&h>1?h-1:h,i&&f>1?f-1:f],C=m[0]/b[0],I=m[1]/b[1],w=1/C,k=1/I,x=2*Math.ceil(w)+2,y=2*Math.ceil(k)+2;for(let e=0;e<l;e++){const t=e*A[0];for(let e=0;e<u;e++){const n=t+e*A[1],r=Math.floor(e*w),s=Math.floor(r-x/2);for(let r=0;r<c;r++){const a=n+r*A[2],l=Math.floor(r*k),m=Math.floor(l-y/2);for(let n=0;n<d;n++){let A=0;for(let a=0;a<x;a++){const l=a+s;if(l<0||l>=h)continue;const d=t+l*o[1],g=l*C;if(e===Math.min(u-1,i?Math.round(g):Math.floor(g)))for(let e=0;e<y;e++){const t=e+m;if(t<0||t>=f)continue;const s=d+t*o[2],a=t*I;r===Math.min(c-1,i?Math.round(a):Math.floor(a))&&(A+=p[s+n])}}g[a+n]=A}}}}return n.makeTensorInfo(s.shape,s.dtype,g)}};const NL={kernelName:Qm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;qF(s,"reverse");const i=s.shape.length,A=Uf(a,s.shape);if(0===i)return aP({inputs:{x:s},backend:n});const o=new CC(s.shape,s.dtype),l=n.bufferSync(s);for(let e=0;e<o.size;e++){const t=o.indexToLoc(e),n=t.slice();A.forEach((e=>n[e]=s.shape[e]-1-n[e])),o.set(l.get(...n),...t)}return n.makeTensorInfo(o.shape,o.dtype,o.values)}},GL={kernelName:vb,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,A=n,o=Yf(r.dtype,Of(r.shape)),[l,u,c,d]=r.shape,[h,f]=IE(i,u,c),g=Math.sin(s),p=Math.cos(s),m=A.data.get(r.dataId).values;for(let e=0;e<l;e++){const t=e*c*u*d;for(let e=0;e<u;e++){const n=e*(c*d);for(let r=0;r<c;r++){const s=r*d;for(let i=0;i<d;i++){const A=[l,e,r,i],b=A[2],C=A[1];let I=(b-h)*p-(C-f)*g,w=(b-h)*g+(C-f)*p;I=Math.round(I+h),w=Math.round(w+f);let k=a;if("number"!=typeof a&&(k=3===i?255:a[i]),I>=0&&I<c&&w>=0&&w<u){k=m[t+w*(c*d)+I*d+i]}o[t+n+s+i]=k}}}}return{dataId:A.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},FL=xP(zm,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1})),PL={kernelName:zm,backendName:"cpu",kernelFunc:FL};const QL={kernelName:Rm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:A,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=Qy(0,s,i),d=HQ(n.bufferSync(s),n.bufferSync(a),i,c,l,o,A,u,0,!0);return n.makeTensorInfo(i,d.dtype,d.values)}};function zL(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function OL(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}const RL={kernelName:Wm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,A=function(e,t,n,r,s,a){const i=Kf("int32",n*s);for(let A=0;A<n;++A){const n=e.slice(A*r,(A+1)*r),o=A*s;for(let e=0;e<s;++e)i[o+e]="left"===a?zL(n,t[e+o]):OL(n,t[e+o])}return i}(n.data.get(s.dataId).values,n.data.get(a.dataId).values,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",A)}};const LL={kernelName:_m,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;qF([r,s,a],"select");const i=r.shape.length,A=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=SC(s.dtype,a.dtype),c=ig(Of(s.shape),u);let d=0;const h=0===i||i>1||1===s.shape.length?1:Of(s.shape.slice(1));for(let e=0;e<A.length;e++)for(let t=0;t<h;t++)1===A[e]?c[d++]=o[e]:c[d++]=l[e];return n.makeTensorInfo(s.shape,u,c)}},WL=EE,_L=BE,VL=xP(Vm,(e=>e>=0?_L*e:WL*(Math.exp(e)-1))),HL={kernelName:Vm,backendName:"cpu",kernelFunc:VL},UL=xP(Ym,(e=>e<0?-1:e>0?1:0)),jL={kernelName:Ym,backendName:"cpu",kernelFunc:UL},YL=xP(Um,(e=>Math.sin(e))),KL={kernelName:Um,backendName:"cpu",kernelFunc:YL},XL=xP(jm,(e=>Math.sinh(e))),qL={kernelName:jm,backendName:"cpu",kernelFunc:XL},ZL=Math.log(1.1920928955078125e-7)+2,JL=xP(Xm,(e=>{const t=e>-ZL,n=e<ZL,r=Math.exp(e);let s;return s=n?r:t?e:Math.log(1+r),s})),$L={kernelName:Xm,backendName:"cpu",kernelFunc:JL};const eW={kernelName:Jm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;qF([s],"spaceToBatchND");const A=Of(a),o=[[0,0]];o.push(...i);for(let e=1+a.length;e<s.shape.length;++e)o.push([0,0]);const l=bL.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:o,constantValue:0}}),u=wE(l.shape,a,A,!1),c=kE(u.length,a.length,!1),d=xE(l.shape,a,A,!1),h=Qz({inputs:{x:l},backend:n,attrs:{shape:u}}),f=vQ({inputs:{x:h},backend:n,attrs:{perm:c}}),g=Qz({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),g}};const tW={kernelName:tb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const A=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values[0],[c,d,h,f,g]=ZQ(A,r.shape,r.dtype,o,s.dtype,l,u);return[n.makeTensorInfo(d,r.dtype,c),n.makeTensorInfo([d[0]],s.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}};const nW={kernelName:nb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),A=n.data.get(r.dataId).values,o=Array.from(n.data.get(a.dataId).values),[l,u,c]=JQ(A,r.shape,r.dtype,i,o);return[n.makeTensorInfo(u,r.dtype,l),n.makeTensorInfo([c.length],a.dtype,new Int32Array(c))]}};const rW={kernelName:rb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,A=n.data.get(s.dataId).values,o=n.data.get(a.dataId).values,[l,u]=$Q(i,r.shape,r.dtype,A,o,!0);return n.makeTensorInfo(u,r.dtype,l)}};const sW={kernelName:sb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,A=n.data.get(s.dataId).values,o=n.data.get(a.dataId).values,[l,u]=$Q(i,r.shape,r.dtype,A,o);return n.makeTensorInfo(u,r.dtype,l)}};const aW={kernelName:ab,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:A}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Qy(0,s,A),h=!1,f=n.bufferSync(s);let g;switch(a.dtype){case"bool":g=HQ(f,n.bufferSync(a),A,d,u,l,o,c,Boolean(n.data.get(i.dataId).values[0]),h);break;case"float32":g=HQ(f,n.bufferSync(a),A,d,u,l,o,c,n.data.get(i.dataId).values[0],h);break;case"int32":g=HQ(f,n.bufferSync(a),A,d,u,l,o,c,n.data.get(i.dataId).values[0],h);break;case"string":g=HQ(f,n.bufferSync(a),A,d,u,l,o,c,oC(n.data.get(i.dataId).values[0]),h);break;default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(A,g.dtype,g.values)}};const iW={kernelName:$m,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,A=Uf(i,s.shape)[0],o=qE(s,a,A),l=new Array(s.shape.length).fill(0),u=s.shape.slice();return o.map((e=>{const t=[...u];t[A]=e;const r=XQ({inputs:{x:s},backend:n,attrs:{begin:l,size:t}});return l[A]+=e,r}))}},AW={kernelName:Ab,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;qF(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let e=0;e<s.length;++e){const t=s[e];a[e]=t*t}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},oW=xP(yb,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),lW={kernelName:yb,backendName:"cpu",kernelFunc:oW};const uW={kernelName:lb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:A,beginMask:o,endMask:l,ellipsisMask:u,newAxisMask:c,shrinkAxisMask:d}=r;qF(s,"stridedSlice");const{finalShapeSparse:h,finalShape:f,isIdentity:g,sliceDim0:p,isSimpleSlice:m,begin:b,end:C,strides:I}=iE(s.shape,a,i,A,o,l,u,c,d);let w;if(g)w=Qz({inputs:{x:s},backend:n,attrs:{shape:f}});else if(p||m){Pf(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=Kv(b,C,I),t=XQ({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});w=Qz({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=oz(h,n.bufferSync(s),I,b);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};const cW={kernelName:ub,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:A,padWidth:o,preserveShortSequences:l}=r,{data:u,dataSplits:c}=t,d=n.data.get(u.dataId).values,h=n.data.get(c.dataId).values,[f,g]=uz(d,h,s,a,i,A,o,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(c.shape,"int32",g)]}};const dW={kernelName:cb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const A=n.data.get(a.dataId).values,o=n.data.get(i.dataId).values[0],[l,u,c]=dz(A,o,s),d=u.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(c))]}};const hW={kernelName:db,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=hz(n.data.get(a.dataId).values,s);return n.makeTensorInfo(a.shape,"int32",i)}},fW=xP(fb,(e=>Math.tan(e))),gW={kernelName:fb,backendName:"cpu",kernelFunc:fW},pW=xP(gb,(e=>Math.tanh(e)));const mW={kernelName:Lm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:A,sliceSize:o,strides:l,outputSize:u}=Qy(0,s,r.shape),c=n.bufferSync(s),d=n.bufferSync(a),h=n.bufferSync(r),f=HQ(c,d,r.shape,u,o,A,i,l,h,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};const bW={kernelName:pb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;qF(s,"tile");const i=bz(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}};const CW={kernelName:mb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;qF(s,"topk");const A=n.data.get(s.dataId).values,[o,l]=wz(A,s.shape,s.dtype,a,i);return[n.makeTensorInfo(o.shape,o.dtype,o.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};const IW={kernelName:bb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:A,fillValue:o,outputShape:l}=n,[u,c,d,h]=s.shape,[f,g]=null!=l?l:[c,d],p=[u,f,g,h],m=ng(s.shape),b=m[0],C=m[1],I=m[2],w=ng(p),k=w[0],x=w[1],y=w[2],v=Yf(s.dtype,Of(p));v.fill(o);const E=r.data.get(s.dataId).values,B=r.data.get(a.dataId).values;for(let e=0;e<u;++e){const t=1===a.shape[0]?B:B.subarray(8*e,8*e+8);for(let n=0;n<f;++n)for(let r=0;r<g;++r)for(let s=0;s<h;++s){let a;const l=t[6]*r+t[7]*n+1;if(0===l)continue;const u=(t[0]*r+t[1]*n+t[2])/l,h=(t[3]*r+t[4]*n+t[5])/l,f=wW(u,d,A),g=wW(h,c,A);switch(i){case"nearest":a=xW(E,c,d,b,C,I,e,g,f,s,o);break;case"bilinear":a=yW(E,c,d,b,C,I,e,g,f,s,o);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}v[e*k+n*x+r*y+s]=a}return r.makeTensorInfo(p,s.dtype,v)}return{dataId:r.write(v,p,s.dtype),shape:s.shape,dtype:s.dtype}}};function wW(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return Nf(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return Nf(0,n,t-1)}(e,t);case"nearest":return function(e,t){return Nf(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function kW(e,t,n,r,s,a,i,A,o,l,u){return 0<=A&&A<t&&0<=o&&o<n?e[i*r+A*s+o*a+l]:u}function xW(e,t,n,r,s,a,i,A,o,l,u){return kW(e,t,n,r,s,a,i,Math.round(A),Math.round(o),l,u)}function yW(e,t,n,r,s,a,i,A,o,l,u){const c=Math.floor(A),d=Math.floor(o),h=c+1,f=d+1;return(h-A)*((f-o)*kW(e,t,n,r,s,a,i,c,d,l,u)+(o-d)*kW(e,t,n,r,s,a,i,c,f,l,u))+(A-c)*((f-o)*kW(e,t,n,r,s,a,i,h,d,l,u)+(o-d)*kW(e,t,n,r,s,a,i,h,f,l,u))}const vW={kernelName:Ib,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;qF(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:A,outputShape:o,indices:l}=kz(i,s,a.shape,a.dtype);return[r.makeTensorInfo(o,a.dtype,A),r.makeTensorInfo([l.length],"int32",l)]}};const EW={kernelName:wb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,A=s.shape[a],o=new Array(i-1);let l=0;for(let e=0;e<i;e++)e!==a&&(o[l++]=s.shape[e]);const u=new Array(i).fill(0),c=s.shape.slice();c[a]=1;const d=new Array(A);for(let e=0;e<d.length;e++){u[a]=e;const t=XQ({inputs:{x:s},backend:n,attrs:{begin:u,size:c}});d[e]=Qz({inputs:{x:t},backend:n,attrs:{shape:o}}),n.disposeIntermediateTensorInfo(t)}return d}};const BW={kernelName:kb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;qF(s,"unsortedSegmentSum");const A=[],o=[],l=s.shape.length-a.shape.length;let u=a;for(let e=0;e<l;++e){const t=oR({inputs:{input:u},backend:n,attrs:{dim:e+1}});u=t,o.push(t)}for(let e=0;e<i;++e){const t=sC(e,"int32"),r=n.makeTensorInfo([],"int32",t),a=TP({inputs:{a:r,b:u},backend:n}),i=uP({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),l=mQ({inputs:{a:i,b:s},backend:n}),c=qO({inputs:{x:l},backend:n,attrs:{axis:0,keepDims:!1}});A.push(c),o.push(r),o.push(a),o.push(i),o.push(l),o.push(c)}const c=pL({inputs:A,backend:n,attrs:{axis:0}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},MW=[Lz,eP,_z,Hz,mP,Uz,jz,Yz,Kz,Xz,Zz,$z,tO,sO,iO,uO,cO,dO,hO,Rz,fO,gO,pO,wP,mO,cP,BP,CO,rP,IO,yO,EO,BO,MO,DO,TO,SO,GO,PO,QO,zO,OO,RO,LO,_O,VO,HO,UO,jO,YO,KO,XO,JO,vz,$O,SP,AR,FP,lR,zP,pR,bR,CR,LP,VP,IR,wR,kR,xR,KP,ZP,iP,yR,kO,ER,MR,TR,Bz,eQ,rQ,SR,AQ,GR,QR,OR,WR,_R,VR,UR,cQ,jR,YR,KR,XR,qR,ZR,JR,fQ,$R,nL,aL,bQ,IQ,AL,lL,cL,xQ,dL,gL,mL,bL,wL,Tz,MQ,kL,xL,yL,vL,oP,dR,BL,Nz,Fz,zz,ML,DL,TL,SL,NL,GL,PL,VQ,QL,RL,LL,HL,YQ,jL,KL,qL,qQ,sL,$L,eW,tW,nW,rW,sW,aW,iW,nz,AW,az,Az,lW,uW,cW,dW,hW,mz,ZO,gW,{kernelName:gb,backendName:"cpu",kernelFunc:pW},mW,bW,CW,IW,EQ,vW,EW,BW,fL];for(const e of MW)Pb(e);const DW={},TW={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function SW(e,t){if(!(e in DW)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(gg().getBool("IS_SAFARI")||"undefined"==typeof OffscreenCanvas||2!==e){if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete DW[e]}),!1),gg().getBool("SOFTWARE_WEBGL_ENABLED")&&(TW.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",TW)||n.getContext("experimental-webgl",TW);return n.getContext("webgl2",TW)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;DW[e]=n}const n=DW[e];return null==n||n.isContextLost()?(delete DW[e],SW(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),DW[e])}var NW,GW,FW;function PW(e,t){return[t,e]}function QW(e){const t=Of(e);return Wf(Math.ceil(t/4))}function zW(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function OW(e,t){const n=e;let r,s,a,i,A,o,l,u,c,d;return 2===gg().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,A=n.RED,l=4,u=1,c=n.HALF_FLOAT,d=n.FLOAT,o=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,A=e.RGBA,l=4,u=4,c=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,o=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:A,downloadTextureFormat:o,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:c,textureTypeFloat:d}}function RW(e,t){const n=t();return gg().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(NW||(NW={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(GW||(GW={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(FW||(FW={}));function LW(e){return!!(gg().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function WW(e,t){return qW(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const _W=/ERROR: [0-9]+:([0-9]+):/g;function VW(e,t){const n=_W.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],s=e.split("\n"),a=s.length.toString().length+2,i=s.map(((e,t)=>_f((t+1).toString(),a)+e));let A=0;for(let e=0;e<i.length;e++)A=Math.max(i[e].length,A);const o=i.slice(0,r-1),l=i.slice(r-1,r),u=i.slice(r);console.log(o.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${_f(l[0],A)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function HW(e,t){if(RW(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function UW(e,t,n,r,s,a,i){const A=e.getAttribLocation(t,n);return-1!==A&&(RW(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),RW(e,(()=>e.vertexAttribPointer(A,s,e.FLOAT,!1,a,i))),RW(e,(()=>e.enableVertexAttribArray(A))),!0)}function jW(e,t,n){!function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}(e,n),RW(e,(()=>e.activeTexture(e.TEXTURE0+n))),RW(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function YW(e,t,n){RW(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),RW(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function KW(e,t){RW(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),RW(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function XW(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function qW(e,t,n){const r=RW(e,(()=>t()));if(null==r)throw new Error(n);return r}function ZW(e,t=2){return Of(e.slice(0,e.length-t))}function JW(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function $W(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[ZW(e),...JW(e)]),t}function e_(e){return e%2==0}function t_(e,t){if(Rf(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(e_(n)&&e_(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&e_(e[0])&&e_(t[0])}let n_,r_;function s_(e,t){return null!=e.getExtension(t)}function a_(e){try{if(null!=SW(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function i_(e){if(0===e)return!1;const t=SW(e);if(1!==e){if(s_(t,"EXT_color_buffer_float"))return A_(t);const e="EXT_color_buffer_half_float";if(s_(t,e)){const n=t.getExtension(e);return function(e,t){const n=OW(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const s=1,a=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,a,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const A=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),A}(t,n)}return!1}if(!s_(t,"OES_texture_float"))return!1;if(!s_(t,"WEBGL_color_buffer_float"))return!1;return A_(t)}function A_(e){const t=OW(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function o_(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Pf("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const l_=gg();function u_(){let e,t,n,r,s,a,i,A,o,l;return 2===gg().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",A=gg().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",o="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",A="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",o="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:A,defineSpecialInf:o,defineRound:l}}function c_(e,t,n="index"){const r=ng(t);return r.map(((t,s)=>`${`int ${e[s]} = ${n} / ${t}`}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`)).join("")}function d_(e,t,n="index"){const r=ng(t);return r.map(((t,s)=>`${`int ${e[s]} = ${n} / outShapeStrides[${s}]`}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`};`)).join("")}function h_(e,t,n="index"){const r=e.map(((e,t)=>t)),s=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),s=new Array(n-1);s[n-2]=r[n-1];for(let e=n-3;e>=0;--e)s[e]=`(${s[e+1]} * ${r[e+1]})`;return s}(r,t);return s.map(((t,r)=>`${`int ${e[r]} = ${n} / ${s[r]}`}; ${r===s.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${s[r]}`:`index -= ${e[r]} * ${s[r]}`};`)).join("")}function f_(e){const t=ng(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}l_.registerFlag("HAS_WEBGL",(()=>l_.getNumber("WEBGL_VERSION")>0)),l_.registerFlag("WEBGL_VERSION",(()=>a_(2)?2:a_(1)?1:0)),l_.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),l_.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===l_.get("WEBGL_VERSION"))),l_.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),l_.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),l_.registerFlag("WEBGL_PACK",(()=>l_.getBool("HAS_WEBGL"))),l_.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>l_.getBool("WEBGL_PACK"))),l_.registerFlag("WEBGL_PACK_CLIP",(()=>l_.getBool("WEBGL_PACK"))),l_.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>l_.getBool("WEBGL_PACK"))),l_.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>l_.getBool("WEBGL_PACK"))),l_.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>l_.getBool("WEBGL_PACK"))),l_.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>l_.getBool("WEBGL_PACK"))),l_.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>l_.getBool("WEBGL_PACK"))),l_.registerFlag("WEBGL_PACK_REDUCE",(()=>l_.getBool("WEBGL_PACK"))),l_.registerFlag("WEBGL_LAZILY_UNPACK",(()=>l_.getBool("WEBGL_PACK"))),l_.registerFlag("WEBGL_CONV_IM2COL",(()=>l_.getBool("WEBGL_PACK"))),l_.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>l_.getBool("WEBGL_PACK"))),l_.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==n_){const t=SW(e);n_=t.getParameter(t.MAX_TEXTURE_SIZE)}return n_}(l_.getNumber("WEBGL_VERSION")))),l_.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==r_){const t=SW(e);r_=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,r_)}(l_.getNumber("WEBGL_VERSION")))),l_.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=l_.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=SW(e);return t=s_(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:s_(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),l_.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>l_.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!HC())),l_.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=SW(e);if(1===e){if(!s_(t,"OES_texture_float"))return!1}else if(!s_(t,"EXT_color_buffer_float"))return!1;return A_(t)}(l_.getNumber("WEBGL_VERSION")))),l_.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!l_.getBool("WEBGL_FORCE_F16_TEXTURES")&&l_.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),l_.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>i_(l_.getNumber("WEBGL_VERSION")))),l_.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=l_.getNumber("WEBGL_VERSION"))&&null!=SW(e).fenceSync;var e})),l_.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>l_.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),l_.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),l_.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>HC()?1:-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),l_.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),l_.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),l_.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),l_.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),l_.registerFlag("WEBGL_EXP_CONV",(()=>!1)),l_.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>l_.getBool("IS_TEST"))),l_.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),l_.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),l_.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),l_.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const g_="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:p_}=gB;function m_(e,t,n){const r=[];if(e.forEach((e=>{const t=Of(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=M_(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const s=r.join("\n"),a=e.map((e=>function(e,t,n=!1,r){let s="";s+=n?C_(e,r):b_(e,r);const a=e.shapeInfo.logicalShape,i=t.logicalShape;a.length<=i.length&&(s+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,A=p_(e.shapeInfo.logicalShape,t.logicalShape),o=B_(i),l=i-a;let u;const c=["x","y","z","w","u","v"];u=0===a?"":i<2&&A.length>=1?"coords = 0;":A.map((e=>`coords.${c[e+l]} = 0;`)).join("\n");let d="";d=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${c[t+l]}`)).join(", ");let h="return outputValue;";const f=1===Of(e.shapeInfo.logicalShape),g=Of(t.logicalShape),p=1===g;if(1!==a||f||p){if(f&&!p)h=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(A.length){const e=a-2,t=a-1;A.indexOf(e)>-1&&A.indexOf(t)>-1?h="return vec4(outputValue.x);":A.indexOf(e)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":A.indexOf(t)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}}else h="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${o} coords = getOutputCoords();\n      ${u}\n      vec4 outputValue = get${r}(${d});\n      ${h}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,A=e.shapeInfo.logicalShape.length,o=t.logicalShape.length;if(!e.shapeInfo.isUniform&&A===o&&null==e.shapeInfo.flatOffset&&Rf(i,a))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=B_(o),u=p_(e.shapeInfo.logicalShape,t.logicalShape),c=o-A;let d;const h=["x","y","z","w","u","v"];d=0===A?"":o<2&&u.length>=1?"coords = 0;":u.map((e=>`coords.${h[e+c]} = 0;`)).join("\n");let f="";f=o<2&&A>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+c]}`)).join(", ");return`\n    float ${s}() {\n      ${l} coords = getOutputCoords();\n      ${d}\n      return get${r}(${f});\n    }\n  `}(e,t));return s}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),i=t.texShape,A=u_(),o=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(A);let l,u,c=function(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${I_}\n    ${w_}\n    ${k_}\n  `;return t}(A);t.isPacked?(l=function(e,t,n){switch(e.length){case 0:return y_();case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `;if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Rf(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2);let i=a,A="",o="b, r, c";for(let t=2;t<e.length-1;t++)i*=e[e.length-t-1],A=`\n      int b${t} = index / ${i};\n      index -= b${t} * ${i};\n    `+A,o=`b${t}, `+o;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${A}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${e.length}(${o});\n    }\n  `}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),u=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(A)):(l=function(e,t,n){switch(e.length){case 0:return y_();case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){if(Rf(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${d_(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const r=c_(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${d_(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=c_(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=c_(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=c_(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,n.enableShapeUniforms),u=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(A)),n.packedInputs&&(c+=x_);return[c,o,u,s,l,a,n.userCode].join("\n")}function b_(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=e.shapeInfo.texShape;if(1===s&&1===a)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=v_(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[A,o]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${A}, ${o}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${E_(e)}\n      }\n    `;const s=e.shapeInfo.texShape,a=s[0],i=s[1];if(1===i&&1===a)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const A=v_(n);if(1===i)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${A}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${A}) + 0.5) / ${a}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===a)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${A}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${A}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(t)return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${A});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${i}, index + ${A});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(null!=a&&Rf(n,a)){if(t)return`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=a[0];return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${a[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:i,keptDims:A}=jf(n),o=i;if(o.length<n.length){const n=["row","col"];return`\n      ${b_(D_(e,o),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${T_(n,A)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${E_(e)}\n      }\n    `;const l=a[0],u=a[1],c=v_(r);if(1===u)return t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${c}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===l)return t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${c}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(t)return`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${c};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `;return`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${c};\n    vec2 uv = uvFromFlat(${l}, ${u}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:A,keptDims:o}=jf(n),l=A;if(l.length<n.length){const n=["row","col","depth"];return`\n        ${b_(D_(e,l),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${T_(n,o)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${i}, 1)));\n        ${E_(e)}\n      }\n    `;const u=e.shapeInfo.texShape,c=u[0],d=u[1],h=e.shapeInfo.flatOffset;if(d===a&&null==h)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${c}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(d===i&&null==h)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=v_(r);if(t)return`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `;return`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${c}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,A=n[1]*i,{newShape:o,keptDims:l}=jf(n);if(o.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${b_(D_(e,o),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${T_(n,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${A}, ${i}, ${a}, 1)));\n        ${E_(e)}\n      }\n    `;const u=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,d=c[0],h=c[1],f=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,p=`int stride0 = ${r}Shape[1] * stride1;`;if(h===A&&null==u)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${g}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(h===a&&null==u)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const m=v_(r);if(t)return`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${g}\n      ${p}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${m});\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${A} + col * ${i} +\n          depth * ${a} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${h}, index + ${m});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,A=t[1]*i,{newShape:o,keptDims:l}=jf(t);if(o.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${b_(D_(e,o))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${T_(t,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${A}, ${i}, ${a}, ${s})) +\n          depth3;\n        ${E_(e)}\n      }\n    `;const u=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,d=c[0],h=c[1];if(h===A&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(h===s&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=v_(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${A} + col * ${i} + depth * ${a} +\n          depth2 * ${s} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${d}, ${h}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=jf(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${b_(D_(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${T_(t,a)});\n      }\n    `}const i=t[5],A=t[4]*i,o=t[3]*A,l=t[2]*o,u=t[1]*l;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${l}, ${o}, ${A})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${E_(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],f=d[1];if(f===u&&null==c)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${o}, ${A}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==c)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const g=v_(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${l} + depth * ${o} +\n          depth2 * ${A} + depth3 * ${i} + depth4 + ${g};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function C_(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=u_();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=u_();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],A=a[1],o=u_();if(null!=a&&Rf(n,a))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${o.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${A}.0, ${i}.0);\n\n        return ${o.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=Math.ceil(n[1]/2);return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${u}, ${l[0]}, ${l[1]}, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===n[0]){const r=[1,2],a=["b","row","col"];return`\n        ${C_(D_(e,n.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${T_(a,r)});\n        }\n      `}const A=u_();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${A.texture2D}(${r}, uv);\n    }\n  `;const o=i[0],l=i[1],u=Math.ceil(n[2]/2),c=u*Math.ceil(n[1]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${o}, ${l}, ${c}, ${u}, b, row, col);\n      return ${A.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=u_();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);\n    }\n  `;const a=e.shapeInfo.logicalShape,i=a.length,A=e.shapeInfo.texShape,o=[Math.ceil(A[0]/2),Math.ceil(A[1]/2)],l=o[0],u=o[1],c=Math.ceil(a[i-1]/2);let d=c*Math.ceil(a[i-2]/2),h="int b, int row, int col",f=`b * ${d} + (row / 2) * ${c} + (col / 2)`;for(let e=2;e<i-1;e++)h=`int b${e}, `+h,d*=a[i-e-1],f=`b${e} * ${d} + `+f;return`\n    vec4 ${r}(${h}) {\n      int index = ${f};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${l});\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const I_="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",w_="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",k_="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",x_="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function y_(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function v_(e){return`offset${e}`}function E_(e){const t=e.name,n=Of(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function B_(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function M_(e,t,n){const{newShape:r,keptDims:s}=jf(t),a=t.length,i=e&&3===a&&1===t[0],A=i?t.slice(1):r,o=!e&&a>1&&!Rf(t,n)&&r.length<a||i;return{useSqueezeShape:o,uniformShape:o?A:t,keptDims:s}}function D_(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function T_(e,t){return t.map((t=>e[t])).join(", ")}function S_(e,t,n,r){const s=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),a=s.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},A=m_(s,i,t),o=function(e,t){const n=qW(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(RW(e,(()=>e.shaderSource(n,t))),RW(e,(()=>e.compileShader(n))),gg().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw VW(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,A),l=e.createProgram(o);return gg().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:o,source:A,webGLProgram:l,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(l),Object.assign({program:t,fragmentShader:o,source:A,webGLProgram:l,inShapeInfos:a,outShapeInfo:i},N_(e,t,l)))}function N_(e,t,n){const r=[],s=[];let a,i,A,o=null,l=null;l=e.getUniformLocation(n,"NAN",!1),1===gg().getNumber("WEBGL_VERSION")&&(o=e.getUniformLocation(n,"INFINITY",!1));const u=!1;for(const s of t.variableNames){const a={name:s,uniform:e.getUniformLocation(n,s,u),offset:e.getUniformLocation(n,`offset${s}`,u)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,`${s}Shape`,u),a.texShape=e.getUniformLocation(n,`${s}TexShape`,u)),r.push(a)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",u),A=e.getUniformLocation(n,"outShapeStrides",u),i=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(const r of t.customUniforms)s.push(e.getUniformLocation(n,r.name,u));return{variablesLocations:r,customUniformLocations:s,infLoc:o,nanLoc:l,outShapeLocation:a,outShapeStridesLocation:A,outTexShapeLocation:i}}function G_(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,s=t[n],a=s.shape;if(!Rf(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,A=s.isUniform?null:s.texData.texShape;if(!Rf(i,A))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${A} must match`)}))}function F_(e){return gg().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class P_{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=NW.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=u_();this.outputShape=e,this.enableShapeUniforms=F_(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?d_(["r","c","d"],e):c_(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class Q_{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=NW.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=u_();this.outputShape=e,this.enableShapeUniforms=F_(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?d_(["r","c","d"],e):c_(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class z_{constructor(e){this.variableNames=["A"],this.outTexUsage=GW.DOWNLOAD;const t=u_();this.outputShape=e,this.userCode=`\n      ${g_}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class O_{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=GW.DOWNLOAD;const t=u_();this.outputShape=e,this.userCode=`\n      ${g_}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const R_={R:0,G:1,B:2,A:3};class L_{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=u_();this.outputShape=e,this.enableShapeUniforms=F_(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let e=0;e<n.length;e++){const t=n[e];a+=`\n          if(offset == ${e}) {\n            result = values[${R_[t]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":f_(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${a}\n        }\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class W_{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=u_();this.outputShape=e,this.enableShapeUniforms=F_(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let s=0;s<=1;s++){const a=2*t+s;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${s} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${s};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":f_(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${s};\n        }\n    `}}function __(e){const t=u_();return function(e,t){const n=qW(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(RW(e,(()=>e.shaderSource(n,t))),RW(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function V_(e){return function(e,t){const n=qW(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return RW(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),RW(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function H_(e){return function(e,t){const n=qW(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return RW(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),RW(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function U_(e,t,n,r,s,a){!function(e,t){const n=gg().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return qW(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),A=e.TEXTURE_2D;return RW(e,(()=>e.bindTexture(A,i))),RW(e,(()=>e.texParameteri(A,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),RW(e,(()=>e.texParameteri(A,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),RW(e,(()=>e.texParameteri(A,e.TEXTURE_MIN_FILTER,e.NEAREST))),RW(e,(()=>e.texParameteri(A,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===gg().getNumber("WEBGL_VERSION")?RW(e,(()=>e.texImage2D(A,0,r,t,n,0,s,a,null))):RW(e,(()=>e.texStorage2D(A,1,r,t,n))),RW(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function j_(e){return e.internalFormatFloat}function Y_(e){return e.internalFormatHalfFloat}function K_(e){return e.downloadTextureFormat}function X_(e){return e.internalFormatPackedFloat}function q_(e){return e.internalFormatPackedHalfFloat}function Z_(e,t,n,r,s,a,i,A){const o=e,l=new Float32Array(function(e,t){const[n,r]=zW(e,t);return n*r*4}(a,i));return o.bindBuffer(o.PIXEL_PACK_BUFFER,t),o.getBufferSubData(o.PIXEL_PACK_BUFFER,0,l),o.bindBuffer(o.PIXEL_PACK_BUFFER,null),l}class J_{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=gg().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){DW[e]=t}(t,e)):this.gl=SW(t),e=this.gl,2===gg().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>RW(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>RW(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>RW(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>RW(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>RW(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>RW(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>RW(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>RW(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===gg().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=WW(this.gl,e),s_(this.gl,t))this.textureHalfFloatExtension=WW(this.gl,t);else if(gg().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),s_(this.gl,r))this.colorBufferHalfFloatExtension=WW(this.gl,r);else if(gg().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",s_(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!s_(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=V_(this.gl),this.indexBuffer=H_(this.gl),this.framebuffer=function(e){return qW(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=OW(this.gl,this.textureHalfFloatExtension)}get debug(){return gg().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;RW(e,(()=>e.finish())),RW(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),RW(e,(()=>e.deleteFramebuffer(this.framebuffer))),RW(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),RW(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),RW(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=PW(t,n);return U_(e,s,a,j_(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=PW(t,n);return U_(e,s,a,Y_(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=PW(t,n);return U_(e,s,a,K_(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){RW(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===gg().getNumber("WEBGL_VERSION")?RW(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):RW(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===gg().getNumber("WEBGL_VERSION")?RW(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):RW(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),RW(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,s,a){let i,A,o;RW(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),s instanceof Uint8Array?(i=new Uint8Array(n*r*4),A=e.UNSIGNED_BYTE,o=e.RGBA):(i=new Float32Array(n*r*4),A=e.FLOAT,o=a.internalFormatPackedFloat),i.set(s),2===gg().getNumber("WEBGL_VERSION")?RW(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,A,i))):RW(e,(()=>e.texImage2D(e.TEXTURE_2D,0,o,n,r,0,e.RGBA,A,i))),RW(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=zW(t,n);return U_(e,s,a,q_(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=zW(t,n);return U_(e,s,a,X_(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(KW(this.gl,this.framebuffer),this.outputTexture=null),RW(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[s,a]=PW(t,n),i=new Uint8Array(t*n*4);return RW(e,(()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return Z_(this.gl,e,0,0,0,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n){const r=e.createBuffer();RW(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const s=16*t*n;return RW(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),RW(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),RW(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(gg().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else gg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,gg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return RW(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=__(t));const n=function(e){return qW(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);RW(t,(()=>t.attachShader(n,this.vertexShader))),RW(t,(()=>t.attachShader(n,e))),function(e,t){if(RW(e,(()=>e.linkProgram(t))),!gg().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&HW(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;RW(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){RW(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),UW(e,t,"clipSpacePos",n,3,20,0)&&UW(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(RW(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&HW(this.gl,this.program),RW(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return qW(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),RW(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(e,t,n,r){RW(e,(()=>jW(e,t,r))),RW(e,(()=>e.uniform1i(n,r)))}(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=zW(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&HW(this.gl,this.program),XW(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}RW(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),RW(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=WW(this.gl,2===gg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===gg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===gg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Vf((()=>this.disposed||this.isQueryAvailable(e,gg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,gg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in gg().platform&&(n=gg().platform.setTimeoutCustom.bind(gg().platform)),Vf((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),YW(this.gl,e,this.framebuffer),this.debug&&XW(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(YW(this.gl,this.outputTexture,this.framebuffer),this.debug&&XW(this.gl)):KW(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;YW(r,e,this.framebuffer),this.debug&&XW(r),this.outputTexture=e,RW(r,(()=>r.viewport(0,0,t,n))),RW(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),RW(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:$_,bincountImpl:eV,bincountReduceImpl:tV,bitwiseAndImpl:nV,castImpl:rV,ceilImpl:sV,concatImpl:aV,equalImpl:iV,expImpl:AV,expm1Impl:oV,floorImpl:lV,gatherNdImpl:uV,gatherV2Impl:cV,greaterImpl:dV,greaterEqualImpl:hV,lessImpl:fV,lessEqualImpl:gV,linSpaceImpl:pV,logImpl:mV,maxImpl:bV,maximumImpl:CV,minimumImpl:IV,multiplyImpl:wV,negImpl:kV,notEqualImpl:xV,prodImpl:yV,raggedGatherImpl:vV,raggedRangeImpl:EV,raggedTensorToTensorImpl:BV,rangeImpl:MV,rsqrtImpl:DV,scatterImpl:TV,sigmoidImpl:SV,simpleAbsImpl:NV,sliceImpl:GV,sparseFillEmptyRowsImpl:FV,sparseReshapeImpl:PV,sparseSegmentReductionImpl:QV,sqrtImpl:zV,staticRegexReplaceImpl:OV,stridedSliceImpl:RV,stringNGramsImpl:LV,stringSplitImpl:WV,stringToHashBucketFastImpl:_V,subImpl:VV,tileImpl:HV,topKImpl:UV,transposeImpl:jV,uniqueImpl:YV}=xz;function KV(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function XV(e,t){return 1===t?[e]:KV(e,t)}class qV{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=F_(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=XV("rc",this.rank),t=B_(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),s=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)s=`${e[e.length-1-t]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class ZV{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=F_(this.outputShape.length);let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var r,s;this.userCode=`\n      ${r=t,s=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${s?h_(["r","c","d"],"inputShape"):c_(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":f_(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class JV{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=eH(t,n),s=tH(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=$V(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[s].pop();return this.usedTextures[s].push(e),e}let i;return r===FW.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===FW.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===FW.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===FW.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===FW.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=eH(n,r),a=tH(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=$V(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),A=gg().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==A&&this._numBytesAllocated>A?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const o=this.usedTextures[a],l=o&&o.indexOf(e);if(null==l||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");o[l]=o[o.length-1],o.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function $V(e,t,n,r,s){const a=function(e,t){switch(e){case FW.PACKED_2X2_FLOAT32:return X_(t);case FW.PACKED_2X2_FLOAT16:return q_(t);case FW.UNPACKED_FLOAT32:return j_(t);case FW.UNPACKED_FLOAT16:return Y_(t);case FW.PACKED_4X1_UNSIGNED_BYTE:return K_(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(s){const[t,n]=zW(e[0],e[1]);i=t*n}else{const[t,n]=PW(e[0],e[1]);i=t*n}const A=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,a);return i*A}function eH(e,t){if(e===GW.UPLOAD)return FW.PACKED_2X2_FLOAT32;if(e===GW.RENDER||null==e)return function(e){return gg().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?FW.PACKED_2X2_FLOAT32:FW.UNPACKED_FLOAT32:e?FW.PACKED_2X2_FLOAT16:FW.UNPACKED_FLOAT16}(t);if(e===GW.DOWNLOAD||e===GW.PIXELS)return FW.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function tH(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class nH{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=F_(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const rH="if (isnan(x)) return x;",sH="return abs(x);",aH=rH+"\n  return (x < 0.0) ? 0.0 : x;\n",iH=rH+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",AH="return x;";class oH{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=F_(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class lH{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=F_(this.outputShape.length);const t=e.length,n=XV("rc",t),r=B_(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const uH=_y,cH={};const dH=gg().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class hH extends Df{nextDataId(){return hH.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!gg().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof J_)t=e;else{const n=SW(gg().getNumber("WEBGL_VERSION"),e);t=new J_(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=SW(gg().getNumber("WEBGL_VERSION"));t=new J_(e),this.binaryCache=((n=gg().getNumber("WEBGL_VERSION"))in cH||(cH[n]={}),cH[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new JV(this.gpgpu),this.numMBBeforeWarning=null==gg().global.screen?1024:gg().global.screen.height*gg().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Mf(this,rI())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,s,a){const i=this.makeTensorInfo(t,n),A=this.texData.get(i.dataId);A.isPacked=!1,A.texture={texture:e,texShape:[r,s]},A.texShape=[r,s];const o=$W(t),l=new L_(o,!1,a),u=this.runWebGLProgram(l,[i],n,[[r,s]]);return u.shape=t,A.texture=null,this.disposeIntermediateTensorInfo(i),u.dataId}write(e,t,n){if((gg().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||gg().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:GW.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,s){if(gg().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:GW.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:i,isPacked:A}=t;if(null!=a){let t;t=A?new oH(i,AH):new nH(i,AH);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const o=null!=this.activeTimers;let l,u;if(o&&(l=iC()),"complex64"===r){u=FE(this.readSync(s.real.dataId),this.readSync(s.imag.dataId))}else u=this.getValuesFromTexture(e);return o&&(this.downloadWaitMs+=iC()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:i,isPacked:A}=t;if(null!=s){let t;t=A?new oH(r,AH):new nH(r,AH);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:a}],a),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if(gg().getBool("DEBUG")&&!gg().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===gg().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let o,l,u=null;if("complex64"!==a&&gg().get("WEBGL_BUFFER_SUPPORTED")){o=this.decode(e);const t=this.texData.get(o.dataId);u=this.gpgpu.createBufferFromTexture(t.texture.texture,...QW(r))}if(this.pendingRead.set(e,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);l=FE(e[0],e[1])}else if(null==u)l=this.getValuesFromTexture(e);else{const e=Of(r);l=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=o&&this.disposeIntermediateTensorInfo(o),null!=u){const e=this.gpgpu.gl;RW(e,(()=>e.deleteBuffer(u)))}const c=this.convertAndCacheOnCPU(e,l),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach((e=>e(c))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&rI().removeDataId(e,this),this.pendingDeletes--),c}readToGPU(e,t={}){const n=this.texData.get(e),{values:r,shape:s,slice:a,dtype:i,isPacked:A,texture:o}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let n;n=A?new oH(s,AH):new nH(s,AH);const r=this.runWebGLProgram(n,[{dataId:e,shape:s,dtype:i}],i),a=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),a}if(null==o)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),u=rI().makeTensorFromTensorInfo(l),c=this.texData.get(l.dataId);return Object.assign({tensorRef:u},c.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>oC(e)));return WI(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return WI(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!LW(n)){if(gg().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=Of(t);if(gg().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...QW(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),a}const a=gg().getBool("WEBGL_PACK")&&!0===r,i=a?$W(t):t,A=a?new O_(i):new z_(i),o=this.runWebGLProgram(A,[{shape:i,dtype:n,dataId:e}],"float32"),l=this.texData.get(o.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(o),u}timerAvailable(){return gg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=uC(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=uC(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(gg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);i.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return gg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:iC(),endMs:null}}endTimer(e){return gg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=iC(),e)}async getQueryTime(e){if(gg().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:i}=this.texData.get(e),A=i&&i.origDataId||e,o=this.dataRefCount.get(A);o>1?this.dataRefCount.set(A,o-1):(this.dataRefCount.delete(A),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=dH){return gg().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Of(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){Db("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return uH(e.shape,t)}packedUnaryOp(e,t,n){const r=new oH(e.shape,t),s=this.compileAndRun(r,[e],n);return rI().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=NV(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(gg().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,sH,e.dtype);const t=new nH(e.shape,sH),n=this.compileAndRun(t,[e]);return rI().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Zf(n[0])){const s=n.map((e=>AC(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return rI().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new lH(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new qV(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[ZW(e.shape),...JW(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[ZW(t),...JW(t)],a=new ZV(s,n),i=[n],A=this.runWebGLProgram(a,[r],e.dtype,i,!0);return{dataId:A.dataId,shape:t,dtype:A.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:s,dtype:a}=n;if(null!=t){Pf(Of(s)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const i=$W(s);let A;A=r?new Q_(i):new P_(i);const o=[null!=t?t:QW(i)];return{dtype:a,shape:s,dataId:this.runWebGLProgram(A,[{shape:i,dtype:a,dataId:e}],a,o,!0,t).dataId}}runWebGLProgram(e,t,n,r,s=!1,a){const i=this.makeTensorInfo(e.outputShape,n),A=this.texData.get(i.dataId);if(e.packedOutput&&(A.isPacked=!0),e.outPackingScheme===NW.DENSE){const t=null!=a?a:QW(e.outputShape);A.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(A.usage=e.outTexUsage),0===Of(i.shape))return A.values=Yf(i.dtype,0),i;const o=[],l=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Of(t.shape)<=gg().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),o.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!t_(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),o.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);const u={shape:i.shape,texData:A,isUniform:!1},c=function(e,t,n){let r="";t.concat(n).forEach((t=>{const s=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const a=t.texData.texShape,{useSqueezeShape:i,uniformShape:A,keptDims:o}=M_(e.packedInputs,t.shape,a);let l="",u="",c="";if(1===A.length&&e.packedInputs){const e=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];l=`${e[0]>1}_${e[1]>1}`}else if(2!==A.length||e.packedInputs){if(A.length>2&&!e.packedInputs){const e=ng(A);c=`${e[0]===a[1]}_${e[e.length-1]===a[1]}`}}else u=`${A[0]>1}_${A[1]>1}`;const d=t.shape.length,h=2===A.length&&Rf(t.shape,a),f=1===Of(t.shape),g=ak(t.shape,n.shape),p=!e.packedInputs&&d===n.shape.length&&Rf(a,n.texData.texShape),m=e.packedInputs||A.length>2?"":`${a[0]>1}_${a[1]>1}`;r+=`${d}_${p}_${i?o:""}_${A.length}_${f}_${g}_${h}_${l}_${u}_${c}_${m}_${s}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${s}`}}));const s=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+s+`${gg().getNumber("WEBGL_VERSION")}`,a}(e,l,u),d=this.getAndSaveBinary(c,(()=>S_(this.gpgpu,e,l,u))),h=null!=this.activeTimers;let f;h&&(f=this.startTimer()),gg().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,s){t.program.enableShapeUniforms||(G_(t.inShapeInfos,n),G_([t.outShapeInfo],[r]));const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===gg().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let r=0;r<n.length;++r){const s=n[r],{uniform:a,offset:i,shape:A,texShape:o}=t.variablesLocations[r];if(A){const{uniformShape:n}=M_(t.program.packedInputs,s.shape,s.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(A,new Int32Array(n));break;case 2:e.gl.uniform2iv(A,new Int32Array(n));break;case 3:e.gl.uniform3iv(A,new Int32Array(n));break;case 4:e.gl.uniform4iv(A,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,s.texData.texShape[0],s.texData.texShape[1]),null!=a)if(s.isUniform)if(Of(s.shape)<2)e.gl.uniform1f(a,s.uniformValues[0]);else{let t=s.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=s.texData.slice&&null!=i&&e.gl.uniform1i(i,s.texData.slice.flatOffset),e.setInputMatrixTexture(s.texData.texture.texture,a,r)}const A=t.outShapeLocation;if(A)switch(r.shape.length){case 1:e.gl.uniform1iv(A,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(A,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(A,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(A,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=ng(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let n=0;n<t.program.customUniforms.length;++n){const r=t.program.customUniforms[n],a=t.customUniformLocations[n],i=s[n];if("float"===r.type)e.gl.uniform1fv(a,i);else if("vec2"===r.type)e.gl.uniform2fv(a,i);else if("vec3"===r.type)e.gl.uniform3fv(a,i);else if("vec4"===r.type)e.gl.uniform4fv(a,i);else if("int"===r.type)e.gl.uniform1iv(a,i);else if("ivec2"===r.type)e.gl.uniform2iv(a,i);else if("ivec3"===r.type)e.gl.uniform3iv(a,i);else{if("ivec4"!==r.type)throw Error(`uniform type ${r.type} is not supported yet.`);e.gl.uniform4iv(a,i)}}e.executeProgram()}(this.gpgpu,d,l,u,r),o.forEach((e=>this.disposeIntermediateTensorInfo(e))),h&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const g=gg().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const e=iC();e-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!gg().getBool("WEBGL_LAZILY_UNPACK")&&A.isPacked&&!1===s){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r,s=!1){n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!gg().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=aI((()=>{if(!gg().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=gg().getBool("DEBUG");gg().set("DEBUG",!1);const t=this.abs(Bk(1e-8)).dataSync()[0];if(gg().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:i,isPacked:A}=t;if(null!=a)return;const o=null!=this.activeTimers;let l;o&&(l=iC());let u=t.texShape;if(null==u&&(u=function(e,t=!1){let n=gg().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=gg().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&gg().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,e=e.map(((t,n)=>n>=e.length-2?Gf(e[n]):e[n])),1===e.length&&(e=[2,e[0]])),2!==e.length){const t=jf(e);e=t.newShape}let s=Of(e),a=null;e.length<=1&&s<=n?a=[1,s]:2===e.length&&e[0]<=n&&e[1]<=n?a=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);const i=null!=a&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(null==a||i)if(t){const t=ZW(e);let n=2,r=2;e.length&&([n,r]=JW(e)),s=t*(n/2)*(r/2),a=Wf(s).map((e=>2*e))}else a=Wf(s);return a}(n,A),t.texShape=u),null!=s){const e=$W(n);let a,i=u[1],c=u[0];const d=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!A&&d||([i,c]=zW(u[0],u[1])),a=A?new W_(e,d):new L_(e,d);const h=d?[c,i]:u,f=this.makeTensorInfo(h,r),g=this.texData.get(f.dataId);g.usage=d?GW.PIXELS:GW.UPLOAD,g.texShape=h,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,c,s);const p=[[c,i]],m=!0,b=this.runWebGLProgram(a,[f],r,p,m),C=this.texData.get(b.dataId);t.texShape=C.texShape,t.isPacked=C.isPacked,t.usage=C.usage,gg().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=C.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),o&&(this.uploadWaitMs+=iC()-l)}else{const e=this.acquireTexture(u,i,r,A);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*qf(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await cE(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw VW(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:A}=N_(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=i,e.outTexShapeLocation=A}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:s,width:a,channels:i}=e,A=rI().backend;if(!A.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const o=A.writeTexture(r,t,n,s,a,i);return rI().makeTensorFromDataId(o,t,n,A)}}hH.nextDataId=0,UC()&&oI("webgl",(()=>new hH),2);const fH="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class gH{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Ak(t,n),this.enableShapeUniforms=F_(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const pH="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class mH{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ak(t,n);const s=this.outputShape.length;this.enableShapeUniforms=F_(s);let a="";if(r)if(0===s||1===Of(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(a=`\n          ${B_(s)} coords = getOutputCoords();\n        `,1===s)this.enableShapeUniforms?a+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=XV("coords",s);this.enableShapeUniforms?a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function bH(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const CH={kernelName:Fp,backendName:"webgl",kernelFunc:bH};function IH(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),A=bH({inputs:{x:r},backend:n}),o=bH({inputs:{x:s},backend:n});return i.complexTensorInfos={real:A,imag:o},a}const wH={kernelName:jg,backendName:"webgl",kernelFunc:IH},kH="return (a < 0.) ? b * a : a;",xH="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const yH={kernelName:Lp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",sC(a,"float32")),A=gg().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mH(xH,s.shape,i.shape):new gH(kH,s.shape,i.shape),o=n.runWebGLProgram(A,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),o}},vH="return (a < 0.) ? b * a : a;",EH="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const BH={kernelName:wm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=gg().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mH(EH,r.shape,s.shape):new gH(vH,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}},MH="if (isnan(x)) return x;";function DH({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{const{x:i}=s,A=a,o=r||i.dtype;if(A.shouldExecuteOnCPU([i])&&null!=n){const e=A.texData.get(i.dataId),t=n(e.values,o);return A.makeTensorInfo(i.shape,o,t)}let l;return l=gg().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new oH(i.shape,t):new nH(i.shape,e),A.runWebGLProgram(l,[i],o)}}function TH({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:A})=>{const{a:o,b:l}=i,u=A;if(r&&"complex64"===o.dtype){const t=u.texData.get(o.dataId),n=u.texData.get(l.dataId),[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,s={dataId:n.dataId,dtype:n.dtype,shape:o.shape},a={dataId:r.dataId,dtype:r.dtype,shape:l.shape},i=new gH(e,o.shape,l.shape);return u.runWebGLProgram(i,[s,a],SC(n.dtype,r.dtype))})),a=IH({inputs:{real:r,imag:s},backend:u});return u.disposeIntermediateTensorInfo(r),u.disposeIntermediateTensorInfo(s),a}const c=a||SC(o.dtype,l.dtype);if(("string"===o.dtype||"string"===l.dtype||u.shouldExecuteOnCPU([o,l]))&&null!=s){const e=u.texData.get(o.dataId).values,t=u.texData.get(l.dataId).values,n="string"===o.dtype?hB(e):e,r="string"===o.dtype?hB(t):t,[a,i]=s(o.shape,l.shape,n,r,c),A=u.makeTensorInfo(i,c);return u.texData.get(A.dataId).values=a,A}let d;return d=gg().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new mH(t,o.shape,l.shape,n):new gH(e,o.shape,l.shape),u.runWebGLProgram(d,[o,l],c)}}function SH(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":aH;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":iH;if("prelu"===e)return t?EH:vH;if("leakyrelu"===e)return t?xH:kH;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class NH{constructor(e,t,n,r=!1,s=!1,a=!1,i=null,A=!1,o=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=F_(this.outputShape.length);const l=r?e[1]:e[2],u=Math.ceil(l/2),c=r?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",p="";i&&(g=A?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,p="result = activation(result);");const m=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),A&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha");let b="rc.x",C="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(C=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${g}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${u}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${C};\n        for (int i = 0; i < ${u}; i++) {\n          vec4 a = getMatrixA(batchA, ${c});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${f[0]});\n          result += (${h[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${m}\n\n        ${p}\n\n        setOutput(result);\n      }\n    `}}const GH="return areal * breal - aimag * bimag;",FH="return areal * bimag + aimag * breal;";class PH{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ak(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const QH="return a * b;";function zH(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=SC(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),a=new PH(GH,r.shape,s.shape),i=new PH(FH,r.shape,s.shape),A=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],o=n.runWebGLProgram(a,A,"float32"),l=n.runWebGLProgram(i,A,"float32"),u=IH({inputs:{real:o,imag:l},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[i,A]=wV(r.shape,s.shape,e.values,t.values,a),o=n.makeTensorInfo(A,a);return n.texData.get(o.dataId).values=i,o}let i;return i=gg().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mH(QH,r.shape,s.shape):new gH(QH,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const OH={kernelName:um,backendName:"webgl",kernelFunc:zH};function RH(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,A=Of(s.shape),o=Hf(a,A),l=Of(o);Pf(A===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${A} elements. The new shape and old shape must have the same number of elements.`));const u=i.texData.get(s.dataId);return!u.isPacked||t_(s.shape,o)||null!==u.texture&&t_(u.shape,o)?(i.incRef(s.dataId),{dataId:s.dataId,shape:o,dtype:s.dtype}):function(e,t,n){const r=[ZW(e.shape),...JW(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[ZW(t),...JW(t)],i=new ZV(a,r),A=[r],o=n.runWebGLProgram(i,[s],e.dtype,A,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}(s,o,i)}const LH={kernelName:Tm,backendName:"webgl",kernelFunc:RH};class WH{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];const i=4*Math.floor(n/4),A=n%4;let o="sumValue += dot(values, ones);";if(null!=t){const e=1/t;o=`sumValue += dot(values * ${Lf(e)?e.toPrecision(2):e}, ones);`}let l="";s%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${o}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===A}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${o}\n        } else if (${2===A}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${o}\n        } else if (${3===A}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${o}\n        }\n        setOutput(sumValue);\n      }\n    `}}class _H{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",A="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",A="min"):"max"===t&&(i="-1.0 / 1e-20",A="max");let o=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?o="sumValue":"prod"===t?o="prodValue":"all"===t?o="allValue":"any"===t&&(o="anyValue");const l=4*Math.floor(n/4),u=n%4;let c=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${A}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${A}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===t?(i="1.0",c="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",c="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let h="";s%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${c}\n        } else if (${2===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${c}\n        } else if (${3===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${c}\n        }\n        setOutput(${o});\n      }\n    `}}function VH(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=CE(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:A,windowSize:o,outSize:l}=s[i];let u,c;u="mean"===n?0===i?new WH({windowSize:o,inSize:A,batchSize:e.shape[0],outSize:l},A):new WH({windowSize:o,inSize:A,batchSize:e.shape[0],outSize:l}):new _H({windowSize:o,inSize:A,batchSize:e.shape[0],outSize:l},n),c=a,a=r.runWebGLProgram(u,[a],t),c.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(c)}return a}class HH{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=B_(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class UH{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=B_(this.rank),s=KV("rc",this.rank),a=new Array(this.rank);for(let e=0;e<t.length;e++)a[t[e]]=s[e];const i=`vec2(${a.slice(-2).join()})`,A=`++${s[this.rank-1]} < ${n[this.rank-1]}`,o=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${o};\n      if(${A}) {\n        result[1] = ${o};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${o};\n        if(${A}) {\n          result[3] = ${o};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function jH(e,t,n){const r=gg().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new UH(e.shape,t):new HH(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function YH(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return function(e,t,n,r){const s=t,a=e.shape.length,i=Uf(s,e.shape);let A=i;const o=wk(A,a),l=null!=o;let u=e;l&&(u=jH(e,o,r),A=xk(A.length,a)),Ik("sum",A,a);const[c,d]=bk(u.shape,A);let h=c;n&&(h=Ck(c,i));const f=Of(d),g=RH({inputs:{x:u},attrs:{shape:[Of(e.shape)/f,f]},backend:r}),p=VH(g,NC(e.dtype),"sum",r),m=RH({inputs:{x:p},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(p),l&&r.disposeIntermediateTensorInfo(u),m}(s,a,i,n)}const KH={kernelName:Zm,backendName:"webgl",kernelFunc:YH};function XH(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,A=s.shape.length,o=new Array(A);for(let e=0;e<o.length;e++)o[e]=s.shape[a[e]];let l;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId).values,t=jV(e,s.shape,s.dtype,a,o);l=i.makeTensorInfo(o,s.dtype);i.texData.get(l.dataId).values=t}else l=jH(s,a,i);return l}const qH={kernelName:Cb,backendName:"webgl",kernelFunc:XH};function ZH({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:A=0,activation:o=null}){const l=e.shape.length,u=t.shape.length,c=n?e.shape[l-2]:e.shape[l-1],d=r?t.shape[u-1]:t.shape[u-2],h=n?e.shape[l-1]:e.shape[l-2],f=r?t.shape[u-2]:t.shape[u-1],g=e.shape.slice(0,-2),p=t.shape.slice(0,-2),m=Of(g),b=Of(p),C=Ak(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,f]);Pf(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));const I=n?[m,c,h]:[m,h,c],w=r?[b,f,d]:[b,d,f],k=RH({inputs:{x:e},backend:s,attrs:{shape:I}}),x=RH({inputs:{x:t},backend:s,attrs:{shape:w}}),y=[k,x],v=Math.max(m,b),E=n?k.shape[1]:k.shape[2],B=null!=a,M=null!=i,D="leakyrelu"===o,T=null!=o?SH(o,!0):null;let S;if((1===h||1===f)&&E>1e3&&!1===(B||M||D||null!=T)){let e=k,t=x;n&&(e=XH({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),y.push(e)),r&&(t=XH({inputs:{x:x},backend:s,attrs:{perm:[0,2,1]}}),y.push(t));const a=1===f;let i=e;1!==f&&(i=RH({inputs:{x:e},backend:s,attrs:{shape:[v,E,1]}}),y.push(i));const A=1===f?2:1;let o=t;a&&(o=RH({inputs:{x:t},backend:s,attrs:{shape:[v,1,E]}}),y.push(o));const l=zH({inputs:{a:i,b:o},backend:s});S=YH({inputs:{x:l},backend:s,attrs:{axis:A,keepDims:!0}}),y.push(l)}else{const o=SC(e.dtype,t.dtype),l=new NH(I,w,[v,h,f],n,r,B,T,M,D),u=[k,x];if(null!=a&&u.push(a),M&&u.push(i),D){const e=s.makeTensorInfo([],"float32",sC(A,"float32"));u.push(e),y.push(e)}S=s.runWebGLProgram(l,u,o)}const N=RH({inputs:{x:S},backend:s,attrs:{shape:C}});y.push(S);for(const e of y)s.disposeIntermediateTensorInfo(e);return N}const JH={kernelName:Eb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:A}=t,{transposeA:o,transposeB:l,activation:u,leakyreluAlpha:c}=r;return ZH({a:s,b:a,transposeA:o,transposeB:l,backend:n,bias:i,preluActivationWeights:A,leakyreluAlpha:c,activation:u})}},$H="return abs(x);";const eU={kernelName:Ig,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=NV(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=gg().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new oH(r.shape,$H):new nH(r.shape,$H),n.runWebGLProgram(s,[r],r.dtype)}},tU=DH({opSnippet:rH+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),nU={kernelName:wg,backendName:"webgl",kernelFunc:tU},rU=DH({opSnippet:rH+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),sU={kernelName:kg,backendName:"webgl",kernelFunc:rU},aU="return a + b;",iU=TH({opSnippet:aU,packedOpSnippet:aU,supportsComplex:!0,cpuKernelImpl:$_}),AU={kernelName:xg,backendName:"webgl",kernelFunc:iU};class oU{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class lU{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const uU={kernelName:yg,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,s=n;if(1===s.length)return bH({inputs:{x:s[0]},backend:r});if(s.length>gg().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:r}),a=e({inputs:s.slice(t),backend:r});return e({inputs:[n,a],backend:r})}const a=s.map((e=>e.dtype)).reduce(((e,t)=>SC(e,t))),i=s.map((e=>e.shape)),A=gg().getBool("WEBGL_PACK")?new lU(s[0].shape,i):new oU(s[0].shape,i);return r.runWebGLProgram(A,s,a)}};const cU={kernelName:vg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,A=s.shape.length,o=Uf(a,s.shape);let l=o;const u=wk(l,A);let c=s;null!=u&&(c=XH({inputs:{x:s},backend:n,attrs:{perm:u}}),l=xk(l.length,A)),Ik("all",l,A);const[d,h]=bk(c.shape,l),f=RH({inputs:{x:c},backend:n,attrs:{shape:[-1,Of(h)]}}),g=VH(f,f.dtype,"all",n);let p;if(i){p=RH({inputs:{x:g},backend:n,attrs:{shape:Ck(d,o)}})}else p=RH({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(c),p}};const dU={kernelName:Eg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,A=s.shape.length,o=Uf(a,s.shape);let l=o;const u=wk(l,A);let c=s;null!=u&&(c=XH({inputs:{x:s},backend:n,attrs:{perm:u}}),l=xk(l.length,A)),Ik("any",l,A);const[d,h]=bk(c.shape,l),f=RH({inputs:{x:c},backend:n,attrs:{shape:[-1,Of(h)]}}),g=VH(f,f.dtype,"any",n);let p;if(i){p=RH({inputs:{x:g},backend:n,attrs:{shape:Ck(d,o)}})}else p=RH({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(c),p}};class hU{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];const i="max"===t?">":"<",A=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${A};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class fU{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Pf(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,A=i.length,o=B_(A),l=XV("coords",A);let u,c;if(1===a){c=A+1;const e=B_(c);u=`\n        ${e} sourceLocR = ${e}(${l.join()}, 0);\n        ++${l[A-1]};\n        ${e} sourceLocG = ${e}(${l.join()}, 0);\n        ++${l[A-2]};\n        ${e} sourceLocA = ${e}(${l.join()}, 0);\n        --${l[A-1]};\n        ${e} sourceLocB = ${e}(${l.join()}, 0);\n        --${l[A-2]};`}else c=A,u=`\n        ${o} sourceLocR = coords;\n        ++${l[A-1]};\n        ${o} sourceLocG = coords;\n        ++${l[A-2]};\n        ${o} sourceLocA = coords;\n        --${l[A-1]};\n        ${o} sourceLocB = coords;\n        --${l[A-2]};`;const d=["x","y","z","w","u","v"].slice(0,c),h="."+d[c-1],f=d.map((e=>"int "+e)),g=XV("sourceLocR",c-1).concat("inIdx.r"),p=XV("sourceLocG",c-1).concat("inIdx.g"),m=XV("sourceLocB",c-1).concat("inIdx.b"),b=XV("sourceLocA",c-1).concat("inIdx.a"),C="max"===n?"greaterThan":"lessThan",I=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${p.join()}),\n                             getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${p.join()}) : 0.,\n            hasNextRow ? getAChannel(${m.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${o} coords = getOutputCoords();\n        bool hasNextCol = ${l[A-1]} < ${i[A-1]-1};\n        bool hasNextRow = ${l[A-2]} < ${i[A-2]-1};\n        ${u}\n        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},\n          sourceLocB${h}, sourceLocA${h}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${I}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${C}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function gU(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];null!=r&&(s=r.shape[0],a=r.shape[1]);const i=CE(a),A={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},o=new hU(A,n,null==r),l=[t];null!=r&&l.push(r);const u=e.runWebGLProgram(o,l,"int32");if(1===u.shape[1])return u;const c=gU(e,t,n,u);return e.disposeIntermediateTensorInfo(u),c}function pU(e,t,n,r=null){const s=null!=r?r.shape:t.shape,a=CE(s[s.length-1]),i=new fU(s,a,n,null==r),A=null==r?[t]:[t,r],o=e.runWebGLProgram(i,A,"int32");if(o.shape.length===t.shape.length){const r=pU(e,t,n,o);return e.disposeIntermediateTensorInfo(o),r}return o}function mU(e,t,n,r){const s=[n];if(Ik("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!gg().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],a=e.texData.get(t.dataId);let i=t;null!==a&&a.isPacked&&(i=e.unpackTensor(t),n.push(i));const[A,o]=bk(i.shape,s),l=Of(o),u=RH({inputs:{x:i},backend:e,attrs:{shape:[-1,l]}});n.push(u);const c=gU(e,u,r);n.push(c);const d=RH({inputs:{x:c},backend:e,attrs:{shape:A}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),d}return pU(e,t,r)}const bU={kernelName:Bg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Uf(a,s.shape);const A=wk(i,s.shape.length);let o=s;const l=[];null!=A&&(o=XH({inputs:{x:s},backend:n,attrs:{perm:A}}),l.push(o),i=xk(i.length,o.shape.length)),Ik("argMax",[i[0]],o.shape.length);const u=mU(n,o,i[0],"max");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};const CU={kernelName:Mg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Uf(a,s.shape);const A=wk(i,s.shape.length);let o=s;const l=[];null!=A&&(o=XH({inputs:{x:s},backend:n,attrs:{perm:A}}),l.push(o),i=xk(i.length,o.shape.length)),Ik("argMin",[i[0]],o.shape.length);const u=mU(n,o,i[0],"min");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},IU=DH({opSnippet:rH+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),wU={kernelName:Dg,backendName:"webgl",kernelFunc:IU},kU=DH({opSnippet:rH+"return log(x + sqrt(x * x + 1.0));"}),xU={kernelName:Tg,backendName:"webgl",kernelFunc:kU},yU=DH({opSnippet:rH+"\n  return atan(x);\n"}),vU={kernelName:Sg,backendName:"webgl",kernelFunc:yU},EU=TH({opSnippet:fH+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+pH+"\n  return result;\n"}),BU={kernelName:Gg,backendName:"webgl",kernelFunc:EU},MU=DH({opSnippet:rH+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),DU={kernelName:Ng,backendName:"webgl",kernelFunc:MU};class TU{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,A=e.strideWidth,o=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,p=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let m="0.0";if(f||(m="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${A});\n        const ivec2 pads = ivec2(${d}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${u};\n              wR += ${o}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${c};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?g:p:`wR * ${c} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");const C=4*Math.floor(a/4),I=a%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${A});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${u};\n            wR += ${o}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${C}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${C};\n          if (${1===I}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===I}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===I}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class SU{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,A=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,g=e.padInfo.front,p=e.padInfo.top,m=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let C="0.0";if(b||(C="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${A}, ${o});\n        const ivec3 pads = ivec3(${g}, ${p}, ${m});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${u}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${c}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let I=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(I="avgValue / max(count, 1.0)");const w=4*Math.floor(a/4),k=a%4,x=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${A}, ${o});\n      const ivec3 pads = ivec3(${g}, ${p}, ${m});\n      const float initializationValue = ${C};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${C});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${c};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${c}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${c}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${c}, ch)\n              );\n\n              ${x}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${x}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${c}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${x}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${c}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${c}, ch),\n                initializationValue\n              );\n\n              ${x}\n            }\n          }\n        }\n        setOutput(${I});\n      }\n    `}}const NU={kernelName:Fg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;o_(s,"avgPool");const{filterSize:a,strides:i,pad:A,dimRoundingMode:o}=r;Pf(bw(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const l=ow(s.shape,a,i,1,A,o);if(1===l.filterWidth&&1===l.filterHeight&&Rf(l.inShape,l.outShape))return bH({inputs:{x:s},backend:n});const u=new TU(l,"avg",!1);return n.runWebGLProgram(u,[s],"float32")}};const GU={kernelName:Qg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:A,dimRoundingMode:o,dataFormat:l}=r,u=lw(s.shape,a,i,[1,1,1],A,o,l),c=new SU(u,"avg",!1);return n.runWebGLProgram(c,[s],"float32")}};class FU{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,A=e.effectiveFilterHeight,o=e.effectiveFilterWidth,l=A-1-e.padInfo.top,u=o-1-e.padInfo.left,c=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${u});\n      const float avgMultiplier = float(${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${A};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class PU{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,A=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=u-1-e.padInfo.front,f=c-1-e.padInfo.top,g=d-1-e.padInfo.left,p=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${f}, ${g});\n      const float avgMultiplier = float(${p});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${u};\n            wD += ${A}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${o}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const QU={kernelName:zg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:A,strides:o,pad:l,dimRoundingMode:u}=r,c=lw(i.shape,A,o,[1,1,1],l,u),d=new PU(c);return n.runWebGLProgram(d,[s],i.dtype)}};const zU={kernelName:Pg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;o_([s,a],"avgPoolGrad");const{filterSize:A,strides:o,pad:l}=r,u=ow(i.shape,A,o,1,l),c=new FU(u);return n.runWebGLProgram(c,[s],i.dtype)}};const OU={kernelName:Og,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:A}=r;return ZH({a:s,b:a,transposeA:i,transposeB:A,backend:n})}};class RU{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Ak(e,t),Ak(e,n);let i="0.0";null!=r&&(Ak(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let A="1.0";null!=s&&(Ak(e,s),this.variableNames.push("scale"),A="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${A};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class LU{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ak(e,t),Ak(e,n);let i="vec4(0.0)";null!=r&&(Ak(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let A="vec4(1.0)";null!=s&&(Ak(e,s),this.variableNames.push("scale"),A="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${A};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const WU={kernelName:Dp,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:A}=e;Pf(s.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Pf(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Pf(null==A||s.shape.length===A.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:o}=n;null==o&&(o=.001);const l=[r,s,a];let u=null;null!=i&&(u=i.shape,l.push(i));let c=null;null!=A&&(c=A.shape,l.push(A));const d=gg().getBool("WEBGL_PACK_NORMALIZATION")?new LU(r.shape,s.shape,a.shape,u,c,o):new RU(r.shape,s.shape,a.shape,u,c,o);return t.runWebGLProgram(d,l,l[0].dtype)}};class _U{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=B_(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return VU.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;const s=e.map(((e,t)=>`sourceLoc.${VU[t]} = start[${t}] + coords.${VU[t]};`));r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${s.join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const VU=["x","y","z","w","u","v"];class HU{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=B_(this.rank),n=XV("coords",this.rank),r=XV("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,A=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,o=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${o}\n        vec4 result = vec4(0.);\n        ${i}\n        ${A}\n        setOutput(result);\n      }\n    `}}function UU(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[A,o]=aE(s,a,i);if(Yv(s,A,o),0===Of(o))return n.makeTensorInfo(o,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=GV(e.values,A,o,s.shape,s.dtype);return n.makeTensorInfo(o,s.dtype,t)}const{isPacked:l}=n.texData.get(s.dataId),u=rE(s.shape,A,o);if(l||!u){const e=gg().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new HU(o):new _U(o),t=[A];return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let A=sE(t,ng(e.shape));s.slice&&(A+=s.slice.flatOffset),i.slice={flatOffset:A,origDataId:s.slice&&s.slice.origDataId||e.dataId};const o=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,o+1),a}(s,A,o,n)}const jU={kernelName:Hm,backendName:"webgl",kernelFunc:UU},YU={kernelName:Rg,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;Pf(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const A=a.reduce(((e,t)=>e*t)),o=wE(s.shape,a,A),l=kE(o.length,a.length),u=xE(s.shape,a,A),c=yE(i,a.length),d=vE(u,i,a.length),h=[],f=RH({inputs:{x:s},backend:n,attrs:{shape:o}}),g=XH({inputs:{x:f},backend:n,attrs:{perm:l}}),p=RH({inputs:{x:g},backend:n,attrs:{shape:u}}),m=UU({inputs:{x:p},backend:n,attrs:{begin:c,size:d}});return h.push(f),h.push(g),h.push(p),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),m}};const KU={kernelName:Lg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,A=n.readSync(s.dataId),o=n.readSync(a.dataId),l=eV(A,o,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,l)}};const XU={kernelName:Wg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=gg().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=gg().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(s.dataId).values,[a,i]=nV(r.shape,s.shape,e,t,r.dtype),A=n.makeTensorInfo(i,r.dtype);return n.texData.get(A.dataId).values=a,A}let A;return A=a?new mH("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,s.shape,!1):new gH("\n  return float(int(a.r) & int(b.r));\n",r.shape,s.shape),n.runWebGLProgram(A,[r,s],r.dtype)}};const qU={kernelName:_g,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),A=Ak(Array.from(a),Array.from(i));return n.makeTensorInfo([A.length],"int32",Int32Array.from(A))}},ZU=TH({opSnippet:"return float(a != b);",cpuKernelImpl:xV,dtype:"bool"}),JU={kernelName:dm,backendName:"webgl",kernelFunc:ZU};function $U(e){const{inputs:t,backend:n}=e,{input:r}=t;return bH({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const ej={kernelName:Bm,backendName:"webgl",kernelFunc:$U};const tj={kernelName:Vg,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:a}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===a.dtype)return bH({inputs:{x:a},backend:r});const t=fx(a.shape),n=e({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),s=IH({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===a.dtype){const t=$U({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!Xf(a.dtype,i)){const e=bH({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([a])){const e=r.texData.get(a.dataId).values,[t,n,s]=rV(e,a.shape,a.dtype,i);return r.makeTensorInfo(t,n,s)}if("int32"===i)return function(e,t){const n=new nH(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(a,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",Yf("bool",1)),t=ZU({inputs:{a:a,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},nj="return ceil(x);",rj=DH({opSnippet:nj,packedOpSnippet:nj,cpuKernelImpl:sV}),sj={kernelName:Hg,backendName:"webgl",kernelFunc:rj};class aj{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class ij{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const Aj={kernelName:Ug,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let A;A=gg().getBool("WEBGL_PACK_CLIP")?new ij(s.shape):new aj(s.shape);const o=[[a],[i]];return n.runWebGLProgram(A,[s],s.dtype,o)}};class oj{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function lj(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const uj={kernelName:Yg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new oj(r.shape),i=[lj(r,s.complexTensorInfos.real),lj(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}};class cj{constructor(e){this.outputShape=[],this.outputShape=hE(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class dj{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=hE(e,t);const n=this.outputShape,r=n.length,s=B_(r),a=XV("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const A=new Array(e.length-1);A[0]=e[0][t];for(let n=1;n<A.length;n++)A[n]=A[n-1]+e[n][t];const o=i[t],l=i.slice(-2),u=i.join();let c=`if (${o} < ${A[0]}) {\n        return getChannel(\n            getT0(${u}), vec2(${l.join()}));\n        }`;for(let e=1;e<A.length;e++){const t=A[e-1];c+=`\n        if (${o} < ${A[e]}  && ${o} >= ${A[e-1]}) {\n          return getChannel(\n            getT${e}(${hj(i,o,t)}),\n            vec2(${hj(l,o,t)}));\n        }`}const d=A.length,h=A[A.length-1];c+=`\n        return getChannel(\n          getT${d}(${hj(i,o,h)}),\n          vec2(${hj(l,o,h)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${c}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function hj(e,t,n){const r=e.indexOf(t),s=e.map(((e,t)=>t===r?`${e} - ${n}`:e));return s.join()}function fj(e){const{inputs:t,backend:n}=e,{input:r}=t;return bH({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const gj={kernelName:Qp,backendName:"webgl",kernelFunc:fj};function pj(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>$U({inputs:{input:e},backend:n}))),s=e.map((e=>fj({inputs:{input:e},backend:n}))),a=pj(r,t,n),i=pj(s,t,n),A=IH({inputs:{real:a,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),s.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),A}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map((e=>{const r=Of(e.shape.slice(t));return RH({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),a=s.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=hE(s.map((e=>e.shape)),1),A=1===s[0].shape[0],o=aV(a,i,r,A),l=hE(e.map((e=>e.shape)),t),u=n.makeTensorInfo(l,r,o);return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}const a=e.filter((e=>Of(e.shape)>0)),i=gg().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(1===a.length){const t=i?new nH(e[0].shape,AH):new oH(e[0].shape,AH);return n.runWebGLProgram(t,e,r)}const A=gg().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>A){const e=[];for(let r=0;r<a.length;r+=A){const s=a.slice(r,r+A);e.push(pj(s,t,n))}const r=pj(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new dj(a.map((e=>e.shape)),t);return n.runWebGLProgram(e,a,r)}const{tensors2D:o,outShape:l}=function(e,t,n){const r=hE(e.map((e=>e.shape)),t),s=e.map((e=>RH({inputs:{x:e},attrs:{shape:[-1,Of(e.shape.slice(t))]},backend:n})));return{tensors2D:s,outShape:r}}(a,t,n),u=new cj(o.map((e=>e.shape))),c=n.runWebGLProgram(u,o,r);o.forEach((e=>n.disposeIntermediateTensorInfo(e)));const d=RH({inputs:{x:c},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(c),d}function mj(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Uf(s,t[0].shape)[0],i=t.map((e=>e.shape));dE(i,a);const A=hE(t.map((e=>e.shape)),a);if(0===Of(A))return n.makeTensorInfo(A,t[0].dtype,[]);const o=t.filter((e=>Of(e.shape)>0));return 1===o.length?bH({inputs:{x:o[0]},backend:n}):pj(o,a,n)}const bj={kernelName:Kg,backendName:"webgl",kernelFunc:mj};class Cj{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,A=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,g="channelsLast"===e.dataFormat,p=g?1:2,m=g?2:3,b=g?3:1;let C="",I="";n&&(C=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,I="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${C}\n\n      const ivec2 strides = ivec2(${A}, ${o});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${p}], coords[${m}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${u};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${g}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${g}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${I}\n        setOutput(result);\n      }\n    `}}class Ij{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,A=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,u=e.filterDepth,c=e.filterHeight,d=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${a}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${u}; wF++) {\n          int xF = xFCorner + wF * ${A};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${c}; wR++) {\n            int xR = xRCorner + wR * ${o};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class wj{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=F_(this.outputShape.length);const a=e.padInfo.left,i=e.strideWidth,A=e.dilationWidth,o=e.filterHeight,l=e.filterWidth,u=l;let c="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<l;e++)c+=`\n           vec4 xTexelC${2*e};\n           int xTexelC${2*e}Ready;\n           vec4 xTexelC${2*e+1};\n           int xTexelC${2*e+1}Ready;\n           vec4 xC${e};`;c+=`\n     for (int r = 0; r < ${o}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let e=0;e<l;e++)c+=`\n           xTexelC${2*e} = vec4(0.0);\n           xTexelC${2*e}Ready = 0;\n           xTexelC${2*e+1} = vec4(0.0);\n           xTexelC${2*e+1}Ready = 0;\n           xC${e} = vec4(0.0);`;c+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let t=0;t<(u+1)/2;t++){const n=2*t;if(c+=`\n           xC = xCCorner + ${n*A};\n           `,1===i){if(n<l&&(a%2==1?(c+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n               `,c+=1===A&&n>0?`\n                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                   } else {\n                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                   }\n                   `):c+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xC${n} = xTexelC${n};\n                 `,n+1<l)){const e=a%2==0?Gf(A):A;A%2==0&&a%2==1||A%2!=0&&a%2!=1?(c+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${n+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${n+1}Ready = 1;\n                   }\n                   `,c+=A>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                     } else {\n                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                     }\n                     `:`\n                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                     `):c+=1===e?`\n                     xC${n+1} = xTexelC${n};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${n+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${n+1}Ready = 1;\n                     }\n\n                     xC${n+1} = xTexelC${n+1};\n                     `}}else n<l&&(a%2==1?(c+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n               `,n+1<l&&(c+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                 `)):(c+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(\n                   xTexelC${n}.xy, xTexelC${n+1}.xy);\n               `,n+1<l&&(c+=`\n                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                 `)));n<l&&(c+=`\n             wTexel = getW(r, ${n}, d1, d2);\n             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,n+1<l&&(c+=`\n               wTexel = getW(r, ${n+1}, d1, d2);\n               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}c+="\n     }\n   ",c+="\n     }\n   ",c+="\n     }\n   ";let d="",h="";n&&(d=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:s?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,h="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${d}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${c}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${h}\n         setOutput(result);\n       }\n     `}}class kj{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=F_(this.outputShape.length);const{dataFormat:n}=t,r=u_(),s="channelsLast"===n,a=s?1:2,i=s?2:3,A=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let o="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)o+=`\n          blockIndex = rc.z + ${t};\n          pos = rc.y + ${e};\n\n          ${A}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${o}\n\n        ${r.output} = result;\n      }\n    `}}function xj(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function yj({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:A=null}){const o=e.shape,l=r.texData.get(e.dataId),u=n.inChannels,c=o[0]*o[1]*o[2],d=n.outChannels,h="channelsLast"===n.dataFormat,f=!1;let g;const p=[];if(null!=a){const e=xj(a.shape,h);null!=e&&(a=RH({inputs:{x:a},backend:r,attrs:{shape:e}}),p.push(a))}if(null!=s){const e=xj(s.shape,h);null!=e&&(s=RH({inputs:{x:s},backend:r,attrs:{shape:e}}),p.push(s))}if(!((1===c||1===d)&&u>1e3)&&l.isPacked&&h&&null!=l.texture&&o[2]%2!=0&&Rf(l.shape.slice(-3),o.slice(-3))){const u=o[0]*o[1]*(o[2]+1),c={dataId:e.dataId,shape:[1,u,n.inChannels],dtype:e.dtype},d=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,Pf(t_(l.shape,c.shape),(()=>`packed reshape ${l.shape} to ${c.shape} isn't free`));const h=RH({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});p.push(h);const m=ZH({a:c,b:h,backend:r,transposeA:false,transposeB:f,bias:s,activation:A,preluActivationWeights:a,leakyreluAlpha:i}),b=r.texData.get(m.dataId);Pf(b.isPacked,(()=>"batchMatMul result is expected to be packed")),l.shape=d,b.shape=n.outShape,g=bH({inputs:{x:m},backend:r}),g.shape=n.outShape,p.push(m)}else{const o=n.outHeight*n.outWidth,l=RH({inputs:{x:e},backend:r,attrs:{shape:h?[n.batchSize,o,n.inChannels]:[n.batchSize,n.inChannels,o]}}),u=RH({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),c=ZH({a:h?l:u,b:h?u:l,transposeA:!h,transposeB:f,backend:r,bias:s,activation:A,preluActivationWeights:a,leakyreluAlpha:i});g=RH({inputs:{x:c},backend:r,attrs:{shape:n.outShape}}),p.push(l),p.push(u),p.push(c)}for(const e of p)r.disposeIntermediateTensorInfo(e);return g}function vj({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:A=null}){const{filterWidth:o,filterHeight:l,inChannels:u,outWidth:c,outHeight:d,dataFormat:h}=n,f="channelsLast"===h,g=o*l*u,p=d*c,m=[n.batchSize,g,p],b=[];if(null!=a){const e=xj(a.shape,f);null!=e&&(a=RH({inputs:{x:a},backend:r,attrs:{shape:e}}),b.push(a))}if(null!=s){const e=xj(s.shape,f);null!=e&&(s=RH({inputs:{x:s},backend:r,attrs:{shape:e}}),b.push(s))}const C=RH({inputs:{x:t},backend:r,attrs:{shape:[1,g,Of(t.shape)/g]}});b.push(C);const I=new kj(m,n),w=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],k=r.runWebGLProgram(I,[e],"float32",w),x=RH({inputs:{x:k},backend:r,attrs:{shape:m}});b.push(k),b.push(x);const y=null!=s,v=null!=a,E="leakyrelu"===A,B=A?SH(A,!0):null,M=new NH(f?x.shape:C.shape,f?C.shape:x.shape,f?[n.batchSize,p,n.outChannels]:[n.batchSize,n.outChannels,p],!0,!1,y,B,v,E),D=f?[x,C]:[C,x];if(s&&D.push(s),v&&D.push(a),E){const e=r.makeTensorInfo([],"float32",sC(i,"float32"));D.push(e),b.push(e)}const T=r.runWebGLProgram(M,D,"float32"),S=RH({inputs:{x:T},backend:r,attrs:{shape:n.outShape}});b.push(T);for(const e of b)r.disposeIntermediateTensorInfo(e);return S}const Ej={kernelName:Xg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:A,dataFormat:o,dilations:l,dimRoundingMode:u}=r,c=Iw(o),d=uw(s.shape,a.shape,i,l,A,u,!1,c);let h;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===c&&gg().getBool("WEBGL_EXP_CONV")){const e=new wj(d),t=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];h=n.runWebGLProgram(e,[s,a],"float32",t)}else if(gg().getBool("WEBGL_CONV_IM2COL"))h=vj({x:s,filter:a,convInfo:d,backend:n});else{const e=new Cj(d);h=n.runWebGLProgram(e,[s,a],"float32")}else h=yj({x:s,filter:a,convInfo:d,backend:n});const f=RH({inputs:{x:h},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(h),f}};class Bj{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${a?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Mj{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,A=n-1-e.padInfo.left,o=a?1:2,l=a?2:3,u=a?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${A});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${u}];\n\n        ivec2 dyCorner = ivec2(coords[${o}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Dj{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${s};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Tj{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,A=t-1-e.padInfo.front,o=n-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${A}, ${o}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Sj={kernelName:qg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:A,dataFormat:o,dimRoundingMode:l,filterShape:u}=r,c=Iw(o),d=uw(s.shape,u,i,1,A,l,!1,c),h=new Bj(d);return n.runWebGLProgram(h,[s,a],"float32")}};class Nj{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=F_(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const Gj={kernelName:Zg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:A,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=Iw(l),d=uw(i,a.shape,A,1,o,u,!1,c);if(gg().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===c){const e=[[d.strideHeight,d.strideWidth]],t=new Nj(d);return n.runWebGLProgram(t,[s,a],"float32",e)}{const e=new Mj(d);return n.runWebGLProgram(e,[s,a],"float32")}}};const Fj={kernelName:Jg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:A,dilations:o}=r,l=cw(s.shape,a.shape,i,o,A),u=new Ij(l);return n.runWebGLProgram(u,[s,a],"float32")}};const Pj={kernelName:$g,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:A,filterShape:o}=r,l=cw(s.shape,o,i,1,A),u=new Dj(l);return n.runWebGLProgram(u,[s,a],"float32")}};const Qj={kernelName:ep,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:A,inputShape:o}=r,l=cw(o,a.shape,A,1,i),u=new Tj(l);return n.runWebGLProgram(u,[s,a],"float32")}},zj=DH({opSnippet:MH+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${pH}\n  return result;\n`}),Oj={kernelName:tp,backendName:"webgl",kernelFunc:zj},Rj=DH({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Lj={kernelName:np,backendName:"webgl",kernelFunc:Rj};class Wj{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,A,o]=e,[l]=t,[u,c]=n;this.outputShape=[l,u,c,o];const d="bilinear"===r?1:0,[h,f]=[i-1+".0",A-1+".0"],[g,p,m]=u>1?[""+(i-1)/(u-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[b,C,I]=c>1?[""+(A-1)/(c-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${p};\n        float width_scale = ${C};\n\n        float in_y = ${m};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${I};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const _j={kernelName:ap,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:A,method:o,extrapolationValue:l}=r,u=new Wj(s.shape,a.shape,A,o,l);return n.runWebGLProgram(u,[s,a,i],"float32")}};var Vj;!function(e){e.Prod="*",e.Sum="+"}(Vj||(Vj={}));class Hj{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=this.op===Vj.Prod?"1.0":"0.0",i=n?a:`getX(${Uj(s,"coords",this.op)})`,A=this.outputShape[this.outputShape.length-1];let o="",l="";n?(o=r?"end != "+(A-1):"end != 0",l=r?"end + 1":"end - 1"):(o=r?`end + pow2 < ${A}`:"end >= pow2",l=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${B_(s)} coords = getOutputCoords();\n        int end = ${jj(s,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${o}) {\n          int idx = ${l};\n          ${jj(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${Uj(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function Uj(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function jj(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Yj(e,t,n,r,s,a){const i=t.shape.length,A=wk([r],i);let o=t;null!=A&&(o=XH({inputs:{x:t},backend:n,attrs:{perm:A}}));const l=xk(1,i)[0];if(l!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const u=o.shape[l];let c=bH({inputs:{x:o},backend:n});for(let t=0;t<=Math.ceil(Math.log2(u))-1;t++){const r=new Hj(e,o.shape,!1,a),s=[[t]],i=c;c=n.runWebGLProgram(r,[c],c.dtype,s),n.disposeIntermediateTensorInfo(i)}if(s){const t=new Hj(e,o.shape,s,a),r=c;c=n.runWebGLProgram(t,[c],c.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=A){const e=XH({inputs:{x:c},backend:n,attrs:{perm:kk(A)}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(o),e}return c}const Kj={kernelName:rp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:A}=r;return Yj(Vj.Prod,s,n,a,i,A)}};const Xj={kernelName:sp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:A}=r;return Yj(Vj.Sum,s,n,a,i,A)}};const qj={kernelName:ip,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:A}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(a.dataId),r=eV(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(a),r=tV(e,t,i,A);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class Zj{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Jj={kernelName:Ap,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,A=s.shape[0],o=("NHWC"===i?s.shape[1]:s.shape[2])*a,l=("NHWC"===i?s.shape[2]:s.shape[3])*a,u=("NHWC"===i?s.shape[3]:s.shape[1])/(a*a),c=new Zj("NHWC"===i?[A,o,l,u]:[A,u,o,l],a,i);return n.runWebGLProgram(c,[s],s.dtype)}};class $j{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=F_(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,A=e.outChannels/e.inChannels;let o="",l="";n&&(o=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,l="result = activation(result);");const u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${o}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${A};\n        int q = d2 - d1 * ${A};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${u}\n        ${l}\n        setOutput(result);\n      }\n    `}}class eY{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=F_(this.outputShape.length);const a=e.outChannels/e.inChannels,i=e.padInfo.left,A=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<u;e++)d+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;d+=`\n    for (int r = 0; r < ${l}; r++) {\n      `;for(let e=0;e<u;e++)d+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(c+1)/2;e++){const t=2*e;if(d+=`\n          xC = xCCorner + ${t*o};\n          `,1===A){if(t<u&&(i%2==1?(d+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,d+=1===o&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):d+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<u)){const e=i%2==0?Gf(o):o;o%2==0&&i%2==1||o%2!=0&&i%2!=1?(d+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,d+=o>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                    } else {\n                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                    }\n                    `:`\n                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                    `):d+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<u&&(i%2==1?(d+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<u&&(d+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(d+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<u&&(d+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<u&&(d+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<u&&(d+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}d+="\n    }\n  ",d+="\n      }\n    ";let h="",f="";n&&(h=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${h}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${d}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${f}\n        setOutput(result);\n      }\n    `}}const tY={kernelName:op,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:A,dilations:o,dimRoundingMode:l}=r;let u=o;null==u&&(u=[1,1]),Pf(bw(i,u),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));const c=uw(s.shape,a.shape,i,u,A,l,!0);let d;d=gg().getBool("WEBGL_PACK_DEPTHWISECONV")&&c.strideWidth<=2&&c.outChannels/c.inChannels===1?new eY(c):new $j(c);const h=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]];return n.runWebGLProgram(d,[s,a],"float32",h)}};class nY{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class rY{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,A=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${A}; dm++) {\n              int d2 = d1 * ${A} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const sY={kernelName:lp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:A,pad:o,dimRoundingMode:l,filterShape:u}=r,c=uw(s.shape,u,i,A,o,l,!0),d=new nY(c);return n.runWebGLProgram(d,[s,a],"float32")}};const aY={kernelName:up,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:A,pad:o,dimRoundingMode:l,inputShape:u}=r,c=uw(u,a.shape,i,A,o,l,!0),d=new rY(c);return n.runWebGLProgram(d,[s,a],"float32")}};class iY{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const AY={kernelName:cp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=Of(r.shape),i=RH({inputs:{x:r},backend:n,attrs:{shape:[a]}}),A=new iY(a),o=n.runWebGLProgram(A,[i],i.dtype),l=RH({inputs:{x:o},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};class oY{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:A,dilationHeight:o,dilationWidth:l}=e,{top:u,left:c}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${a});\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${o};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${A}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const lY={kernelName:dp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:A,dilations:o}=r,l=Aw(s.shape,a.shape,i,A,"NHWC",o);let u;const c=new oY(l);u=n.runWebGLProgram(c,[s,a],"float32");const d=RH({inputs:{x:u},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(u),d}};const uY={kernelName:pp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:A,idDims:o}=HE(s,a.length);jE(i.length,o,a);const{path:l,steps:u}=YE(A,o),c=u.length;let d=null,h=i.length;const f=[];for(let e=0;e<c;++e){for(const t of u[e]){const{permutationIndices:e,expandDims:r}=UE(h,o[t]);let s;KE(e)?s=a[t]:(s=XH({inputs:{x:a[t]},backend:n,attrs:{perm:e}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Rf(s.shape,i)||(s=RH({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=zH({inputs:{a:s,b:d},backend:n}),f.push(d))}e<c-1&&(l[e]>=0&&(d=YH({inputs:{x:d},backend:n,attrs:{axis:l[e]-(i.length-h),keepDims:!1}}),f.push(d)),h--)}for(const e of f)e!==d&&n.disposeIntermediateTensorInfo(e);return d}},cY=DH({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),dY={kernelName:mp,backendName:"webgl",kernelFunc:cY},hY={kernelName:bp,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=gg().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mH("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new gH("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)}},fY=TH({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:iV}),gY={kernelName:Ip,backendName:"webgl",kernelFunc:fY},pY=DH({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${ME};\n  float a1 = ${DE};\n  float a2 = ${TE};\n  float a3 = ${SE};\n  float a4 = ${NE};\n  float a5 = ${GE};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),mY={kernelName:Cp,backendName:"webgl",kernelFunc:pY},bY=DH({opSnippet:MH+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:AV,dtype:"float32"}),CY={kernelName:wp,backendName:"webgl",kernelFunc:bY};function IY(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,A=a.shape.slice();let o=s;return s<0&&(Pf(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),o=i+s+1),A.splice(o,0,1),RH({inputs:{x:a},backend:r,attrs:{shape:A}})}const wY={kernelName:kp,backendName:"webgl",kernelFunc:IY},kY="return exp(x) - 1.0;",xY=DH({opSnippet:kY,packedOpSnippet:kY,cpuKernelImpl:oV}),yY={kernelName:xp,backendName:"webgl",kernelFunc:xY};class vY{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function EY(e,t,n){const r=n.texData.get(e.dataId),s=Of(e.shape),a=e.shape[e.shape.length-1],i=RH({inputs:{x:e},backend:n,attrs:{shape:[s/a,a]}}),A=i.shape,o=new vY("real",A,t),l=new vY("imag",A,t),u=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:A},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:A}],c=n.runWebGLProgram(o,u,"float32"),d=n.runWebGLProgram(l,u,"float32"),h=IH({inputs:{real:c,imag:d},backend:n});n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d);const f=RH({inputs:{x:h},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(h),f}const BY={kernelName:yp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return EY(r,!1,n)}};class MY{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function DY(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||$f(s),"string"===a){const e=Kf(a,Of(r));return e.fill(s),t.makeTensorInfo(r,a,e)}{const e=new MY(r,s),n=[[s]];return t.runWebGLProgram(e,[],a,n)}}const TY={kernelName:vp,backendName:"webgl",kernelFunc:DY};class SY{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const NY={kernelName:Ep,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new SY(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},GY="return floor(x);",FY=DH({opSnippet:GY,packedOpSnippet:GY,cpuKernelImpl:lV}),PY={kernelName:Bp,backendName:"webgl",kernelFunc:FY},QY=TH({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),zY={kernelName:Mp,backendName:"webgl",kernelFunc:QY};class OY{constructor(e){this.variableNames=["A"];const t=u_(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class RY{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=u_(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const LY={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,A="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[o,l]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],u=[l,o],c=[l,o,a];if(A||i){const e=gg().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=WY&&e===_Y||(_Y=e,WY=document.createElement("canvas").getContext("2d",{willReadFrequently:_Y})),WY.canvas.width=o,WY.canvas.height=l,WY.drawImage(s,0,0,o,l),s=WY.canvas}const d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=GW.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const h=gg().getBool("WEBGL_PACK")?new RY(c):new OY(c),f=n.runWebGLProgram(h,[d],"int32");return n.disposeData(d.dataId),f}};let WY,_Y=gg().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const VY={kernelName:Bb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:A}=t,{strides:o,pad:l,dataFormat:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,g=Iw(u),p=uw(s.shape,a.shape,o,c,l,d,!1,g);let m;const b=[],C=null!=i,I=null!=A,w="leakyrelu"===h,k=()=>{const e=[s,a],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=RH({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(C&&e.push(t(i,u)),I&&e.push(t(A,u)),w){const t=n.makeTensorInfo([],"float32",sC(f,"float32"));e.push(t),b.push(t)}return e};if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(p.strideWidth<=2&&"channelsLast"===g&&gg().getBool("WEBGL_EXP_CONV")){const e=h?SH(h,!0):null,t=new wj(p,C,e,I,w),r=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]],s=k();m=n.runWebGLProgram(t,s,"float32",r)}else if(gg().getBool("WEBGL_CONV_IM2COL"))m=vj({x:s,filter:a,convInfo:p,backend:n,bias:i,activation:h,preluActivationWeights:A,leakyreluAlpha:f});else{const e=h?SH(h,!1):null,t=new Cj(p,C,e,I,w),r=k();m=n.runWebGLProgram(t,r,"float32")}else m=yj({x:s,filter:a,convInfo:p,backend:n,bias:i,activation:h,preluActivationWeights:A,leakyreluAlpha:f});const x=RH({inputs:{x:m},backend:n,attrs:{shape:p.outShape}});return b.push(m),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),x}};const HY={kernelName:Mb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:A}=t,{strides:o,pad:l,dilations:u,dimRoundingMode:c,activation:d,leakyreluAlpha:h}=r,f=[];let g=u;null==g&&(g=[1,1]),Pf(bw(o,g),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${g}'`));const p=uw(s.shape,a.shape,o,g,l,c,!0),m=gg().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1,b=d?SH(d,m):null,C=[s,a],I=null!=i,w=null!=A,k="leakyrelu"===d;if(I&&C.push(i),w&&C.push(A),k){const e=n.makeTensorInfo([],"float32",sC(h,"float32"));C.push(e),f.push(e)}let x;x=m?new eY(p,I,b,w,k):new $j(p,I,b,w,k);const y=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]],v=n.runWebGLProgram(x,C,"float32",y);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),v}};class UY{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const s=B_(n.length);let a="\n    int index;";for(let e=0;e<this.sliceDim;e++)a+=`\n          index = round(getIndices(coords[0], ${e}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};\n          flattenIndex += index * ${this.strides[e]};`;this.userCode=`\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${a}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const jY={kernelName:Sp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],A=Of(r.shape),[o,l,u,c]=jv(r,s),d=RH({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),h=RH({inputs:{x:r},backend:n,attrs:{shape:[Of(r.shape)/u,u]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(r),a=uV(e,t,r.dtype,l,i,u,c,r.shape,A);return n.makeTensorInfo(o,r.dtype,a.values)}const f=new UY(i,c,[l,u],r.shape),g=n.runWebGLProgram(f,[h,d],h.dtype),p=RH({inputs:{x:g},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g),p}};class YY{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=B_(this.rank),r=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function KY(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:A}=r,o=Uf(i,s.shape)[0];if(gg().get("DEBUG")){const e=n.readSync(a.dataId),t=s.shape[o];for(let n=0;n<e.length;++n){const r=e[n];Pf(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const l=cB(s,a,o,A),u=Of(a.shape),c=[],d=RH({inputs:{x:s},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),h=RH({inputs:{x:a},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});c.push(d),c.push(h);const f=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([s,a])||"string"===s.dtype){const e=n.bufferSync(h),t=n.bufferSync(d),r=cV(t,e,f);return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(l.outputShape,r.dtype,r.values)}const g=new YY(d.shape,f),p=n.runWebGLProgram(g,[d,h],d.dtype);c.push(p);const m=RH({inputs:{x:p},backend:n,attrs:{shape:l.outputShape}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),m}const XY={kernelName:Tp,backendName:"webgl",kernelFunc:KY},qY=TH({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:dV,dtype:"bool"}),ZY={kernelName:Np,backendName:"webgl",kernelFunc:qY},JY=TH({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:hV}),$Y={kernelName:Gp,backendName:"webgl",kernelFunc:JY};const eK={kernelName:Pp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return EY(r,!0,n)}},tK=DH({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),nK={kernelName:zp,backendName:"webgl",kernelFunc:tK},rK=DH({opSnippet:"return float(isinf(x));",dtype:"bool"}),sK={kernelName:Op,backendName:"webgl",kernelFunc:rK},aK=DH({opSnippet:"return float(isnan(x));",dtype:"bool"}),iK={kernelName:Rp,backendName:"webgl",kernelFunc:aK},AK=TH({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:fV,dtype:"bool"}),oK={kernelName:Wp,backendName:"webgl",kernelFunc:AK},lK=TH({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:gV,dtype:"bool"}),uK={kernelName:_p,backendName:"webgl",kernelFunc:lK};const cK={kernelName:Vp,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=pV(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},dK=DH({opSnippet:MH+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:mV}),hK={kernelName:Hp,backendName:"webgl",kernelFunc:dK},fK=DH({opSnippet:MH+"\n  return log(1.0 + x);\n"}),gK={kernelName:Up,backendName:"webgl",kernelFunc:fK},pK=TH({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),mK={kernelName:jp,backendName:"webgl",kernelFunc:pK},bK=DH({opSnippet:"return float(!(x >= 1.0));"}),CK={kernelName:Yp,backendName:"webgl",kernelFunc:bK},IK=TH({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),wK={kernelName:Kp,backendName:"webgl",kernelFunc:IK};class kK{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;let A;this.outputShape=e;const o=`float(${n}) + float(${r}) * sum`;A=.5===s?`inversesqrt(${o})`:1===s?`1.0/(${o})`:`exp(log(${o}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${A};\n        setOutput(val);\n      }\n    `}}class xK{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;let A;this.outputShape=e;const o=`float(${n}) + float(${r}) * sum`;A=.5===s?`inversesqrt(${o})`:1===s?`1.0/(${o})`:`exp(log(${o}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${A};\n        setOutput(result);\n      }\n    `}}const yK={kernelName:Xp,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:A,beta:o}=r,l=gg().getBool("WEBGL_PACK_NORMALIZATION")?new xK(s.shape,a,i,A,o):new kK(s.shape,a,i,A,o);return n.runWebGLProgram(l,[s],s.dtype)}};class vK{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const EK={kernelName:qp,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:A,bias:o,alpha:l,beta:u}=r,c=new vK(s.shape,A,o,l,u);return n.runWebGLProgram(c,[s,a,i],s.dtype)}};function BK(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,A=s.shape.length,o=Uf(a,s.shape);let l=o;const u=wk(l,A),c=null!=u,d=n.shouldExecuteOnCPU([s]);let h=s;if(c){if(d){const e=n.texData.get(h.dataId).values,t=new Array(A);for(let e=0;e<t.length;e++)t[e]=s.shape[u[e]];const r=jV(e,s.shape,s.dtype,u,t);h=n.makeTensorInfo(t,s.dtype);n.texData.get(h.dataId).values=r}else h=jH(s,u,n);l=xk(l.length,A)}Ik("max",l,A);const[f,g]=bk(h.shape,l);let p,m=f;if(i&&(m=Ck(f,o)),d){const e=n.texData.get(h.dataId).values,t=bV(e,Of(g),m,s.dtype);p=n.makeTensorInfo(m,s.dtype);n.texData.get(p.dataId).values=t}else p=function(e,t,n,r){const s=Of(t),a=RH({inputs:{x:e},attrs:{shape:[Of(e.shape)/s,s]},backend:r}),i=VH(a,e.dtype,"max",r),A=RH({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),A}(h,g,m,n);return c&&n.disposeIntermediateTensorInfo(h),p}const MK={kernelName:Zp,backendName:"webgl",kernelFunc:BK},DK=TH({opSnippet:fH+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+pH+"\n  return result;\n",cpuKernelImpl:CV}),TK={kernelName:Jp,backendName:"webgl",kernelFunc:DK};const SK={kernelName:$p,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;o_(s,"maxPool");const{filterSize:a,strides:i,pad:A,dimRoundingMode:o}=r;Pf(bw(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const l=ow(s.shape,a,i,1,A,o);if(1===l.filterWidth&&1===l.filterHeight&&Rf(l.inShape,l.outShape))return bH({inputs:{x:s},backend:n});const u=new TU(l,"max",!1);return n.runWebGLProgram(u,[s],s.dtype)}};const NK={kernelName:tm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:A,dataFormat:o,dimRoundingMode:l}=r,u=lw(s.shape,a,i,[1,1,1],A,l,o),c=new SU(u,"max",!1);return n.runWebGLProgram(c,[s],s.dtype)}};class GK{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,A=a-1-e.padInfo.left,o=s*a-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${A});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${o} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class FK{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,A=e.effectiveFilterDepth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=A-1-e.padInfo.front,c=o-1-e.padInfo.top,d=l-1-e.padInfo.left,h=A*o*l-1;this.userCode=`\n      const ivec3 pads = ivec3(${u}, ${c}, ${d});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${A};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${o};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${o} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const PK={kernelName:nm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:A,strides:o,pad:l,dimRoundingMode:u}=r,c=lw(i.shape,A,o,[1,1,1],l,u),d=new SU(c,"max",!0),h=n.runWebGLProgram(d,[i],i.dtype),f=new FK(c),g=n.runWebGLProgram(f,[s,h],i.dtype);return n.disposeIntermediateTensorInfo(h),g}};const QK={kernelName:em,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,A=a;o_([a,i],"maxPoolGrad");const{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=ow(A.shape,o,l,1,u,c),h=new TU(d,"max",!0),f=n.runWebGLProgram(h,[A],A.dtype),g=new GK(d),p=n.runWebGLProgram(g,[s,f],A.dtype);return n.disposeIntermediateTensorInfo(f),p}};const zK={kernelName:rm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:A}=t,o=n;Pf(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const l=[1,1];Pf(bw(a,l),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`));const u=ow(r.shape,s,a,l,i),[c,d]=function(e,t,n,r){let s=new TU(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");return s=new TU(n,"max",!0,!0,t),[a,r.runWebGLProgram(s,[e],"float32")]}(r,A,u,o);return[c,d]}};const OK={kernelName:sm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:a}=t,i=n,A=r.shape.length,o=Uf(a,r.shape);let l=o;const u=wk(l,A),c=null!=u,d=i.shouldExecuteOnCPU([r]),h=[];let f=r;if(c){if(d){const e=i.texData.get(f.dataId).values,t=new Array(A);for(let e=0;e<t.length;e++)t[e]=r.shape[u[e]];const n=jV(e,r.shape,r.dtype,u,t);f=i.makeTensorInfo(t,r.dtype);i.texData.get(f.dataId).values=n}else f=jH(r,u,i);h.push(f),l=xk(l.length,A)}Ik("sum",l,A);const[g,p]=bk(f.shape,l);let m=g;s&&(m=Ck(g,o));const b=function(e,t,n,r){const s=Of(t),a=RH({inputs:{x:e},attrs:{shape:[Of(e.shape)/s,s]},backend:r}),i=VH(a,"float32","mean",r),A=RH({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),A}(f,p,m,i);for(const e of h)i.disposeIntermediateTensorInfo(e);return b}};const RK={kernelName:am,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,A=s.shape.length,o=Uf(a,s.shape);let l=o;const u=wk(l,A);let c=s;null!=u&&(c=XH({inputs:{x:s},backend:n,attrs:{perm:u}}),l=xk(l.length,s.shape.length)),Ik("min",l,A);const[d,h]=bk(c.shape,l),f=RH({inputs:{x:c},backend:n,attrs:{shape:[-1,Of(h)]}}),g=VH(f,f.dtype,"min",n);let p;if(i){p=RH({inputs:{x:g},backend:n,attrs:{shape:Ck(d,o)}})}else p=RH({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(c),p}},LK=TH({opSnippet:fH+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+pH+"\n  return result;\n",cpuKernelImpl:IV}),WK={kernelName:im,backendName:"webgl",kernelFunc:LK};class _K{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=B_(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),A=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),o="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${o};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${o};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${A}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${o};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${o};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class VK{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=B_(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),A=XV("rc",r),o=XV("source",r),l=`${A[r-1]} < ${this.outputShape[r-1]}`,u=1===r?"source":`vec2(${o.slice(-2).join()})`,c="reflect"===n?0:1;let d="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${c};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${c};\n        }\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${o.join()}), ${u});\n        ${A[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${o.join()}), ${u});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${c}) +\n                gte * ((end - 1) * 2 - source + ${c});\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${o.join()}), ${u});\n        ${A[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${o.join()}), ${u});\n        }\n        rc = outputLoc;\n        ${A[r-2]} += 1;\n        if(${A[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${o.join()}), ${u});\n          ${A[r-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${o.join()}), ${u});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const HK={kernelName:Am,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:a}=n,i=gg().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new VK(r.shape,s,a):new _K(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)}},UK=TH({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+pH+"\n  return result;\n"}),jK={kernelName:om,backendName:"webgl",kernelFunc:UK};class YK{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const KK=TH({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),XK={kernelName:gp,backendName:"webgl",kernelFunc:KK},qK="return a - b;",ZK=TH({opSnippet:qK,packedOpSnippet:qK,supportsComplex:!0,cpuKernelImpl:VV}),JK={kernelName:hb,backendName:"webgl",kernelFunc:ZK};function $K(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=Uf([a],s.shape),A=BK({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),o=Ck(A.shape,i),l=RH({inputs:{x:A},backend:n,attrs:{shape:o}}),u=ZK({inputs:{a:s,b:l},backend:n}),c=bY({inputs:{x:u},backend:n}),d=YH({inputs:{x:c},backend:n,attrs:{axis:i,keepDims:!1}}),h=RH({inputs:{x:d},backend:n,attrs:{shape:o}}),f=KK({inputs:{a:c,b:h},backend:n});return n.disposeIntermediateTensorInfo(A),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),f}const eX={kernelName:eb,backendName:"webgl",kernelFunc:$K};const tX={kernelName:lm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:A}=r,o=A?s:$K({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),l=o.shape[0],u=o.shape[1],c=new YK(l,u,a),d=[[i]],h=n.runWebGLProgram(c,[o],"int32",d);return A||n.disposeIntermediateTensorInfo(o),h}},nX=rH+"\n  return -x;\n";const rX={kernelName:cm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=kV(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=gg().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new oH(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new nH(r.shape,nX),n.runWebGLProgram(s,[r],r.dtype)}},sX=uv;const aX={kernelName:hm,backendName:"webgl",kernelFunc:function(e){Db("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:A,scoreThreshold:o}=r,l=n.readSync(s.dataId),u=n.readSync(a.dataId),{selectedIndices:c}=sX(l,u,i,A,o);return n.makeTensorInfo([c.length],"int32",new Int32Array(c))}},iX=cv;const AX={kernelName:fm,backendName:"webgl",kernelFunc:function(e){Db("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:A,scoreThreshold:o,padToMaxOutputSize:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:d,validOutputs:h}=iX(u,c,i,A,o,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}},oX=dv;const lX={kernelName:gm,backendName:"webgl",kernelFunc:function(e){Db("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:A,scoreThreshold:o,softNmsSigma:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),d=i,h=A,f=o,g=l,{selectedIndices:p,selectedScores:m}=oX(u,c,d,h,f,g);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([m.length],"float32",new Float32Array(m))]}};class uX{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const cX={kernelName:mm,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:A,offValue:o}=r,l=Of(s.shape),u=new uX(l,i,A,o),c=RH({inputs:{x:s},backend:n,attrs:{shape:[l]}}),d=n.runWebGLProgram(u,[c],a);n.disposeIntermediateTensorInfo(c);const h=RH({inputs:{x:d},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeIntermediateTensorInfo(d),h}};function dX(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=$U({inputs:{input:r},backend:n}),t=dX({inputs:{x:e},backend:n}),s=fj({inputs:{input:r},backend:n}),a=dX({inputs:{x:s},backend:n}),i=IH({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return DY({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const hX={kernelName:xb,backendName:"webgl",kernelFunc:dX};const fX={kernelName:pm,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=$U({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=fj({inputs:{input:s},backend:r}),i=dX({inputs:{x:a},backend:r}),A=IH({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),A}return DY({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}};const gX={kernelName:bm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return IY({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{Qf(a,e.shape,"All tensors passed to stack must have matching shapes"),Pf(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const A=[],o=t.map((e=>{const t=IY({inputs:{input:e},backend:n,attrs:{dim:s}});return A.push(t),t})),l=mj({inputs:o,backend:n,attrs:{axis:s}});return A.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class pX{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=B_(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),A=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${A}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class mX{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=B_(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),A=XV("rc",r),o=XV("source",r),l=`${A[r-1]} < ${this.outputShape[r-1]}`,u=1===r?"source":`vec2(${o.slice(-2).join()})`,c=[`${s} rc = outputLoc;`,`${A[r-1]} += 1;\n       if(${l}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${A[r-2]} += 1;\n       if(${A[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${A[r-1]} += 1;\n         if(${l}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let h="";for(let e=0,t=1===r?2:4;e<t;e++)h+=`\n        ${c[e]}\n        if (${d}) {\n          result[${e}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${e}] = getChannel(getX(${o.join()}), ${u});\n        }\n      `;h+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const bX=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(0===Of(s.shape)){const e=a.map(((e,t)=>e[0]+s.shape[t]+e[1]));return DY({backend:n,attrs:{shape:e,value:i,dtype:s.dtype}})}const A=gg().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mX(s.shape,a,i):new pX(s.shape,a,i),o=[[i]];return n.runWebGLProgram(A,[s],s.dtype,o)},CX={kernelName:Cm,backendName:"webgl",kernelFunc:bX},IX=TH({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+pH+"\n  return result;\n"}),wX={kernelName:Im,backendName:"webgl",kernelFunc:IX};const kX={kernelName:km,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,A=s.shape.length,o=[],l=Uf(a,s.shape);let u=l;const c=wk(u,A);let d,h=s;if(null!=c&&(h=XH({inputs:{x:s},backend:n,attrs:{perm:c}}),u=xk(u.length,A),o.push(h)),Ik("prod",u,A),n.shouldExecuteOnCPU([h])){const e=n.texData.get(h.dataId).values,{outVals:t,outShape:r,outDtype:s}=yV(h.shape,h.dtype,e,u);d=n.makeTensorInfo(r,s,t)}else{const[e,t]=bk(h.shape,u),r=Of(t),a=RH({inputs:{x:h},backend:n,attrs:{shape:[-1,r]}}),i=VH(a,NC(s.dtype),"prod",n);d=RH({inputs:{x:i},backend:n,attrs:{shape:e}}),o.push(a),o.push(i)}if(i){o.push(d);const e=Ck(d.shape,l);d=RH({inputs:{x:d},backend:n,attrs:{shape:e}})}return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}};const xX={kernelName:xm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:A}=r,o=s.map((e=>n.readSync(e.dataId))),l=s.map((e=>e.shape)),u=n.readSync(a.dataId),c=n.readSync(i.dataId),[d,h,f]=vV(o,l,u,a.shape,a.dtype,c,i.shape,A),g=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),p=n.makeTensorInfo(f,a.dtype,h);return g.concat([p])}};const yX={kernelName:ym,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),A=n.readSync(s.dataId),o=n.readSync(a.dataId),[l,u]=EV(i,r.shape,r.dtype,A,s.shape,o,a.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],r.dtype,u)]}};const vX={kernelName:vm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:A}=t,{rowPartitionTypes:o}=r,l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId),d=A.map((e=>n.readSync(e.dataId))),h=A.map((e=>e.shape)),[f,g]=BV(l,s.shape,u,a.shape,a.dtype,c,i.shape,d,h,o);return n.makeTensorInfo(f,a.dtype,g)}},EX=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,A=MV(r,s,a,i);return t.makeTensorInfo([A.length],i,A)},BX={kernelName:Em,backendName:"webgl",kernelFunc:EX},MX=DH({opSnippet:"return 1.0 / x;"}),DX={kernelName:Mm,backendName:"webgl",kernelFunc:MX},TX=DH({opSnippet:rH+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),SX={kernelName:Dm,backendName:"webgl",kernelFunc:TX},NX=DH({opSnippet:rH+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),GX={kernelName:Pm,backendName:"webgl",kernelFunc:NX};class FX{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,A,o]=e;this.outputShape=[a,t,n,o];const l=[r&&t>1?i-1:i,r&&n>1?A-1:A],u=[r&&t>1?t-1:t,r&&n>1?n-1:n];let c;c=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/u[0]},\n          ${l[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${A}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${c};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class PX{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,A,o]=e;this.outputShape=[a,t,n,o];const l=[r&&t>1?i-1:i,r&&n>1?A-1:A],u=[r&&t>1?t-1:t,r&&n>1?n-1:n];let c;c=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/u[0]},\n          ${l[1]/u[1]},\n          ${l[1]/u[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${A}.0,\n                                     ${A}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${c};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${o-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const QX={kernelName:Gm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:A}=r,[o,l]=A,u=gg().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new PX(s.shape,o,l,a,i):new FX(s.shape,o,l,a,i);return n.runWebGLProgram(u,[s],"float32")}};class zX{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,A=[n&&a>1?r-1:r,n&&i>1?s-1:s],o=[n&&a>1?a-1:a,n&&i>1?i-1:i],l=A[0]/o[0],u=A[1]/o[1],c=1/l,d=1/u,h=2*Math.ceil(c)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${u});\n\n        const float invHeightScale = float(${c});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const OX={kernelName:Fm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,A=new zX(a.shape,s.shape,i);return n.runWebGLProgram(A,[a],a.dtype)}};class RX{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,A,o]=e;this.outputShape=[a,t,n,o];const l=[r&&t>1?i-1:i,r&&n>1?A-1:A],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],c=r?"0.5":"0.0";let d;d=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/u[0]},\n          ${l[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${A}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class LX{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,A,o]=e;this.outputShape=[a,t,n,o];const l=[r&&t>1?i-1:i,r&&n>1?A-1:A],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],c=r?"0.5":"0.0";let d;d=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/u[0]},\n          ${l[1]/u[1]},\n          ${l[1]/u[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${A}.0,\n                                     ${A}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${o-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const WX={kernelName:Sm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:A}=r,[o,l]=A,u=gg().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new LX(s.shape,o,l,a,i):new RX(s.shape,o,l,a,i);return n.runWebGLProgram(u,[s],s.dtype)}};class _X{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,A=[n&&a>1?r-1:r,n&&i>1?s-1:s],o=[n&&a>1?a-1:a,n&&i>1?i-1:i],l=A[0]/o[0],u=A[1]/o[1],c=1/l,d=1/u,h=2*Math.ceil(c)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${u});\n\n        const float invHeightScale = float(${c});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${A[0]}) *\n                (float(dyR) / float(${o[0]}));\n\n            float sourceFracCol =\n                float(${A[1]}) *\n                  (float(dyC) / float(${o[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const VX={kernelName:Nm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,A=new _X(a.shape,s.shape,i);return n.runWebGLProgram(A,[a],a.dtype)}};class HX{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),s=B_(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class UX{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=XV("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=B_(n);function A(n){const r=e.map(((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return A(e)}(r.slice())};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",A(e)}(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",A(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",A(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const jX={kernelName:Qm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,A=Uf(a,s.shape);if(0===i)return bH({inputs:{x:s},backend:n});const o=gg().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new UX(s.shape,A):new HX(s.shape,A);return n.runWebGLProgram(o,[s],s.dtype)}};class YX{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let s="";s="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const KX={kernelName:vb,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,A=n,o=new YX(r.shape,a),[l,u]=IE(i,r.shape[1],r.shape[2]),c=[[l,u,Math.sin(s),Math.cos(s)]];return A.runWebGLProgram(o,[r],r.dtype,c)}},XX=DH({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),qX={kernelName:zm,backendName:"webgl",kernelFunc:XX},ZX=DH({opSnippet:"return inversesqrt(x);",cpuKernelImpl:DV}),JX={kernelName:Om,backendName:"webgl",kernelFunc:ZX};class $X{constructor(e,t,n,r,s,a,i=!0,A=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const o=B_(s.length),l=B_(a.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`;let f="";A&&(f="coords[0], coords[1]");const g=`getDefaultValue(${f})`,p=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${p};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(${g}, sum, float(found)));\n        }\n      `}}class eq{constructor(e,t,n,r,s,a,i=!0,A=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const o=B_(s.length),l=B_(a.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`;let f="";A&&(f="coords[0], coords[1]");const g=`getDefaultValue(${f})`,p=t>1?"strides[j]":"strides",m=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${o} strides = ${o}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${c});\n              flattenedIndex += index.xz * ${p};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${m};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${h};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${g}, sum, found));\n        }\n      `}}const tq={kernelName:Rm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:A,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=Qy(0,s,i),d=[c/l,l];if(0===c)return n.makeTensorInfo(i,s.dtype);const h=RH({inputs:{x:s},backend:n,attrs:{shape:[o,A]}}),f=RH({inputs:{x:a},backend:n,attrs:{shape:[o,l]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));let p;p=gg().getBool("WEBGL_PACK")?new eq(o,A,h.shape.length,f.shape.length,u,d):new $X(o,A,h.shape.length,f.shape.length,u,d);const m=n.runWebGLProgram(p,[f,h,g],f.dtype),b=RH({inputs:{x:m},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),b}};class nq{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=2===gg().getNumber("WEBGL_VERSION")?"while (left < right) {":s,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const rq={kernelName:Wm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,A=new nq(s.shape[0],s.shape[1],a.shape[1],i),o=[[s.shape[1]]];return n.runWebGLProgram(A,[s,a],"int32",o)}};class sq{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&a.push(`${n[r]}`);r=a.join(),s=i.join()}const a=B_(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const aq={kernelName:_m,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new sq(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],SC(s.dtype,a.dtype))}},iq=DH({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = ${BE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),Aq={kernelName:Vm,backendName:"webgl",kernelFunc:iq},oq=DH({opSnippet:MH+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:SV}),lq={kernelName:Km,backendName:"webgl",kernelFunc:oq},uq=DH({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),cq={kernelName:Ym,backendName:"webgl",kernelFunc:uq},dq=DH({opSnippet:MH+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${pH}\n  return result;\n`}),hq={kernelName:Um,backendName:"webgl",kernelFunc:dq},fq=DH({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),gq={kernelName:jm,backendName:"webgl",kernelFunc:fq},pq=DH({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),mq={kernelName:Xm,backendName:"webgl",kernelFunc:pq},bq={kernelName:Jm,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;Pf(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const A=a.reduce(((e,t)=>e*t)),o=[[0,0]];o.push(...i);for(let e=1+a.length;e<s.shape.length;++e)o.push([0,0]);const l=[],u=bX({inputs:{x:s},backend:n,attrs:{paddings:o,constantValue:0}}),c=wE(u.shape,a,A,!1),d=kE(c.length,a.length,!1),h=xE(u.shape,a,A,!1),f=RH({inputs:{x:u},backend:n,attrs:{shape:c}}),g=XH({inputs:{x:f},backend:n,attrs:{perm:d}}),p=RH({inputs:{x:g},backend:n,attrs:{shape:h}});return l.push(u),l.push(f),l.push(g),l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const Cq={kernelName:tb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const A=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=n.readSync(i.dataId)[0],[c,d,h,f,g]=FV(A,r.shape,r.dtype,o,s.dtype,l,u);return[n.makeTensorInfo(d,r.dtype,c),n.makeTensorInfo([d[0]],s.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}};const Iq={kernelName:nb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),A=n.readSync(r.dataId),o=Array.from(n.readSync(a.dataId)),[l,u,c]=PV(A,r.shape,r.dtype,i,o);return[n.makeTensorInfo(u,r.dtype,l),n.makeTensorInfo([c.length],a.dtype,new Int32Array(c))]}};const wq={kernelName:rb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);const i=n.readSync(r.dataId),A=n.readSync(s.dataId),o=n.readSync(a.dataId),[l,u]=QV(i,r.shape,r.dtype,A,o,!0);return n.makeTensorInfo(u,r.dtype,l)}};const kq={kernelName:sb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);const i=n.readSync(r.dataId),A=n.readSync(s.dataId),o=n.readSync(a.dataId),[l,u]=QV(i,r.shape,r.dtype,A,o);return n.makeTensorInfo(u,r.dtype,l)}};const xq={kernelName:ab,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:A}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Qy(0,s,A),h=!1;if("string"===a.dtype){const e=n.bufferSync(s),t=n.bufferSync(a),r=oC(n.readSync(i.dataId)[0]),f=TV(e,t,A,d,u,l,o,c,r,h);return n.makeTensorInfo(A,f.dtype,f.values)}const f=new $X(l,o,s.shape.length,a.shape.length,c,[d,1],h),g=n.runWebGLProgram(f,[a,s,i],a.dtype),p=RH({inputs:{x:g},backend:n,attrs:{shape:A}});return n.disposeIntermediateTensorInfo(g),p}};const yq={kernelName:$m,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,A=Uf(i,s.shape)[0],o=qE(s,a,A),l=s.shape.length,u=new Array(l).fill(0),c=s.shape.slice();return o.map((e=>{const t=[...c];t[A]=e;const r=UU({inputs:{x:s},backend:n,attrs:{begin:u,size:t}});return u[A]+=e,r}))}},vq="return sqrt(x);",Eq=DH({opSnippet:vq,packedOpSnippet:vq,cpuKernelImpl:zV}),Bq={kernelName:qm,backendName:"webgl",kernelFunc:Eq},Mq={kernelName:Ab,backendName:"webgl",kernelFunc:DH({opSnippet:"return x * x;"})},Dq="return (a - b) * (a - b);",Tq=TH({opSnippet:Dq,packedOpSnippet:Dq}),Sq={kernelName:ib,backendName:"webgl",kernelFunc:Tq};const Nq={kernelName:ob,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const a=hB(n.readSync(s.dataId)),i=OV(a,"string",r);return n.makeTensorInfo(s.shape,"string",i)}};const Gq={kernelName:yb,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=rH+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,a=new nH(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}};class Fq{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=B_(n.length),a=B_(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const Pq={kernelName:lb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:A,beginMask:o,endMask:l,ellipsisMask:u,newAxisMask:c,shrinkAxisMask:d}=r,{finalShapeSparse:h,finalShape:f,isIdentity:g,sliceDim0:p,isSimpleSlice:m,begin:b,end:C,strides:I}=iE(s.shape,a,i,A,o,l,u,c,d);let w;if(g)w=RH({inputs:{x:s},backend:n,attrs:{shape:f}});else if(p||m){Pf(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=Kv(b,C,I),t=UU({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});w=RH({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=WI(s.shape,s.dtype,e),r=RV(h,t,I,b);w=n.makeTensorInfo(f,s.dtype,r.values)}else{const e=new Fq(b,I,h);w=n.runWebGLProgram(e,[s],s.dtype)}}const k=RH({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const Qq={kernelName:ub,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:A,padWidth:o,preserveShortSequences:l}=r,{data:u,dataSplits:c}=t,d=n.readSync(u.dataId),h=n.readSync(c.dataId),[f,g]=LV(d,h,s,a,i,A,o,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(c.shape,"int32",g)]}};const zq={kernelName:cb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const A=n.readSync(a.dataId),o=n.readSync(i.dataId)[0],[l,u,c]=WV(A,o,s),d=u.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(c))]}};const Oq={kernelName:db,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),A=_V(i,s);return n.makeTensorInfo(a.shape,"int32",A)}},Rq=DH({opSnippet:"return tan(x);"}),Lq={kernelName:fb,backendName:"webgl",kernelFunc:Rq},Wq=DH({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),_q={kernelName:gb,backendName:"webgl",kernelFunc:Wq};const Vq={kernelName:Lm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{sliceRank:A,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=Qy(0,a,s.shape),d=[c/l,l];if(0===c)return n.makeTensorInfo(s.shape,a.dtype);const h=RH({inputs:{x:a},backend:n,attrs:{shape:[o,A]}}),f=RH({inputs:{x:i},backend:n,attrs:{shape:[o,l]}}),g=RH({inputs:{x:s},backend:n,attrs:{shape:d}}),p=new $X(o,A,h.shape.length,f.shape.length,u,d,!1,!0),m=n.runWebGLProgram(p,[f,h,g],g.dtype),b=RH({inputs:{x:m},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),b}};class Hq{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=B_(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function Uq(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map((e=>oC(e))):e,r=WI(s.shape,s.dtype,t),i=HV(r,a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new Hq(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const jq={kernelName:pb,backendName:"webgl",kernelFunc:Uq};class Yq{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Kq{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Xq(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function qq(e){let t=1;for(;t<e;)t*=2;return t}const Zq={kernelName:mb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,A=gg().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),o=gg().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=s.shape,u=l[l.length-1];if(n.shouldExecuteOnCPU([s])||u<A||a>o){const e=n.readSync(s.dataId),[t,r]=UV(e,l,s.dtype,a,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===a)return l[l.length-1]=0,[n.makeTensorInfo(l,s.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===u)return[s,DY({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const c=n.texData.get(s.dataId),d=null!==c&&c.isPacked,h=d?n.unpackTensor(s):s,f=Of(l)/u,g=RH({inputs:{x:h},attrs:{shape:[f,u]},backend:n});d&&Xq(n,h);const p=qq(a),m=qq(u);let b=null;const C=()=>null===b?[g,g]:[g,b],I=(e,t,r)=>{const s=C(),a=new Yq(r),i=[[u],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],A=b;b=n.runWebGLProgram(a,s,"int32",i),Xq(n,A)};for(let e=1;e<p;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)I(t,n,[f,m])}for(let e=m;e>p;e/=2){const t=C(),r=new Kq([f,e/2]),s=[[u],[null===b?1:0],[p]],a=b;b=n.runWebGLProgram(r,t,"int32",s),Xq(n,a);const i=p/2,A=2*i;for(let e=i;e>=1;e/=2)I(A,e,b.shape)}let w=b;b=UU({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,a]}}),Xq(n,w);let k=KY({inputs:{x:g,indices:b},backend:n,attrs:{axis:1,batchDims:1}});Xq(n,g);const x=l.slice(0,-1);x.push(a),w=b,b=RH({inputs:{x:b},attrs:{shape:x},backend:n}),Xq(n,w);const y=k;return k=RH({inputs:{x:k},attrs:{shape:x},backend:n}),Xq(n,y),[k,b]}};class Jq{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i="nearest"===n?1:2;let A;switch(r){case"constant":default:A=1;break;case"reflect":A=2;break;case"wrap":A=3;break;case"nearest":A=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${A} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${A} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${A} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const $q={kernelName:bb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:A,fillValue:o,outputShape:l}=r,[u,c,d,h]=s.shape,[f,g]=null!=l?l:[c,d],p=new Jq(c,d,i,A,o,[u,f,g,h]);return n.runWebGLProgram(p,[s,a],"float32")}};const eZ={kernelName:Ib,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;o_(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:A,outputShape:o,indices:l}=YV(i,s,a.shape,a.dtype);return[r.makeTensorInfo(o,a.dtype,A),r.makeTensorInfo([l.length],"int32",l)]}};const tZ={kernelName:wb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,A=i.shape.length,o=s.shape[a],l=new Array(A-1);let u=0;for(let e=0;e<A;e++)e!==a&&(l[u++]=i.shape[e]);const c=[],d=new Array(A).fill(0),h=i.shape.slice();h[a]=1;const f=new Array(o);for(let e=0;e<f.length;e++){d[a]=e;const t=UU({inputs:{x:i},backend:n,attrs:{begin:d,size:h}}),r=RH({inputs:{x:t},backend:n,attrs:{shape:l}});f[e]=r,c.push(t)}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class nZ{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];const A=4*Math.floor(n/4),o=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let u="";s%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${c}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${A}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${A};\n        if (${1===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}const rZ={kernelName:kb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,A=s.shape.length,o=[];let l=0;const u=wk([l],A);let c=s;null!=u&&(c=XH({inputs:{x:s},backend:n,attrs:{perm:u}}),o.push(c),l=xk(1,A)[0]);const d=uB(c.shape,l,i),h=Of([c.shape[l]]),f=RH({inputs:{x:c},backend:n,attrs:{shape:[-1,h]}});o.push(f);const g=NC(s.dtype),p=(e,t,r,s,a)=>{const i=e.shape[0],A=e.shape[1],l=lB(A,a),u=new nZ({windowSize:l,inSize:A,batchSize:i,numSegments:a},t),c=n.compileAndRun(u,[e,r],s);if(o.push(c),c.shape[1]===a)return c;const d=EX({backend:n,attrs:{start:0,stop:a,step:1,dtype:"float32"}}),h=Uq({inputs:{x:d},backend:n,attrs:{reps:[A/l]}});o.push(d),o.push(h);return p(c,t,h,s,a)},m=RH({inputs:{x:p(f,"unsortedSegmentSum",a,g,i)},backend:n,attrs:{shape:d}});let b=m;if(null!=u){o.push(m);const e=kk(u);b=XH({inputs:{x:b},backend:n,attrs:{perm:e}})}return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},sZ=[JH,eU,nU,sU,AU,uU,cU,dU,bU,CU,wU,xU,vU,BU,DU,NU,GU,QU,zU,OU,WU,YU,KU,XU,qU,tj,sj,Aj,wH,uj,bj,Ej,Sj,Gj,Fj,Pj,Qj,Oj,Lj,_j,Kj,Xj,qj,Jj,tY,sY,aY,AY,lY,uY,dY,hY,gY,mY,CY,wY,yY,BY,TY,NY,PY,zY,LY,VY,HY,jY,XY,ZY,$Y,CH,eK,gj,nK,sK,iK,yH,oK,uK,cK,hK,gK,mK,CK,wK,yK,EK,MK,TK,SK,NK,PK,QK,zK,OK,RK,WK,HK,jK,tX,OH,rX,aX,AX,lX,JU,cX,fX,gX,CX,wX,BH,kX,xX,yX,vX,BX,ej,XK,DX,SX,GX,LH,QX,OX,WX,VX,jX,KX,qX,JX,tq,rq,aq,Aq,lq,cq,hq,gq,jU,eX,mq,bq,Cq,Iq,wq,kq,xq,yq,Bq,Mq,Sq,Nq,Gq,Pq,Qq,zq,Oq,JK,KH,Lq,_q,Vq,jq,Zq,$q,qH,eZ,tZ,rZ,hX];for(const e of sZ)Pb(e);const aZ=256;class iZ{constructor(e,t){this.model=e,this.tokenizer=t}static async from_pretrained(e,{dtype:t="fp32",device:n=null,progress_callback:r=null}={}){const s=Hc.from_pretrained(e,{progress_callback:r,dtype:t,device:n}),a=_c.from_pretrained(e,{progress_callback:r}),i=await Promise.all([s,a]);return new iZ(...i)}get voices(){return vf}list_voices(){console.table(vf)}_validate_voice(e){return e.at(0)}async generate(e,{voice:t="af_heart",speed:n=1}={}){const r=this._validate_voice(t),s=await hf(e,r),{input_ids:a}=this.tokenizer(s,{truncation:!0});return this.generate_from_ids(a,{voice:t,speed:n})}async generate_from_ids(e,{voice:t="af_heart",speed:n=1}={}){const r=Math.min(Math.max(e.dims.at(-1)-2,0),509),s=await async function(e,t){if(e.includes("*")&&e.includes("+"))return await async function(e,t){if(!e||!e.trim())throw new Error("Empty voice formula");const n=e.trim().split("+"),r=t*aZ,s=n.map((async e=>{const[t,n]=e.trim().split("*").map((e=>e.trim())),s=parseFloat(t);if(isNaN(s))throw new Error(`Invalid weight in term: ${e}`);return[(await Bf(n)).slice(r,r+aZ),s]}));return Promise.all(s).then((async e=>function(e,t){if(!e||0===e.length)throw new Error("No tensors provided for blending");if(!t||t.length!==e.length)throw new Error("Weights array length doesn't match tensors length");return aI((()=>{const n=Gy(t),r=n.sum(),s=n.div(r),a=Dy(e),i=a.shape,A=[i[0]];for(let e=1;e<i.length;e++)A.push(1);const o=s.reshape(A);return a.mul(o).sum(0)}))}(e.map((e=>e[0])),e.map((e=>e[1]))).data())),null}(e,t);{const n=await Bf(e),r=t*aZ;return n.slice(r,r+aZ)}}(t,r),a={input_ids:e,style:new Uc("float32",s,[1,aZ]),speed:new Uc("float32",[n],[1])},{waveform:i}=await this.model(a);return new Vc(i.data,24e3)}async*stream(e,{voice:t="af_heart",speed:n=1,split_pattern:r=null}={}){const s=this._validate_voice(t);let a;if(e instanceof kf)a=e;else{if("string"!=typeof e)throw new Error("Invalid input type. Expected string or TextSplitterStream.");{a=new kf;const t=r?e.split(r).map((e=>e.trim())).filter((e=>e.length>0)):[e];a.push(...t)}}for await(const e of a){const r=await hf(e,s),{input_ids:a}=this.tokenizer(r,{truncation:!0}),i=await this.generate_from_ids(a,{voice:t,speed:n});yield{text:e,phonemes:r,audio:i}}}}export{iZ as KokoroTTS,kf as TextSplitterStream};
